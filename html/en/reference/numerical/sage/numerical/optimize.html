<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Numerical Root Finding and Optimization &mdash; Sage Reference Manual v6.6: Numerical Optimization</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '6.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v6.6: Numerical Optimization" href="../../index.html" />
    <link rel="next" title="Interactive Simplex Method" href="interactive_simplex_method.html" />
    <link rel="prev" title="Constraints on Linear Functions Tensored with a Free Module" href="linear_tensor_constraints.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="interactive_simplex_method.html" title="Interactive Simplex Method"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="linear_tensor_constraints.html" title="Constraints on Linear Functions Tensored with a Free Module"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Numerical Optimization</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="numerical-root-finding-and-optimization">
<span id="sage-numerical-optimize"></span><h1>Numerical Root Finding and Optimization<a class="headerlink" href="#numerical-root-finding-and-optimization" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.numerical.optimize"></span><p>AUTHOR:</p>
<ul class="simple">
<li>William Stein (2007): initial version</li>
<li>Nathann Cohen (2008) : Bin Packing</li>
</ul>
<div class="section" id="functions-and-methods">
<h2>Functions and Methods<a class="headerlink" href="#functions-and-methods" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="sage.numerical.optimize.binpacking">
<tt class="descclassname">sage.numerical.optimize.</tt><tt class="descname">binpacking</tt><big>(</big><em>items</em>, <em>maximum=1</em>, <em>k=None</em><big>)</big><a class="headerlink" href="#sage.numerical.optimize.binpacking" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the bin packing problem.</p>
<p>The Bin Packing problem is the following :</p>
<p>Given a list of items of weights <span class="math">\(p_i\)</span> and a real value <span class="math">\(K\)</span>, what is
the least number of bins such that all the items can be put in the
bins, while keeping sure that each bin contains a weight of at most <span class="math">\(K\)</span> ?</p>
<p>For more informations : <a class="reference external" href="http://en.wikipedia.org/wiki/Bin_packing_problem">http://en.wikipedia.org/wiki/Bin_packing_problem</a></p>
<dl class="docutils">
<dt>Two version of this problem are solved by this algorithm :</dt>
<dd><ul class="first last simple">
<li>Is it possible to put the given items in <span class="math">\(L\)</span> bins ?</li>
<li>What is the assignment of items using the
least number of bins with the given list of items ?</li>
</ul>
</dd>
</dl>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">items</span></tt> &#8211; A list of real values (the items&#8217; weight)</li>
<li><tt class="docutils literal"><span class="pre">maximum</span></tt>   &#8211; The maximal size of a bin</li>
<li><tt class="docutils literal"><span class="pre">k</span></tt>     &#8211; Number of bins<ul>
<li>When set to an integer value, the function returns a partition
of the items into <span class="math">\(k\)</span> bins if possible, and raises an
exception otherwise.</li>
<li>When set to <tt class="docutils literal"><span class="pre">None</span></tt>, the function returns a partition of the items
using the least number possible of bins.</li>
</ul>
</li>
</ul>
<p>OUTPUT:</p>
<p>A list of lists, each member corresponding to a box and containing
the list of the weights inside it. If there is no solution, an
exception is raised (this can only happen when <tt class="docutils literal"><span class="pre">k</span></tt> is specified
or if <tt class="docutils literal"><span class="pre">maximum</span></tt> is less that the size of one item).</p>
<p>EXAMPLES:</p>
<p>Trying to find the minimum amount of boxes for 5 items of weights
<span class="math">\(1/5, 1/4, 2/3, 3/4, 5/7\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.numerical.optimize</span> <span class="kn">import</span> <span class="n">binpacking</span>
<span class="gp">sage: </span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="o">/</span><span class="mi">7</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">bins</span> <span class="o">=</span> <span class="n">binpacking</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Checking the bins are of correct size</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span> <span class="nb">sum</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bins</span> <span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Checking every item is in a bin</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span> <span class="o">=</span> <span class="n">bins</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span> <span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">b1</span> <span class="ow">or</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">b2</span> <span class="ow">or</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">b3</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span> <span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>One way to use only three boxes (which is best possible) is to put
<span class="math">\(1/5 + 3/4\)</span> together in a box, <span class="math">\(1/3+2/3\)</span> in another, and <span class="math">\(5/7\)</span>
by itself in the third one.</p>
<p>Of course, we can also check that there is no solution using only two boxes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.numerical.optimize</span> <span class="kn">import</span> <span class="n">binpacking</span>
<span class="gp">sage: </span><span class="n">binpacking</span><span class="p">([</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.8</span><span class="p">,</span><span class="mf">0.9</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">This problem has no solution !</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.numerical.optimize.find_fit">
<tt class="descclassname">sage.numerical.optimize.</tt><tt class="descname">find_fit</tt><big>(</big><em>data</em>, <em>model</em>, <em>initial_guess=None</em>, <em>parameters=None</em>, <em>variables=None</em>, <em>solution_dict=False</em><big>)</big><a class="headerlink" href="#sage.numerical.optimize.find_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds numerical estimates for the parameters of the function model to
give a best fit to data.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">data</span></tt> &#8211; A two dimensional table of floating point numbers of the
form <span class="math">\([[x_{1,1}, x_{1,2}, \ldots, x_{1,k}, f_1],
[x_{2,1}, x_{2,2}, \ldots, x_{2,k}, f_2],
\ldots,
[x_{n,1}, x_{n,2}, \ldots, x_{n,k}, f_n]]\)</span> given as either a list of
lists, matrix, or numpy array.</li>
<li><tt class="docutils literal"><span class="pre">model</span></tt> &#8211; Either a symbolic expression, symbolic function, or a
Python function. <tt class="docutils literal"><span class="pre">model</span></tt> has to be a function of the variables
<span class="math">\((x_1, x_2, \ldots, x_k)\)</span> and free parameters
<span class="math">\((a_1, a_2, \ldots, a_l)\)</span>.</li>
<li><tt class="docutils literal"><span class="pre">initial_guess</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) Initial estimate for the
parameters <span class="math">\((a_1, a_2, \ldots, a_l)\)</span>, given as either a list, tuple,
vector or numpy array. If <tt class="docutils literal"><span class="pre">None</span></tt>, the default estimate for each
parameter is <span class="math">\(1\)</span>.</li>
<li><tt class="docutils literal"><span class="pre">parameters</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) A list of the parameters
<span class="math">\((a_1, a_2, \ldots, a_l)\)</span>. If model is a symbolic function it is
ignored, and the free parameters of the symbolic function are used.</li>
<li><tt class="docutils literal"><span class="pre">variables</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) A list of the variables
<span class="math">\((x_1, x_2, \ldots, x_k)\)</span>. If model is a symbolic function it is
ignored, and the variables of the symbolic function are used.</li>
<li><tt class="docutils literal"><span class="pre">solution_dict</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) if <tt class="docutils literal"><span class="pre">True</span></tt>, return the
solution as a dictionary rather than an equation.</li>
</ul>
<p>EXAMPLES:</p>
<p>First we create some data points of a sine function with some random
perturbations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">data</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">i</span><span class="o">-</span><span class="mf">0.2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">normalvariate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xsrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s">&#39;a, b, c, x&#39;</span><span class="p">)</span>
<span class="go">(a, b, c, x)</span>
</pre></div>
</div>
<p>We define a function with free parameters <span class="math">\(a\)</span>, <span class="math">\(b\)</span> and <span class="math">\(c\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>We search for the parameters that give the best fit to the data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">find_fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
<span class="go">[a == 1.21..., b == 0.49..., c == 0.19...]</span>
</pre></div>
</div>
<p>We can also use a Python function for the model:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span> <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fit</span> <span class="o">=</span> <span class="n">find_fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span> <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">solution_dict</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fit</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">fit</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">fit</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
<span class="go">(1.21..., 0.49..., 0.19...)</span>
</pre></div>
</div>
<p>We search for a formula for the <span class="math">\(n\)</span>-th prime number:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">dataprime</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">nth_prime</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="mi">100</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">find_fit</span><span class="p">(</span><span class="n">dataprime</span><span class="p">,</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">x</span><span class="p">),</span> <span class="n">parameters</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">])</span>
<span class="go">[a == 1.11..., b == 1.24...]</span>
</pre></div>
</div>
<p>ALGORITHM:</p>
<p>Uses <tt class="docutils literal"><span class="pre">scipy.optimize.leastsq</span></tt> which in turn uses MINPACK&#8217;s lmdif and
lmder algorithms.</p>
</dd></dl>

<dl class="function">
<dt id="sage.numerical.optimize.find_local_maximum">
<tt class="descclassname">sage.numerical.optimize.</tt><tt class="descname">find_local_maximum</tt><big>(</big><em>f</em>, <em>a</em>, <em>b</em>, <em>tol=1.48e-08</em>, <em>maxfun=500</em><big>)</big><a class="headerlink" href="#sage.numerical.optimize.find_local_maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically find a local maximum of the expression <span class="math">\(f\)</span> on the interval
<span class="math">\([a,b]\)</span> (or <span class="math">\([b,a]\)</span>) along with the point at which the maximum is attained.</p>
<p>Note that this function only finds a <em>local</em> maximum, and not the
global maximum on that interval &#8211; see the examples with
<a class="reference internal" href="#sage.numerical.optimize.find_local_maximum" title="sage.numerical.optimize.find_local_maximum"><tt class="xref py py-func docutils literal"><span class="pre">find_local_maximum()</span></tt></a>.</p>
<p>See the documentation for <a class="reference internal" href="#sage.numerical.optimize.find_local_maximum" title="sage.numerical.optimize.find_local_maximum"><tt class="xref py py-func docutils literal"><span class="pre">find_local_maximum()</span></tt></a> for more
details and possible workarounds for finding the global minimum on
an interval.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">find_local_maximum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">(0.561096338191..., 0.8603335890...)</span>
<span class="gp">sage: </span><span class="n">find_local_maximum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">maxfun</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">(0.561090323458..., 0.857926501456...)</span>
<span class="gp">sage: </span><span class="n">find_local_maximum</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">(1.579175535558..., 0.7853981...)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.numerical.optimize.find_local_minimum">
<tt class="descclassname">sage.numerical.optimize.</tt><tt class="descname">find_local_minimum</tt><big>(</big><em>f</em>, <em>a</em>, <em>b</em>, <em>tol=1.48e-08</em>, <em>maxfun=500</em><big>)</big><a class="headerlink" href="#sage.numerical.optimize.find_local_minimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically find a local minimum of the expression <tt class="docutils literal"><span class="pre">f</span></tt> on the
interval <span class="math">\([a,b]\)</span> (or <span class="math">\([b,a]\)</span>) and the point at which it attains that
minimum.  Note that <tt class="docutils literal"><span class="pre">f</span></tt> must be a function of (at most) one
variable.</p>
<p>Note that this function only finds a <em>local</em> minimum, and not the
global minimum on that interval &#8211; see the examples below.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> &#8211; a function of at most one variable.</li>
<li><tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">b</span></tt> &#8211; endpoints of interval on which to minimize self.</li>
<li><tt class="docutils literal"><span class="pre">tol</span></tt> &#8211; the convergence tolerance</li>
<li><tt class="docutils literal"><span class="pre">maxfun</span></tt> &#8211; maximum function evaluations</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">minval</span></tt> &#8211; (float) the minimum value that self takes on in the
interval <span class="math">\([a,b]\)</span></li>
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; (float) the point at which self takes on the minimum value</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">find_local_minimum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">(-3.28837139559..., 3.4256184695...)</span>
<span class="gp">sage: </span><span class="n">find_local_minimum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>
<span class="go">(-3.28837136189098..., 3.42575079030572...)</span>
<span class="gp">sage: </span><span class="n">find_local_minimum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">maxfun</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">(-3.28837084598..., 3.4250840220...)</span>
<span class="gp">sage: </span><span class="n">show</span><span class="p">(</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">find_local_minimum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="go">(-9.4772942594..., 9.5293344109...)</span>
</pre></div>
</div>
<p>Only local minima are found; if you enlarge the interval, the
returned minimum may be <em>larger</em>! See <a class="reference external" href="http://trac.sagemath.org/2607">trac ticket #2607</a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">find_local_minimum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(-2.182769784677722, -2.1945027498534686)</span>
</pre></div>
</div>
<p>Enlarging the interval returns a larger minimum:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">find_local_minimum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">(-1.3076194129914434, 1.3552111405712108)</span>
</pre></div>
</div>
<p>One work-around is to plot the function and grab the minimum from
that, although the plotting code does not necessarily do careful
numerics (observe the small number of decimal places that we
actually test):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ymin</span><span class="p">()</span>
<span class="go">-2.1827...</span>
<span class="gp">sage: </span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">ymin</span><span class="p">()</span>
<span class="go">-2.1827...</span>
</pre></div>
</div>
<p>ALGORITHM:</p>
<p>Uses <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fminbound.html">scipy.optimize.fminbound</a>
which uses Brent&#8217;s method.</p>
<p>AUTHOR:</p>
<ul class="simple">
<li>William Stein (2007-12-07)</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="sage.numerical.optimize.find_root">
<tt class="descclassname">sage.numerical.optimize.</tt><tt class="descname">find_root</tt><big>(</big><em>f</em>, <em>a</em>, <em>b</em>, <em>xtol=1e-12</em>, <em>rtol=4.5e-16</em>, <em>maxiter=100</em>, <em>full_output=False</em><big>)</big><a class="headerlink" href="#sage.numerical.optimize.find_root" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically find a root of <tt class="docutils literal"><span class="pre">f</span></tt> on the closed interval <span class="math">\([a,b]\)</span>
(or <span class="math">\([b,a]\)</span>) if possible, where <tt class="docutils literal"><span class="pre">f</span></tt> is a function in the one variable.
Note: this function only works in fixed (machine) precision, it is not
possible to get arbitrary precision approximations with it.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> &#8211; a function of one variable or symbolic equality</li>
<li><tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">b</span></tt> &#8211; endpoints of the interval</li>
<li><tt class="docutils literal"><span class="pre">xtol</span></tt>, <tt class="docutils literal"><span class="pre">rtol</span></tt> &#8211; the routine converges when a root is known
to lie within <tt class="docutils literal"><span class="pre">xtol</span></tt> of the value return. Should be <span class="math">\(\geq 0\)</span>.
The routine modifies this to take into account the relative precision
of doubles.</li>
<li><tt class="docutils literal"><span class="pre">maxiter</span></tt> &#8211; integer; if convergence is not achieved in
<tt class="docutils literal"><span class="pre">maxiter</span></tt> iterations, an error is raised. Must be <span class="math">\(\geq 0\)</span>.</li>
<li><tt class="docutils literal"><span class="pre">full_output</span></tt> &#8211; bool (default: <tt class="docutils literal"><span class="pre">False</span></tt>), if <tt class="docutils literal"><span class="pre">True</span></tt>, also return
object that contains information about convergence.</li>
</ul>
<p>EXAMPLES:</p>
<p>An example involving an algebraic polynomial function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">17</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span><span class="o">^</span><span class="mi">3</span>
<span class="gp">sage: </span><span class="n">find_root</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">2.999999999999995</span>
<span class="gp">sage: </span><span class="n">find_root</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># note -- precision of answer isn&#39;t very good on some machines.</span>
<span class="go">0.124999...</span>
<span class="gp">sage: </span><span class="n">find_root</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">-17.0</span>
</pre></div>
</div>
<p>In Pomerance&#8217;s book on primes he asserts that the famous Riemann
Hypothesis is equivalent to the statement that the function <span class="math">\(f(x)\)</span>
defined below is positive for all <span class="math">\(x \geq 2.01\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>      <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Li</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">prime_pi</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>We find where <span class="math">\(f\)</span> equals, i.e., what value that is slightly smaller
than <span class="math">\(2.01\)</span> that could have been used in the formulation of the Riemann
Hypothesis:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">find_root</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">)</span>
<span class="go">2.0082...</span>
</pre></div>
</div>
<p>This agrees with the plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">2.01</span><span class="p">)</span>
<span class="go">Graphics object consisting of 1 graphics primitive</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.numerical.optimize.linear_program">
<tt class="descclassname">sage.numerical.optimize.</tt><tt class="descname">linear_program</tt><big>(</big><em>c</em>, <em>G</em>, <em>h</em>, <em>A=None</em>, <em>b=None</em>, <em>solver=None</em><big>)</big><a class="headerlink" href="#sage.numerical.optimize.linear_program" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the dual linear programs:</p>
<ul class="simple">
<li>Minimize  <span class="math">\(c'x\)</span> subject to <span class="math">\(Gx + s = h\)</span>, <span class="math">\(Ax = b\)</span>, and <span class="math">\(s \geq 0\)</span> where
<span class="math">\('\)</span> denotes transpose.</li>
<li>Maximize  <span class="math">\(-h'z - b'y\)</span> subject to <span class="math">\(G'z + A'y + c = 0\)</span> and <span class="math">\(z \geq 0\)</span>.</li>
</ul>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">c</span></tt> &#8211; a vector</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">G</span></tt> &#8211; a matrix</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">h</span></tt> &#8211; a vector</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">A</span></tt> &#8211; a matrix</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">b</span></tt> &#8212; a vector</p>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">solver</span></tt> (optional) &#8212; solver to use. If None, the cvxopt&#8217;s lp-solver</dt>
<dd><p class="first last">is used. If it is &#8216;glpk&#8217;, then glpk&#8217;s solver
is used.</p>
</dd>
</dl>
</li>
</ul>
<p>These can be over any field that can be turned into a floating point
number.</p>
<p>OUTPUT:</p>
<p>A dictionary <tt class="docutils literal"><span class="pre">sol</span></tt> with keys <tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">s</span></tt>, <tt class="docutils literal"><span class="pre">y</span></tt>, <tt class="docutils literal"><span class="pre">z</span></tt> corresponding
to the variables above:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">sol['x']</span></tt> &#8211; the solution to the linear program</li>
<li><tt class="docutils literal"><span class="pre">sol['s']</span></tt> &#8211; the slack variables for the solution</li>
<li><tt class="docutils literal"><span class="pre">sol['z']</span></tt>, <tt class="docutils literal"><span class="pre">sol['y']</span></tt> &#8211; solutions to the dual program</li>
</ul>
<p>EXAMPLES:</p>
<p>First, we minimize <span class="math">\(-4x_1 - 5x_2\)</span> subject to <span class="math">\(2x_1 + x_2 \leq 3\)</span>,
<span class="math">\(x_1 +  2x_2 \leq 3\)</span>, <span class="math">\(x_1 \geq 0\)</span>, and <span class="math">\(x_2 \geq 0\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">c</span><span class="o">=</span><span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">=</span><span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">=</span><span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">sol</span><span class="o">=</span><span class="n">linear_program</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sol</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span>
<span class="go">(0.999..., 1.000...)</span>
</pre></div>
</div>
<p>Next, we maximize <span class="math">\(x+y-50\)</span> subject to <span class="math">\(50x + 24y \leq 2400\)</span>,
<span class="math">\(30x + 33y \leq 2100\)</span>, <span class="math">\(x \geq 45\)</span>, and <span class="math">\(y \geq 5\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">v</span><span class="o">=</span><span class="n">vector</span><span class="p">([</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">=</span><span class="n">matrix</span><span class="p">([[</span><span class="mf">50.0</span><span class="p">,</span><span class="mf">24.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">30.0</span><span class="p">,</span><span class="mf">33.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">=</span><span class="n">vector</span><span class="p">([</span><span class="mf">2400.0</span><span class="p">,</span><span class="mf">2100.0</span><span class="p">,</span><span class="o">-</span><span class="mf">45.0</span><span class="p">,</span><span class="o">-</span><span class="mf">5.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">sol</span><span class="o">=</span><span class="n">linear_program</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sol</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span>
<span class="go">(45.000000..., 6.2499999..., 1.00000000...)</span>
<span class="gp">sage: </span><span class="n">sol</span><span class="o">=</span><span class="n">linear_program</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">solver</span><span class="o">=</span><span class="s">&#39;glpk&#39;</span><span class="p">)</span>
<span class="go">GLPK Simplex Optimizer...</span>
<span class="go">OPTIMAL LP SOLUTION FOUND</span>
<span class="gp">sage: </span><span class="n">sol</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span>
<span class="go">(45.0..., 6.25..., 1.0...)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.numerical.optimize.minimize">
<tt class="descclassname">sage.numerical.optimize.</tt><tt class="descname">minimize</tt><big>(</big><em>func</em>, <em>x0</em>, <em>gradient=None</em>, <em>hessian=None</em>, <em>algorithm='default'</em>, <em>**args</em><big>)</big><a class="headerlink" href="#sage.numerical.optimize.minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is an interface to a variety of algorithms for computing
the minimum of a function of several variables.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">func</span></tt> &#8211; Either a symbolic function or a Python function whose
argument is a tuple with <span class="math">\(n\)</span> components</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">x0</span></tt> &#8211; Initial point for finding minimum.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">gradient</span></tt> &#8211; Optional gradient function. This will be computed
automatically for symbolic functions.  For Python functions, it allows
the use of algorithms requiring derivatives.  It should accept a
tuple of arguments and return a NumPy array containing the partial
derivatives at that point.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">hessian</span></tt> &#8211;  Optional hessian function. This will be computed
automatically for symbolic functions. For Python functions, it allows
the use of algorithms requiring derivatives. It should accept a tuple
of arguments and return a NumPy array containing the second partial
derivatives of the function.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; String specifying algorithm to use. Options are
<tt class="docutils literal"><span class="pre">'default'</span></tt> (for Python functions, the simplex method is the default)
(for symbolic functions bfgs is the default):</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">'simplex'</span></tt></li>
<li><tt class="docutils literal"><span class="pre">'powell'</span></tt></li>
<li><tt class="docutils literal"><span class="pre">'bfgs'</span></tt> &#8211; (Broyden-Fletcher-Goldfarb-Shanno) requires
<tt class="docutils literal"><span class="pre">gradient</span></tt></li>
<li><tt class="docutils literal"><span class="pre">'cg'</span></tt> &#8211; (conjugate-gradient) requires gradient</li>
<li><tt class="docutils literal"><span class="pre">'ncg'</span></tt> &#8211; (newton-conjugate gradient) requires gradient and hessian</li>
</ul>
</div></blockquote>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">vars</span><span class="o">=</span><span class="n">var</span><span class="p">(</span><span class="s">&#39;x y z&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">=</span><span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">minimize</span><span class="p">(</span><span class="n">f</span><span class="p">,[</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span><span class="o">.</span><span class="mi">4</span><span class="p">],</span><span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">(1.00..., 1.00..., 1.00...)</span>

<span class="gp">sage: </span><span class="n">minimize</span><span class="p">(</span><span class="n">f</span><span class="p">,[</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span><span class="o">.</span><span class="mi">4</span><span class="p">],</span><span class="n">algorithm</span><span class="o">=</span><span class="s">&quot;ncg&quot;</span><span class="p">,</span><span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">(0.9999999..., 0.999999..., 0.999999...)</span>
</pre></div>
</div>
<p>Same example with just Python functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">rosen</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="c"># The Rosenbrock function</span>
<span class="gp">... </span>     <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mf">100.0</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="n">r</span><span class="p">:]</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="n">r</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="n">r</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="n">r</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span><span class="n">r</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,[</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span><span class="o">.</span><span class="mi">4</span><span class="p">],</span><span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">(1.00..., 1.00..., 1.00...)</span>
</pre></div>
</div>
<p>Same example with a pure Python function and a Python function to
compute the gradient:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">rosen</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="c"># The Rosenbrock function</span>
<span class="gp">... </span>     <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mf">100.0</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="n">r</span><span class="p">:]</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="n">r</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="n">r</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="n">r</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="n">r</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span><span class="n">r</span><span class="p">)</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">rosen_der</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>     <span class="n">xm</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="n">r</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="n">r</span><span class="p">]</span>
<span class="gp">... </span>     <span class="n">xm_m1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="n">r</span><span class="p">]</span>
<span class="gp">... </span>     <span class="n">xm_p1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="n">r</span><span class="p">:]</span>
<span class="gp">... </span>     <span class="n">der</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">... </span>     <span class="n">der</span><span class="p">[</span><span class="mi">1</span><span class="n">r</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">xm</span><span class="o">-</span><span class="n">xm_m1</span><span class="o">**</span><span class="mi">2</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="mi">400</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">xm_p1</span> <span class="o">-</span> <span class="n">xm</span><span class="o">**</span><span class="mi">2</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="n">xm</span> <span class="o">-</span> <span class="mi">2</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="n">r</span><span class="o">-</span><span class="n">xm</span><span class="p">)</span>
<span class="gp">... </span>     <span class="n">der</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">400</span><span class="n">r</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="n">r</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>     <span class="n">der</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="n">r</span><span class="p">)</span>
<span class="gp">... </span>     <span class="k">return</span> <span class="n">der</span>
<span class="gp">sage: </span><span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,[</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span><span class="o">.</span><span class="mi">4</span><span class="p">],</span><span class="n">gradient</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span><span class="n">algorithm</span><span class="o">=</span><span class="s">&quot;bfgs&quot;</span><span class="p">,</span><span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">(1.00...,  1.00..., 1.00...)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.numerical.optimize.minimize_constrained">
<tt class="descclassname">sage.numerical.optimize.</tt><tt class="descname">minimize_constrained</tt><big>(</big><em>func</em>, <em>cons</em>, <em>x0</em>, <em>gradient=None</em>, <em>algorithm='default'</em>, <em>**args</em><big>)</big><a class="headerlink" href="#sage.numerical.optimize.minimize_constrained" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimize a function with constraints.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">func</span></tt> &#8211; Either a symbolic function, or a Python function whose
argument is a tuple with n components</li>
<li><tt class="docutils literal"><span class="pre">cons</span></tt> &#8211; constraints. This should be either a function or list of
functions that must be positive. Alternatively, the constraints can
be specified as a list of intervals that define the region we are
minimizing in. If the constraints are specified as functions, the
functions should be functions of a tuple with <span class="math">\(n\)</span> components
(assuming <span class="math">\(n\)</span> variables). If the constraints are specified as a list
of intervals and there are no constraints for a given variable, that
component can be (<tt class="docutils literal"><span class="pre">None</span></tt>, <tt class="docutils literal"><span class="pre">None</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">x0</span></tt> &#8211; Initial point for finding minimum</li>
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; Optional, specify the algorithm to use:<ul>
<li><tt class="docutils literal"><span class="pre">'default'</span></tt>  &#8211; default choices</li>
<li><tt class="docutils literal"><span class="pre">'l-bfgs-b'</span></tt> &#8211; only effective if you specify bound constraints.
See <a class="reference internal" href="#zbn97" id="id1">[ZBN97]</a>.</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">gradient</span></tt> &#8211; Optional gradient function. This will be computed
automatically for symbolic functions. This is only used when the
constraints are specified as a list of intervals.</li>
</ul>
<p>EXAMPLES:</p>
<p>Let us maximize <span class="math">\(x + y - 50\)</span> subject to the following constraints:
<span class="math">\(50x + 24y \leq 2400\)</span>, <span class="math">\(30x + 33y \leq 2100\)</span>, <span class="math">\(x \geq 45\)</span>,
and <span class="math">\(y \geq 5\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">50</span>
<span class="gp">sage: </span><span class="n">c_1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">45</span>
<span class="gp">sage: </span><span class="n">c_2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">5</span>
<span class="gp">sage: </span><span class="n">c_3</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="o">-</span><span class="mi">50</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">24</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2400</span>
<span class="gp">sage: </span><span class="n">c_4</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="o">-</span><span class="mi">30</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">33</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2100</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">minimize_constrained</span><span class="p">(</span><span class="n">f</span><span class="p">,[</span><span class="n">c_1</span><span class="p">,</span><span class="n">c_2</span><span class="p">,</span><span class="n">c_3</span><span class="p">,</span><span class="n">c_4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span>
<span class="go">(45.0, 6.25...)</span>
</pre></div>
</div>
<p>Let&#8217;s find a minimum of <span class="math">\(\sin(xy)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s">&#39;x y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">minimize_constrained</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[(</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="p">)],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">(4.8..., 4.8...)</span>
</pre></div>
</div>
<p>Check, if L-BFGS-B finds the same minimum:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">minimize_constrained</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[(</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="p">)],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;l-bfgs-b&#39;</span><span class="p">)</span>
<span class="go">(4.7..., 4.9...)</span>
</pre></div>
</div>
<p>Rosenbrock function, [<a class="reference external" href="http://en.wikipedia.org/wiki/Rosenbrock_function">http://en.wikipedia.org/wiki/Rosenbrock_function</a>]:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">rosen</span><span class="p">,</span> <span class="n">rosen_der</span>
<span class="gp">sage: </span><span class="n">minimize_constrained</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="p">[(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">)],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">gradient</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span><span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;l-bfgs-b&#39;</span><span class="p">)</span>
<span class="go">(-10.0, 10.0)</span>
<span class="gp">sage: </span><span class="n">minimize_constrained</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="p">[(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">)],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;l-bfgs-b&#39;</span><span class="p">)</span>
<span class="go">(-10.0, 10.0)</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="zbn97" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[ZBN97]</a></td><td>C. Zhu, R. H. Byrd and J. Nocedal. L-BFGS-B: Algorithm 778:
L-BFGS-B, FORTRAN routines for large scale bound constrained
optimization. ACM Transactions on Mathematical Software, Vol 23, Num. 4,
pp.550&#8211;560, 1997.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Numerical Root Finding and Optimization</a><ul>
<li><a class="reference internal" href="#functions-and-methods">Functions and Methods</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="linear_tensor_constraints.html"
                                  title="previous chapter">Constraints on Linear Functions Tensored with a Free Module</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="interactive_simplex_method.html"
                                  title="next chapter">Interactive Simplex Method</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/numerical/optimize.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="interactive_simplex_method.html" title="Interactive Simplex Method"
             >next</a> |</li>
        <li class="right" >
          <a href="linear_tensor_constraints.html" title="Constraints on Linear Functions Tensored with a Free Module"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Numerical Optimization</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2015, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>