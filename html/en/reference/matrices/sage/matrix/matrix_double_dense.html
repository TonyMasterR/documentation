<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Dense matrices using a NumPy backend. &mdash; Sage Reference Manual v7.1: Matrices and Spaces of Matrices</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v7.1: Matrices and Spaces of Matrices" href="../../index.html" />
    <link rel="next" title="Dense matrices over the Real Double Field using NumPy" href="matrix_real_double_dense.html" />
    <link rel="prev" title="Dense matrices over the rational field" href="matrix_rational_dense.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="matrix_real_double_dense.html" title="Dense matrices over the Real Double Field using NumPy"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="matrix_rational_dense.html" title="Dense matrices over the rational field"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Matrices and Spaces of Matrices</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="dense-matrices-using-a-numpy-backend">
<span id="sage-matrix-matrix-double-dense"></span><h1>Dense matrices using a NumPy backend.<a class="headerlink" href="#dense-matrices-using-a-numpy-backend" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.matrix.matrix_double_dense"></span><p>This serves as a base class for dense matrices over
Real Double Field and Complex Double Field.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li>Jason Grout, Sep 2008: switch to NumPy backend, factored out the Matrix_double_dense class</li>
<li>Josh Kantor</li>
<li>William Stein: many bug fixes and touch ups.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">b</span><span class="o">=</span><span class="n">Mat</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[1.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0]</span>
</pre></div>
</div>
<p>We deal with the case of zero rows or zero columns:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">MatrixSpace</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">zero_matrix</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense">
<em class="property">class </em><tt class="descclassname">sage.matrix.matrix_double_dense.</tt><tt class="descname">Matrix_double_dense</tt><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="matrix_dense.html#sage.matrix.matrix_dense.Matrix_dense" title="sage.matrix.matrix_dense.Matrix_dense"><tt class="xref py py-class docutils literal"><span class="pre">sage.matrix.matrix_dense.Matrix_dense</span></tt></a></p>
<p>Base class for matrices over the Real Double Field and the Complex
Double Field.  These are supposed to be fast matrix operations
using C doubles. Most operations are implemented using numpy which
will call the underlying BLAS on the system.</p>
<p>This class cannot be instantiated on its own.  The numpy matrix
creation depends on several variables that are set in the
subclasses.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">**</span><span class="mi">2</span>
<span class="go">[ 7.0 10.0]</span>
<span class="go">[15.0 22.0]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>        <span class="c1"># rel tol 1e-15</span>
<span class="go">[-1.9999999999999996  0.9999999999999998]</span>
<span class="go">[ 1.4999999999999998 -0.4999999999999999]</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.LU">
<tt class="descname">LU</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.LU" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a decomposition of the (row-permuted) matrix as a product of
a lower-triangular matrix (&#8220;L&#8221;) and an upper-triangular matrix (&#8220;U&#8221;).</p>
<p>OUTPUT:</p>
<p>For an <span class="math">\(m\times n\)</span> matrix <tt class="docutils literal"><span class="pre">A</span></tt> this method returns a triple of
immutable matrices <tt class="docutils literal"><span class="pre">P,</span> <span class="pre">L,</span> <span class="pre">U</span></tt> such that</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">P*A</span> <span class="pre">=</span> <span class="pre">L*U</span></tt></li>
<li><tt class="docutils literal"><span class="pre">P</span></tt> is a square permutation matrix, of size <span class="math">\(m\times m\)</span>,
so is all zeroes, but with exactly a single one in each
row and each column.</li>
<li><tt class="docutils literal"><span class="pre">L</span></tt> is lower-triangular, square of size <span class="math">\(m\times m\)</span>,
with every diagonal entry equal to one.</li>
<li><tt class="docutils literal"><span class="pre">U</span></tt> is upper-triangular with size <span class="math">\(m\times n\)</span>, i.e.
entries below the &#8220;diagonal&#8221; are all zero.</li>
</ul>
<p>The computed decomposition is cached and returned on
subsequent calls, thus requiring the results to be immutable.</p>
<p>Effectively, <tt class="docutils literal"><span class="pre">P</span></tt> permutes the rows of <tt class="docutils literal"><span class="pre">A</span></tt>.  Then <tt class="docutils literal"><span class="pre">L</span></tt>
can be viewed as a sequence of row operations on this matrix,
where each operation is adding a multiple of a row to a
subsequent row.  There is no scaling (thus 1&#8217;s on the diagonal
of <tt class="docutils literal"><span class="pre">L</span></tt>) and no row-swapping (<tt class="docutils literal"><span class="pre">P</span></tt> does that).  As a result
<tt class="docutils literal"><span class="pre">U</span></tt> is close to being the result of Gaussian-elimination.
However, round-off errors can make it hard to determine
the zero entries of <tt class="docutils literal"><span class="pre">U</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Sometimes this decomposition is written as <tt class="docutils literal"><span class="pre">A=P*L*U</span></tt>,
where <tt class="docutils literal"><span class="pre">P</span></tt> represents the inverse permutation and is
the matrix inverse of the <tt class="docutils literal"><span class="pre">P</span></tt> returned by this method.
The computation of this matrix inverse can be accomplished
quickly with just a transpose as the matrix is orthogonal/unitary.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">U</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">LU</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">*</span><span class="n">m</span>
<span class="go">[12.0 13.0 14.0 15.0]</span>
<span class="go">[ 0.0  1.0  2.0  3.0]</span>
<span class="go">[ 8.0  9.0 10.0 11.0]</span>
<span class="go">[ 4.0  5.0  6.0  7.0]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">*</span><span class="n">U</span> <span class="c1"># rel tol 2e-16 </span>
<span class="go">[12.0 13.0 14.0 15.0]</span>
<span class="go">[ 0.0  1.0  2.0  3.0]</span>
<span class="go">[ 8.0  9.0 10.0 11.0]</span>
<span class="go">[ 4.0  5.0  6.0  7.0]</span>
</pre></div>
</div>
<p>Trac 10839 made this routine available for rectangular matrices.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">));</span> <span class="n">A</span>
<span class="go">[ 0.0  1.0  2.0  3.0  4.0  5.0]</span>
<span class="go">[ 6.0  7.0  8.0  9.0 10.0 11.0]</span>
<span class="go">[12.0 13.0 14.0 15.0 16.0 17.0]</span>
<span class="go">[18.0 19.0 20.0 21.0 22.0 23.0]</span>
<span class="go">[24.0 25.0 26.0 27.0 28.0 29.0]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LU</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span>
<span class="go">[0.0 0.0 0.0 0.0 1.0]</span>
<span class="go">[1.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 1.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 1.0 0.0]</span>
<span class="go">[0.0 1.0 0.0 0.0 0.0]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Use zero_at(0) to get rid of signed zeros</span>
<span class="go">[ 1.0  0.0  0.0  0.0  0.0]</span>
<span class="go">[ 0.0  1.0  0.0  0.0  0.0]</span>
<span class="go">[ 0.5  0.5  1.0  0.0  0.0]</span>
<span class="go">[0.75 0.25  0.0  1.0  0.0]</span>
<span class="go">[0.25 0.75  0.0  0.0  1.0]</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Use zero_at(0) to get rid of signed zeros</span>
<span class="go">[24.0 25.0 26.0 27.0 28.0 29.0]</span>
<span class="go">[ 0.0  1.0  2.0  3.0  4.0  5.0]</span>
<span class="go">[ 0.0  0.0  0.0  0.0  0.0  0.0]</span>
<span class="go">[ 0.0  0.0  0.0  0.0  0.0  0.0]</span>
<span class="go">[ 0.0  0.0  0.0  0.0  0.0  0.0]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">*</span><span class="n">A</span><span class="o">-</span><span class="n">L</span><span class="o">*</span><span class="n">U</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0 0.0]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">U</span>
<span class="go">[ 0.0  1.0  2.0  3.0  4.0  5.0]</span>
<span class="go">[ 6.0  7.0  8.0  9.0 10.0 11.0]</span>
<span class="go">[12.0 13.0 14.0 15.0 16.0 17.0]</span>
<span class="go">[18.0 19.0 20.0 21.0 22.0 23.0]</span>
<span class="go">[24.0 25.0 26.0 27.0 28.0 29.0]</span>
</pre></div>
</div>
<p>Trivial cases return matrices of the right size and
characteristics.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">entries</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LU</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 5 by 5 dense matrices over Real Double Field</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 5 by 5 dense matrices over Real Double Field</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 5 by 0 dense matrices over Real Double Field</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">*</span><span class="n">A</span><span class="o">-</span><span class="n">L</span><span class="o">*</span><span class="n">U</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>The results are immutable since they are cached.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">LU</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">matrix is immutable; please change a copy instead (i.e., use copy(M) to change a copy of M).</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">matrix is immutable; please change a copy instead (i.e., use copy(M) to change a copy of M).</span>
<span class="gp">sage: </span><span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">matrix is immutable; please change a copy instead (i.e., use copy(M) to change a copy of M).</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.LU_valid">
<tt class="descname">LU_valid</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.LU_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if the LU form of this matrix has
already been computed.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">random_matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="p">;</span> <span class="n">A</span><span class="o">.</span><span class="n">LU_valid</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LU</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">LU_valid</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.QR">
<tt class="descname">QR</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.QR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a factorization into a unitary matrix and an
upper-triangular matrix.</p>
<p>INPUT:</p>
<p>Any matrix over <tt class="docutils literal"><span class="pre">RDF</span></tt> or <tt class="docutils literal"><span class="pre">CDF</span></tt>.</p>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">Q</span></tt>, <tt class="docutils literal"><span class="pre">R</span></tt> &#8211; a pair of matrices such that if <span class="math">\(A\)</span>
is the original matrix, then</p>
<div class="math">
\[A = QR, \quad Q^\ast Q = I\]</div>
<p>where <span class="math">\(R\)</span> is upper-triangular.  <span class="math">\(Q^\ast\)</span> is the
conjugate-transpose in the complex case, and just
the transpose in the real case. So <span class="math">\(Q\)</span> is a unitary
matrix (or rather, orthogonal, in the real case),
or equivalently <span class="math">\(Q\)</span> has orthogonal columns.  For a
matrix of full rank this factorization is unique
up to adjustments via multiples of rows and columns
by multiples with scalars having modulus <span class="math">\(1\)</span>.  So
in the full-rank case, <span class="math">\(R\)</span> is unique if the diagonal
entries are required to be positive real numbers.</p>
<p>The resulting decomposition is cached.</p>
<p>ALGORITHM:</p>
<p>Calls &#8220;linalg.qr&#8221; from SciPy, which is in turn an
interface to LAPACK routines.</p>
<p>EXAMPLES:</p>
<p>Over the reals, the inverse of <tt class="docutils literal"><span class="pre">Q</span></tt> is its transpose,
since including a conjugate has no effect.  In the real
case, we say <tt class="docutils literal"><span class="pre">Q</span></tt> is orthogonal.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="go">....:                  [-2, 1, -6, -3, -1],</span>
<span class="go">....:                  [1, 1, 7, 4, 5],</span>
<span class="go">....:                  [3, 0, 8, 3, 3],</span>
<span class="go">....:                  [-1, 1, -6, -6, 5]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">QR</span><span class="p">()</span>
</pre></div>
</div>
<p>At this point, <tt class="docutils literal"><span class="pre">Q</span></tt> is only well-defined up to the
signs of its columns, and similarly for <tt class="docutils literal"><span class="pre">R</span></tt> and its
rows, so we normalize them:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Qnorm</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_normalize_columns</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Rnorm</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">_normalize_rows</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Qnorm</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[ 0.458831  0.126051  0.381212  0.394574   0.68744]</span>
<span class="go">[ 0.458831  -0.47269 -0.051983 -0.717294  0.220963]</span>
<span class="go">[-0.229416 -0.661766  0.661923  0.180872 -0.196411]</span>
<span class="go">[-0.688247 -0.189076 -0.204468  -0.09663  0.662889]</span>
<span class="go">[ 0.229416 -0.535715 -0.609939  0.536422 -0.024551]</span>
<span class="gp">sage: </span><span class="n">Rnorm</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[ 4.358899 -0.458831 13.076697  6.194225  2.982405]</span>
<span class="go">[      0.0  1.670172  0.598741  -1.29202  6.207997]</span>
<span class="go">[      0.0       0.0  5.444402  5.468661 -0.682716]</span>
<span class="go">[      0.0       0.0       0.0  1.027626   -3.6193]</span>
<span class="go">[      0.0       0.0       0.0       0.0  0.024551]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>  <span class="c1"># tol 1e-14</span>
<span class="go">[0.9999999999999994                0.0                0.0                0.0                0.0]</span>
<span class="go">[               0.0                1.0                0.0                0.0                0.0]</span>
<span class="go">[               0.0                0.0 0.9999999999999999                0.0                0.0]</span>
<span class="go">[               0.0                0.0                0.0 0.9999999999999998                0.0]</span>
<span class="go">[               0.0                0.0                0.0                0.0 1.0000000000000002]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">R</span> <span class="o">-</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">14</span><span class="p">)</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0 0.0]</span>
</pre></div>
</div>
<p>Now over the complex numbers, demonstrating that the SciPy libraries
are (properly) using the Hermitian inner product, so that <tt class="docutils literal"><span class="pre">Q</span></tt> is
a unitary matrix (its inverse is the conjugate-transpose).</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">I</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                  [1, -2*I - 1, -I + 3, -I + 1],</span>
<span class="go">....:                  [I + 7, 2*I + 1, -2*I + 7, -I + 1],</span>
<span class="go">....:                  [I + 2, 0, I + 12, -1]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">QR</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">_normalize_columns</span><span class="p">()</span>  <span class="c1"># tol 1e-6</span>
<span class="go">[                           0.7302967433402214    0.20705664550556482 + 0.5383472783144685*I   0.24630498099986423 - 0.07644563587232917*I   0.23816176831943323 - 0.10365960327796941*I]</span>
<span class="go">[                         -0.09128709291752768  -0.20705664550556482 - 0.37787837804765584*I   0.37865595338630315 - 0.19522214955246678*I    0.7012444502144682 - 0.36437116509865947*I]</span>
<span class="go">[  -0.6390096504226938 - 0.09128709291752768*I    0.17082173254209104 + 0.6677576817554466*I -0.03411475806452064 + 0.040901987417671426*I   0.31401710855067644 - 0.08251917187054114*I]</span>
<span class="go">[ -0.18257418583505536 - 0.09128709291752768*I  -0.03623491296347384 + 0.07246982592694771*I    0.8632284069415112 + 0.06322839976356195*I  -0.44996948676115206 - 0.01161191812089182*I]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">_normalize_rows</span><span class="p">()</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1e-15</span><span class="p">)</span>  <span class="c1"># tol 1e-6</span>
<span class="go">[                        10.954451150103322                      -1.9170289512680814*I   5.385938482134133 - 2.1908902300206643*I -0.2738612787525829 - 2.1908902300206643*I]</span>
<span class="go">[                                       0.0                            4.8295962564173  -0.8696379111233719 - 5.864879483945123*I  0.993871898426711 - 0.30540855212070794*I]</span>
<span class="go">[                                       0.0                                        0.0                          12.00160760935814 -0.2709533402297273 + 0.4420629644486325*I]</span>
<span class="go">[                                       0.0                                        0.0                                        0.0                         1.9429639442589917]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">*</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1e-15</span><span class="p">)</span>  <span class="c1"># tol 1e-15</span>
<span class="go">[               1.0                0.0                0.0                0.0]</span>
<span class="go">[               0.0 0.9999999999999994                0.0                0.0]</span>
<span class="go">[               0.0                0.0 1.0000000000000002                0.0]</span>
<span class="go">[               0.0                0.0                0.0 1.0000000000000004]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">R</span> <span class="o">-</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">14</span><span class="p">)</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
</pre></div>
</div>
<p>An example of a rectangular matrix that is also rank-deficient.
If you run this example yourself, you may see a very small, nonzero
entries in the third row, in the third column, even though the exact
version of the matrix has rank 2.  The final two columns of <tt class="docutils literal"><span class="pre">Q</span></tt>
span the left kernel of <tt class="docutils literal"><span class="pre">A</span></tt> (as evidenced by the two zero rows of
<tt class="docutils literal"><span class="pre">R</span></tt>).  Different platforms will compute different bases for this
left kernel, so we do not exhibit the actual matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Arat</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="go">....:                    [-1, 1, -1],</span>
<span class="go">....:                    [-1, 3, -3],</span>
<span class="go">....:                    [-5, 1, -1]])</span>
<span class="gp">sage: </span><span class="n">Arat</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Arat</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">CDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">QR</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">_normalize_rows</span><span class="p">()</span>  <span class="c1"># abs tol 1e-14</span>
<span class="go">[     5.567764362830022    -2.6940795304016243     2.6940795304016243]</span>
<span class="go">[                   0.0     3.5695847775155825    -3.5695847775155825]</span>
<span class="go">[                   0.0                    0.0 2.4444034681064287e-16]</span>
<span class="go">[                   0.0                    0.0                    0.0]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">()</span><span class="o">*</span><span class="n">Q</span><span class="p">)</span>  <span class="c1"># abs tol 1e-14</span>
<span class="go">[     1.0000000000000002  -5.185196889911925e-17 -4.1457180570414476e-17  -2.909388767229071e-17]</span>
<span class="go">[ -5.185196889911925e-17      1.0000000000000002  -9.286869233696149e-17 -1.1035822863186828e-16]</span>
<span class="go">[-4.1457180570414476e-17  -9.286869233696149e-17                     1.0  4.4159215672155694e-17]</span>
<span class="go">[ -2.909388767229071e-17 -1.1035822863186828e-16  4.4159215672155694e-17                     1.0]</span>
</pre></div>
</div>
<p>Results are cached, meaning they are immutable matrices.
Make a copy if you need to manipulate a result.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">random_matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">QR</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">matrix is immutable; please change a copy instead (i.e., use copy(M) to change a copy of M).</span>
<span class="gp">sage: </span><span class="n">Qcopy</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Qcopy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">679</span>
<span class="gp">sage: </span><span class="n">Qcopy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">679.0</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Trivial cases return trivial results of the correct size,
and we check <tt class="docutils literal"><span class="pre">Q</span></tt> itself in one case, verifying a fix for
<a class="reference external" href="http://trac.sagemath.org/10795">trac ticket #10795</a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">zero_matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">QR</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">nrows</span><span class="p">(),</span> <span class="n">Q</span><span class="o">.</span><span class="n">ncols</span><span class="p">()</span>
<span class="go">(0, 0)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">nrows</span><span class="p">(),</span> <span class="n">R</span><span class="o">.</span><span class="n">ncols</span><span class="p">()</span>
<span class="go">(0, 10)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">zero_matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">QR</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">nrows</span><span class="p">(),</span> <span class="n">Q</span><span class="o">.</span><span class="n">ncols</span><span class="p">()</span>
<span class="go">(3, 3)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">nrows</span><span class="p">(),</span> <span class="n">R</span><span class="o">.</span><span class="n">ncols</span><span class="p">()</span>
<span class="go">(3, 0)</span>
<span class="gp">sage: </span><span class="n">Q</span>
<span class="go">[1.0 0.0 0.0]</span>
<span class="go">[0.0 1.0 0.0]</span>
<span class="go">[0.0 0.0 1.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.SVD">
<tt class="descname">SVD</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.SVD" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the singular value decomposition of this matrix.</p>
<p>The U and V matrices are not unique and may be returned with different
values in the future or on different systems. The S matrix is unique
and contains the singular values in descending order.</p>
<p>The computed decomposition is cached and returned on subsequent calls.</p>
<p>INPUT:</p>
<ul class="simple">
<li>A &#8211; a matrix</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>U, S, V &#8211; immutable matrices such that <span class="math">\(A = U*S*V.conj().transpose()\)</span>
where U and V are orthogonal and S is zero off of the diagonal.</li>
</ul>
<p>Note that if self is m-by-n, then the dimensions of the
matrices that this returns are (m,m), (m,n), and (n, n).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If all you need is the singular values of the matrix, see
the more convenient <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.singular_values" title="sage.matrix.matrix_double_dense.Matrix_double_dense.singular_values"><tt class="xref py py-meth docutils literal"><span class="pre">singular_values()</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">SVD</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">V</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>  <span class="c1"># tol 1e-14</span>
<span class="go">[0.9999999999999993 1.9999999999999987  3.000000000000001  4.000000000000002]</span>
<span class="go">[ 4.999999999999998  5.999999999999998  6.999999999999998                8.0]</span>
<span class="go">[ 8.999999999999998  9.999999999999996 10.999999999999998               12.0]</span>
<span class="go">[12.999999999999998               14.0               15.0               16.0]</span>
</pre></div>
</div>
<p>A non-square example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">));</span> <span class="n">m</span>
<span class="go">[1.0 2.0 3.0]</span>
<span class="go">[4.0 5.0 6.0]</span>
<span class="gp">sage: </span><span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">SVD</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">V</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>  <span class="c1"># tol 1e-14</span>
<span class="go">[0.9999999999999994 1.9999999999999998  2.999999999999999]</span>
<span class="go">[ 4.000000000000001  5.000000000000002  6.000000000000001]</span>
</pre></div>
</div>
<p>S contains the singular values:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">[ 9.508    0.0    0.0]</span>
<span class="go">[   0.0 0.7729    0.0]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()]</span>
<span class="go">[9.508, 0.7729]</span>
</pre></div>
</div>
<p>U and V are orthogonal matrices:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">U</span> <span class="c1"># random, SVD is not unique</span>
<span class="go">[-0.386317703119 -0.922365780077]</span>
<span class="go">[-0.922365780077  0.386317703119]</span>
<span class="go">[-0.274721127897 -0.961523947641]</span>
<span class="go">[-0.961523947641  0.274721127897]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="n">U</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>  <span class="c1"># tol 1e-15</span>
<span class="go">[               1.0                0.0]</span>
<span class="go">[               0.0 1.0000000000000004]</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="c1"># random, SVD is not unique</span>
<span class="go">[-0.428667133549  0.805963908589  0.408248290464]</span>
<span class="go">[-0.566306918848  0.112382414097 -0.816496580928]</span>
<span class="go">[-0.703946704147 -0.581199080396  0.408248290464]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="n">V</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>  <span class="c1"># tol 1e-15</span>
<span class="go">[0.9999999999999999                0.0                0.0]</span>
<span class="go">[               0.0                1.0                0.0]</span>
<span class="go">[               0.0                0.0 0.9999999999999999]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">));</span> <span class="n">m</span>
<span class="go">[1.0 2.0]</span>
<span class="go">[3.0 4.0]</span>
<span class="go">[5.0 6.0]</span>
<span class="gp">sage: </span><span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">SVD</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">V</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>  <span class="c1"># tol 1e-15</span>
<span class="go">[0.9999999999999996 1.9999999999999998]</span>
<span class="go">[               3.0 3.9999999999999996]</span>
<span class="go">[ 4.999999999999999  6.000000000000001]</span>

<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]);</span> <span class="n">m</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">SVD</span><span class="p">()</span>
<span class="go">([], [], [])</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[]);</span> <span class="n">m</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">SVD</span><span class="p">()</span>
<span class="go">([], [], [])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">nrows</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">ncols</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">sage: </span><span class="nb">map</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">SVD</span><span class="p">())</span>
<span class="go">[(2, 2), (2, 3), (3, 3)]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">SVD</span><span class="p">():</span> <span class="n">x</span><span class="o">.</span><span class="n">is_immutable</span><span class="p">()</span>
<span class="go">True</span>
<span class="go">True</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky">
<tt class="descname">cholesky</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Cholesky factorization of a matrix that
is real symmetric, or complex Hermitian.</p>
<p>INPUT:</p>
<p>Any square matrix with entries from <tt class="docutils literal"><span class="pre">RDF</span></tt> that is symmetric, or
with entries from <tt class="docutils literal"><span class="pre">CDF</span></tt> that is Hermitian.  The matrix must
be positive definite for the Cholesky decomposition to exist.</p>
<p>OUTPUT:</p>
<p>For a matrix <span class="math">\(A\)</span> the routine returns a lower triangular
matrix <span class="math">\(L\)</span> such that,</p>
<div class="math">
\[A = LL^\ast\]</div>
<p>where <span class="math">\(L^\ast\)</span> is the conjugate-transpose in the complex case,
and just the transpose in the real case.  If the matrix fails
to be positive definite (perhaps because it is not symmetric
or Hermitian), then this function raises a <tt class="docutils literal"><span class="pre">ValueError</span></tt>.</p>
<p>IMPLEMENTATION:</p>
<p>The existence of a Cholesky decomposition and the
positive definite property are equivalent.  So this
method and the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite" title="sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite"><tt class="xref py py-meth docutils literal"><span class="pre">is_positive_definite()</span></tt></a> method compute and
cache both the Cholesky decomposition and the
positive-definiteness.  So the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite" title="sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite"><tt class="xref py py-meth docutils literal"><span class="pre">is_positive_definite()</span></tt></a>
method or catching a <tt class="docutils literal"><span class="pre">ValueError</span></tt> from the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky" title="sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky"><tt class="xref py py-meth docutils literal"><span class="pre">cholesky()</span></tt></a>
method are equally expensive computationally and if the
decomposition exists, it is cached as a side-effect of either
routine.</p>
<p>EXAMPLES:</p>
<p>A real matrix that is symmetric and positive definite.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,[[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span><span class="p">,</span>     <span class="mi">1</span><span class="p">,</span>     <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                 [ 1,  5,   31,   121,   341],</span>
<span class="go">....:                 [ 1, 31,  341,  1555,  4681],</span>
<span class="go">....:                 [ 1,121, 1555,  7381, 22621],</span>
<span class="go">....:                 [ 1,341, 4681, 22621, 69905]])</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cholesky</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">[   1.0    0.0         0.0        0.0     0.0]</span>
<span class="go">[   1.0    2.0         0.0        0.0     0.0]</span>
<span class="go">[   1.0   15.0   10.723805        0.0     0.0]</span>
<span class="go">[   1.0   60.0   60.985814   7.792973     0.0]</span>
<span class="go">[   1.0  170.0  198.623524  39.366567  1.7231]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="n">L</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">[ 1.0     1.0     1.0     1.0     1.0]</span>
<span class="go">[ 1.0     5.0    31.0   121.0   341.0]</span>
<span class="go">[ 1.0    31.0   341.0  1555.0  4681.0]</span>
<span class="go">[ 1.0   121.0  1555.0  7381.0 22621.0]</span>
<span class="go">[ 1.0   341.0  4681.0 22621.0 69905.0]</span>
</pre></div>
</div>
<p>A complex matrix that is Hermitian and positive definite.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>        <span class="mi">23</span><span class="p">,</span>  <span class="mi">17</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">24</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">25</span><span class="p">,</span>     <span class="mi">21</span><span class="o">*</span><span class="n">I</span><span class="p">],</span>
<span class="go">....:                  [ -17*I + 3,        38, -69*I + 89, 7*I + 15],</span>
<span class="go">....:                  [-24*I + 25, 69*I + 89,        976, 24*I + 6],</span>
<span class="go">....:                  [     -21*I, -7*I + 15,  -24*I + 6,       28]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">cholesky</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">[               4.795832                     0.0                    0.0       0.0]</span>
<span class="go">[  0.625543 - 3.544745*I                5.004346                    0.0       0.0]</span>
<span class="go">[   5.21286 - 5.004346*I 13.588189 + 10.721116*I              24.984023       0.0]</span>
<span class="go">[            -4.378803*I  -0.104257 - 0.851434*I  -0.21486 + 0.371348*I  2.811799]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="n">L</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">())</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">[         23.0  3.0 + 17.0*I 25.0 + 24.0*I        21.0*I]</span>
<span class="go">[ 3.0 - 17.0*I          38.0 89.0 - 69.0*I  15.0 + 7.0*I]</span>
<span class="go">[25.0 - 24.0*I 89.0 + 69.0*I         976.0  6.0 + 24.0*I]</span>
<span class="go">[      -21.0*I  15.0 - 7.0*I  6.0 - 24.0*I          28.0]</span>
</pre></div>
</div>
<p>This routine will recognize when the input matrix is not
positive definite.  The negative eigenvalues are an
equivalent indicator.  (Eigenvalues of a Hermitian matrix
must be real, so there is no loss in ignoring the imprecise
imaginary parts).</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">3</span><span class="p">,</span>  <span class="o">-</span><span class="mi">6</span><span class="p">,</span>   <span class="mi">9</span><span class="p">,</span>   <span class="mi">6</span><span class="p">,</span>  <span class="o">-</span><span class="mi">9</span><span class="p">],</span>
<span class="go">....:                  [-6,  11, -16, -11,  17],</span>
<span class="go">....:                  [ 9, -16,  28,  16, -40],</span>
<span class="go">....:                  [ 6, -11,  16,   9, -19],</span>
<span class="go">....:                  [-9,  17, -40, -19,  68]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()</span>
<span class="go">[108.07..., 13.02..., -0.02..., -0.70..., -1.37...]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">cholesky</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">matrix is not positive definite</span>

<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>      <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">],</span>
<span class="go">....:                  [4 + 2*I,       8,    10*I],</span>
<span class="go">....:                  [2 - 2*I,   -10*I,      -3]])</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">ev</span><span class="o">.</span><span class="n">real</span><span class="p">()</span> <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="n">B</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()]</span>
<span class="go">[15.88..., 0.08..., -8.97...]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">cholesky</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">matrix is not positive definite</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>A trivial case.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">cholesky</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>The Cholesky factorization is only defined for square matrices.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">cholesky</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Cholesky decomposition requires a square matrix, not a 4 x 5 matrix</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.condition">
<tt class="descname">condition</tt><big>(</big><em>p='frob'</em><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.condition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the condition number of a square nonsingular matrix.</p>
<p>Roughly speaking, this is a measure of how sensitive
the matrix is to round-off errors in numerical computations.
The minimum possible value is 1.0, and larger numbers indicate
greater sensitivity.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">p</span></tt> - default: &#8216;frob&#8217; - controls which norm is used
to compute the condition number, allowable values are
&#8216;frob&#8217; (for the Frobenius norm), integers -2, -1, 1, 2,
positive and negative infinity. See output discussion
for specifics.</li>
</ul>
<p>OUTPUT:</p>
<p>The condition number of a matrix is the product of a norm
of the matrix times the norm of the inverse of the matrix.
This requires that the matrix be square and invertible
(nonsingular, full rank).</p>
<p>Returned value is a double precision floating point value
in <tt class="docutils literal"><span class="pre">RDF</span></tt>, or <tt class="docutils literal"><span class="pre">Infinity</span></tt>.  Row and column sums described below are
sums of the absolute values of the entries, where the
absolute value of the complex number <span class="math">\(a+bi\)</span> is <span class="math">\(\sqrt{a^2+b^2}\)</span>.
Singular values are the &#8220;diagonal&#8221; entries of the &#8220;S&#8221; matrix in
the singular value decomposition.</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">'frob'</span></tt>: the default norm employed in computing
the condition number, the Frobenius norm, which for a
matrix <span class="math">\(A=(a_{ij})\)</span> computes</p>
<div class="math">
\[\left(\sum_{i,j}\left\lvert{a_{i,j}}\right\rvert^2\right)^{1/2}\]</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">'sv'</span></tt>: the quotient of the maximal and minimal singular value.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">Infinity</span></tt> or <tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">oo</span></tt>: the maximum row sum.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">-Infinity</span></tt> or <tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">-oo</span></tt>: the minimum column sum.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">1</span></tt>: the maximum column sum.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">-1</span></tt>: the minimum column sum.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">2</span></tt>: the 2-norm, equal to the maximum singular value.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">-2</span></tt>: the minimum singular value.</p>
</li>
</ul>
<p>ALGORITHM:</p>
<p>Computation is performed by the <tt class="docutils literal"><span class="pre">cond()</span></tt> function of
the SciPy/NumPy library.</p>
<p>EXAMPLES:</p>
<p>First over the reals.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">)]);</span> <span class="n">A</span>
<span class="go">[   0.0   0.25    2.0   6.75]</span>
<span class="go">[  16.0  31.25   54.0  85.75]</span>
<span class="go">[ 128.0 182.25  250.0 332.75]</span>
<span class="go">[ 432.0 549.25  686.0 843.75]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">()</span>
<span class="go">9923.88955...</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="s1">&#39;frob&#39;</span><span class="p">)</span>
<span class="go">9923.88955...</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">Infinity</span><span class="p">)</span>  <span class="c1"># tol 2e-14</span>
<span class="go">22738.50000000045</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="n">Infinity</span><span class="p">)</span>  <span class="c1"># tol 2e-14</span>
<span class="go">17.50000000000028</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">12139.21...</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># tol 2e-14</span>
<span class="go">550.0000000000093</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">9897.8088...</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.000101032462...</span>
</pre></div>
</div>
<p>And over the complex numbers.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)]);</span> <span class="n">B</span>
<span class="go">[         0.0  1.0 + 1.0*I  2.0 + 4.0*I]</span>
<span class="go">[ 3.0 + 9.0*I 4.0 + 16.0*I 5.0 + 25.0*I]</span>
<span class="go">[6.0 + 36.0*I 7.0 + 49.0*I 8.0 + 64.0*I]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">()</span>
<span class="go">203.851798...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="s1">&#39;frob&#39;</span><span class="p">)</span>
<span class="go">203.851798...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">Infinity</span><span class="p">)</span>
<span class="go">369.55630...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="n">Infinity</span><span class="p">)</span>
<span class="go">5.46112969...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">289.251481...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">20.4566639...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">202.653543...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.00493453005...</span>
</pre></div>
</div>
<p>Hilbert matrices are famously ill-conditioned, while
an identity matrix can hit the minimum with the right norm.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">()</span>  <span class="c1"># tol 3e-5</span>
<span class="go">16332197709146.014</span>
<span class="gp">sage: </span><span class="nb">id</span> <span class="o">=</span> <span class="n">identity_matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">id</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>Return values are in <span class="math">\(RDF\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">()</span> <span class="ow">in</span> <span class="n">RDF</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Rectangular and singular matrices raise errors if p is not &#8216;sv&#8217;.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">matrix must be square if p is not &#39;sv&#39;, not 2 x 3</span>

<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="s1">&#39;sv&#39;</span><span class="p">)</span>
<span class="go">7.34...</span>

<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">25</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_singular</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">CDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">condition</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">LinAlgError</span>: <span class="n">Singular matrix</span>
</pre></div>
</div>
<p>Improper values of <tt class="docutils literal"><span class="pre">p</span></tt> are caught.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="s1">&#39;bogus&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">condition number &#39;p&#39; must be +/- infinity, &#39;frob&#39;, &#39;sv&#39; or an integer, not bogus</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">632</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">condition number integer values of &#39;p&#39; must be -2, -1, 1 or 2, not 632</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Some condition numbers, first by the definition which also exercises
<a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.norm" title="sage.matrix.matrix_double_dense.Matrix_double_dense.norm"><tt class="xref py py-meth docutils literal"><span class="pre">norm()</span></tt></a>, then by this method.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">abs</span><span class="p">(</span><span class="n">c</span><span class="o">-</span><span class="n">d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.0e-12</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">abs</span><span class="p">(</span><span class="n">c</span><span class="o">-</span><span class="n">d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.0e-12</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.determinant">
<tt class="descname">determinant</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.determinant" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the determinant of self.</p>
<p>ALGORITHM:</p>
<p>Use numpy</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span> <span class="n">m</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
<span class="go">-2.0</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">0</span><span class="p">,[]);</span> <span class="n">m</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
<span class="go">1.0</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span> <span class="n">m</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">self must be a square matrix</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvalues">
<tt class="descname">eigenvalues</tt><big>(</big><em>algorithm='default'</em>, <em>tol=None</em><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of eigenvalues.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> - a square matrix</li>
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> - default: <tt class="docutils literal"><span class="pre">'default'</span></tt><ul>
<li><tt class="docutils literal"><span class="pre">'default'</span></tt> - applicable to any matrix
with double-precision floating point entries.
Uses the <tt class="xref py py-meth docutils literal"><span class="pre">eigvals()</span></tt> method from SciPy.</li>
<li><tt class="docutils literal"><span class="pre">'symmetric'</span></tt> - converts the matrix into a real matrix
(i.e. with entries from <tt class="xref py py-class docutils literal"><span class="pre">RDF</span></tt>),
then applies the algorithm for Hermitian matrices.  This
algorithm can be significantly faster than the
<tt class="docutils literal"><span class="pre">'default'</span></tt> algorithm.</li>
<li><tt class="docutils literal"><span class="pre">'hermitian'</span></tt> - uses the <tt class="xref py py-meth docutils literal"><span class="pre">eigh()</span></tt> method
from SciPy, which applies only to real symmetric or complex
Hermitian matrices.  Since Hermitian is defined as a matrix
equaling its conjugate-transpose, for a matrix with real
entries this property is equivalent to being symmetric.
This algorithm can be significantly faster than the
<tt class="docutils literal"><span class="pre">'default'</span></tt> algorithm.</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">'tol'</span></tt> - default: <tt class="docutils literal"><span class="pre">None</span></tt> - if set to a value other than
<tt class="docutils literal"><span class="pre">None</span></tt> this is interpreted as a small real number used to aid in
grouping eigenvalues that are numerically similar.  See the output
description for more information.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>When using the <tt class="docutils literal"><span class="pre">'symmetric'</span></tt> or <tt class="docutils literal"><span class="pre">'hermitian'</span></tt> algorithms,
no check is made on the input matrix, and only the entries below,
and on, the main diagonal are employed in the computation.</p>
<p class="last">Methods such as <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_symmetric" title="sage.matrix.matrix_double_dense.Matrix_double_dense.is_symmetric"><tt class="xref py py-meth docutils literal"><span class="pre">is_symmetric()</span></tt></a> and <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_hermitian" title="sage.matrix.matrix_double_dense.Matrix_double_dense.is_hermitian"><tt class="xref py py-meth docutils literal"><span class="pre">is_hermitian()</span></tt></a>
could be used to verify this beforehand.</p>
</div>
<p>OUTPUT:</p>
<p>Default output for a square matrix of size <span class="math">\(n\)</span> is a list of <span class="math">\(n\)</span>
eigenvalues from the complex double field,
<tt class="xref py py-class docutils literal"><span class="pre">CDF</span></tt>.  If the <tt class="docutils literal"><span class="pre">'symmetric'</span></tt>
or <tt class="docutils literal"><span class="pre">'hermitian'</span></tt> algorithms are chosen, the returned eigenvalues
are from the real double field,
<tt class="xref py py-class docutils literal"><span class="pre">RDF</span></tt>.</p>
<p>If a tolerance is specified, an attempt is made to group eigenvalues
that are numerically similar.  The return is then a list of pairs,
where each pair is an eigenvalue followed by its multiplicity.
The eigenvalue reported is the mean of the eigenvalues computed,
and these eigenvalues are contained in an interval (or disk) whose
radius is less than <tt class="docutils literal"><span class="pre">5*tol</span></tt> for <span class="math">\(n &lt; 10,000\)</span> in the worst case.</p>
<p>More precisely, for an <span class="math">\(n\times n\)</span> matrix, the diameter of the
interval containing similar eigenvalues could be as large as sum
of the reciprocals of the first <span class="math">\(n\)</span> integers times <tt class="docutils literal"><span class="pre">tol</span></tt>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Use caution when using the  <tt class="docutils literal"><span class="pre">tol</span></tt> parameter to group
eigenvalues.  See the examples below to see how this can go wrong.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">ev</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">();</span> <span class="n">ev</span>
<span class="go">[-0.372281323..., 5.37228132...]</span>
<span class="gp">sage: </span><span class="n">ev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Complex Double Field</span>

<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">)</span>
<span class="go">[1.0*I, -1.0*I]</span>

<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">I</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="n">I</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()</span>
<span class="go">[-0.624810533... + 1.30024259...*I, 0.624810533... - 0.30024259...*I]</span>
</pre></div>
</div>
<p>The adjacency matrix of a graph will be symmetric, and the
eigenvalues will be real.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ev</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">);</span> <span class="n">ev</span>  <span class="c1"># tol 1e-14</span>
<span class="go">[-2.0000000000000004, -1.9999999999999998, -1.9999999999999998, -1.9999999999999993, 0.9999999999999994, 0.9999999999999997, 1.0, 1.0000000000000002, 1.0000000000000004, 2.9999999999999996]</span>
<span class="gp">sage: </span><span class="n">ev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Real Double Field</span>
</pre></div>
</div>
<p>The matrix <tt class="docutils literal"><span class="pre">A</span></tt> is &#8220;random&#8221;, but the construction of <tt class="docutils literal"><span class="pre">B</span></tt>
provides a positive-definite Hermitian matrix.  Note that
the eigenvalues of a Hermitian matrix are real, and the
eigenvalues of a positive-definite matrix will be positive.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span> <span class="mi">4</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span>  <span class="mi">8</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">7</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">5</span><span class="p">],</span>
<span class="go">....:             [ 7*I - 2, -4*I + 7, -2*I + 4, 8*I + 8],</span>
<span class="go">....:             [-2*I + 1,  6*I + 6,  5*I + 5,  -I - 4],</span>
<span class="go">....:             [ 5*I + 1,  6*I + 2,    I - 4, -I + 3]])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">())</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">CDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ev</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;hermitian&#39;</span><span class="p">);</span> <span class="n">ev</span>
<span class="go">[2.68144025..., 49.5167998..., 274.086188..., 390.71557...]</span>
<span class="gp">sage: </span><span class="n">ev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Real Double Field</span>
</pre></div>
</div>
<p>A tolerance can be given to aid in grouping eigenvalues that
are similar numerically.  However, if the parameter is too small
it might split too finely.  Too large, and it can go wrong very
badly.  Use with care.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">spectrum</span><span class="p">()</span>
<span class="go">[3, 1, 1, 1, 1, 1, -2, -2, -2, -2]</span>

<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">)</span>  <span class="c1"># tol 1e-15</span>
<span class="go">[(-1.9999999999999998, 4), (1.0, 5), (2.9999999999999996, 1)]</span>

<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">2.5</span><span class="p">)</span>  <span class="c1"># tol 1e-15</span>
<span class="go">[(-1.9999999999999998, 4), (1.3333333333333333, 6)]</span>
</pre></div>
</div>
<p>An (extreme) example of properly grouping similar eigenvalues.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">HigmanSimsGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">)</span>  <span class="c1"># tol 2e-15</span>
<span class="go">[(-8.0, 22), (1.9999999999999984, 77), (21.999999999999996, 1)]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Testing bad input.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;junk&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">algorithm must be &#39;default&#39;, &#39;symmetric&#39;, or &#39;hermitian&#39;, not junk</span>

<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">matrix must be square, not 2 x 3</span>

<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">cannot apply symmetric algorithm to matrix with complex entries</span>

<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="s1">&#39;junk&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">tolerance parameter must be a real number, not junk</span>

<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">tol</span><span class="o">=-</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">tolerance parameter must be positive, not -0.01</span>
</pre></div>
</div>
<p>A very small matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_left">
<tt class="descname">eigenvectors_left</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_left" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the left eigenvectors of a matrix of double precision
real or complex numbers (i.e. RDF or CDF).</p>
<p>OUTPUT:
Returns a list of triples, each of the form <tt class="docutils literal"><span class="pre">(e,[v],1)</span></tt>,
where <tt class="docutils literal"><span class="pre">e</span></tt> is the eigenvalue, and <tt class="docutils literal"><span class="pre">v</span></tt> is an associated
left eigenvector.  If the matrix is of size <span class="math">\(n\)</span>, then there are
<span class="math">\(n\)</span> triples.  Values are computed with the SciPy library.</p>
<p>The format of this output is designed to match the format
for exact results.  However, since matrices here have numerical
entries, the resulting eigenvalues will also be numerical.  No
attempt is made to determine if two eigenvalues are equal, or if
eigenvalues might actually be zero.  So the algebraic multiplicity
of each eigenvalue is reported as 1.  Decisions about equal
eigenvalues or zero eigenvalues should be addressed in the
calling routine.</p>
<p>The SciPy routines used for these computations produce eigenvectors
normalized to have length 1, but on different hardware they may vary
by a sign. So for doctests we have normalized output by forcing their
eigenvectors to have their first non-zero entry equal to one.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">17</span><span class="p">],[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">13</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">m</span>
<span class="go">[ -5.0   3.0   2.0   8.0]</span>
<span class="go">[ 10.0   2.0   4.0  -2.0]</span>
<span class="go">[ -1.0 -10.0 -10.0 -17.0]</span>
<span class="go">[ -2.0   7.0   6.0  13.0]</span>
<span class="gp">sage: </span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">left_eigenvectors</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)):</span>
<span class="go">....:   spectrum[i][1][0]=matrix(RDF, spectrum[i][1]).echelon_form()[0]</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(2.0000000000000675, [(1.0, 1.0000000000000138, 1.0000000000000147, 1.0000000000000309)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(0.9999999999999164, [(0.9999999999999999, 0.7999999999999833, 0.7999999999999836, 0.5999999999999696)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(-1.9999999999999782, [(1.0, 0.40000000000000335, 0.6000000000000039, 0.2000000000000051)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(-1.0000000000000018, [(1.0, 0.9999999999999568, 1.9999999999998794, 1.9999999999998472)], 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_right">
<tt class="descname">eigenvectors_right</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.eigenvectors_right" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the right eigenvectors of a matrix of double precision
real or complex numbers (i.e. RDF or CDF).</p>
<p>OUTPUT:</p>
<p>Returns a list of triples, each of the form <tt class="docutils literal"><span class="pre">(e,[v],1)</span></tt>,
where <tt class="docutils literal"><span class="pre">e</span></tt> is the eigenvalue, and <tt class="docutils literal"><span class="pre">v</span></tt> is an associated
right eigenvector.  If the matrix is of size <span class="math">\(n\)</span>, then there
are <span class="math">\(n\)</span> triples.  Values are computed with the SciPy library.</p>
<p>The format of this output is designed to match the format
for exact results.  However, since matrices here have numerical
entries, the resulting eigenvalues will also be numerical.  No
attempt is made to determine if two eigenvalues are equal, or if
eigenvalues might actually be zero.  So the algebraic multiplicity
of each eigenvalue is reported as 1.  Decisions about equal
eigenvalues or zero eigenvalues should be addressed in the
calling routine.</p>
<p>The SciPy routines used for these computations produce eigenvectors
normalized to have length 1, but on different hardware they may vary
by a sign. So for doctests we have normalized output by forcing their
eigenvectors to have their first non-zero entry equal to one.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">14</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="o">-</span><span class="mi">74</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span><span class="p">],[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">32</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">m</span>
<span class="go">[ -9.0 -14.0  19.0 -74.0]</span>
<span class="go">[ -1.0   2.0   4.0 -11.0]</span>
<span class="go">[ -4.0 -12.0   6.0 -32.0]</span>
<span class="go">[  0.0  -2.0  -1.0   1.0]</span>
<span class="gp">sage: </span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">right_eigenvectors</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)):</span>
<span class="go">....:   spectrum[i][1][0]=matrix(RDF, spectrum[i][1]).echelon_form()[0]</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(2.000000000000048, [(1.0, -2.0000000000001523, 3.000000000000181, 1.0000000000000746)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(0.999999999999941, [(1.0, -0.666666666666633, 1.333333333333286, 0.33333333333331555)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(-1.9999999999999483, [(1.0, -0.2000000000000063, 1.0000000000000173, 0.20000000000000498)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(-1.0000000000000406, [(1.0, -0.49999999999996264, 1.9999999999998617, 0.499999999999958)], 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.exp">
<tt class="descname">exp</tt><big>(</big><em>algorithm=None</em>, <em>order=None</em><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the exponential of this matrix X, which is the matrix</p>
<div class="math">
\[e^X = \sum_{k=0}^{\infty} \frac{X^k}{k!}.\]</div>
<p>INPUT:</p>
<ul class="simple">
<li>algorithm &#8211; deprecated</li>
<li>order &#8211; deprecated</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">=</span><span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span> <span class="n">A</span>
<span class="go">[1.0 2.0]</span>
<span class="go">[3.0 4.0]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>  <span class="c1"># tol 1e-15</span>
<span class="go">[51.968956198705044  74.73656456700327]</span>
<span class="go">[112.10484685050491 164.07380304920997]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">=</span><span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">+</span><span class="n">I</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span> <span class="n">A</span>
<span class="go">[        1.0 2.0 + 1.0*I]</span>
<span class="go">[      3.0*I         4.0]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>  <span class="c1"># tol 1e-14</span>
<span class="go">[-19.614602953804912 + 12.517743846762578*I   3.7949636449582176 + 28.88379930658099*I]</span>
<span class="go">[ -32.383580980922254 + 21.88423595789845*I   2.269633004093535 + 44.901324827684824*I]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;eig&#39;</span><span class="p">)</span>
<span class="go">doctest:...: DeprecationWarning: The algorithm and order arguments are deprecated.</span>
<span class="go">See http://trac.sagemath.org/17140 for details.</span>
<span class="gp">sage: </span><span class="n">E</span>  <span class="c1"># tol 1e-15</span>
<span class="go">[51.968956198705044  74.73656456700327]</span>
<span class="go">[112.10484685050491 164.07380304920997]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;taylor&#39;</span><span class="p">)</span>   <span class="c1"># tol 1e-15</span>
<span class="go">[51.968956198705044  74.73656456700327]</span>
<span class="go">[112.10484685050491 164.07380304920997]</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">+</span><span class="n">I</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;eig&#39;</span><span class="p">)</span>  <span class="c1"># tol 3e-14</span>
<span class="go">[-19.614602953804923 + 12.51774384676257*I 3.7949636449582016 + 28.883799306580997*I]</span>
<span class="go">[-32.38358098092227 + 21.884235957898433*I  2.2696330040935084 + 44.90132482768484*I]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.is_hermitian">
<tt class="descname">is_hermitian</tt><big>(</big><em>tol=1e-12</em>, <em>algorithm='orthonormal'</em><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_hermitian" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if the matrix is equal to its conjugate-transpose.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">tol</span></tt> - default: <tt class="docutils literal"><span class="pre">1e-12</span></tt> - the largest value of the
absolute value of the difference between two matrix entries
for which they will still be considered equal.</li>
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> - default: &#8216;orthonormal&#8217; - set to &#8216;orthonormal&#8217;
for a stable procedure and set to &#8216;naive&#8217; for a fast
procedure.</li>
</ul>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">True</span></tt> if the matrix is square and equal to the transpose
with every entry conjugated, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>Note that if conjugation has no effect on elements of the base
ring (such as for integers), then the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_symmetric" title="sage.matrix.matrix_double_dense.Matrix_double_dense.is_symmetric"><tt class="xref py py-meth docutils literal"><span class="pre">is_symmetric()</span></tt></a>
method is equivalent and faster.</p>
<p>The tolerance parameter is used to allow for numerical values
to be equal if there is a slight difference due to round-off
and other imprecisions.</p>
<p>The result is cached, on a per-tolerance and per-algorithm basis.</p>
<p>ALGORITHMS:</p>
<p>The naive algorithm simply compares corresponing entries on either
side of the diagonal (and on the diagonal itself) to see if they are
conjugates, with equality controlled by the tolerance parameter.</p>
<p>The orthonormal algorithm first computes a Schur decomposition
(via the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.schur" title="sage.matrix.matrix_double_dense.Matrix_double_dense.schur"><tt class="xref py py-meth docutils literal"><span class="pre">schur()</span></tt></a> method) and checks that the result is a
diagonal matrix with real entries.</p>
<p>So the naive algorithm can finish quickly for a matrix that is not
Hermitian, while the orthonormal algorithm will always compute a
Schur decomposition before going through a similar check of the matrix
entry-by-entry.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span>  <span class="mi">1</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">I</span><span class="p">],</span>
<span class="go">....:                  [-3 - I,     -4*I,     -2],</span>
<span class="go">....:                  [-1 + I, -2 - 8*I,  2 + I]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A matrix that is nearly Hermitian, but for one non-real
diagonal entry.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>    <span class="mi">2</span><span class="p">,</span>   <span class="mi">2</span><span class="o">-</span><span class="n">I</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">],</span>
<span class="go">....:                  [  2+I,   3+I, 2-6*I],</span>
<span class="go">....:                  [1-4*I, 2+6*I,     5]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">132</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We get a unitary matrix from the SVD routine and use this
numerical matrix to create a matrix that should be Hermitian
(indeed it should be the identity matrix), but with some
imprecision.  We use this to illustrate that if the tolerance
is set too small, then we can be too strict about the equality
of entries and may achieve the wrong result (depending on
the system):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span>  <span class="mi">1</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">I</span><span class="p">],</span>
<span class="go">....:                  [-3 - I,     -4*I,     -2],</span>
<span class="go">....:                  [-1 + I, -2 - 8*I,  2 + I]])</span>
<span class="gp">sage: </span><span class="n">U</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">SVD</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">=</span><span class="n">U</span><span class="o">*</span><span class="n">U</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-17</span><span class="p">)</span>  <span class="c1"># random</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-15</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A square, empty matrix is trivially Hermitian.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Rectangular matrices are never Hermitian, no matter which
algorithm is requested.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>The tolerance must be strictly positive.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">tolerance must be positive, not -3.1</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">algorithm</span></tt> keyword gets checked.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;junk&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">algorithm must be &#39;naive&#39; or &#39;orthonormal&#39;, not junk</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Rob Beezer (2011-03-30)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.is_normal">
<tt class="descname">is_normal</tt><big>(</big><em>tol=1e-12</em>, <em>algorithm='orthonormal'</em><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if the matrix commutes with its conjugate-transpose.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">tol</span></tt> - default: <tt class="docutils literal"><span class="pre">1e-12</span></tt> - the largest value of the
absolute value of the difference between two matrix entries
for which they will still be considered equal.</li>
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> - default: &#8216;orthonormal&#8217; - set to &#8216;orthonormal&#8217;
for a stable procedure and set to &#8216;naive&#8217; for a fast
procedure.</li>
</ul>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">True</span></tt> if the matrix is square and commutes with its
conjugate-transpose, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>Normal matrices are precisely those that can be diagonalized
by a unitary matrix.</p>
<p>The tolerance parameter is used to allow for numerical values
to be equal if there is a slight difference due to round-off
and other imprecisions.</p>
<p>The result is cached, on a per-tolerance and per-algorithm basis.</p>
<p>ALGORITHMS:</p>
<p>The naive algorithm simply compares entries of the two possible
products of the matrix with its conjugate-transpose, with equality
controlled by the tolerance parameter.</p>
<p>The orthonormal algorithm first computes a Schur decomposition
(via the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.schur" title="sage.matrix.matrix_double_dense.Matrix_double_dense.schur"><tt class="xref py py-meth docutils literal"><span class="pre">schur()</span></tt></a> method) and checks that the result is a
diagonal matrix.  An orthonormal diagonalization
is equivalent to being normal.</p>
<p>So the naive algorithm can finish fairly quickly for a matrix
that is not normal, once the products have been computed.
However, the orthonormal algorithm will compute a Schur
decomposition before going through a similar check of a
matrix entry-by-entry.</p>
<p>EXAMPLES:</p>
<p>First over the complexes.  <tt class="docutils literal"><span class="pre">B</span></tt> is Hermitian, hence normal.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span>  <span class="mi">1</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">I</span><span class="p">],</span>
<span class="go">....:                  [-3 - I,     -4*I,     -2],</span>
<span class="go">....:                  [-1 + I, -2 - 8*I,  2 + I]])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Now over the reals.  Circulant matrices are normal.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CirculantGraph</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">D</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_normal</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">[</span><span class="mi">19</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.0</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_normal</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Skew-Hermitian matrices are normal.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span>  <span class="mi">1</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">I</span><span class="p">],</span>
<span class="go">....:                  [-3 - I,     -4*I,     -2],</span>
<span class="go">....:                  [-1 + I, -2 - 8*I,  2 + I]])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_normal</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A small matrix that does not fit into any of the usual categories
of normal matrices.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="go">....:                  [1,  1]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_normal</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="ow">not</span> <span class="n">A</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">A</span><span class="o">.</span><span class="n">is_skew_symmetric</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Sage has several fields besides the entire complex numbers
where conjugation is non-trivial.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span><span class="o">.&lt;</span><span class="n">b</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">7</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="mi">3</span><span class="p">],</span>
<span class="go">....:                [-2*b - 3, -3*b + 2,   -2*b],</span>
<span class="go">....:                [   b + 1,        0,     -2]])</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_normal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A square, empty matrix is trivially normal.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_normal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Rectangular matrices are never normal, no matter which
algorithm is requested.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_normal</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>The tolerance must be strictly positive.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">tolerance must be positive, not -3.1</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">algorithm</span></tt> keyword gets checked.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_normal</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;junk&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">algorithm must be &#39;naive&#39; or &#39;orthonormal&#39;, not junk</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<blockquote>
<div><ul class="simple">
<li>Rob Beezer (2011-03-31)</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite">
<tt class="descname">is_positive_definite</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if a matrix is positive definite.</p>
<p>A matrix <span class="math">\(A\)</span> is positive definite if it is square,
is Hermitian (which reduces to symmetric in the real case),
and for every nonzero vector <span class="math">\(\vec{x}\)</span>,</p>
<div class="math">
\[\begin{split}\vec{x}^\ast A \vec{x} &gt; 0\end{split}\]</div>
<p>where <span class="math">\(\vec{x}^\ast\)</span> is the conjugate-transpose in the
complex case and just the transpose in the real case.
Equivalently, a positive definite matrix has only positive
eigenvalues and only positive determinants of leading
principal submatrices.</p>
<p>INPUT:</p>
<p>Any matrix over <tt class="docutils literal"><span class="pre">RDF</span></tt> or <tt class="docutils literal"><span class="pre">CDF</span></tt>.</p>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">True</span></tt> if and only if the matrix is square, Hermitian,
and meets the condition above on the quadratic form.
The result is cached.</p>
<p>IMPLEMENTATION:</p>
<p>The existence of a Cholesky decomposition and the
positive definite property are equivalent.  So this
method and the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky" title="sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky"><tt class="xref py py-meth docutils literal"><span class="pre">cholesky()</span></tt></a> method compute and
cache both the Cholesky decomposition and the
positive-definiteness.  So the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite" title="sage.matrix.matrix_double_dense.Matrix_double_dense.is_positive_definite"><tt class="xref py py-meth docutils literal"><span class="pre">is_positive_definite()</span></tt></a>
method or catching a <tt class="docutils literal"><span class="pre">ValueError</span></tt> from the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky" title="sage.matrix.matrix_double_dense.Matrix_double_dense.cholesky"><tt class="xref py py-meth docutils literal"><span class="pre">cholesky()</span></tt></a>
method are equally expensive computationally and if the
decomposition exists, it is cached as a side-effect of either
routine.</p>
<p>EXAMPLES:</p>
<p>A matrix over <tt class="docutils literal"><span class="pre">RDF</span></tt> that is positive definite.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,[[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span><span class="p">,</span>     <span class="mi">1</span><span class="p">,</span>     <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                 [ 1,  5,   31,   121,   341],</span>
<span class="go">....:                 [ 1, 31,  341,  1555,  4681],</span>
<span class="go">....:                 [ 1,121, 1555,  7381, 22621],</span>
<span class="go">....:                 [ 1,341, 4681, 22621, 69905]])</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()</span>
<span class="go">[77547.66..., 82.44..., 2.41..., 0.46..., 0.011...]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">M</span><span class="p">[:</span><span class="n">i</span><span class="p">,:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">determinant</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="go">[1, 4, 460, 27936, 82944]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A matrix over <tt class="docutils literal"><span class="pre">CDF</span></tt> that is positive definite.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>        <span class="mi">23</span><span class="p">,</span>  <span class="mi">17</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">24</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">25</span><span class="p">,</span>     <span class="mi">21</span><span class="o">*</span><span class="n">I</span><span class="p">],</span>
<span class="go">....:                  [ -17*I + 3,        38, -69*I + 89, 7*I + 15],</span>
<span class="go">....:                  [-24*I + 25, 69*I + 89,        976, 24*I + 6],</span>
<span class="go">....:                  [     -21*I, -7*I + 15,  -24*I + 6,       28]])</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()]</span>
<span class="go">[991.46..., 55.96..., 3.69..., 13.87...]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">C</span><span class="p">[:</span><span class="n">i</span><span class="p">,:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">determinant</span><span class="p">()</span><span class="o">.</span><span class="n">real</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="go">[23, 576, 359540, 2842600]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A matrix over <tt class="docutils literal"><span class="pre">RDF</span></tt> that is not positive definite.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">3</span><span class="p">,</span>  <span class="o">-</span><span class="mi">6</span><span class="p">,</span>   <span class="mi">9</span><span class="p">,</span>   <span class="mi">6</span><span class="p">,</span>  <span class="o">-</span><span class="mi">9</span><span class="p">],</span>
<span class="go">....:                  [-6,  11, -16, -11,  17],</span>
<span class="go">....:                  [ 9, -16,  28,  16, -40],</span>
<span class="go">....:                  [ 6, -11,  16,   9, -19],</span>
<span class="go">....:                  [-9,  17, -40, -19,  68]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()</span>
<span class="go">[108.07..., 13.02..., -0.02..., -0.70..., -1.37...]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="n">i</span><span class="p">,:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">determinant</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="go">[3, -3, -15, 30, -30]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A matrix over <tt class="docutils literal"><span class="pre">CDF</span></tt> that is not positive definite.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>      <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">],</span>
<span class="go">....:                  [4 + 2*I,       8,    10*I],</span>
<span class="go">....:                  [2 - 2*I,   -10*I,      -3]])</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">ev</span><span class="o">.</span><span class="n">real</span><span class="p">()</span> <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="n">B</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()]</span>
<span class="go">[15.88..., 0.08..., -8.97...]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">B</span><span class="p">[:</span><span class="n">i</span><span class="p">,:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">determinant</span><span class="p">()</span><span class="o">.</span><span class="n">real</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="go">[2, -4, -12]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A large random matrix that is guaranteed by theory to be
positive definite.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">random_matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">conjugate_transpose</span><span class="p">()</span><span class="o">*</span><span class="n">R</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>A trivially small case.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">nrows</span><span class="p">(),</span> <span class="n">S</span><span class="o">.</span><span class="n">ncols</span><span class="p">()</span>
<span class="go">(0, 0)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A rectangular matrix will never be positive definite.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A non-Hermitian matrix will never be positive definite.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Rob Beezer (2012-05-28)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.is_symmetric">
<tt class="descname">is_symmetric</tt><big>(</big><em>tol=1e-12</em><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether this matrix is symmetric, to the given tolerance.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span> <span class="n">m</span>
<span class="go">[0.0 1.0]</span>
<span class="go">[2.0 3.0]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">;</span> <span class="n">m</span>
<span class="go">[0.0 1.0]</span>
<span class="go">[1.1 3.0]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="docutils">
<dt>The tolerance inequality is strict:</dt>
<dd>sage: m.is_symmetric(tol=0.1)
False
sage: m.is_symmetric(tol=0.11)
True</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.is_unitary">
<tt class="descname">is_unitary</tt><big>(</big><em>tol=1e-12</em>, <em>algorithm='orthonormal'</em><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.is_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if the columns of the matrix are an orthonormal basis.</p>
<p>For a matrix with real entries this determines if a matrix is
&#8220;orthogonal&#8221; and for a matrix with complex entries this determines
if the matrix is &#8220;unitary.&#8221;</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">tol</span></tt> - default: <tt class="docutils literal"><span class="pre">1e-12</span></tt> - the largest value of the
absolute value of the difference between two matrix entries
for which they will still be considered equal.</li>
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> - default: &#8216;orthonormal&#8217; - set to &#8216;orthonormal&#8217;
for a stable procedure and set to &#8216;naive&#8217; for a fast
procedure.</li>
</ul>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">True</span></tt> if the matrix is square and its conjugate-transpose is
its inverse, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.  In other words, a matrix
is orthogonal or unitary if the product of its conjugate-transpose
times the matrix is the identity matrix.</p>
<p>The tolerance parameter is used to allow for numerical values
to be equal if there is a slight difference due to round-off
and other imprecisions.</p>
<p>The result is cached, on a per-tolerance and per-algorithm basis.</p>
<p>ALGORITHMS:</p>
<p>The naive algorithm simply computes the product of the
conjugate-transpose with the matrix and compares the entries
to the identity matrix, with equality controlled by the
tolerance parameter.</p>
<p>The orthonormal algorithm first computes a Schur decomposition
(via the <a class="reference internal" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.schur" title="sage.matrix.matrix_double_dense.Matrix_double_dense.schur"><tt class="xref py py-meth docutils literal"><span class="pre">schur()</span></tt></a> method) and checks that the result is a
diagonal matrix with entries of modulus 1, which is equivalent to
being unitary.</p>
<p>So the naive algorithm might finish fairly quickly for a matrix
that is not unitary, once the product has been computed.
However, the orthonormal algorithm will compute a Schur
decomposition before going through a similar check of a
matrix entry-by-entry.</p>
<p>EXAMPLES:</p>
<p>A matrix that is far from unitary.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">*</span><span class="n">A</span>
<span class="go">[224.0 248.0 272.0 296.0]</span>
<span class="go">[248.0 276.0 304.0 332.0]</span>
<span class="go">[272.0 304.0 336.0 368.0]</span>
<span class="go">[296.0 332.0 368.0 404.0]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The QR decoposition will produce a unitary matrix as Q and the
SVD decomposition will create two unitary matrices, U and V.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>   <span class="mi">1</span> <span class="o">-</span> <span class="n">I</span><span class="p">,</span>   <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>  <span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span>        <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">],</span>
<span class="go">....:                  [   1 - I, -2 + I, 1 + 4*I,        0,    2 + I],</span>
<span class="go">....:                  [      -1, -5 + I,  -2 + I,    1 + I, -5 - 4*I],</span>
<span class="go">....:                  [-2 + 4*I,  2 - I, 8 - 4*I,  1 - 8*I,  3 - 2*I]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">QR</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">SVD</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If we make the tolerance too strict we can get misleading results.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">QR</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-16</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-17</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Rectangular matrices are not unitary/orthogonal, even if their
columns form an orthonormal set.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The smallest cases.  The Schur decomposition used by the
orthonormal algorithm will fail on a matrix of size zero.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;orthonormal&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">failed to create intent(cache|hide)|optional array-- must have defined dimensions but got (0,)</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="s1">&#39;junk&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">tolerance must be a real number, not junk</span>

<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">tol</span><span class="o">=-</span><span class="mf">0.3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">tolerance must be positive, not -0.3</span>

<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;junk&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">algorithm must be &#39;naive&#39; or &#39;orthonormal&#39;, not junk</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Rob Beezer (2011-05-04)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.left_eigenvectors">
<tt class="descname">left_eigenvectors</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.left_eigenvectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the left eigenvectors of a matrix of double precision
real or complex numbers (i.e. RDF or CDF).</p>
<p>OUTPUT:
Returns a list of triples, each of the form <tt class="docutils literal"><span class="pre">(e,[v],1)</span></tt>,
where <tt class="docutils literal"><span class="pre">e</span></tt> is the eigenvalue, and <tt class="docutils literal"><span class="pre">v</span></tt> is an associated
left eigenvector.  If the matrix is of size <span class="math">\(n\)</span>, then there are
<span class="math">\(n\)</span> triples.  Values are computed with the SciPy library.</p>
<p>The format of this output is designed to match the format
for exact results.  However, since matrices here have numerical
entries, the resulting eigenvalues will also be numerical.  No
attempt is made to determine if two eigenvalues are equal, or if
eigenvalues might actually be zero.  So the algebraic multiplicity
of each eigenvalue is reported as 1.  Decisions about equal
eigenvalues or zero eigenvalues should be addressed in the
calling routine.</p>
<p>The SciPy routines used for these computations produce eigenvectors
normalized to have length 1, but on different hardware they may vary
by a sign. So for doctests we have normalized output by forcing their
eigenvectors to have their first non-zero entry equal to one.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">17</span><span class="p">],[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">13</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">m</span>
<span class="go">[ -5.0   3.0   2.0   8.0]</span>
<span class="go">[ 10.0   2.0   4.0  -2.0]</span>
<span class="go">[ -1.0 -10.0 -10.0 -17.0]</span>
<span class="go">[ -2.0   7.0   6.0  13.0]</span>
<span class="gp">sage: </span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">left_eigenvectors</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)):</span>
<span class="go">....:   spectrum[i][1][0]=matrix(RDF, spectrum[i][1]).echelon_form()[0]</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(2.0000000000000675, [(1.0, 1.0000000000000138, 1.0000000000000147, 1.0000000000000309)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(0.9999999999999164, [(0.9999999999999999, 0.7999999999999833, 0.7999999999999836, 0.5999999999999696)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(-1.9999999999999782, [(1.0, 0.40000000000000335, 0.6000000000000039, 0.2000000000000051)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(-1.0000000000000018, [(1.0, 0.9999999999999568, 1.9999999999998794, 1.9999999999998472)], 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.log_determinant">
<tt class="descname">log_determinant</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.log_determinant" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the log of the absolute value of the determinant
using LU decomposition.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is useful if the usual determinant overflows.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span> <span class="n">m</span>
<span class="go">[0.0 1.0]</span>
<span class="go">[2.0 3.0]</span>
<span class="gp">sage: </span><span class="n">RDF</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">determinant</span><span class="p">())))</span>
<span class="go">0.6931471805599453</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">log_determinant</span><span class="p">()</span>
<span class="go">0.6931471805599453</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,[]);</span> <span class="n">m</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">log_determinant</span><span class="p">()</span>
<span class="go">0.0</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span> <span class="n">m</span>
<span class="go">[0.0 1.0]</span>
<span class="go">[2.0 3.0]</span>
<span class="gp">sage: </span><span class="n">RDF</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">determinant</span><span class="p">())))</span>
<span class="go">0.6931471805599453</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">log_determinant</span><span class="p">()</span>
<span class="go">0.6931471805599453</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,[]);</span> <span class="n">m</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">log_determinant</span><span class="p">()</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.norm">
<tt class="descname">norm</tt><big>(</big><em>p=2</em><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the norm of the matrix.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">p</span></tt> - default: 2 - controls which norm is computed,
allowable values are &#8216;frob&#8217; (for the Frobenius norm),
integers -2, -1, 1, 2, positive and negative infinity.  See
output discussion for specifics.</li>
</ul>
<p>OUTPUT:</p>
<p>Returned value is a double precision floating point value
in <tt class="docutils literal"><span class="pre">RDF</span></tt>.  Row and column sums described below are
sums of the absolute values of the entries, where the
absolute value of the complex number <span class="math">\(a+bi\)</span> is <span class="math">\(\sqrt{a^2+b^2}\)</span>.
Singular values are the &#8220;diagonal&#8221; entries of the &#8220;S&#8221; matrix in
the singular value decomposition.</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">'frob'</span></tt>: the Frobenius norm, which for
a matrix <span class="math">\(A=(a_{ij})\)</span> computes</p>
<div class="math">
\[\left(\sum_{i,j}\left\lvert{a_{i,j}}\right\rvert^2\right)^{1/2}\]</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">Infinity</span></tt> or <tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">oo</span></tt>: the maximum row sum.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">-Infinity</span></tt> or <tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">-oo</span></tt>: the minimum column sum.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">1</span></tt>: the maximum column sum.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">-1</span></tt>: the minimum column sum.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">2</span></tt>: the induced 2-norm, equal to the maximum singular value.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">-2</span></tt>: the minimum singular value.</p>
</li>
</ul>
<p>ALGORITHM:</p>
<p>Computation is performed by the <tt class="docutils literal"><span class="pre">norm()</span></tt> function of
the SciPy/NumPy library.</p>
<p>EXAMPLES:</p>
<p>First over the reals.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">));</span> <span class="n">A</span>
<span class="go">[-3.0 -2.0 -1.0]</span>
<span class="go">[ 0.0  1.0  2.0]</span>
<span class="go">[ 3.0  4.0  5.0]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="go">7.99575670...</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="s1">&#39;frob&#39;</span><span class="p">)</span>
<span class="go">8.30662386...</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">Infinity</span><span class="p">)</span>
<span class="go">12.0</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="n">Infinity</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">8.0</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">6.0</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">7.99575670...</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">^-</span><span class="mi">15</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And over the complex numbers.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="o">+</span><span class="n">I</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">],[</span><span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">]]);</span> <span class="n">B</span>
<span class="go">[1.0 + 1.0*I 2.0 + 3.0*I]</span>
<span class="go">[3.0 + 4.0*I       3.0*I]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="go">6.66189877...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="s1">&#39;frob&#39;</span><span class="p">)</span>
<span class="go">7.0</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">Infinity</span><span class="p">)</span>
<span class="go">8.0</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="n">Infinity</span><span class="p">)</span>
<span class="go">5.01976483...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">6.60555127...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">6.41421356...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">6.66189877...</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2.14921023...</span>
</pre></div>
</div>
<p>Since it is invariant under unitary multiplication, the
Frobenius norm is equal to the square root of the sum of
squares of the singular values.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">26</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="s1">&#39;frob&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">SVD</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]))</span>
<span class="gp">sage: </span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="o">-</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.0e-12</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Return values are in <span class="math">\(RDF\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="ow">in</span> <span class="n">RDF</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Improper values of <tt class="docutils literal"><span class="pre">p</span></tt> are caught.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="s1">&#39;bogus&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">matrix norm &#39;p&#39; must be +/- infinity, &#39;frob&#39; or an integer, not bogus</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">632</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">matrix norm integer values of &#39;p&#39; must be -2, -1, 1 or 2, not 632</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.numpy">
<tt class="descname">numpy</tt><big>(</big><em>dtype=None</em><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns a copy of the matrix as a numpy array. It
uses the numpy C/api so is very fast.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">dtype</span></tt> - The desired data-type for the array. If not given,
then the type will be determined as the minimum type required
to hold the objects in the sequence.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">sage: </span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">(array([-0.37228132,  5.37228132]), array([[-0.82456484, -0.41597356],</span>
<span class="go">       [ 0.56576746, -0.90937671]]))</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span> <span class="n">m</span>
<span class="go">[0.0 1.0 2.0]</span>
<span class="go">[3.0 4.0 5.0]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4.,  5.]])</span>
</pre></div>
</div>
<p>Alternatively, numpy automatically calls this function (via
the magic <tt class="xref py py-meth docutils literal"><span class="pre">__array__()</span></tt> method) to convert Sage matrices
to numpy arrays:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span> <span class="n">m</span>
<span class="go">[0.0 1.0 2.0]</span>
<span class="go">[3.0 4.0 5.0]</span>
<span class="gp">sage: </span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4.,  5.]])</span>
<span class="gp">sage: </span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span> <span class="n">m</span>
<span class="go">[0.0 1.0 2.0]</span>
<span class="go">[3.0 4.0 5.0]</span>
<span class="gp">sage: </span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">array([[ 0.+0.j,  1.+0.j,  2.+0.j],</span>
<span class="go">       [ 3.+0.j,  4.+0.j,  5.+0.j]])</span>
<span class="gp">sage: </span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;complex128&#39;)</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,[]);</span> <span class="n">m</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
<span class="go">array([], shape=(0, 5), dtype=float64)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,[]);</span> <span class="n">m</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
<span class="go">array([], shape=(5, 0), dtype=float64)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.right_eigenvectors">
<tt class="descname">right_eigenvectors</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.right_eigenvectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the right eigenvectors of a matrix of double precision
real or complex numbers (i.e. RDF or CDF).</p>
<p>OUTPUT:</p>
<p>Returns a list of triples, each of the form <tt class="docutils literal"><span class="pre">(e,[v],1)</span></tt>,
where <tt class="docutils literal"><span class="pre">e</span></tt> is the eigenvalue, and <tt class="docutils literal"><span class="pre">v</span></tt> is an associated
right eigenvector.  If the matrix is of size <span class="math">\(n\)</span>, then there
are <span class="math">\(n\)</span> triples.  Values are computed with the SciPy library.</p>
<p>The format of this output is designed to match the format
for exact results.  However, since matrices here have numerical
entries, the resulting eigenvalues will also be numerical.  No
attempt is made to determine if two eigenvalues are equal, or if
eigenvalues might actually be zero.  So the algebraic multiplicity
of each eigenvalue is reported as 1.  Decisions about equal
eigenvalues or zero eigenvalues should be addressed in the
calling routine.</p>
<p>The SciPy routines used for these computations produce eigenvectors
normalized to have length 1, but on different hardware they may vary
by a sign. So for doctests we have normalized output by forcing their
eigenvectors to have their first non-zero entry equal to one.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">14</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="o">-</span><span class="mi">74</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span><span class="p">],[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">32</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">m</span>
<span class="go">[ -9.0 -14.0  19.0 -74.0]</span>
<span class="go">[ -1.0   2.0   4.0 -11.0]</span>
<span class="go">[ -4.0 -12.0   6.0 -32.0]</span>
<span class="go">[  0.0  -2.0  -1.0   1.0]</span>
<span class="gp">sage: </span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">right_eigenvectors</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)):</span>
<span class="go">....:   spectrum[i][1][0]=matrix(RDF, spectrum[i][1]).echelon_form()[0]</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(2.000000000000048, [(1.0, -2.0000000000001523, 3.000000000000181, 1.0000000000000746)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(0.999999999999941, [(1.0, -0.666666666666633, 1.333333333333286, 0.33333333333331555)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(-1.9999999999999483, [(1.0, -0.2000000000000063, 1.0000000000000173, 0.20000000000000498)], 1)</span>
<span class="gp">sage: </span><span class="n">spectrum</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># tol 1e-13</span>
<span class="go">(-1.0000000000000406, [(1.0, -0.49999999999996264, 1.9999999999998617, 0.499999999999958)], 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.round">
<tt class="descname">round</tt><big>(</big><em>ndigits=0</em><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the matrix where all entries have been rounded
to a given precision in decimal digits (default 0 digits).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ndigits</span></tt> - The precision in number of decimal digits</li>
</ul>
<p>OUTPUT:</p>
<p>A modified copy of the matrix</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mf">10.234</span><span class="n">r</span> <span class="o">+</span> <span class="mf">34.2343j</span><span class="n">r</span><span class="p">,</span> <span class="mf">34e10</span><span class="n">r</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">M</span>
<span class="go">[10.234 + 34.2343*I     340000000000.0]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[10.23 + 34.23*I  340000000000.0]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">[ 10.0 + 34.0*I 340000000000.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.schur">
<tt class="descname">schur</tt><big>(</big><em>base_ring=None</em><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.schur" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Schur decomposition of the matrix.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">base_ring</span></tt> - optional, defaults to the base ring of <tt class="docutils literal"><span class="pre">self</span></tt>.
Use this to request the base ring of the returned matrices, which
will affect the format of the results.</li>
</ul>
<p>OUTPUT:</p>
<p>A pair of immutable matrices.  The first is a unitary matrix <span class="math">\(Q\)</span>.
The second, <span class="math">\(T\)</span>, is upper-triangular when returned over the complex
numbers, while it is almost upper-triangular over the reals.  In the
latter case, there can be some <span class="math">\(2\times 2\)</span> blocks on the diagonal
which represent a pair of conjugate complex eigenvalues of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>If <tt class="docutils literal"><span class="pre">self</span></tt> is the matrix <span class="math">\(A\)</span>, then</p>
<div class="math">
\[A = QT({\overline Q})^t\]</div>
<p>where the latter matrix is the conjugate-transpose of <tt class="docutils literal"><span class="pre">Q</span></tt>, which
is also the inverse of <tt class="docutils literal"><span class="pre">Q</span></tt>, since <tt class="docutils literal"><span class="pre">Q</span></tt> is unitary.</p>
<p>Note that in the case of a normal matrix (Hermitian, symmetric, and
others), the upper-triangular matrix is  a diagonal matrix with
eigenvalues of <tt class="docutils literal"><span class="pre">self</span></tt> on the diagonal, and the unitary matrix
has columns that form an orthonormal basis composed of eigenvectors
of <tt class="docutils literal"><span class="pre">self</span></tt>.  This is known as &#8220;orthonormal diagonalization&#8221;.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>The Schur decomposition is not unique, as there may be numerous
choices for the vectors of the orthonormal basis, and consequently
different possibilities for the upper-triangular matrix.  However,
the diagonal of the upper-triangular matrix will always contain the
eigenvalues of the matrix (in the complex version), or <span class="math">\(2\times 2\)</span>
block matrices in the real version representing pairs of conjugate
complex eigenvalues.</p>
<p class="last">In particular, results may vary across systems and processors.</p>
</div>
<p>EXAMPLES:</p>
<p>First over the complexes.  The similar matrix is always
upper-triangular in this case.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span> <span class="o">+</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1e-12</span><span class="p">)</span>  <span class="c1"># tol 1e-12</span>
<span class="go">[ 0.999999999999999                0.0                0.0                0.0]</span>
<span class="go">[               0.0 0.9999999999999996                0.0                0.0]</span>
<span class="go">[               0.0                0.0 0.9999999999999992                0.0]</span>
<span class="go">[               0.0                0.0                0.0 0.9999999999999999]</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span><span class="n">T</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-12</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-11</span><span class="p">)</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="gp">sage: </span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)];</span> <span class="n">eigenvalues</span>
<span class="go">[30.733... + 4648.541...*I, -0.184... - 159.057...*I, -0.523... + 11.158...*I, -0.025... - 0.642...*I]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()</span>
<span class="go">[30.733... + 4648.541...*I, -0.184... - 159.057...*I, -0.523... + 11.158...*I, -0.025... - 0.642...*I]</span>
<span class="gp">sage: </span><span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span><span class="o">-</span><span class="n">T</span><span class="o">.</span><span class="n">norm</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We begin with a real matrix but ask for a decomposition over the
complexes.  The result will yield an upper-triangular matrix over
the complex numbers for <tt class="docutils literal"><span class="pre">T</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">CDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1e-12</span><span class="p">)</span>  <span class="c1"># tol 1e-12</span>
<span class="go">[0.9999999999999987                0.0                0.0                0.0]</span>
<span class="go">[               0.0 0.9999999999999999                0.0                0.0]</span>
<span class="go">[               0.0                0.0 1.0000000000000013                0.0]</span>
<span class="go">[               0.0                0.0                0.0 1.0000000000000007]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 4 by 4 dense matrices over Complex Double Field</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span><span class="n">T</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-12</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-11</span><span class="p">)</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
</pre></div>
</div>
<p>Now totally over the reals.  But with complex eigenvalues, the
similar matrix may not be upper-triangular. But &#8220;at worst&#8221; there
may be some <span class="math">\(2\times 2\)</span> blocks on the diagonal which represent
a pair of conjugate complex eigenvalues. These blocks will then
just interrupt the zeros below the main diagonal.  This example
has a pair of these of the blocks.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="go">....:                        [4, -16, -7, 0],</span>
<span class="go">....:                        [1, 21, 1, -2],</span>
<span class="go">....:                        [26, -1, -2, 1]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>  <span class="c1"># tol 1e-12</span>
<span class="go">[0.9999999999999994                0.0                0.0                0.0]</span>
<span class="go">[               0.0 1.0000000000000013                0.0                0.0]</span>
<span class="go">[               0.0                0.0 1.0000000000000004                0.0]</span>
<span class="go">[               0.0                0.0                0.0 1.0000000000000016]</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span><span class="n">T</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-12</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span><span class="n">T</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-12</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-11</span><span class="p">)</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">()</span> <span class="o">+</span> <span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">())</span>
<span class="go">[-5.710... - 8.382...*I, -5.710... + 8.382...*I, -0.789... - 2.336...*I, -0.789... + 2.336...*I]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">())</span>
<span class="go">[-5.710... - 8.382...*I, -5.710... + 8.382...*I, -0.789... - 2.336...*I, -0.789... + 2.336...*I]</span>
<span class="gp">sage: </span><span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span><span class="o">-</span><span class="n">T</span><span class="o">.</span><span class="n">norm</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">1e-12</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Starting with complex numbers and requesting a result over the reals
will never happen.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="o">+</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mi">2</span><span class="o">-</span><span class="mi">7</span><span class="o">*</span><span class="n">I</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">RDF</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">unable to convert input matrix over CDF to a matrix over RDF</span>
</pre></div>
</div>
<p>If theory predicts your matrix is real, but it contains some
very small imaginary parts, you can specify the cutoff for &#8220;small&#8221;
imaginary parts, then request the output as real matrices, and let
the routine do the rest.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0e-14</span><span class="o">*</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 2 by 2 dense matrices over Complex Double Field</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">schur</span><span class="p">(</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 2 by 2 dense matrices over Real Double Field</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 2 by 2 dense matrices over Real Double Field</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[ 0.707107  0.707107]</span>
<span class="go">[-0.707107  0.707107]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[ 0.5  1.5]</span>
<span class="go">[-0.5  0.5]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">-</span><span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-11</span><span class="p">)</span>
<span class="go">[0.0 0.0]</span>
<span class="go">[0.0 0.0]</span>
</pre></div>
</div>
<p>A Hermitian matrix has real eigenvalues, so the similar matrix
will be upper-triangular.  Furthermore, a Hermitian matrix is
diagonalizable with respect to an orthonormal basis, composed
of eigenvectors of the matrix.  Here that basis is the set of
columns of the unitary matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>        <span class="mi">52</span><span class="p">,</span>   <span class="o">-</span><span class="mi">9</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">8</span><span class="p">,</span>    <span class="mi">6</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">187</span><span class="p">,</span>  <span class="o">-</span><span class="mi">188</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span>
<span class="go">....:                  [   9*I - 8,         12,   -58*I + 59,   30*I + 42],</span>
<span class="go">....:                  [-6*I - 187,  58*I + 59,         2677, 2264*I + 65],</span>
<span class="go">....:                  [ 188*I + 2, -30*I + 42, -2264*I + 65,       2080]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-12</span><span class="p">)</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[4680.13301        0.0        0.0        0.0]</span>
<span class="go">[       0.0 102.715967        0.0        0.0]</span>
<span class="go">[       0.0        0.0  35.039344        0.0]</span>
<span class="go">[       0.0        0.0        0.0    3.11168]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1e-12</span><span class="p">)</span>  <span class="c1"># tol 1e-12</span>
<span class="go">[1.0000000000000004                0.0                0.0                0.0]</span>
<span class="go">[               0.0 0.9999999999999989                0.0                0.0]</span>
<span class="go">[               0.0                0.0 1.0000000000000002                0.0]</span>
<span class="go">[               0.0                0.0                0.0 0.9999999999999992]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-11</span><span class="p">)</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
</pre></div>
</div>
<p>Similarly, a real symmetric matrix has only real eigenvalues,
and there is an orthonormal basis composed of eigenvectors of
the matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span>
<span class="go">....:                  [-2,  9, 1,  5],</span>
<span class="go">....:                  [ 5,  1, 3 , 7],</span>
<span class="go">....:                  [-3,  5, 7, -8]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">[-0.3027  -0.751   0.576 -0.1121]</span>
<span class="go">[  0.139 -0.3892 -0.2648  0.8713]</span>
<span class="go">[ 0.4361   0.359  0.7599  0.3217]</span>
<span class="go">[ -0.836  0.3945  0.1438  0.3533]</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mi">10</span><span class="o">^-</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">^-</span><span class="mi">4</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="n">diagonal_matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">13.5698</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8508</span><span class="p">,</span> <span class="mf">7.7664</span><span class="p">,</span> <span class="mf">11.6542</span><span class="p">]))</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>  <span class="c1"># tol 1e-12</span>
<span class="go">[0.9999999999999998                0.0                0.0                0.0]</span>
<span class="go">[               0.0                1.0                0.0                0.0]</span>
<span class="go">[               0.0                0.0 0.9999999999999998                0.0]</span>
<span class="go">[               0.0                0.0                0.0 0.9999999999999996]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">Q</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1.0e-11</span><span class="p">)</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
<span class="go">[0.0 0.0 0.0 0.0]</span>
</pre></div>
</div>
<p>The results are cached, both as a real factorization and also as a
complex factorization.  This means the returned matrices are
immutable.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Qr</span><span class="p">,</span> <span class="n">Tr</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Qc</span><span class="p">,</span> <span class="n">Tc</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">CDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span><span class="n">M</span><span class="o">.</span><span class="n">is_immutable</span><span class="p">()</span> <span class="k">for</span> <span class="n">M</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Qr</span><span class="p">,</span> <span class="n">Tr</span><span class="p">,</span> <span class="n">Qc</span><span class="p">,</span> <span class="n">Tc</span><span class="p">]])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Tr</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Tc</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>The Schur factorization is only defined for square matrices.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Schur decomposition requires a square matrix, not a 4 x 5 matrix</span>
</pre></div>
</div>
<p>A base ring request is checked.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">schur</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">base ring of Schur decomposition matrices must be RDF or CDF, not Rational Field</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Rob Beezer (2011-03-31)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.singular_values">
<tt class="descname">singular_values</tt><big>(</big><em>eps=None</em><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.singular_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sorted list of the singular values of the matrix.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">eps</span></tt> - default: <tt class="docutils literal"><span class="pre">None</span></tt> - the largest number which
will be considered to be zero.  May also be set to the
string &#8216;auto&#8217;.  See the discussion below.</li>
</ul>
<p>OUTPUT:</p>
<p>A sorted list of the singular values of the matrix, which are the
diagonal entries of the &#8220;S&#8221; matrix in the SVD decomposition.  As such,
the values are real and are returned as elements of <tt class="docutils literal"><span class="pre">RDF</span></tt>.  The
list is sorted with larger values first, and since theory predicts
these values are always positive, for a rank-deficient matrix the
list should end in zeros (but in practice may not).  The length of
the list is the minimum of the row count and column count for the
matrix.</p>
<p>The number of non-zero singular values will be the rank of the
matrix.  However, as a numerical matrix, it is impossible to
control the difference between zero entries and very small
non-zero entries.  As an informed consumer it is up to you
to use the output responsibly.  We will do our best, and give
you the tools to work with the output, but we cannot
give you a guarantee.</p>
<p>With <tt class="docutils literal"><span class="pre">eps</span></tt> set to <tt class="docutils literal"><span class="pre">None</span></tt> you will get the raw singular
values and can manage them as you see fit.  You may also set
<tt class="docutils literal"><span class="pre">eps</span></tt> to any positive floating point value you wish.  If you
set <tt class="docutils literal"><span class="pre">eps</span></tt> to &#8216;auto&#8217; this routine will compute a reasonable
cutoff value, based on the size of the matrix, the largest
singular value and the smallest nonzero value representable
by the 53-bit precision values used.  See the discussion
at page 268 of <a class="reference internal" href="#watkins" id="id1">[WATKINS]</a>.</p>
<p>See the examples for a way to use the &#8220;verbose&#8221; facility
to easily watch the zero cutoffs in action.</p>
<p>ALGORITHM:</p>
<p>The singular values come from the SVD decomposition
computed by SciPy/NumPy.</p>
<p>EXAMPLES:</p>
<p>Singular values close to zero have trailing digits that may vary
on different hardware.  For exact matrices, the number of non-zero
singular values will equal the rank of the matrix.  So for some of
the doctests we round the small singular values that ideally would
be zero, to control the variability across hardware.</p>
<p>This matrix has a determinant of one.  A chain of two or
three theorems implies the product of the singular values
must also be one.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">3</span><span class="p">],</span>
<span class="go">....:                 [-2,  1,  1, -2,  0, -4,  0],</span>
<span class="go">....:                 [ 1,  0,  1, -4, -6, -3,  7],</span>
<span class="go">....:                 [-2,  2,  1,  1,  7,  1, -1],</span>
<span class="go">....:                 [-1,  0, -1,  5,  8,  4, -6],</span>
<span class="go">....:                 [ 4, -2, -2,  1, -3,  0,  8],</span>
<span class="go">....:                 [-2,  1,  0,  2,  7,  3, -4]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">determinant</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sv</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">singular_values</span><span class="p">();</span> <span class="n">sv</span>  <span class="c1"># tol 1e-12</span>
<span class="go">[20.523980658874265, 8.486837028536643, 5.86168134845073, 2.4429165899286978, 0.5831970144724045, 0.26933287286576313, 0.0025524488076110402]</span>
<span class="gp">sage: </span><span class="n">prod</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span>  <span class="c1"># tol 1e-12</span>
<span class="go">0.9999999999999525</span>
</pre></div>
</div>
<p>An exact matrix that is obviously not of full rank, and then
a computation of the singular values after conversion
to an approximate matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="o">/</span><span class="mi">3</span><span class="p">],</span>
<span class="go">....:                 [2/3, 1/3,  7/3],</span>
<span class="go">....:                 [2/3, 5/3, 27/3]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">CDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sv</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">singular_values</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">sv</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[10.1973039..., 0.487045871...]</span>
<span class="gp">sage: </span><span class="n">sv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1e-14</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A matrix of rank 3 over the complex numbers.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">46</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">28</span><span class="p">,</span> <span class="o">-</span><span class="mi">47</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">21</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">51</span><span class="p">,</span> <span class="o">-</span><span class="mi">62</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">782</span><span class="p">,</span> <span class="mi">13</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="mi">22</span><span class="p">],</span>
<span class="go">....:                  [35*I - 20, -32*I - 46, 18*I + 43, -57*I - 670, 7*I + 3],</span>
<span class="go">....:                  [22*I - 13, -23*I - 23, 9*I + 24, -26*I - 347, 7*I + 13],</span>
<span class="go">....:                  [-44*I + 23, 41*I + 57, -19*I - 54, 60*I + 757, -11*I - 9],</span>
<span class="go">....:                  [30*I - 18, -30*I - 34, 14*I + 34, -42*I - 522, 8*I + 12]])</span>
<span class="gp">sage: </span><span class="n">sv</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">singular_values</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">sv</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># tol 1e-14</span>
<span class="go">[1440.7336659952966, 18.404403413369227, 6.839707797136151]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">sv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">^-</span><span class="mi">13</span><span class="p">)</span> <span class="ow">or</span> <span class="n">sv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">sv</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">^-</span><span class="mi">14</span><span class="p">)</span> <span class="ow">or</span> <span class="n">sv</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A full-rank matrix that is ill-conditioned.  We use this to
illustrate ways of using the various possibilities for <tt class="docutils literal"><span class="pre">eps</span></tt>,
including one that is ill-advised. Notice that the automatically
computed cutoff gets this (difficult) example slightly wrong.
This illustrates the impossibility of any automated process always
getting this right.  Use with caution and judgement.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">entries</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="n">entries</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">12</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">1.6e16</span> <span class="ow">or</span> <span class="n">A</span><span class="o">.</span><span class="n">condition</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">singular_values</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>  <span class="c1"># abs tol 7e-16</span>
<span class="go">[1.7953720595619975, 0.38027524595503703, 0.04473854875218107, 0.0037223122378911614, 0.0002330890890217751, 1.116335748323284e-05, 4.082376110397296e-07, 1.1228610675717613e-08, 2.2519645713496478e-10, 3.1113486853814003e-12, 2.6500422260778388e-14, 9.87312834948426e-17]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">singular_values</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>  <span class="c1"># abs tol 7e-16</span>
<span class="go">[1.7953720595619975, 0.38027524595503703, 0.04473854875218107, 0.0037223122378911614, 0.0002330890890217751, 1.116335748323284e-05, 4.082376110397296e-07, 1.1228610675717613e-08, 2.2519645713496478e-10, 3.1113486853814003e-12, 2.6500422260778388e-14, 0.0]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">singular_values</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>  <span class="c1"># abs tol 7e-16</span>
<span class="go">[1.7953720595619975, 0.38027524595503703, 0.04473854875218107, 0.0037223122378911614, 0.0002330890890217751, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]</span>
</pre></div>
</div>
<p>With Sage&#8217;s &#8220;verbose&#8221; facility, you can compactly see the cutoff
at work.  In any application of this routine, or those that build upon
it, it would be a good idea to conduct this exercise on samples.
We also test here that all the  values are returned in <span class="math">\(RDF\)</span> since
singular values are always real.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">set_verbose</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sv</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">singular_values</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">);</span> <span class="n">sv</span>
<span class="go">verbose 1 (&lt;module&gt;) singular values,</span>
<span class="go">smallest-non-zero:cutoff:largest-zero,</span>
<span class="go">2.2766...:6.2421...e-14:...</span>
<span class="go">[35.13996365902..., 2.27661020871472..., 0.0, 0.0]</span>
<span class="gp">sage: </span><span class="n">set_verbose</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span><span class="n">s</span> <span class="ow">in</span> <span class="n">RDF</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sv</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Bogus values of the <tt class="docutils literal"><span class="pre">eps</span></tt> keyword will be caught.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">singular_values</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="s1">&#39;junk&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">could not convert string to float: junk</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="watkins" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[WATKINS]</a></td><td>Watkins, David S. Fundamentals of Matrix Computations,
Third Edition.  Wiley, Hoboken, New Jersey, 2010.</td></tr>
</tbody>
</table>
<p>AUTHOR:</p>
<ul class="simple">
<li>Rob Beezer - (2011-02-18)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.solve_left">
<tt class="descname">solve_left</tt><big>(</big><em>b</em><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.solve_left" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the vector equation <tt class="docutils literal"><span class="pre">x*A</span> <span class="pre">=</span> <span class="pre">b</span></tt> for a nonsingular <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> - a square matrix that is nonsigular (of full rank).</li>
<li><tt class="docutils literal"><span class="pre">b</span></tt> - a vector of the correct size.  Elements of the vector
must coerce into the base ring of the coefficient matrix.  In
particular, if <tt class="docutils literal"><span class="pre">b</span></tt> has entries from <tt class="docutils literal"><span class="pre">CDF</span></tt> then <tt class="docutils literal"><span class="pre">self</span></tt>
must have <tt class="docutils literal"><span class="pre">CDF</span></tt> as its base ring.</li>
</ul>
<p>OUTPUT:</p>
<p>The unique solution <tt class="docutils literal"><span class="pre">x</span></tt> to the matrix equation <tt class="docutils literal"><span class="pre">x*A</span> <span class="pre">=</span> <span class="pre">b</span></tt>,
as a vector over the same base ring as <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>ALGORITHM:</p>
<p>Uses the <tt class="docutils literal"><span class="pre">solve()</span></tt> routine from the SciPy <tt class="docutils literal"><span class="pre">scipy.linalg</span></tt> module,
after taking the tranpose of the coefficient matrix.</p>
<p>EXAMPLES:</p>
<p>Over the reals.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mf">7.6</span><span class="p">,</span><span class="mf">2.3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span> <span class="n">A</span>
<span class="go">[ 1.0  2.0  5.0]</span>
<span class="go">[ 7.6  2.3  1.0]</span>
<span class="go">[ 1.0  2.0 -1.0]</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">solve_left</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">x</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1e-18</span><span class="p">)</span> <span class="c1"># fix noisy zeroes</span>
<span class="go">(0.666666666..., 0.0, 0.333333333...)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Vector space of dimension 3 over Real Double Field</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">*</span><span class="n">A</span>  <span class="c1"># tol 1e-14</span>
<span class="go">(0.9999999999999999, 1.9999999999999998, 3.0)</span>
</pre></div>
</div>
<p>Over the complex numbers.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>      <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>  <span class="mi">1</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>        <span class="n">I</span><span class="p">],</span>
<span class="go">....:                  [2 + 4*I, -2 + 3*I, -1 + 2*I,   -1 - I],</span>
<span class="go">....:                  [  2 + I,    1 - I,       -1,        5],</span>
<span class="go">....:                  [    3*I,   -1 - I,   -1 + I,   -3 + I]])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">solve_left</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">x</span>
<span class="go">(-1.55765124... - 0.644483985...*I, 0.183274021... + 0.286476868...*I, 0.270818505... + 0.246619217...*I, -1.69003558... - 0.828113879...*I)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Vector space of dimension 4 over Complex Double Field</span>
<span class="gp">sage: </span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">A</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-14</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The vector of constants, <tt class="docutils literal"><span class="pre">b</span></tt>, can be given in a
variety of forms, so long as it coerces to a vector
over the same base ring as the coefficient matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">=</span><span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">solve_left</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># tol 1e-11</span>
<span class="go">(5.0, -120.0, 630.0, -1120.0, 630.0)</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>A degenerate case.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">solve_left</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,[]))</span>
<span class="go">()</span>
</pre></div>
</div>
<p>The coefficent matrix must be square.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">solve_left</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">coefficient matrix of a system over RDF/CDF must be square, not 2 x 3</span>
</pre></div>
</div>
<p>The coefficient matrix must be nonsingular.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">25</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">solve_left</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">LinAlgError</span>: <span class="n">singular matrix</span>
</pre></div>
</div>
<p>The vector of constants needs the correct degree.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">25</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">solve_left</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">vector of constants over Real Double Field incompatible with matrix over Real Double Field</span>
</pre></div>
</div>
<p>The vector of constants needs to be compatible with
the base ring of the coefficient matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">FiniteField</span><span class="p">(</span><span class="mi">27</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">solve_left</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">vector of constants over Finite Field in a of size 3^3 incompatible with matrix over Real Double Field</span>
</pre></div>
</div>
<p>With a coefficient matrix over <tt class="docutils literal"><span class="pre">RDF</span></tt>, a vector of constants
over <tt class="docutils literal"><span class="pre">CDF</span></tt> can be accomodated by converting the base ring
of the coefficient matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="n">I</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">solve_left</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">vector of constants over Complex Double Field incompatible with matrix over Real Double Field</span>

<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">CDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">solve_left</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">(0.5 - 1.5*I, 0.5 + 0.5*I)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.solve_right">
<tt class="descname">solve_right</tt><big>(</big><em>b</em><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.solve_right" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the vector equation <tt class="docutils literal"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></tt> for a nonsingular <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> - a square matrix that is nonsigular (of full rank).</li>
<li><tt class="docutils literal"><span class="pre">b</span></tt> - a vector of the correct size.  Elements of the vector
must coerce into the base ring of the coefficient matrix.  In
particular, if <tt class="docutils literal"><span class="pre">b</span></tt> has entries from <tt class="docutils literal"><span class="pre">CDF</span></tt> then <tt class="docutils literal"><span class="pre">self</span></tt>
must have <tt class="docutils literal"><span class="pre">CDF</span></tt> as its base ring.</li>
</ul>
<p>OUTPUT:</p>
<p>The unique solution <tt class="docutils literal"><span class="pre">x</span></tt> to the matrix equation <tt class="docutils literal"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></tt>,
as a vector over the same base ring as <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>ALGORITHM:</p>
<p>Uses the <tt class="docutils literal"><span class="pre">solve()</span></tt> routine from the SciPy <tt class="docutils literal"><span class="pre">scipy.linalg</span></tt> module.</p>
<p>EXAMPLES:</p>
<p>Over the reals.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mf">7.6</span><span class="p">,</span><span class="mf">2.3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span> <span class="n">A</span>
<span class="go">[ 1.0  2.0  5.0]</span>
<span class="go">[ 7.6  2.3  1.0]</span>
<span class="go">[ 1.0  2.0 -1.0]</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">solve_right</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">x</span>  <span class="c1"># tol 1e-14</span>
<span class="go">(-0.1136950904392765, 1.3901808785529717, -0.33333333333333337)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Vector space of dimension 3 over Real Double Field</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">*</span><span class="n">x</span>  <span class="c1"># tol 1e-14</span>
<span class="go">(1.0, 1.9999999999999996, 3.0000000000000004)</span>
</pre></div>
</div>
<p>Over the complex numbers.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span>      <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>  <span class="mi">1</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>        <span class="n">I</span><span class="p">],</span>
<span class="go">....:                  [2 + 4*I, -2 + 3*I, -1 + 2*I,   -1 - I],</span>
<span class="go">....:                  [  2 + I,    1 - I,       -1,        5],</span>
<span class="go">....:                  [    3*I,   -1 - I,   -1 + I,   -3 + I]])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">solve_right</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">x</span>
<span class="go">(1.96841637... - 1.07606761...*I, -0.614323843... + 1.68416370...*I, 0.0733985765... + 1.73487544...*I, -1.6018683... + 0.524021352...*I)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Vector space of dimension 4 over Complex Double Field</span>
<span class="gp">sage: </span><span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-14</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The vector of constants, <tt class="docutils literal"><span class="pre">b</span></tt>, can be given in a
variety of forms, so long as it coerces to a vector
over the same base ring as the coefficient matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">=</span><span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">solve_right</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># tol 1e-11</span>
<span class="go">(5.0, -120.0, 630.0, -1120.0, 630.0)</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>A degenerate case.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">solve_right</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,[]))</span>
<span class="go">()</span>
</pre></div>
</div>
<p>The coefficent matrix must be square.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">solve_right</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">coefficient matrix of a system over RDF/CDF must be square, not 2 x 3</span>
</pre></div>
</div>
<p>The coefficient matrix must be nonsingular.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">25</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">solve_right</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">LinAlgError</span>: <span class="n">singular matrix</span>
</pre></div>
</div>
<p>The vector of constants needs the correct degree.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">25</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">solve_right</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">vector of constants over Real Double Field incompatible with matrix over Real Double Field</span>
</pre></div>
</div>
<p>The vector of constants needs to be compatible with
the base ring of the coefficient matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">FiniteField</span><span class="p">(</span><span class="mi">27</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">solve_right</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">vector of constants over Finite Field in a of size 3^3 incompatible with matrix over Real Double Field</span>
</pre></div>
</div>
<p>With a coefficient matrix over <tt class="docutils literal"><span class="pre">RDF</span></tt>, a vector of constants
over <tt class="docutils literal"><span class="pre">CDF</span></tt> can be accomodated by converting the base ring
of the coefficient matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="n">I</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">solve_right</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">vector of constants over Complex Double Field incompatible with matrix over Real Double Field</span>

<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">CDF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">solve_right</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">(-0.5 - 1.5*I, 1.0 + 1.0*I)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.transpose">
<tt class="descname">transpose</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the transpose of this matrix, without changing self.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span> <span class="n">m</span>
<span class="go">[0.0 1.0 2.0]</span>
<span class="go">[3.0 4.0 5.0]</span>
<span class="gp">sage: </span><span class="n">m2</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">m2</span>           <span class="c1">#note that m2 hasn&#39;t changed</span>
<span class="go">[0.0 3.0]</span>
<span class="go">[1.0 4.0]</span>
<span class="go">[2.0 5.0]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">.T</span></tt> is a convenient shortcut for the transpose:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">T</span>
<span class="go">[2.0 3.0]</span>
<span class="go">[1.0 4.0]</span>
<span class="go">[2.0 5.0]</span>

<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RDF</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="n">m</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 3 by 0 dense matrices over Real Double Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.matrix.matrix_double_dense.Matrix_double_dense.zero_at">
<tt class="descname">zero_at</tt><big>(</big><em>eps</em><big>)</big><a class="headerlink" href="#sage.matrix.matrix_double_dense.Matrix_double_dense.zero_at" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the matrix where elements smaller than or
equal to <tt class="docutils literal"><span class="pre">eps</span></tt> are replaced with zeroes. For complex matrices,
the real and imaginary parts are considered individually.</p>
<p>This is useful for modifying output from algorithms which have large
relative errors when producing zero elements, e.g. to create reliable
doctests.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">eps</span></tt> - Cutoff value</li>
</ul>
<p>OUTPUT:</p>
<p>A modified copy of the matrix.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CDF</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1e-4</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mf">1e-100j</span><span class="n">r</span><span class="p">],</span> <span class="p">[</span><span class="mf">1e-8</span><span class="o">+</span><span class="mi">3j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1e-58</span><span class="n">r</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">a</span>
<span class="go">[           1.0         0.0001 1.0 + 1e-100*I]</span>
<span class="go">[ 1e-08 + 3.0*I            0.0          1e-58]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1e-50</span><span class="p">)</span>
<span class="go">[          1.0        0.0001           1.0]</span>
<span class="go">[1e-08 + 3.0*I           0.0           0.0]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">zero_at</span><span class="p">(</span><span class="mf">1e-4</span><span class="p">)</span>
<span class="go">[  1.0   0.0   1.0]</span>
<span class="go">[3.0*I   0.0   0.0]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="matrix_rational_dense.html"
                                  title="previous chapter">Dense matrices over the rational field</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="matrix_real_double_dense.html"
                                  title="next chapter">Dense matrices over the Real Double Field using NumPy</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/matrix/matrix_double_dense.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="matrix_real_double_dense.html" title="Dense matrices over the Real Double Field using NumPy"
             >next</a> |</li>
        <li class="right" >
          <a href="matrix_rational_dense.html" title="Dense matrices over the rational field"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Matrices and Spaces of Matrices</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>