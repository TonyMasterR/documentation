<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Lazy attributes &mdash; Sage Reference Manual v6.10: Utilities</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '6.10',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v6.10: Utilities" href="../../index.html" />
    <link rel="next" title="Lazy format strings" href="lazy_format.html" />
    <link rel="prev" title="Miscellaneous functions (Cython)" href="misc_c.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="lazy_format.html" title="Lazy format strings"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="misc_c.html" title="Miscellaneous functions (Cython)"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Utilities</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="lazy-attributes">
<span id="sage-misc-lazy-attribute"></span><h1>Lazy attributes<a class="headerlink" href="#lazy-attributes" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.misc.lazy_attribute"></span><p>AUTHORS:</p>
<ul class="simple">
<li>Nicolas Thiery (2008): Initial version</li>
<li>Nils Bruin (2013-05): Cython version</li>
</ul>
<dl class="class">
<dt id="sage.misc.lazy_attribute.lazy_attribute">
<em class="property">class </em><tt class="descclassname">sage.misc.lazy_attribute.</tt><tt class="descname">lazy_attribute</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.misc.lazy_attribute.lazy_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">sage.misc.lazy_attribute._lazy_attribute</span></tt></p>
<p>A lazy attribute for an object is like a usual attribute, except
that, instead of being computed when the object is constructed
(i.e. in <tt class="docutils literal"><span class="pre">__init__</span></tt>), it is computed on the fly the first time it
is accessed.</p>
<p>For constant values attached to an object, lazy attributes provide
a shorter syntax and automatic caching (unlike methods), while
playing well with inheritance (like methods): a subclass can
easily override a given attribute; you don&#8217;t need to call the
super class constructor, etc.</p>
<p>Technically, a <a class="reference internal" href="#sage.misc.lazy_attribute.lazy_attribute" title="sage.misc.lazy_attribute.lazy_attribute"><tt class="xref py py-class docutils literal"><span class="pre">lazy_attribute</span></tt></a> is a non-data descriptor (see
Invoking Descriptors in the Python reference manual).</p>
<p>EXAMPLES:</p>
<p>We create a class whose instances have a lazy attribute <tt class="docutils literal"><span class="pre">x</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">....:     def __init__(self):</span>
<span class="go">....:         self.a=2 # just to have some data to calculate from</span>
<span class="go">....:</span>
<span class="go">....:     @lazy_attribute</span>
<span class="go">....:     def x(self):</span>
<span class="go">....:         print &quot;calculating x in A&quot;</span>
<span class="go">....:         return self.a + 1</span>
<span class="go">....:</span>
</pre></div>
</div>
<p>For an instance <tt class="docutils literal"><span class="pre">a</span></tt> of <tt class="docutils literal"><span class="pre">A</span></tt>, <tt class="docutils literal"><span class="pre">a.x</span></tt> is calculated the first time it
is accessed, and then stored as a usual attribute:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="go">calculating x in A</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="go">3</span>
</pre></div>
</div>
<p class="rubric">Implementation details</p>
<p>We redo the same example, but opening the hood to see what happens to
the internal dictionary of the object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">{&#39;a&#39;: 2}</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="go">calculating x in A</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">{&#39;a&#39;: 2, &#39;x&#39;: 3}</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">timeit</span><span class="p">(</span><span class="s">&#39;a.x&#39;</span><span class="p">)</span> <span class="c"># random</span>
<span class="go">625 loops, best of 3: 89.6 ns per loop</span>
</pre></div>
</div>
<p>This shows that, after the first calculation, the attribute <tt class="docutils literal"><span class="pre">x</span></tt>
becomes a usual attribute; in particular, there is no time penalty
to access it.</p>
<p>A lazy attribute may be set as usual, even before its first access,
in which case the lazy calculation is completely ignored:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">{&#39;a&#39;: 2, &#39;x&#39;: 4}</span>
</pre></div>
</div>
<p>Class binding results in the lazy attribute itself:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">x</span>
<span class="go">&lt;sage.misc.lazy_attribute.lazy_attribute object at ...&gt;</span>
</pre></div>
</div>
<p class="rubric">Conditional definitions</p>
<p>The function calculating the attribute may return NotImplemented
to declare that, after all, it is not able to do it. In that case,
the attribute lookup proceeds in the super class hierarchy:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
<span class="go">....:     @lazy_attribute</span>
<span class="go">....:     def x(self):</span>
<span class="go">....:         if hasattr(self, &quot;y&quot;):</span>
<span class="go">....:             print &quot;calculating x from y in B&quot;</span>
<span class="go">....:             return self.y</span>
<span class="go">....:         else:</span>
<span class="go">....:             print &quot;y not there; B does not define x&quot;</span>
<span class="go">....:             return NotImplemented</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">x</span>
<span class="go">y not there; B does not define x</span>
<span class="go">calculating x in A</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">x</span>
<span class="go">calculating x from y in B</span>
<span class="go">1</span>
</pre></div>
</div>
<p class="rubric">Attribute existence testing</p>
<p>Testing for the existence of an attribute with hasattr currently
always triggers its full calculation, which may not be desirable
when the calculation is expensive:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
<span class="go">calculating x in A</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It would be great if we could take over the control somehow, if at
all possible without a special implementation of hasattr, so as to
allow for something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">class</span> <span class="nc">A</span> <span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">....:     @lazy_attribute</span>
<span class="go">....:     def x(self, existence_only=False):</span>
<span class="go">....:         if existence_only:</span>
<span class="go">....:             print &quot;testing for x existence&quot;</span>
<span class="go">....:             return True</span>
<span class="go">....:         else:</span>
<span class="go">....:             print &quot;calculating x in A&quot;</span>
<span class="go">....:             return 3</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="c"># todo: not implemented</span>
<span class="go">testing for x existence</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="go">calculating x in A</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Here is a full featured example, with both conditional definition
and existence testing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
<span class="go">....:     @lazy_attribute</span>
<span class="go">....:     def x(self, existence_only=False):</span>
<span class="go">....:         if hasattr(self, &quot;y&quot;):</span>
<span class="go">....:             if existence_only:</span>
<span class="go">....:                 print &quot;testing for x existence in B&quot;</span>
<span class="go">....:                 return True</span>
<span class="go">....:             else:</span>
<span class="go">....:                 print &quot;calculating x from y in B&quot;</span>
<span class="go">....:                 return self.y</span>
<span class="go">....:         else:</span>
<span class="go">....:             print &quot;y not there; B does not define x&quot;</span>
<span class="go">....:             return NotImplemented</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="c"># todo: not implemented</span>
<span class="go">y not there; B does not define x</span>
<span class="go">testing for x existence</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">x</span>
<span class="go">y not there; B does not define x</span>
<span class="go">calculating x in A</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="c"># todo: not implemented</span>
<span class="go">testing for x existence in B</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">x</span>
<span class="go">calculating x from y in B</span>
<span class="go">1</span>
</pre></div>
</div>
<p class="rubric">lazy attributes and introspection</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p>Make the following work nicely:</p>
<div class="last highlight-python"><div class="highlight"><pre>sage: b.x?                # todo: not implemented
sage: b.x??               # todo: not implemented
</pre></div>
</div>
</div>
<p>Right now, the first one includes the doc of this class, and the
second one brings up the code of this class, both being not very
useful.</p>
<p>TESTS:</p>
<p class="rubric">Partial support for old style classes</p>
<p>Old style and new style classes play a bit differently with
&#64;property and attribute setting:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
<span class="go">....:     @property</span>
<span class="go">....:     def x(self):</span>
<span class="go">....:         print &quot;calculating x&quot;</span>
<span class="go">....:         return 3</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">{&#39;x&#39;: 4}</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">5</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="go">5</span>

<span class="gp">sage: </span><span class="k">class</span> <span class="nc">A</span> <span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">....:     @property</span>
<span class="go">....:     def x(self):</span>
<span class="go">....:         print &quot;calculating x&quot;</span>
<span class="go">....:         return 3</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">can&#39;t set attribute</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">{}</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="go">calculating x</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">5</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="go">calculating x</span>
<span class="go">3</span>
</pre></div>
</div>
<p>In particular, lazy_attributes need to be implemented as non-data
descriptors for new style classes, so as to leave access to
setattr. We now check that this implementation also works for old
style classes (conditional definition does not work yet):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
<span class="go">....:     def __init__(self):</span>
<span class="go">....:         self.a=2 # just to have some data to calculate from</span>
<span class="go">....:</span>
<span class="go">....:     @lazy_attribute</span>
<span class="go">....:     def x(self):</span>
<span class="go">....:         print &quot;calculating x&quot;</span>
<span class="go">....:         return self.a + 1</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">{&#39;a&#39;: 2}</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="go">calculating x</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">{&#39;a&#39;: 2, &#39;x&#39;: 3}</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">timeit</span><span class="p">(</span><span class="s">&#39;a.x&#39;</span><span class="p">)</span> <span class="c"># random</span>
<span class="go">625 loops, best of 3: 115 ns per loop</span>

<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">x</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">{&#39;a&#39;: 2, &#39;x&#39;: 4}</span>

<span class="gp">sage: </span><span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
<span class="go">....:     @lazy_attribute</span>
<span class="go">....:     def x(self):</span>
<span class="go">....:         if hasattr(self, &quot;y&quot;):</span>
<span class="go">....:             print &quot;calculating x from y in B&quot;</span>
<span class="go">....:             return self.y</span>
<span class="go">....:         else:</span>
<span class="go">....:             print &quot;y not there; B does not define x&quot;</span>
<span class="go">....:             return NotImplemented</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">x</span>                         <span class="c"># todo: not implemented</span>
<span class="go">y not there; B does not define x</span>
<span class="go">calculating x in A</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">x</span>
<span class="go">calculating x from y in B</span>
<span class="go">1</span>
</pre></div>
</div>
<p class="rubric">Lazy attributes and Cython</p>
<p>This attempts to check that lazy attributes work with built-in
functions like cpdef methods:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
<span class="go">....:     def __len__(x):</span>
<span class="go">....:         return int(5)</span>
<span class="go">....:     len = lazy_attribute(len)</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">()</span><span class="o">.</span><span class="n">len</span>
<span class="go">5</span>
</pre></div>
</div>
<p>Since <a class="reference external" href="http://trac.sagemath.org/11115">trac ticket #11115</a>, extension classes derived from
<a class="reference external" href="../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Basic Structures v6.10)"><tt class="xref py py-class docutils literal"><span class="pre">Parent</span></tt></a> can inherit a lazy attribute,
such as <tt class="docutils literal"><span class="pre">element_class</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">cython_code</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;from sage.structure.parent cimport Parent&quot;</span><span class="p">,</span>
<span class="go">....: &quot;from sage.structure.element cimport Element&quot;,</span>
<span class="go">....: &quot;cdef class MyElement(Element): pass&quot;,</span>
<span class="go">....: &quot;cdef class MyParent(Parent):&quot;,</span>
<span class="go">....: &quot;    Element = MyElement&quot;]</span>
<span class="gp">sage: </span><span class="n">cython</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cython_code</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MyParent</span><span class="p">(</span><span class="n">category</span><span class="o">=</span><span class="n">Rings</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">element_class</span>    <span class="c"># indirect doctest</span>
<span class="go">&lt;type &#39;...MyElement&#39;&gt;</span>
</pre></div>
</div>
<p class="rubric">About descriptor specifications</p>
<p>The specifications of descriptors (see 3.4.2.3 Invoking
Descriptors in the Python reference manual) are incomplete
w.r.t. inheritance, and maybe even ill-implemented. We illustrate
this on a simple class hierarchy, with an instrumented descriptor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">class</span> <span class="nc">descriptor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">....:     def __get__(self, obj, cls):</span>
<span class="go">....:         print cls</span>
<span class="go">....:         return 1</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">....:     x = descriptor()</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
<span class="go">....:     pass</span>
<span class="go">....:</span>
</pre></div>
</div>
<p>This is fine:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">x</span>
<span class="go">&lt;class &#39;__main__.A&#39;&gt;</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The behaviour for the following case is not specified (see Instance Binding)
when <tt class="docutils literal"><span class="pre">x</span></tt> is not in the dictionary of <tt class="docutils literal"><span class="pre">B</span></tt> but in that of some super
category:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">x</span>
<span class="go">&lt;class &#39;__main__.B&#39;&gt;</span>
<span class="go">1</span>
</pre></div>
</div>
<p>It would seem more natural (and practical!) to get <tt class="docutils literal"><span class="pre">A</span></tt> rather than <tt class="docutils literal"><span class="pre">B</span></tt>.</p>
<p>From the specifications for Super Binding, it would be expected to
get <tt class="docutils literal"><span class="pre">A</span></tt> and not <tt class="docutils literal"><span class="pre">B</span></tt> as cls parameter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">super</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">B</span><span class="p">())</span><span class="o">.</span><span class="n">x</span>
<span class="go">&lt;class &#39;__main__.B&#39;&gt;</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Due to this, the natural implementation runs into an infinite loop
in the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">....:     @lazy_attribute</span>
<span class="go">....:     def unimplemented_A(self):</span>
<span class="go">....:         return NotImplemented</span>
<span class="go">....:     @lazy_attribute</span>
<span class="go">....:     def unimplemented_AB(self):</span>
<span class="go">....:         return NotImplemented</span>
<span class="go">....:     @lazy_attribute</span>
<span class="go">....:     def unimplemented_B_implemented_A(self):</span>
<span class="go">....:         return 1</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
<span class="go">....:     @lazy_attribute</span>
<span class="go">....:     def unimplemented_B(self):</span>
<span class="go">....:         return NotImplemented</span>
<span class="go">....:     @lazy_attribute</span>
<span class="go">....:     def unimplemented_AB(self):</span>
<span class="go">....:         return NotImplemented</span>
<span class="go">....:     @lazy_attribute</span>
<span class="go">....:     def unimplemented_B_implemented_A(self):</span>
<span class="go">....:         return NotImplemented</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
<span class="go">....:     pass</span>
<span class="go">....:</span>
</pre></div>
</div>
<p>This is the simplest case where, without workaround, we get an
infinite loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">B</span><span class="p">(),</span> <span class="s">&quot;unimplemented_A&quot;</span><span class="p">)</span> <span class="c"># todo: not implemented</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p>Improve the error message:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">unimplemented_A</span> <span class="c"># todo: not implemented</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;super&#39; object has no attribute &#39;unimplemented_A&#39;</span>
</pre></div>
</div>
</div>
<p>We now make some systematic checks:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">unimplemented_A</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;...&#39; object has no attribute &#39;unimplemented_A&#39;</span>
<span class="gp">sage: </span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">unimplemented_B</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;...&#39; object has no attribute &#39;unimplemented_B&#39;</span>
<span class="gp">sage: </span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">unimplemented_AB</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;...&#39; object has no attribute &#39;unimplemented_AB&#39;</span>
<span class="gp">sage: </span><span class="n">B</span><span class="p">()</span><span class="o">.</span><span class="n">unimplemented_B_implemented_A</span>
<span class="go">1</span>

<span class="gp">sage: </span><span class="n">C</span><span class="p">()</span><span class="o">.</span><span class="n">unimplemented_A</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;...&#39; object has no attribute &#39;unimplemented_A&#39;</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">()</span><span class="o">.</span><span class="n">unimplemented_B</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;...&#39; object has no attribute &#39;unimplemented_B&#39;</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">()</span><span class="o">.</span><span class="n">unimplemented_AB</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;...&#39; object has no attribute &#39;unimplemented_AB&#39;</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">()</span><span class="o">.</span><span class="n">unimplemented_B_implemented_A</span> <span class="c"># todo: not implemented</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.misc.lazy_attribute.lazy_class_attribute">
<em class="property">class </em><tt class="descclassname">sage.misc.lazy_attribute.</tt><tt class="descname">lazy_class_attribute</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.misc.lazy_attribute.lazy_class_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.misc.lazy_attribute.lazy_attribute" title="sage.misc.lazy_attribute.lazy_attribute"><tt class="xref py py-class docutils literal"><span class="pre">sage.misc.lazy_attribute.lazy_attribute</span></tt></a></p>
<p>A lazy class attribute for an class is like a usual class attribute,
except that, instead of being computed when the class is constructed, it
is computed on the fly the first time it is accessed, either through the
class itself or trough on of its objects.</p>
<p>This is very similar to <a class="reference internal" href="#sage.misc.lazy_attribute.lazy_attribute" title="sage.misc.lazy_attribute.lazy_attribute"><tt class="xref py py-class docutils literal"><span class="pre">lazy_attribute</span></tt></a> except that the attribute
is a class attribute. More precisely, once computed, the lazy class
attribute is stored in the class rather than in the object. The lazy class
attribute is only computed once for all the objects:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">class</span> <span class="nc">Cl</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">....:     @lazy_class_attribute</span>
<span class="go">....:     def x(cls):</span>
<span class="go">....:          print &quot;computing x&quot;</span>
<span class="go">....:          return 1</span>
<span class="gp">sage: </span><span class="n">Cl</span><span class="o">.</span><span class="n">x</span>
<span class="go">computing x</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">Cl</span><span class="o">.</span><span class="n">x</span>
<span class="go">1</span>
</pre></div>
</div>
<p>As for a any usual class attribute it is also possible to access it from
an object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">Cl</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">x</span>
<span class="go">1</span>
</pre></div>
</div>
<p>First access from an object also porperly triggers the computation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">class</span> <span class="nc">Cl1</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">....:     @lazy_class_attribute</span>
<span class="go">....:     def x(cls):</span>
<span class="go">....:          print &quot;computing x&quot;</span>
<span class="go">....:          return 1</span>
<span class="gp">sage: </span><span class="n">Cl1</span><span class="p">()</span><span class="o">.</span><span class="n">x</span>
<span class="go">computing x</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">Cl1</span><span class="p">()</span><span class="o">.</span><span class="n">x</span>
<span class="go">1</span>
</pre></div>
</div>
<p>..WARNING:</p>
<div class="highlight-python"><div class="highlight"><pre>The behavior of lazy class attributes with respect to inheritance is
not specified. It currently depends on the evaluation order::

    sage: class A(object):
    ....:     @lazy_class_attribute
    ....:     def x(cls):
    ....:          print &quot;computing x&quot;
    ....:          return str(cls)
    ....:     @lazy_class_attribute
    ....:     def y(cls):
    ....:          print &quot;computing y&quot;
    ....:          return str(cls)
    sage: class B(A):
    ....:     pass

    sage: A.x
    computing x
    &quot;&lt;class &#39;__main__.A&#39;&gt;&quot;
    sage: B.x
    &quot;&lt;class &#39;__main__.A&#39;&gt;&quot;

    sage: B.y
    computing y
    &quot;&lt;class &#39;__main__.B&#39;&gt;&quot;
    sage: A.y
    computing y
    &quot;&lt;class &#39;__main__.A&#39;&gt;&quot;
    sage: B.y
    &quot;&lt;class &#39;__main__.B&#39;&gt;&quot;
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="s">&quot;x&quot;</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">__dict__</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="misc_c.html"
                                  title="previous chapter">Miscellaneous functions (Cython)</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="lazy_format.html"
                                  title="next chapter">Lazy format strings</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/misc/lazy_attribute.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="lazy_format.html" title="Lazy format strings"
             >next</a> |</li>
        <li class="right" >
          <a href="misc_c.html" title="Miscellaneous functions (Cython)"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Utilities</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2015, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>