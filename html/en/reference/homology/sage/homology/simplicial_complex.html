<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Finite simplicial complexes &mdash; Sage Reference Manual v6.6: Cell complexes and their homology</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '6.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v6.6: Cell complexes and their homology" href="../../index.html" />
    <link rel="next" title="Morphisms of simplicial complexes" href="simplicial_complex_morphism.html" />
    <link rel="prev" title="Homspaces between chain complexes" href="chain_complex_homspace.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="simplicial_complex_morphism.html" title="Morphisms of simplicial complexes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="chain_complex_homspace.html" title="Homspaces between chain complexes"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Cell complexes and their homology</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="finite-simplicial-complexes">
<span id="sage-homology-simplicial-complex"></span><h1>Finite simplicial complexes<a class="headerlink" href="#finite-simplicial-complexes" title="Permalink to this headline">Â¶</a></h1>
<span class="target" id="module-sage.homology.simplicial_complex"></span><p>AUTHORS:</p>
<ul class="simple">
<li>John H. Palmieri (2009-04)</li>
<li>D. Benjamin Antieau (2009-06): added is_connected, generated_subcomplex,
remove_facet, and is_flag_complex methods;
cached the output of the graph() method.</li>
<li>Travis Scrimshaw (2012-08-17): Made <a class="reference internal" href="#sage.homology.simplicial_complex.SimplicialComplex" title="sage.homology.simplicial_complex.SimplicialComplex"><tt class="xref py py-class docutils literal"><span class="pre">SimplicialComplex</span></tt></a> have an
immutable option, and added <tt class="docutils literal"><span class="pre">__hash__()</span></tt> function which checks to make
sure it is immutable. Made <a class="reference internal" href="#sage.homology.simplicial_complex.SimplicialComplex.remove_face" title="sage.homology.simplicial_complex.SimplicialComplex.remove_face"><tt class="xref py py-meth docutils literal"><span class="pre">SimplicialComplex.remove_face()</span></tt></a> into a
mutator. Deprecated the <tt class="docutils literal"><span class="pre">vertex_set</span></tt> parameter.</li>
<li>Christian Stump (2011-06): implementation of is_cohen_macaulay</li>
<li>Travis Scrimshaw (2013-02-16): Allowed <a class="reference internal" href="#sage.homology.simplicial_complex.SimplicialComplex" title="sage.homology.simplicial_complex.SimplicialComplex"><tt class="xref py py-class docutils literal"><span class="pre">SimplicialComplex</span></tt></a> to make
mutable copies.</li>
<li>Simon King (2014-05-02): Let simplicial complexes be objects of the
category of simplicial complexes.</li>
</ul>
<p>This module implements the basic structure of finite simplicial
complexes. Given a set <span class="math">\(V\)</span> of &#8220;vertices&#8221;, a simplicial complex on <span class="math">\(V\)</span>
is a collection <span class="math">\(K\)</span> of subsets of <span class="math">\(V\)</span> satisfying the condition that if
<span class="math">\(S\)</span> is one of the subsets in <span class="math">\(K\)</span>, then so is every subset of <span class="math">\(S\)</span>.  The
subsets <span class="math">\(S\)</span> are called the &#8216;simplices&#8217; of <span class="math">\(K\)</span>.</p>
<p>A simplicial complex <span class="math">\(K\)</span> can be viewed as a purely combinatorial
object, as described above, but it also gives rise to a topological
space <span class="math">\(|K|\)</span> (its <em>geometric realization</em>) as follows: first, the
points of <span class="math">\(V\)</span> should be in general position in euclidean space.  Next,
if <span class="math">\(\{v\}\)</span> is in <span class="math">\(K\)</span>, then the vertex <span class="math">\(v\)</span> is in <span class="math">\(|K|\)</span>.  If <span class="math">\(\{v, w\}\)</span>
is in <span class="math">\(K\)</span>, then the line segment from <span class="math">\(v\)</span> to <span class="math">\(w\)</span> is in <span class="math">\(|K|\)</span>. If <span class="math">\(\{u,
v, w\}\)</span> is in <span class="math">\(K\)</span>, then the triangle with vertices <span class="math">\(u\)</span>, <span class="math">\(v\)</span>, and <span class="math">\(w\)</span>
is in <span class="math">\(|K|\)</span>.  In general, <span class="math">\(|K|\)</span> is the union of the convex hulls of
simplices of <span class="math">\(K\)</span>.  Frequently, one abuses notation and uses <span class="math">\(K\)</span> to
denote both the simplicial complex and the associated topological
space.</p>
<img alt="../../_images/simplices.png" src="../../_images/simplices.png" />
<p>For any simplicial complex <span class="math">\(K\)</span> and any commutative ring <span class="math">\(R\)</span> there is
an associated chain complex, with differential of degree <span class="math">\(-1\)</span>.  The
<span class="math">\(n^{th}\)</span> term is the free <span class="math">\(R\)</span>-module with basis given by the
<span class="math">\(n\)</span>-simplices of <span class="math">\(K\)</span>.  The differential is determined by its value on
any simplex: on the <span class="math">\(n\)</span>-simplex with vertices <span class="math">\((v_0, v_1, ..., v_n)\)</span>,
the differential is the alternating sum with <span class="math">\(i^{th}\)</span> summand <span class="math">\((-1)^i\)</span>
multiplied by the <span class="math">\((n-1)\)</span>-simplex obtained by omitting vertex <span class="math">\(v_i\)</span>.</p>
<p>In the implementation here, the vertex set must be finite. To define a
simplicial complex, specify its vertex set: this should be a list,
tuple, or set, or it can be a non-negative integer <span class="math">\(n\)</span>, in which case
the vertex set is <span class="math">\((0, ..., n)\)</span>.  Also specify the facets: the maximal
faces.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The elements of the vertex set are not automatically contained in
the simplicial complex: each one is only included if and only if it
is a vertex of at least one of the specified facets.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class derives from
<a class="reference internal" href="cell_complex.html#sage.homology.cell_complex.GenericCellComplex" title="sage.homology.cell_complex.GenericCellComplex"><tt class="xref py py-class docutils literal"><span class="pre">GenericCellComplex</span></tt></a>, and so
inherits its methods.  Some of those methods are not listed here;
see the <a class="reference internal" href="cell_complex.html#module-sage.homology.cell_complex" title="sage.homology.cell_complex"><tt class="xref py py-mod docutils literal"><span class="pre">Generic</span> <span class="pre">Cell</span> <span class="pre">Complex</span></tt></a>
page instead.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="go">Simplicial complex with vertex set (1, 3, 7) and facets {(3, 7), (1,)}</span>
<span class="gp">sage: </span><span class="n">SimplicialComplex</span><span class="p">()</span>   <span class="c"># the empty simplicial complex</span>
<span class="go">Simplicial complex with vertex set () and facets {()}</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">X</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3) and facets {(1, 2), (2, 3), (0, 3), (0, 1)}</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">stanley_reisner_ring</span><span class="p">()</span>
<span class="go">Quotient of Multivariate Polynomial Ring in x0, x1, x2, x3 over Integer Ring by the ideal (x1*x3, x0*x2)</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">is_pure</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Sage can perform a number of operations on simplicial complexes, such
as the join and the product, and it can also compute homology:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span> <span class="c"># circle</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>  <span class="c"># torus</span>
<span class="gp">sage: </span><span class="n">T</span>
<span class="go">Simplicial complex with 9 vertices and 18 facets</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>   <span class="c"># this computes reduced homology</span>
<span class="go">{0: 0, 1: Z x Z, 2: Z}</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">euler_characteristic</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Sage knows about some basic combinatorial data associated to a
simplicial complex:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 4, 4]</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">face_poset</span><span class="p">()</span>
<span class="go">Finite poset containing 8 elements</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">stanley_reisner_ring</span><span class="p">()</span>
<span class="go">Quotient of Multivariate Polynomial Ring in x0, x1, x2, x3 over Integer Ring by the ideal (x1*x3, x0*x2)</span>
</pre></div>
</div>
<p>Mutability (see <a class="reference external" href="http://trac.sagemath.org/12587">trac ticket #12587</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">add_face</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">remove_face</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">S</span>
<span class="go">Simplicial complex with vertex set (1, 2, 3, 4) and facets {(2, 4), (1, 4), (3,)}</span>
<span class="gp">sage: </span><span class="nb">hash</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">This simplicial complex must be immutable. Call set_immutable().</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">add_face</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">This simplicial complex is not mutable</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">remove_face</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">This simplicial complex is not mutable</span>
<span class="gp">sage: </span><span class="nb">hash</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span> <span class="n">is_mutable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">hash</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can also make mutable copies of an immutable simplicial complex
(see <a class="reference external" href="http://trac.sagemath.org/14142">trac ticket #14142</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">==</span> <span class="n">T</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.homology.simplicial_complex.Simplex">
<em class="property">class </em><tt class="descclassname">sage.homology.simplicial_complex.</tt><tt class="descname">Simplex</tt><big>(</big><em>X</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.Simplex" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Basic Structures v6.6)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.sage_object.SageObject</span></tt></a></p>
<p>Define a simplex.</p>
<p>Topologically, a simplex is the convex hull of a collection of
vertices in general position.  Combinatorially, it is defined just
by specifying a set of vertices.  It is represented in Sage by the
tuple of the vertices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>X</strong> (<em>integer or list, tuple, or other iterable</em>) &#8211; set of vertices</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">simplex with those vertices</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal"><span class="pre">X</span></tt> may be a non-negative integer <span class="math">\(n\)</span>, in which case the
simplicial complex will have <span class="math">\(n+1\)</span> vertices <span class="math">\((0, 1, ..., n)\)</span>, or
it may be anything which may be converted to a tuple, in which
case the vertices will be that tuple.  In the second case, each
vertex must be hashable, so it should be a number, a string, or a
tuple, for instance, but not a list.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The vertices should be distinct, and no error checking is done
to make sure this is the case.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Simplex</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">(0, 1, 2, 3, 4)</span>
<span class="gp">sage: </span><span class="n">Simplex</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(3, 4, 1)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">Simplex</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;vertex&#39;</span><span class="p">));</span> <span class="n">X</span>
<span class="go">(3, &#39;a&#39;, &#39;vertex&#39;)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">==</span> <span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Vertices may be tuples but not lists:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Simplex</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)])</span>
<span class="go">((1, 2), (3, 4))</span>
<span class="gp">sage: </span><span class="n">Simplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">TypeError: unhashable type</span>: <span class="n-Identifier">&#39;list&#39;</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.homology.simplicial_complex.Simplex.dimension">
<tt class="descname">dimension</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.Simplex.dimension" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The dimension of this simplex.</p>
<p>The dimension of a simplex is the number of vertices minus 1.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Simplex</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">5</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Simplex</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">face</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.Simplex.face">
<tt class="descname">face</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.Simplex.face" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The <span class="math">\(n\)</span>-th face of this simplex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>integer</em>) &#8211; an integer between 0 and the dimension of this simplex</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the simplex obtained by removing the <span class="math">\(n\)</span>-th vertex from this
simplex</td>
</tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Simplex</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">face</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">(1, 2, 3, 4)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">face</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(0, 1, 2, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.Simplex.faces">
<tt class="descname">faces</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.Simplex.faces" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The list of faces (of codimension 1) of this simplex.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Simplex</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>
<span class="go">[(1, 2, 3, 4), (0, 2, 3, 4), (0, 1, 3, 4), (0, 1, 2, 4), (0, 1, 2, 3)]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">faces</span><span class="p">())</span>
<span class="go">11</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.Simplex.is_empty">
<tt class="descname">is_empty</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.Simplex.is_empty" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> iff this simplex is the empty simplex.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="p">[</span><span class="n">Simplex</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="go">[True, False, False, False, False]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.Simplex.is_face">
<tt class="descname">is_face</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.Simplex.is_face" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> iff this simplex is a face of other.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Simplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">is_face</span><span class="p">(</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Simplex</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">is_face</span><span class="p">(</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Simplex</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">is_face</span><span class="p">(</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.Simplex.join">
<tt class="descname">join</tt><big>(</big><em>right</em>, <em>rename_vertices=True</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.Simplex.join" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The join of this simplex with another one.</p>
<p>The join of two simplices <span class="math">\([v_0, ..., v_k]\)</span> and <span class="math">\([w_0, ...,
w_n]\)</span> is the simplex <span class="math">\([v_0, ..., v_k, w_0, ..., w_n]\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>right</strong> &#8211; the other simplex (the right-hand factor)</li>
<li><strong>rename_vertices</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; If this is <tt class="docutils literal"><span class="pre">True</span></tt>, the vertices in the
join will be renamed by this formula: vertex &#8220;v&#8221; in the
left-hand factor &#8211;&gt; vertex &#8220;Lv&#8221; in the join, vertex &#8220;w&#8221;
in the right-hand factor &#8211;&gt; vertex &#8220;Rw&#8221; in the join.  If
this is false, this tries to construct the join without
renaming the vertices; this may cause problems if the two
factors have any vertices with names in common.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Simplex</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">(&#39;L0&#39;, &#39;L1&#39;, &#39;L2&#39;, &#39;R0&#39;, &#39;R1&#39;, &#39;R2&#39;, &#39;R3&#39;)</span>
<span class="gp">sage: </span><span class="n">Simplex</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Simplex</span><span class="p">([</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="s">&#39;z&#39;</span><span class="p">]))</span>
<span class="go">(&#39;La&#39;, &#39;Lb&#39;, &#39;Rx&#39;, &#39;Ry&#39;, &#39;Rz&#39;)</span>
<span class="gp">sage: </span><span class="n">Simplex</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Simplex</span><span class="p">([</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="s">&#39;z&#39;</span><span class="p">]),</span> <span class="n">rename_vertices</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">(&#39;a&#39;, &#39;b&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.Simplex.product">
<tt class="descname">product</tt><big>(</big><em>other</em>, <em>rename_vertices=True</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.Simplex.product" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The product of this simplex with another one, as a list of simplices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other</strong> &#8211; the other simplex</li>
<li><strong>rename_vertices</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; If this is <tt class="docutils literal"><span class="pre">False</span></tt>, then the vertices in
the product are the set of ordered pairs <span class="math">\((v,w)\)</span> where <span class="math">\(v\)</span>
is a vertex in the left-hand factor (<tt class="docutils literal"><span class="pre">self</span></tt>) and <span class="math">\(w\)</span> is
a vertex in the right-hand factor (<tt class="docutils literal"><span class="pre">other</span></tt>). If this is
<tt class="docutils literal"><span class="pre">True</span></tt>, then the vertices are renamed as &#8220;LvRw&#8221; (e.g., the
vertex (1,2) would become &#8220;L1R2&#8221;).  This is useful if you
want to define the Stanley-Reisner ring of the complex:
vertex names like (0,1) are not suitable for that, while
vertex names like &#8220;L0R1&#8221; are.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Algorithm: see Hatcher, p. 277-278 <a class="reference internal" href="delta_complex.html#hat" id="id1">[Hat]</a> (who in turn refers to
Eilenberg-Steenrod, p. 68): given <tt class="docutils literal"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">Simplex(m)</span></tt> and
<tt class="docutils literal"><span class="pre">T</span> <span class="pre">=</span> <span class="pre">Simplex(n)</span></tt>, then <span class="math">\(S \times T\)</span> can be
triangulated as follows: for each path <span class="math">\(f\)</span> from <span class="math">\((0,0)\)</span> to
<span class="math">\((m,n)\)</span> along the integer grid in the plane, going up or right
at each lattice point, associate an <span class="math">\((m+n)\)</span>-simplex with
vertices <span class="math">\(v_0\)</span>, <span class="math">\(v_1\)</span>, ..., where <span class="math">\(v_k\)</span> is the <span class="math">\(k^{th}\)</span> vertex
in the path <span class="math">\(f\)</span>.</p>
<p>Note that there are <span class="math">\(m+n\)</span> choose <span class="math">\(n\)</span> such paths.  Note also
that each vertex in the product is a pair of vertices <span class="math">\((v,w)\)</span>
where <span class="math">\(v\)</span> is a vertex in the left-hand factor and <span class="math">\(w\)</span>
is a vertex in the right-hand factor.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This produces a list of simplices &#8211; not a <a class="reference internal" href="#sage.homology.simplicial_complex.Simplex" title="sage.homology.simplicial_complex.Simplex"><tt class="xref py py-class docutils literal"><span class="pre">Simplex</span></tt></a>, not
a <a class="reference internal" href="#sage.homology.simplicial_complex.SimplicialComplex" title="sage.homology.simplicial_complex.SimplicialComplex"><tt class="xref py py-class docutils literal"><span class="pre">SimplicialComplex</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">Simplex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(&#39;L0R0&#39;, &#39;L0R1&#39;, &#39;L1R1&#39;), (&#39;L0R0&#39;, &#39;L1R0&#39;, &#39;L1R1&#39;)]</span>
<span class="gp">sage: </span><span class="n">Simplex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">rename_vertices</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">[((0, 0), (0, 1), (1, 1)), ((0, 0), (1, 0), (1, 1))]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.Simplex.set">
<tt class="descname">set</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.Simplex.set" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The frozenset attached to this simplex.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Simplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
<span class="go">frozenset({0, 1, 2, 3})</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.Simplex.tuple">
<tt class="descname">tuple</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.Simplex.tuple" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The tuple attached to this simplex.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Simplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">tuple</span><span class="p">()</span>
<span class="go">(0, 1, 2, 3)</span>
</pre></div>
</div>
<p>Although simplices are printed as if they were tuples, they
are not the same type:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">tuple</span><span class="p">())</span>
<span class="go">&lt;type &#39;tuple&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">&lt;class &#39;sage.homology.simplicial_complex.Simplex&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.homology.simplicial_complex.SimplicialComplex">
<em class="property">class </em><tt class="descclassname">sage.homology.simplicial_complex.</tt><tt class="descname">SimplicialComplex</tt><big>(</big><em>maximal_faces=None</em>, <em>from_characteristic_function=None</em>, <em>maximality_check=True</em>, <em>sort_facets=True</em>, <em>name_check=False</em>, <em>is_mutable=True</em>, <em>is_immutable=False</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/category_object.html#sage.structure.category_object.CategoryObject" title="(in Sage Reference Manual: Basic Structures v6.6)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.category_object.CategoryObject</span></tt></a>, <a class="reference internal" href="cell_complex.html#sage.homology.cell_complex.GenericCellComplex" title="sage.homology.cell_complex.GenericCellComplex"><tt class="xref py py-class docutils literal"><span class="pre">sage.homology.cell_complex.GenericCellComplex</span></tt></a></p>
<p>Define a simplicial complex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>maximal_faces</strong> &#8211; set of maximal faces</li>
<li><strong>from_characteristic_function</strong> &#8211; see below</li>
<li><strong>maximality_check</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; see below</li>
<li><strong>sort_facets</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; see below</li>
<li><strong>name_check</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">False</span></tt>) &#8211; see below</li>
<li><strong>is_mutable</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; Set to <tt class="docutils literal"><span class="pre">False</span></tt> to make this immutable</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a simplicial complex</p>
</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal"><span class="pre">maximal_faces</span></tt> should be a list or tuple or set (indeed,
anything which may be converted to a set) whose elements are lists
(or tuples, etc.) of vertices.  Maximal faces are also known as
&#8216;facets&#8217;.</p>
<p>Alternatively, the maximal faces can be defined from a monotome boolean
function on the subsets of a set <span class="math">\(X\)</span>. While defining <tt class="docutils literal"><span class="pre">maximal_faces=None</span></tt>,
you can thus set <tt class="docutils literal"><span class="pre">from_characteristic_function=(f,X)</span></tt> where <tt class="docutils literal"><span class="pre">X</span></tt> is the
set of points and <tt class="docutils literal"><span class="pre">f</span></tt> a boolean monotone hereditary function that accepts
a list of elements from <tt class="docutils literal"><span class="pre">X</span></tt> as input (see
<a class="reference external" href="../../../combinat/sage/combinat/subsets_hereditary.html#sage.combinat.subsets_hereditary.subsets_with_hereditary_property" title="(in Sage Reference Manual: Combinatorics v6.6)"><tt class="xref py py-func docutils literal"><span class="pre">subsets_with_hereditary_property()</span></tt></a>
for more information).</p>
<p>If <tt class="docutils literal"><span class="pre">maximality_check</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt>, check that each maximal face is,
in fact, maximal. In this case, when producing the internal
representation of the simplicial complex, omit those that are not.
It is highly recommended that this be <tt class="docutils literal"><span class="pre">True</span></tt>; various methods for
this class may fail if faces which are claimed to be maximal are
in fact not.</p>
<p>If <tt class="docutils literal"><span class="pre">sort_facets</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt>, sort the vertices in each facet.  If
the vertices in different facets are not ordered compatibly (e.g.,
if you have facets <tt class="docutils literal"><span class="pre">(1,</span> <span class="pre">3,</span> <span class="pre">5)</span></tt> and <tt class="docutils literal"><span class="pre">(5,</span> <span class="pre">3,</span> <span class="pre">8)</span></tt>), then homology
calculations may have unpredictable results.</p>
<p>If <tt class="docutils literal"><span class="pre">name_check</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt>, check the names of the vertices to see
if they can be easily converted to generators of a polynomial ring
&#8211; use this if you plan to use the Stanley-Reisner ring for the
simplicial complex.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="go">Simplicial complex with vertex set (1, 2, 4) and facets {(1, 2), (1, 4)}</span>
<span class="gp">sage: </span><span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="go">Simplicial complex with vertex set (0, 2, 3) and facets {(0, 2), (0, 3)}</span>
<span class="gp">sage: </span><span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">maximality_check</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Simplicial complex with vertex set (0, 2, 3) and facets {(0, 2), (0, 3), (0,)}</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">(((</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">),</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">],</span> <span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">S</span>
<span class="go">Simplicial complex with vertex set (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) and facets {(&#39;b&#39;, &#39;c&#39;), (&#39;a&#39;, &#39;c&#39;), (&#39;a&#39;, &#39;b&#39;)}</span>
</pre></div>
</div>
<p>Finally, if there is only one argument and it is a
simplicial complex, return that complex.  If it is an object with
a built-in conversion to simplicial complexes (via a
<tt class="docutils literal"><span class="pre">_simplicial_</span></tt> method), then the resulting simplicial complex is
returned:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">SimplicialComplex</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">==</span> <span class="n">S</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Tc</span> <span class="o">=</span> <span class="n">cubical_complexes</span><span class="o">.</span><span class="n">Torus</span><span class="p">();</span> <span class="n">Tc</span>
<span class="go">Cubical complex with 16 vertices and 64 cubes</span>
<span class="gp">sage: </span><span class="n">Ts</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">(</span><span class="n">Tc</span><span class="p">);</span> <span class="n">Ts</span>
<span class="go">Simplicial complex with 16 vertices and 32 facets</span>
<span class="gp">sage: </span><span class="n">Ts</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: Z x Z, 2: Z}</span>
</pre></div>
</div>
<p>From a characteristic monotone boolean function, e.g. the simplicial complex
of all subsets <span class="math">\(S\subseteq \{0,1,2,3,4\}\)</span> such that <span class="math">\(sum(S)\leq 4\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">SimplicialComplex</span><span class="p">(</span><span class="n">from_characteristic_function</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">4</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3, 4) and facets {(0, 4), (0, 1, 2), (0, 1, 3)}</span>
</pre></div>
</div>
<p>or e.g. the simplicial complex of all 168 hyperovals of the projective plane of order 4:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">l</span><span class="o">=</span><span class="n">designs</span><span class="o">.</span><span class="n">ProjectiveGeometryDesign</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">GF</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SimplicialComplex</span><span class="p">(</span><span class="n">from_characteristic_function</span><span class="o">=</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">21</span><span class="p">)))</span>
<span class="go">Simplicial complex with 21 vertices and 168 facets</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Check that we can make mutable copies (see <a class="reference external" href="http://trac.sagemath.org/14142">trac ticket #14142</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]],</span> <span class="n">is_mutable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">SimplicialComplex</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">is_mutable</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">SimplicialComplex</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">is_immutable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.add_face">
<tt class="descname">add_face</tt><big>(</big><em>face</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.add_face" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Add a face to this simplicial complex</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>face</strong> &#8211; a subset of the vertex set</td>
</tr>
</tbody>
</table>
<p>This <em>changes</em> the simplicial complex, adding a new face and all
of its subfaces.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">add_face</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,]);</span> <span class="n">X</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2) and facets {(0, 1, 2)}</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">();</span> <span class="n">Y</span>
<span class="go">Simplicial complex with vertex set () and facets {()}</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">add_face</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">add_face</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Y</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3) and facets {(1, 2, 3), (0, 1)}</span>
</pre></div>
</div>
<p>If you add a face which is already present, there is no effect:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">add_face</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">Y</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3) and facets {(1, 2, 3), (0, 1)}</span>
</pre></div>
</div>
<p>Check that the bug reported at <a class="reference external" href="http://trac.sagemath.org/14354">trac ticket #14354</a> has been fixed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: Z x Z x Z}</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">add_face</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: Z x Z, 2: 0}</span>
</pre></div>
</div>
<p>Check we&#8217;ve fixed the bug reported at <a class="reference external" href="http://trac.sagemath.org/14578">trac ticket #14578</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t0</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t0</span><span class="o">.</span><span class="n">add_face</span><span class="p">((</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">t0</span><span class="o">.</span><span class="n">add_face</span><span class="p">((</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">t0</span><span class="o">.</span><span class="n">add_face</span><span class="p">((</span><span class="s">&#39;e&#39;</span><span class="p">,</span> <span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">t0</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: Z, 1: 0, 2: 0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.alexander_dual">
<tt class="descname">alexander_dual</tt><big>(</big><em>is_mutable=True</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.alexander_dual" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The Alexander dual of this simplicial complex: according to
the Macaulay2 documentation, this is the simplicial complex
whose faces are the complements of its nonfaces.</p>
<p>Thus find the minimal nonfaces and take their complements to
find the facets in the Alexander dual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>is_mutable</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; Determines if the output is mutable</td>
</tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]);</span> <span class="n">Y</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3, 4) and facets {(4,), (2,), (3,), (0,), (1,)}</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">alexander_dual</span><span class="p">()</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3, 4) and 10 facets</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">alexander_dual</span><span class="p">()</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3) and facets {(1, 3), (0, 2)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.automorphism_group">
<tt class="descname">automorphism_group</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.automorphism_group" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the automorphism group of the simplicial complex.</p>
<p>This is done by creating a bipartite graph, whose vertices are
vertices and facets of the simplicial complex, and computing
its automorphism group.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Since <a class="reference external" href="http://trac.sagemath.org/14319">trac ticket #14319</a> the domain of the automorphism group is equal to
the graph&#8217;s vertex set, and the <tt class="docutils literal"><span class="pre">translation</span></tt> argument has become
useless.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">RealProjectivePlane</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">AlternatingGroup</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="s">&#39;1&#39;</span><span class="p">,</span><span class="s">&#39;2&#39;</span><span class="p">],[</span><span class="s">&#39;2&#39;</span><span class="p">,</span><span class="s">&#39;3&#39;</span><span class="p">,</span><span class="s">&#39;a&#39;</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">CyclicPermutationGroup</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">group</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">group</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
<span class="go">{&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;a&#39;}</span>
</pre></div>
</div>
<p>Check that <a class="reference external" href="http://trac.sagemath.org/17032">trac ticket #17032</a> is fixed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)]])</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">()</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.barycentric_subdivision">
<tt class="descname">barycentric_subdivision</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.barycentric_subdivision" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The barycentric subdivision of this simplicial complex.</p>
<p>See <a class="reference external" href="http://en.wikipedia.org/wiki/Barycentric_subdivision">http://en.wikipedia.org/wiki/Barycentric_subdivision</a> for a
definition.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">triangle</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">hexagon</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="n">barycentric_subdivision</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">hexagon</span>
<span class="go">Simplicial complex with 6 vertices and 6 facets</span>
<span class="gp">sage: </span><span class="n">hexagon</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">triangle</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Barycentric subdivisions can get quite large, since each
<span class="math">\(n\)</span>-dimensional facet in the original complex produces
<span class="math">\((n+1)!\)</span> facets in the subdivision:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S4</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S4</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3, 4, 5) and 6 facets</span>
<span class="gp">sage: </span><span class="n">S4</span><span class="o">.</span><span class="n">barycentric_subdivision</span><span class="p">()</span>
<span class="go">Simplicial complex with 62 vertices and 720 facets</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.cells">
<tt class="descname">cells</tt><big>(</big><em>subcomplex=None</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.cells" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The faces of this simplicial complex, in the form of a
dictionary of sets keyed by dimension.  If the optional
argument <tt class="docutils literal"><span class="pre">subcomplex</span></tt> is present, then return only the
faces which are <em>not</em> in the subcomplex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>subcomplex</strong> (optional, default <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; a subcomplex of this simplicial complex.
Return faces which are not in this subcomplex.</td>
</tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>
<span class="go">{-1: {()}, 0: {(1,), (2,), (4,)}, 1: {(1, 2), (1, 4)}}</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">subcomplex</span><span class="o">=</span><span class="n">L</span><span class="p">)</span>
<span class="go">{-1: set(), 0: {(4,)}, 1: {(1, 4)}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.chain_complex">
<tt class="descname">chain_complex</tt><big>(</big><em>**kwds</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.chain_complex" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The chain complex associated to this simplicial complex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dimensions</strong> &#8211; if <tt class="docutils literal"><span class="pre">None</span></tt>, compute the chain complex in all
dimensions.  If a list or tuple of integers, compute the
chain complex in those dimensions, setting the chain groups
in all other dimensions to zero.</li>
<li><strong>base_ring</strong> (optional, default <tt class="docutils literal"><span class="pre">ZZ</span></tt>) &#8211; commutative ring</li>
<li><strong>subcomplex</strong> (<em>optional, default empty</em>) &#8211; a subcomplex of this simplicial complex.
Compute the chain complex relative to this subcomplex.</li>
<li><strong>augmented</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">False</span></tt>) &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt>, return the augmented chain complex
(that is, include a class in dimension <span class="math">\(-1\)</span> corresponding
to the empty cell).  This is ignored if <tt class="docutils literal"><span class="pre">dimensions</span></tt> is
specified.</li>
<li><strong>cochain</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">False</span></tt>) &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt>, return the cochain complex (that is,
the dual of the chain complex).</li>
<li><strong>verbose</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">False</span></tt>) &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt>, print some messages as the chain
complex is computed.</li>
<li><strong>check_diffs</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">False</span></tt>) &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt>, make sure that the chain complex
is actually a chain complex: the differentials are
composable and their product is zero.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If subcomplex is nonempty, then the argument <tt class="docutils literal"><span class="pre">augmented</span></tt>
has no effect: the chain complex relative to a nonempty
subcomplex is zero in dimension <span class="math">\(-1\)</span>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">circle</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">circle</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">()</span>
<span class="go">Chain complex with at most 2 nonzero terms over Integer Ring</span>
<span class="gp">sage: </span><span class="n">circle</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">()</span><span class="o">.</span><span class="n">_latex_</span><span class="p">()</span>
<span class="go">&#39;\Bold{Z}^{3} \xrightarrow{d_{1}} \Bold{Z}^{3}&#39;</span>
<span class="gp">sage: </span><span class="n">circle</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">,</span> <span class="n">augmented</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Chain complex with at most 3 nonzero terms over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.cone">
<tt class="descname">cone</tt><big>(</big><em>is_mutable=True</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.cone" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The cone on this simplicial complex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>is_mutable</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; Determines if the output is mutable</td>
</tr>
</tbody>
</table>
<p>The cone is the simplicial complex formed by adding a new
vertex <span class="math">\(C\)</span> and simplices of the form <span class="math">\([C, v_0, ..., v_k]\)</span> for
every simplex <span class="math">\([v_0, ..., v_k]\)</span> in the original simplicial
complex.  That is, the cone is the join of the original
complex with a one-point simplicial complex.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">cone</span><span class="p">()</span>
<span class="go">Simplicial complex with vertex set (&#39;L0&#39;, &#39;L1&#39;, &#39;R0&#39;) and facets {(&#39;L0&#39;, &#39;R0&#39;), (&#39;L1&#39;, &#39;R0&#39;)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.connected_component">
<tt class="descname">connected_component</tt><big>(</big><em>simplex=None</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.connected_component" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the connected component of this simplicial complex
containing <tt class="docutils literal"><span class="pre">simplex</span></tt>. If <tt class="docutils literal"><span class="pre">simplex</span></tt> is omitted, then return
the connected component containing the zeroth vertex in the
vertex list. (If the simplicial complex is empty, raise an
error.)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">==</span> <span class="n">S1</span><span class="o">.</span><span class="n">connected_component</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">==</span> <span class="n">X</span><span class="o">.</span><span class="n">connected_component</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">v0</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">vertices</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">v1</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">vertices</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">connected_component</span><span class="p">(</span><span class="n">Simplex</span><span class="p">([</span><span class="n">v0</span><span class="p">]))</span> <span class="o">==</span> <span class="n">X</span><span class="o">.</span><span class="n">connected_component</span><span class="p">(</span><span class="n">Simplex</span><span class="p">([</span><span class="n">v1</span><span class="p">]))</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">(0, 1)</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">connected_component</span><span class="p">()</span>
<span class="go">Simplicial complex with vertex set (0,) and facets {(0,)}</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">connected_component</span><span class="p">(</span><span class="n">Simplex</span><span class="p">((</span><span class="mi">1</span><span class="p">,)))</span>
<span class="go">Simplicial complex with vertex set (1,) and facets {(1,)}</span>

<span class="gp">sage: </span><span class="n">SimplicialComplex</span><span class="p">([[]])</span><span class="o">.</span><span class="n">connected_component</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">the empty simplicial complex has no connected components.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.connected_sum">
<tt class="descname">connected_sum</tt><big>(</big><em>other</em>, <em>is_mutable=True</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.connected_sum" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The connected sum of this simplicial complex with another one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>other</strong> &#8211; another simplicial complex</li>
<li><strong>is_mutable</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; Determines if the output is mutable</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the connected sum <tt class="docutils literal"><span class="pre">self</span> <span class="pre">#</span> <span class="pre">other</span></tt></p>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This does not check that <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt> are manifolds,
only that their facets all have the same dimension.  Since a
(more or less) random facet is chosen from each complex and
then glued together, this method may return random
results if applied to non-manifolds, depending on which
facet is chosen.</p>
</div>
<p>Algorithm: a facet is chosen from each surface, and removed.
The vertices of these two facets are relabeled to
<tt class="docutils literal"><span class="pre">(0,1,...,dim)</span></tt>.  Of the remaining vertices, the ones from
the left-hand factor are renamed by prepending an &#8220;L&#8221;, and
similarly the remaining vertices in the right-hand factor are
renamed by prepending an &#8220;R&#8221;.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">connected_sum</span><span class="p">(</span><span class="n">S1</span><span class="o">.</span><span class="n">connected_sum</span><span class="p">(</span><span class="n">S1</span><span class="p">))</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: Z}</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">RealProjectivePlane</span><span class="p">();</span> <span class="n">P</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3, 4, 5) and 10 facets</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">connected_sum</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>    <span class="c"># the Klein bottle</span>
<span class="go">Simplicial complex with 9 vertices and 18 facets</span>
</pre></div>
</div>
<p>The notation &#8216;+&#8217; may be used for connected sum, also:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">+</span> <span class="n">P</span>    <span class="c"># the Klein bottle</span>
<span class="go">Simplicial complex with 9 vertices and 18 facets</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Z x C2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.delta_complex">
<tt class="descname">delta_complex</tt><big>(</big><em>sort_simplices=False</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.delta_complex" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">self</span></tt> as a <span class="math">\(\Delta\)</span>-complex.  The <span class="math">\(\Delta\)</span>-complex
is essentially identical to the simplicial complex: it has
same simplices with the same boundaries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sort_simplices</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">False</span></tt>) &#8211; if <tt class="docutils literal"><span class="pre">True</span></tt>, sort the list of simplices in
each dimension</td>
</tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Td</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">delta_complex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Td</span>
<span class="go">Delta complex with 7 vertices and 43 simplices</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span> <span class="o">==</span> <span class="n">Td</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.disjoint_union">
<tt class="descname">disjoint_union</tt><big>(</big><em>right</em>, <em>rename_vertices=True</em>, <em>is_mutable=True</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.disjoint_union" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The disjoint union of this simplicial complex with another one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>right</strong> &#8211; the other simplicial complex (the right-hand factor)</li>
<li><strong>rename_vertices</strong> (<em>boolean; optional, default True</em>) &#8211; If this is True, the vertices in the
disjoint union will be renamed by the formula: vertex &#8220;v&#8221;
in the left-hand factor &#8211;&gt; vertex &#8220;Lv&#8221; in the disjoint
union, vertex &#8220;w&#8221; in the right-hand factor &#8211;&gt; vertex &#8220;Rw&#8221;
in the disjoint union.  If this is false, this tries to
construct the disjoint union without renaming the vertices;
this will cause problems if the two factors have any
vertices with names in common.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: Z, 1: Z, 2: Z}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.face_iterator">
<tt class="descname">face_iterator</tt><big>(</big><em>increasing=True</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.face_iterator" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An iterator for the faces in this simplicial complex.</p>
<p>INPUTS:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">increasing</span></tt> &#8211; (optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) if <tt class="docutils literal"><span class="pre">True</span></tt>, return
faces in increasing order of dimension, thus starting with
the empty face. Otherwise it returns faces in decreasing order of
dimension.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">S1</span><span class="o">.</span><span class="n">face_iterator</span><span class="p">()]</span>
<span class="go">[(), (2,), (0,), (1,), (1, 2), (0, 2), (0, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.faces">
<tt class="descname">faces</tt><big>(</big><em>subcomplex=None</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.faces" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The faces of this simplicial complex, in the form of a
dictionary of sets keyed by dimension.  If the optional
argument <tt class="docutils literal"><span class="pre">subcomplex</span></tt> is present, then return only the
faces which are <em>not</em> in the subcomplex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>subcomplex</strong> (optional, default <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; a subcomplex of this simplicial complex.
Return faces which are not in this subcomplex.</td>
</tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>
<span class="go">{-1: {()}, 0: {(1,), (2,), (4,)}, 1: {(1, 2), (1, 4)}}</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">subcomplex</span><span class="o">=</span><span class="n">L</span><span class="p">)</span>
<span class="go">{-1: set(), 0: {(4,)}, 1: {(1, 4)}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.facets">
<tt class="descname">facets</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.facets" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The maximal faces (a.k.a. facets) of this simplicial complex.</p>
<p>This just returns the set of facets used in defining the
simplicial complex, so if the simplicial complex was defined
with no maximality checking, none is done here, either.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">maximal_faces</span><span class="p">()</span>
<span class="go">{(1, 4), (0, 2)}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">facets</span></tt> is a synonym for <tt class="docutils literal"><span class="pre">maximal_faces</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">facets</span><span class="p">()</span>
<span class="go">{(0, 1, 2)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.fixed_complex">
<tt class="descname">fixed_complex</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.fixed_complex" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the fixed simplicial complex <span class="math">\(Fix(G)\)</span> for a subgroup <span class="math">\(G\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">G</span></tt> &#8211; a subgroup of the automorphism group of the simplicial
complex or a list of elements of the automorphism group</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a simplicial complex <span class="math">\(Fix(G)\)</span></li>
</ul>
<p>Vertices in <span class="math">\(Fix(G)\)</span> are the orbits of <span class="math">\(G\)</span> (acting on vertices
of <tt class="docutils literal"><span class="pre">self</span></tt>) that form a simplex in <tt class="docutils literal"><span class="pre">self</span></tt>. More generally,
simplices in <span class="math">\(Fix(G)\)</span> correspond to simplices in <tt class="docutils literal"><span class="pre">self</span></tt> that
are union of such orbits.</p>
<p>A basic example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S4</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fix</span> <span class="o">=</span> <span class="n">S4</span><span class="o">.</span><span class="n">fixed_complex</span><span class="p">([</span><span class="n">S4</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">()([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])])</span>
<span class="gp">sage: </span><span class="n">fix</span>
<span class="go">Simplicial complex with vertex set (0, 2, 3, 4, 5) and 5 facets</span>
<span class="gp">sage: </span><span class="n">fix</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Another simple example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">fixed_complex</span><span class="p">([</span><span class="n">G</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)])])</span>
<span class="go">Simplicial complex with vertex set (2, 3) and facets {(2, 3)}</span>
</pre></div>
</div>
<p>A more sophisticated example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">RP2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">ProjectivePlane</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">CP2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">ComplexProjectivePlane</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">CP2</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgroup</span><span class="p">([</span><span class="n">G</span><span class="p">([(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">)])])</span>
<span class="gp">sage: </span><span class="n">CP2</span><span class="o">.</span><span class="n">fixed_complex</span><span class="p">(</span><span class="n">H</span><span class="p">)</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">RP2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.flip_graph">
<tt class="descname">flip_graph</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.flip_graph" title="Permalink to this definition">Â¶</a></dt>
<dd><p>If <tt class="docutils literal"><span class="pre">self</span></tt> is pure, then it returns the the flip graph of <tt class="docutils literal"><span class="pre">self</span></tt>,
otherwise, it returns <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<p>The flip graph of a pure simplicial complex is the (undirected) graph
with vertices being the facets, such that two facets are joined by
an edge if they meet in a codimension <span class="math">\(1\)</span> face.</p>
<p>The flip graph is used to detect if <tt class="docutils literal"><span class="pre">self</span></tt> is a pseudomanifold.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">S0</span><span class="o">.</span><span class="n">flip_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">();</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">[(0,), (1,)]</span>
<span class="go">[((0,), (1,))]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="p">(</span><span class="n">S0</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S0</span><span class="p">))</span><span class="o">.</span><span class="n">flip_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">();</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">[(0,), (&#39;L1&#39;,), (&#39;R1&#39;,)]</span>
<span class="go">[((0,), (&#39;L1&#39;,)), ((0,), (&#39;R1&#39;,)), ((&#39;L1&#39;,), (&#39;R1&#39;,))]</span>

<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="p">(</span><span class="n">S1</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S1</span><span class="p">))</span><span class="o">.</span><span class="n">flip_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">();</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">[(0, &#39;L1&#39;), (0, &#39;L2&#39;), (0, &#39;R1&#39;), (0, &#39;R2&#39;), (&#39;L1&#39;, &#39;L2&#39;), (&#39;R1&#39;, &#39;R2&#39;)]</span>
<span class="go">[((0, &#39;L1&#39;), (0, &#39;L2&#39;)),</span>
<span class="go"> ((0, &#39;L1&#39;), (0, &#39;R1&#39;)),</span>
<span class="go"> ((0, &#39;L1&#39;), (0, &#39;R2&#39;)),</span>
<span class="go"> ((0, &#39;L1&#39;), (&#39;L1&#39;, &#39;L2&#39;)),</span>
<span class="go"> ((0, &#39;L2&#39;), (0, &#39;R1&#39;)),</span>
<span class="go"> ((0, &#39;L2&#39;), (0, &#39;R2&#39;)),</span>
<span class="go"> ((0, &#39;L2&#39;), (&#39;L1&#39;, &#39;L2&#39;)),</span>
<span class="go"> ((0, &#39;R1&#39;), (0, &#39;R2&#39;)),</span>
<span class="go"> ((0, &#39;R1&#39;), (&#39;R1&#39;, &#39;R2&#39;)),</span>
<span class="go"> ((0, &#39;R2&#39;), (&#39;R1&#39;, &#39;R2&#39;))]</span>

<span class="gp">sage: </span><span class="p">(</span><span class="n">S1</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S2</span><span class="p">))</span><span class="o">.</span><span class="n">flip_graph</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">flip_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">();</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">[(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)]</span>
<span class="go">[((0, 1, 2), (0, 1, 3)),</span>
<span class="go"> ((0, 1, 2), (0, 2, 3)),</span>
<span class="go"> ((0, 1, 2), (1, 2, 3)),</span>
<span class="go"> ((0, 1, 3), (0, 2, 3)),</span>
<span class="go"> ((0, 1, 3), (1, 2, 3)),</span>
<span class="go"> ((0, 2, 3), (1, 2, 3))]</span>

<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">suspension</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">flip_graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">());</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="go">46</span>
<span class="go">161</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.fundamental_group">
<tt class="descname">fundamental_group</tt><big>(</big><em>base_point=None</em>, <em>simplify=True</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.fundamental_group" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the fundamental group of this simplicial complex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">base_point</span></tt> (optional, default None) &#8211; if this complex is
not path-connected, then specify a vertex; the fundamental
group is computed with that vertex as a base point. If the
complex is path-connected, then you may specify a vertex or
leave this as its default setting of <tt class="docutils literal"><span class="pre">None</span></tt>. (If this
complex is path-connected, then this argument is ignored.)</li>
<li><tt class="docutils literal"><span class="pre">simplify</span></tt> (bool, optional True) &#8211; if False, then return a
presentation of the group in terms of generators and
relations. If True, the default, simplify as much as GAP is
able to.</li>
</ul>
<p>Algorithm: we compute the edge-path group &#8211; see
<a class="reference external" href="http://en.wikipedia.org/wiki/Fundamental_group">Wikipedia article Fundamental_group</a>. Choose a spanning tree for the
1-skeleton, and then the group&#8217;s generators are given by the
edges in the 1-skeleton; there are two types of relations:
<span class="math">\(e=1\)</span> if <span class="math">\(e\)</span> is in the spanning tree, and for every 2-simplex,
if its edges are <span class="math">\(e_0\)</span>, <span class="math">\(e_1\)</span>, and <span class="math">\(e_2\)</span>, then we impose the
relation <span class="math">\(e_0 e_1^{-1} e_2 = 1\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">()</span>
<span class="go">Finitely presented group &lt; e |  &gt;</span>
</pre></div>
</div>
<p>If we pass the argument <tt class="docutils literal"><span class="pre">simplify=False</span></tt>, we get generators and
relations in a form which is not usually very helpful. Here is the
cyclic group of order 2, for instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">RP2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C2</span> <span class="o">=</span> <span class="n">RP2</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C2</span>
<span class="go">Finitely presented group &lt; e0, e1, e2, e3, e4, e5, e6, e7, e8, e9 | e6, e5, e3, e9, e4*e7^-1*e6, e9*e7^-1*e0, e0*e1^-1*e2, e5*e1^-1*e8, e4*e3^-1*e8, e2 &gt;</span>
<span class="gp">sage: </span><span class="n">C2</span><span class="o">.</span><span class="n">simplified</span><span class="p">()</span>
<span class="go">Finitely presented group &lt; e0 | e0^2 &gt;</span>
</pre></div>
</div>
<p>This is the same answer given if the argument <tt class="docutils literal"><span class="pre">simplify</span></tt> is True
(the default):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">RP2</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">()</span>
<span class="go">Finitely presented group &lt; e0 | e0^2 &gt;</span>
</pre></div>
</div>
<p>You must specify a base point to compute the fundamental group
of a non-connected complex:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">RP2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">this complex is not connected, so you must specify a base point.</span>
<span class="gp">sage: </span><span class="n">v0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">vertices</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">(</span><span class="n">base_point</span><span class="o">=</span><span class="n">v0</span><span class="p">)</span>
<span class="go">Finitely presented group &lt; e |  &gt;</span>
<span class="gp">sage: </span><span class="n">v1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">vertices</span><span class="p">())[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">(</span><span class="n">base_point</span><span class="o">=</span><span class="n">v1</span><span class="p">)</span>
<span class="go">Finitely presented group &lt; e0 | e0^2 &gt;</span>
</pre></div>
</div>
<p>Some other examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">()</span>
<span class="go">Finitely presented group &lt; e0, e1 | &gt;</span>
<span class="gp">sage: </span><span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">()</span>
<span class="go">Finitely presented group &lt; e0, e3 | e0*e3^-1*e0^-1*e3 &gt;</span>
<span class="gp">sage: </span><span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">MooreSpace</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">()</span>
<span class="go">Finitely presented group &lt; e1 | e1^5 &gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.g_vector">
<tt class="descname">g_vector</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.g_vector" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The <span class="math">\(g\)</span>-vector of this simplicial complex.</p>
<p>If the <span class="math">\(h\)</span>-vector of the complex is <span class="math">\((h_0, h_1, ..., h_d,
h_{d+1})\)</span> &#8211; see <a class="reference internal" href="#sage.homology.simplicial_complex.SimplicialComplex.h_vector" title="sage.homology.simplicial_complex.SimplicialComplex.h_vector"><tt class="xref py py-meth docutils literal"><span class="pre">h_vector()</span></tt></a> &#8211; then its <span class="math">\(g\)</span>-vector
<span class="math">\((g_0, g_1, ..., g_{[(d+1)/2]})\)</span> is defined by <span class="math">\(g_0 = 1\)</span> and
<span class="math">\(g_i = h_i - h_{i-1}\)</span> for <span class="math">\(i &gt; 0\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">barycentric_subdivision</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S3</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 30, 150, 240, 120]</span>
<span class="gp">sage: </span><span class="n">S3</span><span class="o">.</span><span class="n">h_vector</span><span class="p">()</span>
<span class="go">[1, 26, 66, 26, 1]</span>
<span class="gp">sage: </span><span class="n">S3</span><span class="o">.</span><span class="n">g_vector</span><span class="p">()</span>
<span class="go">[1, 25, 40]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.generated_subcomplex">
<tt class="descname">generated_subcomplex</tt><big>(</big><em>sub_vertex_set</em>, <em>is_mutable=True</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.generated_subcomplex" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns the largest sub-simplicial complex of <tt class="docutils literal"><span class="pre">self</span></tt> containing
exactly <tt class="docutils literal"><span class="pre">sub_vertex_set</span></tt> as vertices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sub_vertex_set</strong> &#8211; The sub-vertex set.</li>
<li><strong>is_mutable</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; Determines if the output is mutable</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3) and facets {(0, 2, 3), (0, 1, 2), (1, 2, 3), (0, 1, 3)}</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">generated_subcomplex</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2) and facets {(0, 1, 2)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.graph">
<tt class="descname">graph</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.graph" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The 1-skeleton of this simplicial complex, as a graph.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This may give the wrong answer if the simplicial complex
was constructed with <tt class="docutils literal"><span class="pre">maximality_check</span></tt> set to <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">graph</span><span class="p">();</span> <span class="n">G</span>
<span class="go">Graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 2, None), (0, 3, None), (1, 2, None), (1, 3, None), (2, 3, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.h_vector">
<tt class="descname">h_vector</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.h_vector" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The <span class="math">\(h\)</span>-vector of this simplicial complex.</p>
<p>If the complex has dimension <span class="math">\(d\)</span> and <span class="math">\((f_{-1}, f_0, f_1, ...,
f_d)\)</span> is its <span class="math">\(f\)</span>-vector (with <span class="math">\(f_{-1} = 1\)</span>, representing the
empy simplex), then the <span class="math">\(h\)</span>-vector <span class="math">\((h_0, h_1, ..., h_d,
h_{d+1})\)</span> is defined by</p>
<div class="math">
\[\sum_{i=0}^{d+1} h_i x^{d+1-i} = \sum_{i=0}^{d+1} f_{i-1} (x-1)^{d+1-i}.\]</div>
<p>Alternatively,</p>
<div class="math">
\[h_j = \sum_{i=-1}^{j-1} (-1)^{j-i-1} \binom{d-i}{j-i-1} f_i.\]</div>
<p>EXAMPLES:</p>
<p>The <span class="math">\(f\)</span>- and <span class="math">\(h\)</span>-vectors of the boundary of an octahedron are
computed in Wikipedia&#8217;s page on simplicial complexes,
<a class="reference external" href="http://en.wikipedia.org/wiki/Simplicial_complex">http://en.wikipedia.org/wiki/Simplicial_complex</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">square</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">octa</span> <span class="o">=</span> <span class="n">square</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">S0</span><span class="p">)</span> <span class="c"># boundary of an octahedron</span>
<span class="gp">sage: </span><span class="n">octa</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 6, 12, 8]</span>
<span class="gp">sage: </span><span class="n">octa</span><span class="o">.</span><span class="n">h_vector</span><span class="p">()</span>
<span class="go">[1, 3, 3, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.is_cohen_macaulay">
<tt class="descname">is_cohen_macaulay</tt><big>(</big><em>ncpus=0</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.is_cohen_macaulay" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns True if <tt class="docutils literal"><span class="pre">self</span></tt> is Cohen-Macaulay, i.e., if
<span class="math">\(\tilde{H}_i(\operatorname{lk}_\Delta(F);\ZZ) = 0\)</span> for all
<span class="math">\(F \in \Delta\)</span> and <span class="math">\(i &lt; \operatorname{dim}\operatorname{lk}_\Delta(F)\)</span>.
Here, <span class="math">\(\Delta\)</span> is <tt class="docutils literal"><span class="pre">self</span></tt>, and <span class="math">\(\operatorname{lk}\)</span> denotes the
link operator on <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ncpus</span></tt> &#8211; (default: 0) number of cpus used for the
computation. If this is 0, determine the number of cpus
automatically based on the hardware being used.</li>
</ul>
<p>For finite simplicial complexes, this is equivalent to the
statement that the Stanley-Reisner ring of <tt class="docutils literal"><span class="pre">self</span></tt> is
Cohen-Macaulay.</p>
<p>EXAMPLES:</p>
<p>Spheres are Cohen-Macaulay:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">is_cohen_macaulay</span><span class="p">(</span><span class="n">ncpus</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The following example is taken from Bruns, Herzog - Cohen-Macaulay
rings, Figure 5.3:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">is_cohen_macaulay</span><span class="p">(</span><span class="n">ncpus</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.is_connected">
<tt class="descname">is_connected</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.is_connected" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if and only if <tt class="docutils literal"><span class="pre">self</span></tt> is connected.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This may give the wrong answer if the simplicial complex
was constructed with <tt class="docutils literal"><span class="pre">maximality_check</span></tt> set to <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">V</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3) and facets {(0, 1, 2), (3,)}</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">ChessboardComplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.is_flag_complex">
<tt class="descname">is_flag_complex</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.is_flag_complex" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if and only if <tt class="docutils literal"><span class="pre">self</span></tt> is a flag complex.</p>
<p>A flag complex is a simplicial complex that is the largest simplicial
complex on its 1-skeleton. Thus a flag complex is the clique complex
of its graph.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">clique_complex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3, 4) and facets {(0, 1, 4), (0, 1, 2, 3)}</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">is_flag_complex</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">ChessboardComplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">is_flag_complex</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.is_immutable">
<tt class="descname">is_immutable</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.is_immutable" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if immutable.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">is_immutable</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">is_immutable</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.is_isomorphic">
<tt class="descname">is_isomorphic</tt><big>(</big><em>other</em>, <em>certify=False</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.is_isomorphic" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Check whether two simplicial complexes are isomorphic.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">certify</span></tt> &#8211; if <tt class="docutils literal"><span class="pre">True</span></tt>, then output is <tt class="docutils literal"><span class="pre">(a,b)</span></tt>, where <tt class="docutils literal"><span class="pre">a</span></tt>
is a boolean and <tt class="docutils literal"><span class="pre">b</span></tt> is either a map or <tt class="docutils literal"><span class="pre">None</span></tt>.</li>
</ul>
<p>This is done by creating two graphs and checking whether they
are isomorphic.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Z1</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Z2</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">],[</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;c&#39;</span><span class="p">],[</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">,</span><span class="s">&#39;e&#39;</span><span class="p">],[</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="s">&#39;f&#39;</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Z3</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Z1</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">Z2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Z1</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">Z2</span><span class="p">,</span> <span class="n">certify</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(True, {0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39;, 3: &#39;d&#39;, 4: &#39;e&#39;, 5: &#39;f&#39;})</span>
<span class="gp">sage: </span><span class="n">Z3</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">Z2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.is_mutable">
<tt class="descname">is_mutable</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.is_mutable" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if mutable.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span> <span class="n">is_mutable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span> <span class="n">is_mutable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S3</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.is_pseudomanifold">
<tt class="descname">is_pseudomanifold</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.is_pseudomanifold" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return True if self is a pseudomanifold.</p>
<p>A pseudomanifold is a simplicial complex with the following properties:</p>
<ul>
<li><p class="first">it is pure of some dimension <span class="math">\(d\)</span> (all of its facets are <span class="math">\(d\)</span>-dimensional)</p>
</li>
<li><p class="first">every <span class="math">\((d-1)\)</span>-dimensional simplex is the face of exactly two facets</p>
</li>
<li><p class="first">for every two facets <span class="math">\(S\)</span> and <span class="math">\(T\)</span>, there is a sequence of
facets</p>
<div class="math">
\[S = f_0, f_1, ..., f_n = T\]</div>
<p>such that for each <span class="math">\(i\)</span>, <span class="math">\(f_i\)</span> and <span class="math">\(f_{i-1}\)</span> intersect in a
<span class="math">\((d-1)\)</span>-simplex.</p>
</li>
</ul>
<p>By convention, <span class="math">\(S^0\)</span> is the only 0-dimensional pseudomanifold.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">is_pseudomanifold</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S0</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S0</span><span class="p">))</span><span class="o">.</span><span class="n">is_pseudomanifold</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S1</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S1</span><span class="p">))</span><span class="o">.</span><span class="n">is_pseudomanifold</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S1</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S2</span><span class="p">))</span><span class="o">.</span><span class="n">is_pseudomanifold</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">is_pseudomanifold</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">suspension</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">is_pseudomanifold</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.is_pure">
<tt class="descname">is_pure</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.is_pure" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> iff this simplicial complex is pure.</p>
<p>A simplicial complex is pure if and only if all of its maximal faces
have the same dimension.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This may give the wrong answer if the simplicial complex
was constructed with <tt class="docutils literal"><span class="pre">maximality_check</span></tt> set to <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">U</span><span class="o">.</span><span class="n">is_pure</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">is_pure</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Demonstration of the warning:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">maximality_check</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">is_pure</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.join">
<tt class="descname">join</tt><big>(</big><em>right</em>, <em>rename_vertices=True</em>, <em>is_mutable=True</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.join" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The join of this simplicial complex with another one.</p>
<p>The join of two simplicial complexes <span class="math">\(S\)</span> and <span class="math">\(T\)</span> is the
simplicial complex <span class="math">\(S*T\)</span> with simplices of the form <span class="math">\([v_0,
..., v_k, w_0, ..., w_n]\)</span> for all simplices <span class="math">\([v_0, ..., v_k]\)</span> in
<span class="math">\(S\)</span> and <span class="math">\([w_0, ..., w_n]\)</span> in <span class="math">\(T\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>right</strong> &#8211; the other simplicial complex (the right-hand factor)</li>
<li><strong>rename_vertices</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; If this is True, the vertices in the
join will be renamed by the formula: vertex &#8220;v&#8221; in the
left-hand factor &#8211;&gt; vertex &#8220;Lv&#8221; in the join, vertex &#8220;w&#8221; in
the right-hand factor &#8211;&gt; vertex &#8220;Rw&#8221; in the join.  If this
is false, this tries to construct the join without renaming
the vertices; this will cause problems if the two factors
have any vertices with names in common.</li>
<li><strong>is_mutable</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; Determines if the output is mutable</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">Simplicial complex with vertex set (&#39;L0&#39;, &#39;L1&#39;, &#39;R2&#39;, &#39;R3&#39;) and 4 facets</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">rename_vertices</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3) and facets {(1, 3), (1, 2), (0, 2), (0, 3)}</span>
</pre></div>
</div>
<p>The notation &#8216;*&#8217; may be used, as well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">*</span> <span class="n">S</span>
<span class="go">Simplicial complex with vertex set (&#39;L0&#39;, &#39;L1&#39;, &#39;R0&#39;, &#39;R1&#39;) and 4 facets</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">*</span> <span class="n">S</span> <span class="o">*</span> <span class="n">S</span> <span class="o">*</span> <span class="n">S</span> <span class="o">*</span> <span class="n">S</span> <span class="o">*</span> <span class="n">S</span> <span class="o">*</span> <span class="n">S</span> <span class="o">*</span> <span class="n">S</span>
<span class="go">Simplicial complex with 16 vertices and 256 facets</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.link">
<tt class="descname">link</tt><big>(</big><em>simplex</em>, <em>is_mutable=True</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.link" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The link of a simplex in this simplicial complex.</p>
<p>The link of a simplex <span class="math">\(F\)</span> is the simplicial complex formed by
all simplices <span class="math">\(G\)</span> which are disjoint from <span class="math">\(F\)</span> but for which <span class="math">\(F
\cup G\)</span> is a simplex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>simplex</strong> &#8211; a simplex in this simplicial complex.</li>
<li><strong>is_mutable</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; Determines if the output is mutable</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">link</span><span class="p">(</span><span class="n">Simplex</span><span class="p">([</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">Simplicial complex with vertex set (1, 2) and facets {(1, 2)}</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">link</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">Simplicial complex with vertex set (0, 3) and facets {(3,), (0,)}</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">link</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">Simplicial complex with vertex set (0, 2, 3) and facets {(0, 2, 3)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.maximal_faces">
<tt class="descname">maximal_faces</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.maximal_faces" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The maximal faces (a.k.a. facets) of this simplicial complex.</p>
<p>This just returns the set of facets used in defining the
simplicial complex, so if the simplicial complex was defined
with no maximality checking, none is done here, either.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">maximal_faces</span><span class="p">()</span>
<span class="go">{(1, 4), (0, 2)}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">facets</span></tt> is a synonym for <tt class="docutils literal"><span class="pre">maximal_faces</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">facets</span><span class="p">()</span>
<span class="go">{(0, 1, 2)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.minimal_nonfaces">
<tt class="descname">minimal_nonfaces</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.minimal_nonfaces" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set consisting of the minimal subsets of the vertex set of
this simplicial complex which do not form faces.</p>
<p>Algorithm: first take the complement (within the vertex set)
of each facet, obtaining a set <span class="math">\((f_1, f_2, ...)\)</span> of simplices.
Now form the set of all simplices of the form <span class="math">\((v_1, v_2,
...)\)</span> where vertex <span class="math">\(v_i\)</span> is in face <span class="math">\(f_i\)</span>.  This set will
contain the minimal nonfaces and may contain some non-minimal
nonfaces also, so loop through the set to find the minimal
ones.  (The last two steps are taken care of by the
<tt class="docutils literal"><span class="pre">_transpose_simplices</span></tt> routine.)</p>
<p>This is used in computing the
<a class="reference internal" href="#sage.homology.simplicial_complex.SimplicialComplex.stanley_reisner_ring" title="sage.homology.simplicial_complex.SimplicialComplex.stanley_reisner_ring"><tt class="xref py py-meth docutils literal"><span class="pre">Stanley-Reisner</span> <span class="pre">ring</span></tt></a> and the
<a class="reference internal" href="#sage.homology.simplicial_complex.SimplicialComplex.alexander_dual" title="sage.homology.simplicial_complex.SimplicialComplex.alexander_dual"><tt class="xref py py-meth docutils literal"><span class="pre">Alexander</span> <span class="pre">dual</span></tt></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">minimal_nonfaces</span><span class="p">()</span>
<span class="go">{(2, 3)}</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">minimal_nonfaces</span><span class="p">()</span>
<span class="go">{(1, 3), (0, 2)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.n_faces">
<tt class="descname">n_faces</tt><big>(</big><em>n</em>, <em>subcomplex=None</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.n_faces" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The set of simplices of dimension <tt class="docutils literal"><span class="pre">n</span></tt> of this simplicial complex.
If the optional argument <tt class="docutils literal"><span class="pre">subcomplex</span></tt> is present, then
return the <tt class="docutils literal"><span class="pre">n</span></tt>-dimensional faces which are <em>not</em> in the
subcomplex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> &#8211; non-negative integer</li>
<li><strong>subcomplex</strong> (optional, default <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; a subcomplex of this simplicial complex.
Return <tt class="docutils literal"><span class="pre">n</span></tt>-dimensional faces which are not in this
subcomplex.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">subsets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Z</span>
<span class="go">Simplicial complex with vertex set (1, 2, 3, 4) and facets {(1, 2, 3, 4)}</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">n_faces</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">{(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)}</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">n_faces</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">subcomplex</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
<span class="go">{(1, 2, 4), (1, 3, 4)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.n_skeleton">
<tt class="descname">n_skeleton</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.n_skeleton" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The <span class="math">\(n\)</span>-skeleton of this simplicial complex.</p>
<p>The <span class="math">\(n\)</span>-skeleton of a simplicial complex is obtained by discarding
all of the simplices in dimensions larger than <span class="math">\(n\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> &#8211; non-negative integer</td>
</tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3) and facets {(2, 3), (0, 2), (1, 3), (1, 2), (0, 3), (0, 1)}</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3) and facets {(0, 2, 3), (1, 2, 3), (0, 1)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.product">
<tt class="descname">product</tt><big>(</big><em>right</em>, <em>rename_vertices=True</em>, <em>is_mutable=True</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.product" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The product of this simplicial complex with another one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>right</strong> &#8211; the other simplicial complex (the right-hand
factor)</li>
<li><strong>rename_vertices</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; If this is False, then the vertices in
the product are the set of ordered pairs <span class="math">\((v,w)\)</span> where <span class="math">\(v\)</span>
is a vertex in <tt class="docutils literal"><span class="pre">self</span></tt> and <span class="math">\(w\)</span> is a vertex in
<tt class="docutils literal"><span class="pre">right</span></tt>. If this is <tt class="docutils literal"><span class="pre">True</span></tt>, then the vertices are renamed
as &#8220;LvRw&#8221; (e.g., the vertex (1,2) would become &#8220;L1R2&#8221;).
This is useful if you want to define the Stanley-Reisner
ring of the complex: vertex names like (0,1) are not
suitable for that, while vertex names like &#8220;L0R1&#8221; are.</li>
<li><strong>is_mutable</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; Determines if the output is mutable</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The vertices in the product will be the set of ordered pairs
<span class="math">\((v,w)\)</span> where <span class="math">\(v\)</span> is a vertex in self and <span class="math">\(w\)</span> is a vertex in
right.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If <tt class="docutils literal"><span class="pre">X</span></tt> and <tt class="docutils literal"><span class="pre">Y</span></tt> are simplicial complexes, then <tt class="docutils literal"><span class="pre">X*Y</span></tt>
returns their join, not their product.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span> <span class="c"># circle</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>   <span class="c"># edge</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>  <span class="c"># cylinder</span>
<span class="go">(&#39;L0R0&#39;, &#39;L0R1&#39;, &#39;L1R0&#39;, &#39;L1R1&#39;, &#39;L2R0&#39;, &#39;L2R1&#39;)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">rename_vertices</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">((0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1))</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>  <span class="c"># torus</span>
<span class="gp">sage: </span><span class="n">T</span>
<span class="go">Simplicial complex with 9 vertices and 18 facets</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: Z x Z, 2: Z}</span>
</pre></div>
</div>
<p>These can get large pretty quickly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Torus</span><span class="p">();</span> <span class="n">T</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3, 4, 5, 6) and 14 facets</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">();</span> <span class="n">K</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3, 4, 5, 6, 7) and 16 facets</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>      <span class="c"># long time: 5 or 6 seconds</span>
<span class="go">Simplicial complex with 56 vertices and 1344 facets</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.remove_face">
<tt class="descname">remove_face</tt><big>(</big><em>face</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.remove_face" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Remove a face from this simplicial complex and return the
resulting simplicial complex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>face</strong> &#8211; a face of the simplicial complex</td>
</tr>
</tbody>
</table>
<p>This <em>changes</em> the simplicial complex.</p>
<p>ALGORITHM:</p>
<p>The facets of the new simplicial complex are
the facets of the original complex not containing <tt class="docutils literal"><span class="pre">face</span></tt>,
together with those of <tt class="docutils literal"><span class="pre">link(face)*boundary(face)</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([</span><span class="n">S</span><span class="p">]);</span> <span class="n">Z</span>
<span class="go">Simplicial complex with vertex set (1, 2, 3, 4) and facets {(1, 2, 3, 4)}</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">remove_face</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Z</span>
<span class="go">Simplicial complex with vertex set (1, 2, 3, 4) and facets {(1, 3, 4), (2, 3, 4)}</span>

<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3) and facets {(0, 1, 2), (2, 3)}</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">remove_face</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">S</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3) and facets {(1, 2), (2, 3), (0, 2), (0, 1)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.set_immutable">
<tt class="descname">set_immutable</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.set_immutable" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Make this simplicial complex immutable.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.stanley_reisner_ring">
<tt class="descname">stanley_reisner_ring</tt><big>(</big><em>base_ring=Integer Ring</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.stanley_reisner_ring" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The Stanley-Reisner ring of this simplicial complex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>base_ring</strong> (optional, default <tt class="docutils literal"><span class="pre">ZZ</span></tt>) &#8211; a commutative ring</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a quotient of a polynomial algebra with coefficients
in <tt class="docutils literal"><span class="pre">base_ring</span></tt>, with one generator for each vertex in the
simplicial complex, by the ideal generated by the products
of those vertices which do not form faces in it.</td>
</tr>
</tbody>
</table>
<p>Thus the ideal is generated by the products corresponding to
the minimal nonfaces of the simplicial complex.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>This may be quite slow!</p>
<p>Also, this may behave badly if the vertices have the
&#8216;wrong&#8217; names. To avoid this, define the simplicial complex
at the start with the flag <tt class="docutils literal"><span class="pre">name_check</span></tt> set to <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p class="last">More precisely, this is a quotient of a polynomial ring
with one generator for each vertex.  If the name of a
vertex is a non-negative integer, then the corresponding
polynomial generator is named <tt class="docutils literal"><span class="pre">'x'</span></tt> followed by that integer
(e.g., <tt class="docutils literal"><span class="pre">'x2'</span></tt>, <tt class="docutils literal"><span class="pre">'x3'</span></tt>, <tt class="docutils literal"><span class="pre">'x5'</span></tt>, ...).  Otherwise, the
polynomial generators are given the same names as the vertices.
Thus if the vertex set is <tt class="docutils literal"><span class="pre">(2,</span> <span class="pre">'x2')</span></tt>, there will be problems.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">stanley_reisner_ring</span><span class="p">()</span>
<span class="go">Quotient of Multivariate Polynomial Ring in x0, x1, x2, x3 over Integer Ring by the ideal (x1*x3, x0*x2)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]);</span> <span class="n">Y</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3, 4) and facets {(0, 1, 2, 3, 4)}</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">add_face</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">stanley_reisner_ring</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Multivariate Polynomial Ring in x0, x1, x2, x3, x4 over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.suspension">
<tt class="descname">suspension</tt><big>(</big><em>n=1</em>, <em>is_mutable=True</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.suspension" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The suspension of this simplicial complex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> (<em>optional, default 1</em>) &#8211; positive integer &#8211; suspend this many times.</li>
<li><strong>is_mutable</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; Determines if the output is mutable</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The suspension is the simplicial complex formed by adding two
new vertices <span class="math">\(S_0\)</span> and <span class="math">\(S_1\)</span> and simplices of the form <span class="math">\([S_0,
v_0, ..., v_k]\)</span> and <span class="math">\([S_1, v_0, ..., v_k]\)</span> for every simplex
<span class="math">\([v_0, ..., v_k]\)</span> in the original simplicial complex.  That
is, the suspension is the join of the original complex with a
two-point simplicial complex.</p>
<p>If the simplicial complex <span class="math">\(M\)</span> happens to be a pseudomanifold
(see <a class="reference internal" href="#sage.homology.simplicial_complex.SimplicialComplex.is_pseudomanifold" title="sage.homology.simplicial_complex.SimplicialComplex.is_pseudomanifold"><tt class="xref py py-meth docutils literal"><span class="pre">is_pseudomanifold()</span></tt></a>), then this instead constructs
Datta&#8217;s one-point suspension (see p. 434 in the cited
article): choose a vertex <span class="math">\(u\)</span> in <span class="math">\(M\)</span> and choose a new vertex
<span class="math">\(w\)</span> to add.  Denote the join of simplices by &#8220;<span class="math">\(*\)</span>&#8221;.  The
facets in the one-point suspension are of the two forms</p>
<ul class="simple">
<li><span class="math">\(u * \alpha\)</span> where <span class="math">\(\alpha\)</span> is a facet of <span class="math">\(M\)</span> not containing
<span class="math">\(u\)</span></li>
<li><span class="math">\(w * \beta\)</span> where <span class="math">\(\beta\)</span> is any facet of <span class="math">\(M\)</span>.</li>
</ul>
<p>REFERENCES:</p>
<ul class="simple">
<li>Basudeb Datta, &#8220;Minimal triangulations of manifolds&#8221;,
J. Indian Inst. Sci. 87 (2007), no. 4, 429-449.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">suspension</span><span class="p">()</span> <span class="o">==</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">S0</span><span class="o">.</span><span class="n">suspension</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c"># the 3-sphere</span>
<span class="gp">sage: </span><span class="n">S3</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: 0, 2: 0, 3: Z}</span>
</pre></div>
</div>
<p>For pseudomanifolds, the complex constructed here will be
smaller than that obtained by taking the join with the
0-sphere: the join adds two vertices, while this construction
only adds one.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">S0</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>      <span class="c"># 9 vertices</span>
<span class="go">(&#39;L0&#39;, &#39;L1&#39;, &#39;L2&#39;, &#39;L3&#39;, &#39;L4&#39;, &#39;L5&#39;, &#39;L6&#39;, &#39;R0&#39;, &#39;R1&#39;)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">suspension</span><span class="p">()</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>  <span class="c"># 8 vertices</span>
<span class="go">(0, 1, 2, 3, 4, 5, 6, 7)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.vertices">
<tt class="descname">vertices</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.vertices" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The vertex set of this simplicial complex.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">S</span>
<span class="go">Simplicial complex with 16 vertices and 15 facets</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)</span>
</pre></div>
</div>
<p>Note that this actually returns a simplex:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
<span class="go">&lt;class &#39;sage.homology.simplicial_complex.Simplex&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_complex.SimplicialComplex.wedge">
<tt class="descname">wedge</tt><big>(</big><em>right</em>, <em>rename_vertices=True</em>, <em>is_mutable=True</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.SimplicialComplex.wedge" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The wedge (one-point union) of this simplicial complex with
another one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>right</strong> &#8211; the other simplicial complex (the right-hand factor)</li>
<li><strong>rename_vertices</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; If this is <tt class="docutils literal"><span class="pre">True</span></tt>, the vertices in the
wedge will be renamed by the formula: first vertex in each
are glued together and called &#8220;0&#8221;.  Otherwise, each vertex
&#8220;v&#8221; in the left-hand factor &#8211;&gt; vertex &#8220;Lv&#8221; in the wedge,
vertex &#8220;w&#8221; in the right-hand factor &#8211;&gt; vertex &#8220;Rw&#8221; in the
wedge.  If this is <tt class="docutils literal"><span class="pre">False</span></tt>, this tries to construct the wedge
without renaming the vertices; this will cause problems if
the two factors have any vertices with names in common.</li>
<li><strong>is_mutable</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; Determines if the output is mutable</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This operation is not well-defined if <tt class="docutils literal"><span class="pre">self</span></tt> or
<tt class="docutils literal"><span class="pre">other</span></tt> is not path-connected.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: Z, 2: Z}</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.homology.simplicial_complex.lattice_paths">
<tt class="descclassname">sage.homology.simplicial_complex.</tt><tt class="descname">lattice_paths</tt><big>(</big><em>t1</em>, <em>t2</em>, <em>length=None</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.lattice_paths" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Given lists (or tuples or ...) <tt class="docutils literal"><span class="pre">t1</span></tt> and <tt class="docutils literal"><span class="pre">t2</span></tt>, think of them as
labelings for vertices: <tt class="docutils literal"><span class="pre">t1</span></tt> labeling points on the x-axis,
<tt class="docutils literal"><span class="pre">t2</span></tt> labeling points on the y-axis, both increasing.  Return the
list of rectilinear paths along the grid defined by these points
in the plane, starting from <tt class="docutils literal"><span class="pre">(t1[0],</span> <span class="pre">t2[0])</span></tt>, ending at
<tt class="docutils literal"><span class="pre">(t1[last],</span> <span class="pre">t2[last])</span></tt>, and at each grid point, going either
right or up.  See the examples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t1</strong> (<em>tuple, list, other iterable</em>) &#8211; labeling for vertices</li>
<li><strong>t2</strong> (<em>tuple, list, other iterable</em>) &#8211; labeling for vertices</li>
<li><strong>length</strong> (integer or <tt class="docutils literal"><span class="pre">None</span></tt>; optional, default <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; if not <tt class="docutils literal"><span class="pre">None</span></tt>, then an integer, the length of the desired
path.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of lists of vertices making up the paths as described above</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of lists</p>
</td>
</tr>
</tbody>
</table>
<p>This is used when triangulating the product of simplices.  The
optional argument <tt class="docutils literal"><span class="pre">length</span></tt> is used for <span class="math">\(\Delta\)</span>-complexes, to
specify all simplices in a product: in the triangulation of a
product of two simplices, there is a <span class="math">\(d\)</span>-simplex for every path of
length <span class="math">\(d+1\)</span> in the lattice.  The path must start at the bottom
left and end at the upper right, and it must use at least one
point in each row and in each column, so if <tt class="docutils literal"><span class="pre">length</span></tt> is too
small, there will be no paths.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_complex</span> <span class="kn">import</span> <span class="n">lattice_paths</span>
<span class="gp">sage: </span><span class="n">lattice_paths</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[[(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)],</span>
<span class="go"> [(0, 0), (0, 1), (1, 1), (1, 2), (2, 2)],</span>
<span class="go"> [(0, 0), (1, 0), (1, 1), (1, 2), (2, 2)],</span>
<span class="go"> [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)],</span>
<span class="go"> [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)],</span>
<span class="go"> [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]]</span>
<span class="gp">sage: </span><span class="n">lattice_paths</span><span class="p">((</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">[[(&#39;a&#39;, 0), (&#39;a&#39;, 3), (&#39;a&#39;, 5), (&#39;b&#39;, 5), (&#39;c&#39;, 5)],</span>
<span class="go"> [(&#39;a&#39;, 0), (&#39;a&#39;, 3), (&#39;b&#39;, 3), (&#39;b&#39;, 5), (&#39;c&#39;, 5)],</span>
<span class="go"> [(&#39;a&#39;, 0), (&#39;b&#39;, 0), (&#39;b&#39;, 3), (&#39;b&#39;, 5), (&#39;c&#39;, 5)],</span>
<span class="go"> [(&#39;a&#39;, 0), (&#39;a&#39;, 3), (&#39;b&#39;, 3), (&#39;c&#39;, 3), (&#39;c&#39;, 5)],</span>
<span class="go"> [(&#39;a&#39;, 0), (&#39;b&#39;, 0), (&#39;b&#39;, 3), (&#39;c&#39;, 3), (&#39;c&#39;, 5)],</span>
<span class="go"> [(&#39;a&#39;, 0), (&#39;b&#39;, 0), (&#39;c&#39;, 0), (&#39;c&#39;, 3), (&#39;c&#39;, 5)]]</span>
<span class="gp">sage: </span><span class="n">lattice_paths</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">length</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">lattice_paths</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">length</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[[(0, 0), (1, 1), (2, 2)]]</span>
<span class="gp">sage: </span><span class="n">lattice_paths</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">length</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">[[(0, 0), (1, 1), (1, 2), (2, 2)],</span>
<span class="go"> [(0, 0), (0, 1), (1, 2), (2, 2)],</span>
<span class="go"> [(0, 0), (1, 1), (2, 1), (2, 2)],</span>
<span class="go"> [(0, 0), (1, 0), (2, 1), (2, 2)],</span>
<span class="go"> [(0, 0), (0, 1), (1, 1), (2, 2)],</span>
<span class="go"> [(0, 0), (1, 0), (1, 1), (2, 2)]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.homology.simplicial_complex.rename_vertex">
<tt class="descclassname">sage.homology.simplicial_complex.</tt><tt class="descname">rename_vertex</tt><big>(</big><em>n</em>, <em>keep</em>, <em>left=True</em><big>)</big><a class="headerlink" href="#sage.homology.simplicial_complex.rename_vertex" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Rename a vertex: the vertices from the list <tt class="docutils literal"><span class="pre">keep</span></tt> get
relabeled 0, 1, 2, ..., in order.  Any other vertex (e.g. 4) gets
renamed to by prepending an &#8216;L&#8217; or an &#8216;R&#8217; (thus to either &#8216;L4&#8217; or
&#8216;R4&#8217;), depending on whether the argument left is <tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> &#8211; a &#8216;vertex&#8217;: either an integer or a string</li>
<li><strong>keep</strong> &#8211; a list of three vertices</li>
<li><strong>left</strong> (boolean; optional, default <tt class="docutils literal"><span class="pre">True</span></tt>) &#8211; if <tt class="docutils literal"><span class="pre">True</span></tt>, rename for use in left factor</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This is used by the <a class="reference internal" href="#sage.homology.simplicial_complex.SimplicialComplex.connected_sum" title="sage.homology.simplicial_complex.SimplicialComplex.connected_sum"><tt class="xref py py-meth docutils literal"><span class="pre">connected_sum()</span></tt></a> method for
simplicial complexes.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_complex</span> <span class="kn">import</span> <span class="n">rename_vertex</span>
<span class="gp">sage: </span><span class="n">rename_vertex</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">rename_vertex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">&#39;L3&#39;</span>
<span class="gp">sage: </span><span class="n">rename_vertex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">left</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">&#39;R3&#39;</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="chain_complex_homspace.html"
                                  title="previous chapter">Homspaces between chain complexes</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="simplicial_complex_morphism.html"
                                  title="next chapter">Morphisms of simplicial complexes</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/homology/simplicial_complex.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="simplicial_complex_morphism.html" title="Morphisms of simplicial complexes"
             >next</a> |</li>
        <li class="right" >
          <a href="chain_complex_homspace.html" title="Homspaces between chain complexes"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Cell complexes and their homology</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2015, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>