<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Generic cell complexes &mdash; Sage Reference Manual v7.0: Cell complexes and their homology</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v7.0: Cell complexes and their homology" href="../../index.html" />
    <link rel="next" title="Koszul Complexes" href="koszul_complex.html" />
    <link rel="prev" title="Finite cubical complexes" href="cubical_complex.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="koszul_complex.html" title="Koszul Complexes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cubical_complex.html" title="Finite cubical complexes"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Cell complexes and their homology</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="generic-cell-complexes">
<span id="sage-homology-cell-complex"></span><h1>Generic cell complexes<a class="headerlink" href="#generic-cell-complexes" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.homology.cell_complex"></span><p>AUTHORS:</p>
<ul class="simple">
<li>John H. Palmieri (2009-08)</li>
</ul>
<p>This module defines a class of abstract finite cell complexes.  This
is meant as a base class from which other classes (like
<a class="reference internal" href="simplicial_complex.html#sage.homology.simplicial_complex.SimplicialComplex" title="sage.homology.simplicial_complex.SimplicialComplex"><tt class="xref py py-class docutils literal"><span class="pre">SimplicialComplex</span></tt></a>,
<a class="reference internal" href="cubical_complex.html#sage.homology.cubical_complex.CubicalComplex" title="sage.homology.cubical_complex.CubicalComplex"><tt class="xref py py-class docutils literal"><span class="pre">CubicalComplex</span></tt></a>, and
<a class="reference internal" href="delta_complex.html#sage.homology.delta_complex.DeltaComplex" title="sage.homology.delta_complex.DeltaComplex"><tt class="xref py py-class docutils literal"><span class="pre">DeltaComplex</span></tt></a>) should derive.  As
such, most of its properties are not implemented.  It is meant for use
by developers producing new classes, not casual users.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Keywords for <a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.chain_complex" title="sage.homology.cell_complex.GenericCellComplex.chain_complex"><tt class="xref py py-meth docutils literal"><span class="pre">chain_complex()</span></tt></a>,
<a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.homology" title="sage.homology.cell_complex.GenericCellComplex.homology"><tt class="xref py py-meth docutils literal"><span class="pre">homology()</span></tt></a>, etc.: any keywords given to
the <a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.homology" title="sage.homology.cell_complex.GenericCellComplex.homology"><tt class="xref py py-meth docutils literal"><span class="pre">homology()</span></tt></a> method get passed on to
the <a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.chain_complex" title="sage.homology.cell_complex.GenericCellComplex.chain_complex"><tt class="xref py py-meth docutils literal"><span class="pre">chain_complex()</span></tt></a> method and also to
the constructor for chain complexes in
<a class="reference internal" href="chain_complex.html#sage.homology.chain_complex.ChainComplex" title="sage.homology.chain_complex.ChainComplex"><tt class="xref py py-class docutils literal"><span class="pre">sage.homology.chain_complex.ChainComplex_class</span></tt></a>,
as well as its associated
<a class="reference internal" href="chain_complex.html#sage.homology.chain_complex.ChainComplex_class.homology" title="sage.homology.chain_complex.ChainComplex_class.homology"><tt class="xref py py-meth docutils literal"><span class="pre">homology()</span></tt></a> method.
This means that those keywords should have consistent meaning in
all of those situations.  It also means that it is easy to
implement new keywords: for example, if you implement a new
keyword for the
<a class="reference internal" href="chain_complex.html#sage.homology.chain_complex.ChainComplex_class.homology" title="sage.homology.chain_complex.ChainComplex_class.homology"><tt class="xref py py-meth docutils literal"><span class="pre">sage.homology.chain_complex.ChainComplex_class.homology()</span></tt></a> method,
then it will be automatically accessible through the
<a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.homology" title="sage.homology.cell_complex.GenericCellComplex.homology"><tt class="xref py py-meth docutils literal"><span class="pre">homology()</span></tt></a> method for cell complexes &#8211;
just make sure it gets documented.</p>
</div>
<dl class="class">
<dt id="sage.homology.cell_complex.Chains">
<em class="property">class </em><tt class="descclassname">sage.homology.cell_complex.</tt><tt class="descname">Chains</tt><big>(</big><em>n_cells</em>, <em>base_ring=None</em>, <em>cochains=False</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.Chains" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../combinat/sage/combinat/free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="(in Sage Reference Manual: Combinatorics v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></tt></a></p>
<p>Class for the free module of chains and/or cochains in a given
degree.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n_cells</span></tt> &#8211; tuple of <span class="math">\(n\)</span>-cells, which thus forms a basis for
this module</li>
<li><tt class="docutils literal"><span class="pre">base_ring</span></tt> &#8211; optional (default <span class="math">\(\ZZ\)</span>)</li>
<li><tt class="docutils literal"><span class="pre">cochains</span></tt> &#8211; boolean (optional, default <tt class="docutils literal"><span class="pre">False</span></tt>); if
<tt class="docutils literal"><span class="pre">True</span></tt>, return cochains instead</li>
</ul>
<p>One difference between chains and cochains is notation. In a
simplicial complex, for example, a simplex <tt class="docutils literal"><span class="pre">(0,1,2)</span></tt> is written
as &#8220;(0,1,2)&#8221; in the group of chains but as &#8220;chi_(0,1,2)&#8221; in the
group of cochains.</p>
<p>Also, since the free modules of chains and cochains are dual,
there is a pairing <span class="math">\(\langle c, z \rangle\)</span>, sending a cochain <span class="math">\(c\)</span>
and a chain <span class="math">\(z\)</span> to a scalar.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C_2</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">n_chains</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C_2_co</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">n_chains</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cochains</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">C_2</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="n">Simplex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))]</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">C_2</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="n">Simplex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))]</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">C_2_co</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="n">Simplex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))]</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">C_2_co</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="n">Simplex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">))]</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span>
<span class="gp">sage: </span><span class="n">z</span>
<span class="go">(0, 2) + 2*(1, 3)</span>
<span class="gp">sage: </span><span class="n">c</span>
<span class="go">-2*\chi_(0, 3) + 3*\chi_(1, 3)</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.homology.cell_complex.Chains.Element">
<em class="property">class </em><tt class="descname">Element</tt><big>(</big><em>M</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.Chains.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../combinat/sage/combinat/free_module.html#sage.combinat.free_module.CombinatorialFreeModuleElement" title="(in Sage Reference Manual: Combinatorics v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.free_module.CombinatorialFreeModuleElement</span></tt></a></p>
<p>Create a combinatorial module element. This should never be
called directly, but only through the parent combinatorial
free module&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt> method.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;c&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">B</span><span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">];</span> <span class="n">f</span>
<span class="go">B[&#39;a&#39;] + 3*B[&#39;c&#39;]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">==</span> <span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.homology.cell_complex.Chains.Element.eval">
<tt class="descname">eval</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.Chains.Element.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate this cochain on the chain <tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; a chain for the same cell complex in the
same dimension with the same base ring</li>
</ul>
<p>OUTPUT: scalar</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C_2</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">n_chains</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C_2_co</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">n_chains</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cochains</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">C_2</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="n">Simplex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))]</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">C_2</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="n">Simplex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))]</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">C_2_co</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="n">Simplex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))]</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">C_2_co</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="n">Simplex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">))]</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span>
<span class="gp">sage: </span><span class="n">z</span>
<span class="go">(0, 2) + 2*(1, 3)</span>
<span class="gp">sage: </span><span class="n">c</span>
<span class="go">-2*\chi_(0, 3) + 3*\chi_(1, 3)</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">z</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="c"># z is not a cochain</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">this element is not a cochain</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="c"># can&#39;t evaluate a cochain on a cochain</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">the elements are not compatible</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.homology.cell_complex.GenericCellComplex">
<em class="property">class </em><tt class="descclassname">sage.homology.cell_complex.</tt><tt class="descname">GenericCellComplex</tt><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Basic Structures v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.sage_object.SageObject</span></tt></a></p>
<p>Class of abstract cell complexes.</p>
<p>This is meant to be used by developers to produce new classes, not
by casual users.  Classes which derive from this are
<a class="reference internal" href="simplicial_complex.html#sage.homology.simplicial_complex.SimplicialComplex" title="sage.homology.simplicial_complex.SimplicialComplex"><tt class="xref py py-class docutils literal"><span class="pre">SimplicialComplex</span></tt></a>,
<a class="reference internal" href="delta_complex.html#sage.homology.delta_complex.DeltaComplex" title="sage.homology.delta_complex.DeltaComplex"><tt class="xref py py-class docutils literal"><span class="pre">DeltaComplex</span></tt></a>, and
<a class="reference internal" href="cubical_complex.html#sage.homology.cubical_complex.CubicalComplex" title="sage.homology.cubical_complex.CubicalComplex"><tt class="xref py py-class docutils literal"><span class="pre">CubicalComplex</span></tt></a>.</p>
<p>Most of the methods here are not implemented, but probably should
be implemented in a derived class.  Most of the other methods call
a non-implemented one; their docstrings contain examples from
derived classes in which the various methods have been defined.
For example, <a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.homology" title="sage.homology.cell_complex.GenericCellComplex.homology"><tt class="xref py py-meth docutils literal"><span class="pre">homology()</span></tt></a> calls <a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.chain_complex" title="sage.homology.cell_complex.GenericCellComplex.chain_complex"><tt class="xref py py-meth docutils literal"><span class="pre">chain_complex()</span></tt></a>; the
class <a class="reference internal" href="delta_complex.html#sage.homology.delta_complex.DeltaComplex" title="sage.homology.delta_complex.DeltaComplex"><tt class="xref py py-class docutils literal"><span class="pre">DeltaComplex</span></tt></a>
implements
<a class="reference internal" href="delta_complex.html#sage.homology.delta_complex.DeltaComplex.chain_complex" title="sage.homology.delta_complex.DeltaComplex.chain_complex"><tt class="xref py py-meth docutils literal"><span class="pre">chain_complex()</span></tt></a>,
and so the <a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.homology" title="sage.homology.cell_complex.GenericCellComplex.homology"><tt class="xref py py-meth docutils literal"><span class="pre">homology()</span></tt></a> method here is illustrated with
examples involving <span class="math">\(\Delta\)</span>-complexes.</p>
<p>EXAMPLES:</p>
<p>It&#8217;s hard to give informative examples of the base class, since
essentially nothing is implemented.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.algebraic_topological_model">
<tt class="descname">algebraic_topological_model</tt><big>(</big><em>base_ring=None</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.algebraic_topological_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebraic topological model for this cell complex with
coefficients in <tt class="docutils literal"><span class="pre">base_ring</span></tt>.</p>
<p>The term &#8220;algebraic topological model&#8221; is defined by Pilarczyk
and Réal <a class="reference internal" href="chain_homotopy.html#pr" id="id1">[PR]</a>.</p>
<p>This is implemented for simplicial, cubical, and
<span class="math">\(\Delta\)</span>-complexes, not for arbitrary generic cell complexes.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">base_ring</span></tt> - coefficient ring (optional, default
<tt class="docutils literal"><span class="pre">QQ</span></tt>). Must be a field.</li>
</ul>
<p>Denote by <span class="math">\(C\)</span> the chain complex associated to this cell
complex. The algebraic topological model is a chain complex
<span class="math">\(M\)</span> with zero differential, with the same homology as <span class="math">\(C\)</span>,
along with chain maps <span class="math">\(\pi: C \to M\)</span> and <span class="math">\(\iota: M \to C\)</span>
satisfying <span class="math">\(\iota \pi = 1_M\)</span> and <span class="math">\(\pi \iota\)</span> chain homotopic
to <span class="math">\(1_C\)</span>. The chain homotopy <span class="math">\(\phi\)</span> must satisfy</p>
<ul class="simple">
<li><span class="math">\(\phi \phi = 0\)</span>,</li>
<li><span class="math">\(\pi \phi = 0\)</span>,</li>
<li><span class="math">\(\phi \iota = 0\)</span>.</li>
</ul>
<p>Such a chain homotopy is called a <em>chain contraction</em>.</p>
<p>OUTPUT: a pair consisting of</p>
<ul class="simple">
<li>chain contraction <tt class="docutils literal"><span class="pre">phi</span></tt> associated to <span class="math">\(C\)</span>, <span class="math">\(M\)</span>, <span class="math">\(\pi\)</span>, and
<span class="math">\(\iota\)</span></li>
<li>the chain complex <span class="math">\(M\)</span></li>
</ul>
<p>Note that from the chain contraction <tt class="docutils literal"><span class="pre">phi</span></tt>, one can recover the
chain maps <span class="math">\(\pi\)</span> and <span class="math">\(\iota\)</span> via <tt class="docutils literal"><span class="pre">phi.pi()</span></tt> and
<tt class="docutils literal"><span class="pre">phi.iota()</span></tt>. Then one can recover <span class="math">\(C\)</span> and <span class="math">\(M\)</span> from, for
example, <tt class="docutils literal"><span class="pre">phi.pi().domain()</span></tt> and <tt class="docutils literal"><span class="pre">phi.pi().codomain()</span></tt>,
respectively.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">RP2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">RealProjectivePlane</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">RP2</span><span class="o">.</span><span class="n">algebraic_topological_model</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 1: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 2: Vector space of dimension 1 over Finite Field of size 2}</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">algebraic_topological_model</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: Vector space of dimension 1 over Rational Field,</span>
<span class="go"> 1: Vector space of dimension 2 over Rational Field,</span>
<span class="go"> 2: Vector space of dimension 1 over Rational Field}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.betti">
<tt class="descname">betti</tt><big>(</big><em>dim=None</em>, <em>subcomplex=None</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.betti" title="Permalink to this definition">¶</a></dt>
<dd><p>The Betti numbers of this simplicial complex as a dictionary
(or a single Betti number, if only one dimension is given):
the ith Betti number is the rank of the ith homology group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dim</strong> (integer or list of integers or <tt class="docutils literal"><span class="pre">None</span></tt>; optional,
default <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; If <tt class="docutils literal"><span class="pre">None</span></tt>, then return every Betti number, as
a dictionary with keys the non-negative integers.  If
<tt class="docutils literal"><span class="pre">dim</span></tt> is an integer or list, return the Betti number for
each given dimension.  (Actually, if <tt class="docutils literal"><span class="pre">dim</span></tt> is a list,
return the Betti numbers, as a dictionary, in the range
from <tt class="docutils literal"><span class="pre">min(dim)</span></tt> to <tt class="docutils literal"><span class="pre">max(dim)</span></tt>.  If <tt class="docutils literal"><span class="pre">dim</span></tt> is a number,
return the Betti number in that dimension.)</li>
<li><strong>subcomplex</strong> (optional, default <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; a subcomplex of this cell complex.  Compute
the Betti numbers of the homology relative to this subcomplex.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<p>Build the two-sphere as a three-fold join of a
two-point space with itself:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">betti</span><span class="p">()</span>
<span class="go">{0: 1, 1: 0, 2: 1}</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">betti</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">{1: 0, 2: 1}</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">betti</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Or build the two-sphere as a <span class="math">\(\Delta\)</span>-complex:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">delta_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">betti</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">{1: 0, 2: 1}</span>
</pre></div>
</div>
<p>Or as a cubical complex:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S2c</span> <span class="o">=</span> <span class="n">cubical_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2c</span><span class="o">.</span><span class="n">betti</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.cells">
<tt class="descname">cells</tt><big>(</big><em>subcomplex=None</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>The cells of this cell complex, in the form of a dictionary:
the keys are integers, representing dimension, and the value
associated to an integer <span class="math">\(d\)</span> is the set of <span class="math">\(d\)</span>-cells.  If the
optional argument <tt class="docutils literal"><span class="pre">subcomplex</span></tt> is present, then return only
the faces which are <em>not</em> in the subcomplex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>subcomplex</strong> (<em>optional, default None</em>) &#8211; a subcomplex of this cell complex.  Return
the cells which are not in this subcomplex.</td>
</tr>
</tbody>
</table>
<p>This is not implemented in general; it should be implemented
in any derived class.  When implementing, see the warning in
the <a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.dimension" title="sage.homology.cell_complex.GenericCellComplex.dimension"><tt class="xref py py-meth docutils literal"><span class="pre">dimension()</span></tt></a> method.</p>
<p>This method is used by various other methods, such as
<a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.n_cells" title="sage.homology.cell_complex.GenericCellComplex.n_cells"><tt class="xref py py-meth docutils literal"><span class="pre">n_cells()</span></tt></a> and <a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.f_vector" title="sage.homology.cell_complex.GenericCellComplex.f_vector"><tt class="xref py py-meth docutils literal"><span class="pre">f_vector()</span></tt></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">cells</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.chain_complex">
<tt class="descname">chain_complex</tt><big>(</big><em>**kwds</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.chain_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>This is not implemented for general cell complexes.</p>
<p>Some keywords to possibly implement in a derived class:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">subcomplex</span></tt> &#8211; a subcomplex: compute the relative chain complex</li>
<li><tt class="docutils literal"><span class="pre">augmented</span></tt> &#8211; a bool: whether to return the augmented complex</li>
<li><tt class="docutils literal"><span class="pre">verbose</span></tt> &#8211; a bool: whether to print informational messages as
the chain complex is being computed</li>
<li><tt class="docutils literal"><span class="pre">check_diffs</span></tt> &#8211; a bool: whether to check that the each
composite of two consecutive differentials is zero</li>
<li><tt class="docutils literal"><span class="pre">dimensions</span></tt> &#8211; if <tt class="docutils literal"><span class="pre">None</span></tt>, compute the chain complex in all
dimensions.  If a list or tuple of integers, compute the
chain complex in those dimensions, setting the chain groups
in all other dimensions to zero.</li>
</ul>
<p>Definitely implement the following:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">base_ring</span></tt> &#8211; commutative ring (optional, default ZZ)</li>
<li><tt class="docutils literal"><span class="pre">cochain</span></tt> &#8211; a bool: whether to return the cochain complex</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.cohomology">
<tt class="descname">cohomology</tt><big>(</big><em>dim=None</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.cohomology" title="Permalink to this definition">¶</a></dt>
<dd><p>The reduced cohomology of this cell complex.</p>
<p>The arguments are the same as for the <a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.homology" title="sage.homology.cell_complex.GenericCellComplex.homology"><tt class="xref py py-meth docutils literal"><span class="pre">homology()</span></tt></a> method,
except that <a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.homology" title="sage.homology.cell_complex.GenericCellComplex.homology"><tt class="xref py py-meth docutils literal"><span class="pre">homology()</span></tt></a> accepts a <tt class="docutils literal"><span class="pre">cohomology</span></tt> key
word, while this function does not: <tt class="docutils literal"><span class="pre">cohomology</span></tt> is
automatically true here.  Indeed, this function just calls
<a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.homology" title="sage.homology.cell_complex.GenericCellComplex.homology"><tt class="xref py py-meth docutils literal"><span class="pre">homology()</span></tt></a> with <tt class="docutils literal"><span class="pre">cohomology</span></tt> set to <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dim</strong> &#8211; </li>
<li><strong>base_ring</strong> &#8211; </li>
<li><strong>subcomplex</strong> &#8211; </li>
<li><strong>algorithm</strong> &#8211; </li>
<li><strong>verbose</strong> &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">circle</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">circle</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">circle</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Z</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>   <span class="c"># projective plane</span>
<span class="gp">sage: </span><span class="n">P2</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">C2</span>
<span class="gp">sage: </span><span class="n">P2</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Vector space of dimension 1 over Finite Field of size 2</span>
<span class="gp">sage: </span><span class="n">P2</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">Vector space of dimension 0 over Finite Field of size 3</span>

<span class="gp">sage: </span><span class="n">cubical_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">C2</span>
</pre></div>
</div>
<p>Relative cohomology:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">subcomplex</span><span class="o">=</span><span class="n">U</span><span class="p">)</span>
<span class="go">Z</span>
</pre></div>
</div>
<p>A <span class="math">\(\Delta\)</span>-complex example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s5</span> <span class="o">=</span> <span class="n">delta_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s5</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">))[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">Vector space of dimension 1 over Finite Field of size 7</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.cohomology_ring">
<tt class="descname">cohomology_ring</tt><big>(</big><em>base_ring=None</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.cohomology_ring" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unreduced cohomology with coefficients in
<tt class="docutils literal"><span class="pre">base_ring</span></tt> with a chosen basis.</p>
<p>This is implemented for simplicial, cubical, and
<span class="math">\(\Delta\)</span>-complexes, not for arbitrary generic cell complexes.
The resulting elements are suitable for computing cup
products. For simplicial complexes, they should be suitable
for computing cohomology operations; so far, only mod 2
cohomology operations have been implemented.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">base_ring</span></tt> &#8211; coefficient ring (optional, default
<tt class="docutils literal"><span class="pre">QQ</span></tt>); must be a field</li>
</ul>
<p>The basis elements in dimension <tt class="docutils literal"><span class="pre">dim</span></tt> are named &#8216;h^{dim,i}&#8217;
where <span class="math">\(i\)</span> ranges between 0 and <span class="math">\(r-1\)</span>, if <span class="math">\(r\)</span> is the rank of
the cohomology group.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For all but the smallest complexes, this is likely to be
slower than <a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.cohomology" title="sage.homology.cell_complex.GenericCellComplex.cohomology"><tt class="xref py py-meth docutils literal"><span class="pre">cohomology()</span></tt></a> (with field coefficients),
possibly by several orders of magnitute. This and its
companion <a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.homology_with_basis" title="sage.homology.cell_complex.GenericCellComplex.homology_with_basis"><tt class="xref py py-meth docutils literal"><span class="pre">homology_with_basis()</span></tt></a> carry extra
information which allows computation of cup products, for
example, but because of speed issues, you may only wish to
use these if you need that extra information.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">cohomology_ring</span><span class="p">(</span><span class="n">QQ</span><span class="p">);</span> <span class="n">H</span>
<span class="go">Cohomology ring of Minimal triangulation of the Klein bottle</span>
<span class="go"> over Rational Field</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[h^{0,0}, h^{1,0}]</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">cohomology_ring</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="n">H</span>
<span class="go">Cohomology ring of Minimal triangulation of the Klein bottle</span>
<span class="go"> over Finite Field of size 2</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[h^{0,0}, h^{1,0}, h^{1,1}, h^{2,0}]</span>

<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">delta_complexes</span><span class="o">.</span><span class="n">SurfaceOfGenus</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">cohomology_ring</span><span class="p">(</span><span class="n">QQ</span><span class="p">);</span> <span class="n">H</span>
<span class="go">Cohomology ring of Delta complex with 3 vertices and 29 simplices</span>
<span class="go"> over Rational Field</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[h^{1,0}, h^{1,1}, h^{1,2}, h^{1,3}]</span>

<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span><span class="o">.</span><span class="n">cohomology_ring</span><span class="p">(</span><span class="n">QQ</span><span class="p">);</span> <span class="n">H</span>
<span class="go">Cohomology ring of Minimal triangulation of the torus</span>
<span class="go"> over Rational Field</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span> <span class="n">x</span>
<span class="go">h^{1,0}</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span> <span class="n">y</span>
<span class="go">h^{1,1}</span>
</pre></div>
</div>
<p>You can compute cup products of cohomology classes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">cup_product</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">h^{2,0}</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="c"># alternate notation</span>
<span class="go">h^{2,0}</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">cup_product</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">-h^{2,0}</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">cup_product</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Cohomology operations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">RP2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">RealProjectivePlane</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">RP2</span><span class="o">.</span><span class="n">suspension</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">cohomology_ring</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span> <span class="n">y</span>
<span class="go">h^{2,0}</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">Sq</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">h^{3,0}</span>
</pre></div>
</div>
<p>To compute the cohomology ring, the complex must be
&#8220;immutable&#8221;. This is only relevant for simplicial complexes,
and most simplicial complexes are immutable, but certain
constructions make them mutable. The suspension is one
example, and this is the reason for calling
<tt class="docutils literal"><span class="pre">K.set_immutable()</span></tt> above. Another example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_immutable</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">cohomology_ring</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">This simplicial complex must be immutable. Call set_immutable().</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">cohomology_ring</span><span class="p">()</span>
<span class="go">Cohomology ring of Simplicial complex with 9 vertices and</span>
<span class="go">18 facets over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.dimension">
<tt class="descname">dimension</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimension of this cell complex: the maximum
dimension of its cells.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If the <a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.cells" title="sage.homology.cell_complex.GenericCellComplex.cells"><tt class="xref py py-meth docutils literal"><span class="pre">cells()</span></tt></a> method calls <a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.dimension" title="sage.homology.cell_complex.GenericCellComplex.dimension"><tt class="xref py py-meth docutils literal"><span class="pre">dimension()</span></tt></a>,
then you&#8217;ll get an infinite loop.  So either don&#8217;t use
<a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.dimension" title="sage.homology.cell_complex.GenericCellComplex.dimension"><tt class="xref py py-meth docutils literal"><span class="pre">dimension()</span></tt></a> or override <a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.dimension" title="sage.homology.cell_complex.GenericCellComplex.dimension"><tt class="xref py py-meth docutils literal"><span class="pre">dimension()</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">RandomComplex</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">delta_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">cubical_complexes</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.disjoint_union">
<tt class="descname">disjoint_union</tt><big>(</big><em>right</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.disjoint_union" title="Permalink to this definition">¶</a></dt>
<dd><p>The disjoint union of this simplicial complex with another one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>right</strong> &#8211; the other simplicial complex (the right-hand factor)</td>
</tr>
</tbody>
</table>
<p>Disjoint unions are not implemented for general cell complexes.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">();</span> <span class="n">B</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.euler_characteristic">
<tt class="descname">euler_characteristic</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.euler_characteristic" title="Permalink to this definition">¶</a></dt>
<dd><p>The Euler characteristic of this cell complex: the
alternating sum over <span class="math">\(n \geq 0\)</span> of the number of
<span class="math">\(n\)</span>-cells.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">euler_characteristic</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">delta_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">euler_characteristic</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">cubical_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">euler_characteristic</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.f_vector">
<tt class="descname">f_vector</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.f_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>The <span class="math">\(f\)</span>-vector of this cell complex: a list whose <span class="math">\(n^{th}\)</span>
item is the number of <span class="math">\((n-1)\)</span>-cells.  Note that, like all
lists in Sage, this is indexed starting at 0: the 0th element
in this list is the number of <span class="math">\((-1)\)</span>-cells (which is 1: the
empty cell is the only <span class="math">\((-1)\)</span>-cell).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 8, 24, 16]</span>
<span class="gp">sage: </span><span class="n">delta_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 1, 3, 2]</span>
<span class="gp">sage: </span><span class="n">cubical_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 42, 84, 42]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.face_poset">
<tt class="descname">face_poset</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.face_poset" title="Permalink to this definition">¶</a></dt>
<dd><p>The face poset of this cell complex, the poset of
nonempty cells, ordered by inclusion.</p>
<p>This uses the <a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.cells" title="sage.homology.cell_complex.GenericCellComplex.cells"><tt class="xref py py-meth docutils literal"><span class="pre">cells()</span></tt></a> method, and also assumes that for
each cell <tt class="docutils literal"><span class="pre">f</span></tt>, all of <tt class="docutils literal"><span class="pre">f.faces()</span></tt>, <tt class="docutils literal"><span class="pre">tuple(f)</span></tt>, and
<tt class="docutils literal"><span class="pre">f.dimension()</span></tt> make sense.  (If this is not the case in
some derived class, as happens with <span class="math">\(\Delta\)</span>-complexes, then
override this method.)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span><span class="o">.</span><span class="n">face_poset</span><span class="p">();</span> <span class="n">P</span>
<span class="go">Finite poset containing 7 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[(3,), (2,), (2, 3), (1,), (1, 2), (0,), (0, 1)]</span>

<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">cubical_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">face_poset</span><span class="p">()</span>
<span class="go">Finite poset containing 26 elements</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.graph">
<tt class="descname">graph</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>The 1-skeleton of this cell complex, as a graph.</p>
<p>This is not implemented for general cell complexes.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.homology">
<tt class="descname">homology</tt><big>(</big><em>dim=None</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.homology" title="Permalink to this definition">¶</a></dt>
<dd><p>The reduced homology of this cell complex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dim</strong> (<em>integer or list of integers or None; optional,
default None</em>) &#8211; If None, then return the homology in every
dimension.  If <tt class="docutils literal"><span class="pre">dim</span></tt> is an integer or list, return the
homology in the given dimensions.  (Actually, if <tt class="docutils literal"><span class="pre">dim</span></tt> is
a list, return the homology in the range from <tt class="docutils literal"><span class="pre">min(dim)</span></tt>
to <tt class="docutils literal"><span class="pre">max(dim)</span></tt>.)</li>
<li><strong>base_ring</strong> (<em>optional, default ZZ</em>) &#8211; commutative ring, must be ZZ or a field.</li>
<li><strong>subcomplex</strong> (<em>optional, default empty</em>) &#8211; a subcomplex of this simplicial complex.
Compute homology relative to this subcomplex.</li>
<li><strong>generators</strong> (<em>boolean; optional, default False</em>) &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt>, return generators for the homology
groups along with the groups.  NOTE: Since <a class="reference external" href="http://trac.sagemath.org/6100">trac ticket #6100</a>, the result
may not be what you expect when not using CHomP since its return
is in terms of the chain complex.</li>
<li><strong>cohomology</strong> (<em>boolean; optional, default False</em>) &#8211; If True, compute cohomology rather than homology.</li>
<li><strong>algorithm</strong> (<em>string; optional, default &#8216;auto&#8217;</em>) &#8211; The options are &#8216;auto&#8217;, &#8216;dhsw&#8217;, &#8216;pari&#8217; or &#8216;no_chomp&#8217;.
See below for a description of what they mean.</li>
<li><strong>verbose</strong> (<em>boolean; optional, default False</em>) &#8211; If True, print some messages as the homology is
computed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The keyword arguments to this function get passed on to
<a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.chain_complex" title="sage.homology.cell_complex.GenericCellComplex.chain_complex"><tt class="xref py py-meth docutils literal"><span class="pre">chain_complex()</span></tt></a> and its homology.</p>
</div>
<p>ALGORITHM:</p>
<p>If <tt class="docutils literal"><span class="pre">algorithm</span></tt> is set to &#8216;auto&#8217; (the default), then use
CHomP if available.  (CHomP is available at the web page
<a class="reference external" href="http://chomp.rutgers.edu/">http://chomp.rutgers.edu/</a>.  It is also an experimental package
for Sage.)</p>
<p>CHomP computes homology, not cohomology, and only works over
the integers or finite prime fields.  Therefore if any of
these conditions fails, or if CHomP is not present, or if
<tt class="docutils literal"><span class="pre">algorithm</span></tt> is set to &#8216;no_chomp&#8217;, go to plan B: if this complex
has a <tt class="docutils literal"><span class="pre">_homology</span></tt> method &#8211; each simplicial complex has
this, for example &#8211; then call that.  Such a method implements
specialized algorithms for the particular type of cell
complex.</p>
<p>Otherwise, move on to plan C: compute the chain complex of
this complex and compute its homology groups.  To do this: over a
field, just compute ranks and nullities, thus obtaining
dimensions of the homology groups as vector spaces.  Over the
integers, compute Smith normal form of the boundary matrices
defining the chain complex according to the value of
<tt class="docutils literal"><span class="pre">algorithm</span></tt>.  If <tt class="docutils literal"><span class="pre">algorithm</span></tt> is &#8216;auto&#8217; or &#8216;no_chomp&#8217;, then
for each relatively small matrix, use the standard Sage
method, which calls the Pari package.  For any large matrix,
reduce it using the Dumas, Heckenbach, Saunders, and Welker
elimination algorithm: see
<a class="reference internal" href="matrix_utils.html#sage.homology.matrix_utils.dhsw_snf" title="sage.homology.matrix_utils.dhsw_snf"><tt class="xref py py-func docutils literal"><span class="pre">sage.homology.matrix_utils.dhsw_snf()</span></tt></a> for details.</p>
<p>Finally, <tt class="docutils literal"><span class="pre">algorithm</span></tt> may also be &#8216;pari&#8217; or &#8216;dhsw&#8217;, which
forces the named algorithm to be used regardless of the size
of the matrices and regardless of whether CHomP is available.</p>
<p>As of this writing, CHomP is by far the fastest option,
followed by the &#8216;auto&#8217; or &#8216;no_chomp&#8217; setting of using the
Dumas, Heckenbach, Saunders, and Welker elimination algorithm
for large matrices and Pari for small ones.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">delta_complexes</span><span class="o">.</span><span class="n">RealProjectivePlane</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: C2, 2: 0}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">{0: Vector space of dimension 0 over Finite Field of size 2,</span>
<span class="go"> 1: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 2: Vector space of dimension 1 over Finite Field of size 2}</span>
<span class="gp">sage: </span><span class="n">S7</span> <span class="o">=</span> <span class="n">delta_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S7</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Z</span>
<span class="gp">sage: </span><span class="n">cubical_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Vector space of dimension 2 over Finite Field of size 2</span>
</pre></div>
</div>
<p>If CHomP is installed, Sage can compute generators of homology
groups:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">generators</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>  <span class="c"># optional - CHomP</span>
<span class="go">(Vector space of dimension 1 over Finite Field of size 2, [(0, 1, 2) + (0, 1, 3) + (0, 2, 3) + (1, 2, 3)])</span>
</pre></div>
</div>
<p>When generators are computed, Sage returns a pair for each
dimension: the group and the list of generators.  For
simplicial complexes, each generator is represented as a
linear combination of simplices, as above, and for cubical
complexes, each generator is a linear combination of cubes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S2_cub</span> <span class="o">=</span> <span class="n">cubical_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2_cub</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">generators</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># optional - CHomP</span>
<span class="go">(Z, [-[[0,1] x [0,1] x [0,0]] + [[0,1] x [0,1] x [1,1]] - [[0,0] x [0,1] x [0,1]] - [[0,1] x [1,1] x [0,1]] + [[0,1] x [0,0] x [0,1]] + [[1,1] x [0,1] x [0,1]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.homology_with_basis">
<tt class="descname">homology_with_basis</tt><big>(</big><em>base_ring=None</em>, <em>cohomology=False</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.homology_with_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unreduced homology of this complex with
coefficients in <tt class="docutils literal"><span class="pre">base_ring</span></tt> with a chosen basis.</p>
<p>This is implemented for simplicial, cubical, and
<span class="math">\(\Delta\)</span>-complexes, not for arbitrary generic cell complexes.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">base_ring</span></tt> &#8211; coefficient ring (optional, default
<tt class="docutils literal"><span class="pre">QQ</span></tt>); must be a field</li>
<li><tt class="docutils literal"><span class="pre">cohomology</span></tt> &#8211; boolean (optional, default <tt class="docutils literal"><span class="pre">False</span></tt>); if
<tt class="docutils literal"><span class="pre">True</span></tt>, return cohomology instead of homology</li>
</ul>
<p>Homology basis elements are named &#8216;h_{dim,i}&#8217; where i ranges
between 0 and <span class="math">\(r-1\)</span>, if <span class="math">\(r\)</span> is the rank of the homology
group. Cohomology basis elements are denoted <span class="math">\(h^{dim,i}\)</span>
instead.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">If <tt class="docutils literal"><span class="pre">cohomology</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt>, this returns the cohomology
as a graded module. For the ring structure, use
<a class="reference internal" href="#sage.homology.cell_complex.GenericCellComplex.cohomology_ring" title="sage.homology.cell_complex.GenericCellComplex.cohomology_ring"><tt class="xref py py-meth docutils literal"><span class="pre">cohomology_ring()</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">homology_with_basis</span><span class="p">(</span><span class="n">QQ</span><span class="p">);</span> <span class="n">H</span>
<span class="go">Homology module of Minimal triangulation of the Klein bottle</span>
<span class="go"> over Rational Field</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[h_{0,0}, h_{1,0}]</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">homology_with_basis</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="n">H</span>
<span class="go">Homology module of Minimal triangulation of the Klein bottle</span>
<span class="go"> over Finite Field of size 2</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[h_{0,0}, h_{1,0}, h_{1,1}, h_{2,0}]</span>
</pre></div>
</div>
<p>The homology is constructed as a graded object, so for
example, you can ask for the basis in a single degree:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Finite family {(1, 0): h_{1,0}, (1, 1): h_{1,1}}</span>
<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">delta_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">S3</span><span class="o">.</span><span class="n">homology_with_basis</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">cohomology</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[h^{3,0}]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.join">
<tt class="descname">join</tt><big>(</big><em>right</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.join" title="Permalink to this definition">¶</a></dt>
<dd><p>The join of this cell complex with another one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>right</strong> &#8211; the other simplicial complex (the right-hand factor)</td>
</tr>
</tbody>
</table>
<p>Joins are not implemented for general cell complexes.  They
may be implemented in some derived classes (like simplicial
complexes).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">();</span> <span class="n">B</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.n_cells">
<tt class="descname">n_cells</tt><big>(</big><em>n</em>, <em>subcomplex=None</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.n_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>List of cells of dimension <tt class="docutils literal"><span class="pre">n</span></tt> of this cell complex.
If the optional argument <tt class="docutils literal"><span class="pre">subcomplex</span></tt> is present, then
return the <tt class="docutils literal"><span class="pre">n</span></tt>-dimensional faces which are <em>not</em> in the
subcomplex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> (<em>non-negative integer</em>) &#8211; the dimension</li>
<li><strong>subcomplex</strong> (optional, default <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; a subcomplex of this cell complex. Return
the cells which are not in this subcomplex.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[(1, 2), (0, 2), (0, 1)]</span>
<span class="gp">sage: </span><span class="n">delta_complexes</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[(0, 0), (0, 0), (0, 0)]</span>
<span class="gp">sage: </span><span class="n">cubical_complexes</span><span class="o">.</span><span class="n">Cube</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[[1,1], [0,0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.n_chains">
<tt class="descname">n_chains</tt><big>(</big><em>n</em>, <em>base_ring=None</em>, <em>cochains=False</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.n_chains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the free module of chains in degree <tt class="docutils literal"><span class="pre">n</span></tt> over <tt class="docutils literal"><span class="pre">base_ring</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; integer</li>
<li><tt class="docutils literal"><span class="pre">base_ring</span></tt> &#8211; ring (optional, default <span class="math">\(\ZZ\)</span>)</li>
<li><tt class="docutils literal"><span class="pre">cochains</span></tt> &#8211; boolean (optional, default <tt class="docutils literal"><span class="pre">False</span></tt>); if
<tt class="docutils literal"><span class="pre">True</span></tt>, return cochains instead</li>
</ul>
<p>The only difference between chains and cochains is
notation. In a simplicial complex, for example, a simplex
<tt class="docutils literal"><span class="pre">(0,1,2)</span></tt> is written as &#8220;(0,1,2)&#8221; in the group of chains but
as &#8220;chi_(0,1,2)&#8221; in the group of cochains.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">n_chains</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">QQ</span><span class="p">)</span>
<span class="go">Free module generated by {(2, 3), (0, 2), (1, 3), (1, 2), (0, 3), (0, 1)} over Rational Field</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">n_chains</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">cochains</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">basis</span><span class="p">())</span>
<span class="go">[(2, 3), (0, 2), (1, 3), (1, 2), (0, 3), (0, 1)]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">n_chains</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">cochains</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">basis</span><span class="p">())</span>
<span class="go">[\chi_(2, 3), \chi_(0, 2), \chi_(1, 3), \chi_(1, 2), \chi_(0, 3), \chi_(0, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.n_skeleton">
<tt class="descname">n_skeleton</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.n_skeleton" title="Permalink to this definition">¶</a></dt>
<dd><p>The <span class="math">\(n\)</span>-skeleton of this cell complex: the cell
complex obtained by discarding all of the simplices in
dimensions larger than <span class="math">\(n\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> &#8211; non-negative integer</td>
</tr>
</tbody>
</table>
<p>This is not implemented for general cell complexes.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.product">
<tt class="descname">product</tt><big>(</big><em>right</em>, <em>rename_vertices=True</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.product" title="Permalink to this definition">¶</a></dt>
<dd><p>The (Cartesian) product of this cell complex with another one.</p>
<p>Products are not implemented for general cell complexes.  They
may be implemented in some derived classes (like simplicial
complexes).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">();</span> <span class="n">B</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.cell_complex.GenericCellComplex.wedge">
<tt class="descname">wedge</tt><big>(</big><em>right</em><big>)</big><a class="headerlink" href="#sage.homology.cell_complex.GenericCellComplex.wedge" title="Permalink to this definition">¶</a></dt>
<dd><p>The wedge (one-point union) of this simplicial complex with
another one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>right</strong> &#8211; the other simplicial complex (the right-hand factor)</td>
</tr>
</tbody>
</table>
<p>Wedges are not implemented for general cell complexes.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.cell_complex</span> <span class="kn">import</span> <span class="n">GenericCellComplex</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">();</span> <span class="n">B</span> <span class="o">=</span> <span class="n">GenericCellComplex</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="cubical_complex.html"
                                  title="previous chapter">Finite cubical complexes</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="koszul_complex.html"
                                  title="next chapter">Koszul Complexes</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/homology/cell_complex.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="koszul_complex.html" title="Koszul Complexes"
             >next</a> |</li>
        <li class="right" >
          <a href="cubical_complex.html" title="Finite cubical complexes"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Cell complexes and their homology</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>