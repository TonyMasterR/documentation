<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Quiver Representations &mdash; Sage Reference Manual v6.6: Quivers</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '6.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v6.6: Quivers" href="../../index.html" />
    <link rel="prev" title="Path Semigroups" href="path_semigroup.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="path_semigroup.html" title="Path Semigroups"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Quivers</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="quiver-representations">
<span id="sage-quivers-representation"></span><h1>Quiver Representations<a class="headerlink" href="#quiver-representations" title="Permalink to this headline">Â¶</a></h1>
<span class="target" id="module-sage.quivers.representation"></span><p>AUTHORS:</p>
<ul class="simple">
<li>Jim Stark (2012-03-04): Initial implementation of acyclic quivers without
relations.</li>
<li>Simon King (2013-05, 2014-02): Split code up. Allow cyclic quivers where
possible.</li>
</ul>
<p>A quiver is a directed graph used for representation theory. In our
representation theoretic code, it is assumed that</p>
<ul class="simple">
<li>the vertices of the quiver are labelled by integers, and</li>
<li>each edge of the quiver is labelled with a nonempty string.  The label
cannot begin with <tt class="docutils literal"><span class="pre">'e_'</span></tt> or contain <tt class="docutils literal"><span class="pre">'*'</span></tt> and distinct edges must have
distinct labels.</li>
</ul>
<p>As far as the <a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.6)"><tt class="xref py py-class docutils literal"><span class="pre">DiGraph</span></tt></a> class is concerned, a
path is a finite list of pairwise distinct vertices <span class="math">\(v_1, ..., v_n\)</span> such
that there exists an edge from <span class="math">\(v_i\)</span> to <span class="math">\(v_{i + 1}\)</span>.  If there are
multiple edges between the same two vertices this does not contribute
additional paths as listed by the <a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.6)"><tt class="xref py py-class docutils literal"><span class="pre">DiGraph</span></tt></a>
class; for example only two paths are listed from 1 to 3 in <tt class="docutils literal"><span class="pre">Q</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;d&#39;</span><span class="p">]}})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(1, 2, &#39;a&#39;), (1, 2, &#39;b&#39;), (1, 3, &#39;c&#39;), (2, 3, &#39;d&#39;)]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[[1, 2, 3], [1, 3]]</span>
</pre></div>
</div>
<p>The notion of a path in a quiver (in representation theory) is
fundamentally different in several aspects. First, paths are no longer
required to have distinct vertices, or even distinct edges; thus, &#8220;path&#8221;
in quiver theory is closer to the notion of &#8220;walk&#8221; in graph theory.
Furthermore, paths in quiver theory &#8220;know&#8221; their edges, so parallel edges
between the same two vertices of a Quiver make different paths. But
paths in quiver theory also &#8220;know&#8221; their vertices, so that a length-<span class="math">\(0\)</span>
path from <span class="math">\(a\)</span> to <span class="math">\(a\)</span> is not the same as a length-<span class="math">\(0\)</span> path from <span class="math">\(b\)</span> to <span class="math">\(b\)</span>
for <span class="math">\(a \neq b\)</span>.
Formally, we say that a path is given by two vertices, <tt class="docutils literal"><span class="pre">start</span></tt> and
<tt class="docutils literal"><span class="pre">end</span></tt>, and a finite (possibly empty) list of edges <span class="math">\(e_1, e_2, \ldots, e_n\)</span>
such that the initial vertex of <span class="math">\(e_1\)</span> is <tt class="docutils literal"><span class="pre">start</span></tt>, the final vertex of <span class="math">\(e_i\)</span>
is the initial vertex of <span class="math">\(e_{i + 1}\)</span>, and the final vertex of <span class="math">\(e_n\)</span> is
<tt class="docutils literal"><span class="pre">end</span></tt>.  In the case where no edges are specified, we must have
<tt class="docutils literal"><span class="pre">start</span> <span class="pre">=</span> <span class="pre">end</span></tt> and the path is called the trivial path at the given vertex.</p>
<p>Quiver paths in the sense stated above correspond to the elements of a
partial semigroup, with multiplication of paths given by concatenation. Hence,
rather than overloading the method name inherited from
<a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.6)"><tt class="xref py py-class docutils literal"><span class="pre">DiGraph</span></tt></a> or inventing a
new method name, we move this functionality to this so-called <em>path
semigroup</em>.  Note that with this definition there are three paths from 1 to 3
in our example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[a*d, b*d, c]</span>
</pre></div>
</div>
<p>The returned paths are of type <tt class="xref py py-class docutils literal"><span class="pre">QuiverPath</span></tt>, which
are elements in the path semigroup that is associated with the quiver (a
partial semigroup, which does not generally have a neutral element). You can
specify a <tt class="xref py py-class docutils literal"><span class="pre">QuiverPath</span></tt> by giving an edge or a
list of edges, passed as arguments to the path semigroup containing this path.
Here an edge is a tuple of the form <tt class="docutils literal"><span class="pre">(i,</span> <span class="pre">j,</span> <span class="pre">l)</span></tt>, where <tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">j</span></tt>
are vertices and <tt class="docutils literal"><span class="pre">l</span></tt> is the label of an edge from i to j:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span>
<span class="go">a*d</span>
</pre></div>
</div>
<p>Trivial paths are indicated by passing the tuple <tt class="docutils literal"><span class="pre">(vertex,</span> <span class="pre">vertex)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="go">e_6</span>
</pre></div>
</div>
<p>Trivial &#8220;edges&#8221; can occur in the input.  They are simply deleted if their
vertex matches the start and end vertex of adjacent edges. Here is an
alternative way to define a path:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">PQ</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">PQ</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">==</span> <span class="n">q</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If the vertex of a trivial path does not match with adjacent edges, or if two
adjacent edges do not match, an error is raised.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">inv1</span> <span class="o">=</span> <span class="n">PQ</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">Cannot interpret [(1, 2, &#39;a&#39;), (1, 1)] as element of</span>
<span class="go"> Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices</span>
<span class="gp">sage: </span><span class="n">inv2</span> <span class="o">=</span> <span class="n">PQ</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">Cannot interpret [(1, 2, &#39;a&#39;), (1, 2, &#39;a&#39;)] as element of</span>
<span class="go"> Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices</span>
<span class="gp">sage: </span><span class="n">inv3</span> <span class="o">=</span> <span class="n">PQ</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;x&#39;</span><span class="p">)])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">Cannot interpret [(1, 2, &#39;x&#39;)] as element of</span>
<span class="go"> Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">*</span></tt> operator is concatenation of paths. If the two paths do not compose,
then the result is <tt class="docutils literal"><span class="pre">None</span></tt> (whence the &#8220;partial&#8221; in &#8220;partial semigroup&#8221;).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">print</span> <span class="n">p</span><span class="o">*</span><span class="n">q</span>
<span class="go">None</span>
</pre></div>
</div>
<p>Let us now construct a larger quiver:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Qbig</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;d&#39;</span><span class="p">]},</span> <span class="mi">3</span><span class="p">:{</span><span class="mi">4</span><span class="p">:[</span><span class="s">&#39;e&#39;</span><span class="p">]},</span> <span class="mi">4</span><span class="p">:{</span><span class="mi">5</span><span class="p">:[</span><span class="s">&#39;f&#39;</span><span class="p">]},</span> <span class="mi">5</span><span class="p">:{</span><span class="mi">1</span><span class="p">:[</span><span class="s">&#39;g&#39;</span><span class="p">]}</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">Pbig</span> <span class="o">=</span> <span class="n">Qbig</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
</pre></div>
</div>
<p>Since <tt class="docutils literal"><span class="pre">Q</span></tt> is a sub-digraph of <tt class="docutils literal"><span class="pre">Qbig</span></tt>, we have a coercion of the associated
path semigroups:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Pbig</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">PQ</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In particular, <tt class="docutils literal"><span class="pre">p</span></tt> is considered to be an element of <tt class="docutils literal"><span class="pre">Pbig</span></tt>, and can be
composed with paths that were defined for the larger quiver:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="ow">in</span> <span class="n">Pbig</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">*</span><span class="n">Pbig</span><span class="p">([(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">)])</span>
<span class="go">a*d*e</span>
<span class="gp">sage: </span><span class="n">Pbig</span><span class="p">([(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s">&#39;f&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">)])</span><span class="o">*</span><span class="n">p</span>
<span class="go">f*g*a*d</span>
</pre></div>
</div>
<p>The length of a path is the number of edges in that path:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">triv</span> <span class="o">=</span> <span class="n">PQ</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">triv</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>List index and slice notation can be used to access the edges in a path.
QuiverPaths can also be iterated over.  Trivial paths have no elements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span> <span class="k">print</span> <span class="n">x</span>
<span class="go">(1, 2, &#39;a&#39;)</span>
<span class="go">(2, 3, &#39;d&#39;)</span>
<span class="gp">sage: </span><span class="n">triv</span><span class="p">[:]</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>There are methods giving the initial and terminal vertex of a path:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">initial_vertex</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">terminal_vertex</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p><tt class="xref py py-class docutils literal"><span class="pre">QuiverPath</span></tt> form the basis of the quiver
algebra of a quiver.  Given a field <span class="math">\(k\)</span> and a quiver <span class="math">\(Q\)</span>, the quiver
algebra <span class="math">\(kQ\)</span> is, as a vector space, the free <span class="math">\(k\)</span>-vector space whose basis
is the set of all paths in <span class="math">\(Q\)</span>. Multiplication is defined on this basis
and extended bilinearly.  The product of two basis elements is given by
path composition when it makes sense and is set to be zero otherwise.
Specifically, if the terminal vertex of the left path equals the initial
vertex of the right path, then their product is the concatenation of the
two paths, and otherwise their product is zero. In sage, quiver algebras
are handled by the <tt class="xref py py-class docutils literal"><span class="pre">QuiverAlgebra</span></tt> class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">PQ</span><span class="o">.</span><span class="n">algebra</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">A</span>
<span class="go">Path algebra of Multi-digraph on 3 vertices over Finite Field of size 7</span>
</pre></div>
</div>
<p>Quivers have a method that creates their algebra over a given field (or,
more generally, commutative ring).  Note that
<tt class="xref py py-class docutils literal"><span class="pre">QuiverAlgebras</span></tt> are uniquely defined by
their quiver and field, and play nicely with coercions of the underlying
path semigroups:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="ow">is</span> <span class="n">PQ</span><span class="o">.</span><span class="n">algebra</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="ow">is</span> <span class="n">PQ</span><span class="o">.</span><span class="n">algebra</span><span class="p">(</span><span class="n">RR</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q1</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q1</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">PQ1</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="ow">is</span> <span class="n">PQ1</span><span class="o">.</span><span class="n">algebra</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Pbig</span><span class="o">.</span><span class="n">algebra</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The <tt class="xref py py-class docutils literal"><span class="pre">QuiverAlgebra</span></tt> can create elements
from <tt class="xref py py-class docutils literal"><span class="pre">QuiverPaths</span></tt> or from elements of the
base ring:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">5*e_1 + 5*e_2 + 5*e_3</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="n">PQ</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">e2</span> <span class="o">=</span> <span class="n">PQ</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">A</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">e_2 + a*d</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">A</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span>
<span class="go">a*d + b*d</span>
</pre></div>
</div>
<p><tt class="xref py py-class docutils literal"><span class="pre">QuiverAlgebras</span></tt> are <span class="math">\(\NN\)</span>-graded algebras.
The grading is given by assigning to each basis element the length of the
path corresponding to that basis element:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">is_homogeneous</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">Element is not homogeneous.</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">is_homogeneous</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Free module spanned by [a, b, c, d] over Finite Field of size 7</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">Free module spanned by [a*d, b*d] over Finite Field of size 7</span>
</pre></div>
</div>
<p>The category of right modules over a given quiver algebra is equivalent to the
category of representations of that quiver.  A quiver representation is a
diagram in the category of vector spaces whose underlying graph is the quiver.
So to each vertex of the quiver we assign a vector space and to each edge of
the quiver a linear map between the vector spaces assigned to the start and end
vertices of that edge.  To create the zero representation we just specify the
base ring and the path semigroup:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>To each vertex of a quiver there is associated a simple module, an
indecomposable projective, and an indecomposable injective, and these can
be created from the qQuiver:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">PQ</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">PQ</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">PQ</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Radicals, socles, tops, and quotients can all be computed and we can test if
modules are simple or semisimple, get their dimension, and test for equality.
Like quivers, <tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt> objects
are unique and therefore equal if and only if they are identical:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_simple</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">radical</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">socle</span><span class="p">()</span>
<span class="go">Representation with dimension vector (0, 0, 3)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">P</span><span class="o">/</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">is_simple</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">==</span> <span class="n">R</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">top</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P</span><span class="o">/</span><span class="n">R</span>
<span class="go">True</span>
</pre></div>
</div>
<p>There are special methods to deal with modules that are given as right
ideals in the quiver algebra.  To create such a module pass the keyword
<tt class="docutils literal"><span class="pre">option='paths'</span></tt> along with a path or list of paths that generate the
desired ideal:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">PQ</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(1, 2, 3)</span>
</pre></div>
</div>
<p>There are also special methods to deal with modules that are given as the
linear dual of a right ideal in the quiver algebra.  To create such a
module, pass the keyword <tt class="docutils literal"><span class="pre">option='dual</span> <span class="pre">paths'</span></tt> to the constructor along
with a path or list of paths.  The module returned is the dual of the
ideal created in the opposite quiver by the reverses of the given paths:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">PQ</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;dual paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(2, 0, 0)</span>
</pre></div>
</div>
<p>For modules that are not a standard module or an ideal of the quiver algebra
<tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt> can take as input two
dictionaries.  The first associates to each vertex a vector space or an
integer (the desired dimension of the vector space), the second associates to
each edge a map or a matrix or something from which sage can construct a map:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">PQ2</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M2</span> <span class="o">=</span> <span class="n">PQ2</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">1</span><span class="p">},</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">):</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">):</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">get_space</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Vector space of dimension 2 over Rational Field</span>
<span class="gp">sage: </span><span class="n">M2</span><span class="o">.</span><span class="n">get_space</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Vector space of dimension 1 over Rational Field</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">get_map</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">))</span>
<span class="go">Vector space morphism represented by the matrix:</span>
<span class="go">[1 0]</span>
<span class="go">Domain: Vector space of dimension 1 over Rational Field</span>
<span class="go">Codomain: Vector space of dimension 2 over Rational Field</span>
</pre></div>
</div>
<p>A homomorphism between two quiver representations is given by homomorphisms
between the spaces assigned to the vertices of those representations such that
those homomorphisms commute with the edge maps of the representations. The
homomorphisms are created in the usual Sage syntax, the defining data given by
a dictionary associating maps to vertices:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">PQ2</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">P2</span><span class="o">.</span><span class="n">hom</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]},</span> <span class="n">M2</span><span class="p">)</span>
</pre></div>
</div>
<p>When the domain is given as a right ideal in the quiver algebra we can also
create a homomorphism by just giving a single element in the codomain.
The map is then induced by acting on that element:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">P2</span><span class="o">.</span><span class="n">gens</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">x_0</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">==</span> <span class="n">P2</span><span class="o">.</span><span class="n">hom</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">M2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As you can see, the above homomorphisms can be applied to elements.  Just
like elements, addition is defined via the <tt class="docutils literal"><span class="pre">+</span></tt> operator.  On elements scalar
multiplication is defined via the <tt class="docutils literal"><span class="pre">*</span></tt> operator but on homomorphisms <tt class="docutils literal"><span class="pre">*</span></tt>
defines composition, so scalar multiplication is done using a method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">f</span> <span class="o">+</span> <span class="n">f</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">scalar_mult</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span>       <span class="c"># This multiplies the map with the scalar 2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c"># This applies the map, then multiplies by the scalar</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">direct_sum</span></tt> method for modules returns only the resulting module by
default.  But can also return the projection and inclusion homomorphisms into
the various factors:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">N2</span><span class="p">,</span> <span class="n">inclusions</span><span class="p">,</span> <span class="n">projections</span> <span class="o">=</span> <span class="n">M2</span><span class="o">.</span><span class="n">direct_sum</span><span class="p">([</span><span class="n">P2</span><span class="p">],</span> <span class="n">return_maps</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">inclusions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">M2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">projections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">M2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">projections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">inclusions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">is_isomorphism</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As you see above we can determine if a given map is an isomorphism.  Testing
for injectivity and surjectivity works as well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">is_injective</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">is_surjective</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can create all the standard modules associated to maps:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">Representation with dimension vector (0, 1)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">cokernel</span><span class="p">()</span>
<span class="go">Representation with dimension vector (1, 0)</span>
<span class="gp">sage: </span><span class="n">im</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">image</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">im</span>
<span class="go">Representation with dimension vector (1, 1)</span>
</pre></div>
</div>
<p>These methods, as well as the <tt class="docutils literal"><span class="pre">submodule</span></tt> and <tt class="docutils literal"><span class="pre">quotient</span></tt> methods that are
defined for representations, return only the resulting representation.  To get
the inclusion map of a submodule or the factor homomorphism of a quotient use
<tt class="docutils literal"><span class="pre">coerce_map_from</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">incl</span> <span class="o">=</span> <span class="n">M2</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">incl</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">im</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">incl</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">M2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">incl</span><span class="o">.</span><span class="n">is_injective</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Both <tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt> objects and
<tt class="xref py py-class docutils literal"><span class="pre">QuiverRepHom</span></tt> objects have <tt class="docutils literal"><span class="pre">linear_dual</span></tt> and
<tt class="docutils literal"><span class="pre">algebraic_dual</span></tt> methods.  The <tt class="docutils literal"><span class="pre">linear_dual</span></tt> method applies the functor
<span class="math">\(Hom_k(..., k)\)</span> where <span class="math">\(k\)</span> is the base ring of the representation, and the
<tt class="docutils literal"><span class="pre">algebraic_dual</span></tt> method applies the functor <span class="math">\(Hom_Q(..., kQ)\)</span> where <span class="math">\(kQ\)</span>
is the quiver algebra.  Both these functors yield left modules.  A left
module is equivalent to a right module over the opposite algebra, and the
opposite of a quiver algebra is the algebra of the opposite quiver, so both
these methods yield modules and representations of the opposite quiver:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">linear_dual</span><span class="p">()</span>
<span class="go">Homomorphism of representations of Reverse of (): Multi-digraph on 2 vertices</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">M2</span><span class="o">.</span><span class="n">algebraic_dual</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span> <span class="ow">is</span> <span class="n">PQ2</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Change the wording <tt class="docutils literal"><span class="pre">Reverse</span> <span class="pre">of</span> <span class="pre">()</span></tt> into something more meaningful.</p>
</div>
<p>There is a method returning the projective cover of any module.  Note that
this method returns the homomorphism; to get the module take the domain of
the homomorphism:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">cov</span> <span class="o">=</span> <span class="n">M2</span><span class="o">.</span><span class="n">projective_cover</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">cov</span>
<span class="go">Homomorphism of representations of Multi-digraph on 2 vertices</span>
<span class="gp">sage: </span><span class="n">cov</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
<span class="go">Representation with dimension vector (2, 4)</span>
</pre></div>
</div>
<p>As projective covers are computable, so are the transpose and Auslander-Reiten
translates of modules:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M2</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">Representation with dimension vector (4, 3)</span>
<span class="gp">sage: </span><span class="n">PQ2</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">AR_translate</span><span class="p">()</span>
<span class="go">Representation with dimension vector (3, 2)</span>
</pre></div>
</div>
<p>We have already used the <tt class="docutils literal"><span class="pre">gens</span></tt> method above to get an element of a quiver
representation.  An element of a quiver representation is simply a choice of
element from each of the spaces assigned to the vertices of the quiver.
Addition, subtraction, and scalar multiplication are performed pointwise and
implemented by the usual operators:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M2</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(2, 1)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">M2</span><span class="o">.</span><span class="n">gens</span><span class="p">(</span><span class="s">&#39;xyz&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span>
<span class="go">True</span>
</pre></div>
</div>
<p>To create a specific element of a given representation we just specify the
representation and a dictionary associating to each vertex an element of the
space associated to that vertex in the representation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">M2</span><span class="p">({</span><span class="mi">1</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">:(</span><span class="mi">3</span><span class="p">,)})</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(1, -1)</span>
</pre></div>
</div>
<p>The right action of a quiver algebra on an element is implemented via
the <tt class="docutils literal"><span class="pre">*</span></tt> operator:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A2</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span><span class="o">.</span><span class="n">algebra</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">A2</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">*</span><span class="n">a</span> <span class="o">==</span> <span class="n">z</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.quivers.representation.QuiverRepElement">
<em class="property">class </em><tt class="descclassname">sage.quivers.representation.</tt><tt class="descname">QuiverRepElement</tt><big>(</big><em>parent</em>, <em>elements=None</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRepElement" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/element.html#sage.structure.element.ModuleElement" title="(in Sage Reference Manual: Basic Structures v6.6)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.element.ModuleElement</span></tt></a></p>
<p>An element of a quiver representation is a choice of element from each
of the spaces assigned to the vertices of the quiver.  Addition,
subtraction, and scalar multiplication of these elements is done
pointwise within these spaces.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">module</span></tt> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt> (default: <tt class="docutils literal"><span class="pre">None</span></tt>), the module to
which the element belongs</li>
<li><tt class="docutils literal"><span class="pre">elements</span></tt> - dict (default: empty), a dictionary associating to each
vertex a vector or an object from which sage can create a vector.
Not all vertices must be specified, unspecified vertices will be
assigned the zero vector of the space associated to that vertex in
the given module.  Keys that do not correspond to a vertex are ignored.</li>
<li><tt class="docutils literal"><span class="pre">name</span></tt> &#8211; string (default: <tt class="docutils literal"><span class="pre">None</span></tt>), the name of the element</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference internal" href="#sage.quivers.representation.QuiverRepElement" title="sage.quivers.representation.QuiverRepElement"><tt class="xref py py-class docutils literal"><span class="pre">QuiverRepElement</span></tt></a></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The constructor needs to know the quiver in order to create an
element of a representation over that quiver.  The default is to
read this information from <tt class="docutils literal"><span class="pre">module</span></tt> as well as to fill in
unspecified vectors with the zeros of the spaces in <tt class="docutils literal"><span class="pre">module</span></tt>.
If <tt class="docutils literal"><span class="pre">module</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt> then <tt class="docutils literal"><span class="pre">quiver</span></tt> <em>MUST</em> be a quiver and each
vertex <em>MUST</em> be specified or an error will result.  If both
<tt class="docutils literal"><span class="pre">module</span></tt> and <tt class="docutils literal"><span class="pre">quiver</span></tt> are given then <tt class="docutils literal"><span class="pre">quiver</span></tt> is ignored.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">spaces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">quiver</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">spaces</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">elems</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
<span class="go">Element of quiver representation</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">elems</span><span class="p">,</span> <span class="s">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span>
<span class="go">v</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">v</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.quivers.representation.QuiverRepElement.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRepElement.copy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return a copy of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">spaces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">quiver</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">spaces</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">elems</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">_set_element</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(0, 0)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(1, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRepElement.get_element">
<tt class="descname">get_element</tt><big>(</big><em>vertex</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRepElement.get_element" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the element at the given vertex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">vertex</span></tt> &#8211; integer, a vertex of the quiver</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>vector, the vector assigned to the given vertex</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">spaces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">quiver</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">spaces</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">elems</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(1, 0)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">get_element</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(2, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRepElement.is_zero">
<tt class="descname">is_zero</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRepElement.is_zero" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Test whether <tt class="docutils literal"><span class="pre">self</span></tt> is zero.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>bool, <tt class="docutils literal"><span class="pre">True</span></tt> if the element is the zero element, <tt class="docutils literal"><span class="pre">False</span></tt>
otherwise</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">spaces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">quiver</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">spaces</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">elems</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRepElement.quiver">
<tt class="descname">quiver</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRepElement.quiver" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the quiver of the representation.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.6)"><tt class="xref py py-class docutils literal"><span class="pre">DiGraph</span></tt></a>, the quiver of the representation</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Q</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRepElement.support">
<tt class="descname">support</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRepElement.support" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the support of <tt class="docutils literal"><span class="pre">self</span></tt> as a list.</p>
<p>The support is the set of vertices to which a nonzero vector is
associated.</p>
<p>OUTPUT</p>
<ul class="simple">
<li>list, the support</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">spaces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">quiver</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">spaces</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">elems</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="go">[1, 3]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.quivers.representation.QuiverRepFactory">
<em class="property">class </em><tt class="descclassname">sage.quivers.representation.</tt><tt class="descname">QuiverRepFactory</tt><a class="headerlink" href="#sage.quivers.representation.QuiverRepFactory" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/factory.html#sage.structure.factory.UniqueFactory" title="(in Sage Reference Manual: Basic Structures v6.6)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.factory.UniqueFactory</span></tt></a></p>
<p>A quiver representation is a diagram in the category of vector spaces whose
underlying graph is the quiver.  Giving a finite dimensional representation
is equivalent to giving a finite dimensional right module for the path
algebra of the quiver.</p>
<p>INPUT:</p>
<p>The first two arguments specify the base ring and the quiver,
and they are always required:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">k</span></tt> &#8211; ring, the base ring of the representation</li>
<li><tt class="docutils literal"><span class="pre">P</span></tt> &#8211; the partial semigroup formed by the paths of the quiver of the
representation</li>
</ul>
<p>Then to specify the spaces and maps associated to the quiver
there are three possible options.  The first is the <tt class="docutils literal"><span class="pre">'values'</span></tt> option,
where the next two arguments give the data to be assigned.  The following
can either be the next two entries in the argument list or they can be
passed by keyword.  If the argument list is long enough the keywords
are ignored; the keywords are only checked in the event that the argument
list does not have enough entries after <tt class="docutils literal"><span class="pre">P</span></tt>.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">spaces</span></tt> &#8211; dict (default: empty); a dictionary associating to each
vertex a free module over the base ring <span class="math">\(k\)</span>.  Not all vertices must be
specified; unspecified vertices are automatically set to <span class="math">\(k^0\)</span>.  Keys
of the dictionary  that don&#8217;t correspond to vertices are ignored.</li>
<li><tt class="docutils literal"><span class="pre">maps</span></tt> - dict (default: empty); a dictionary associating to each edge
a map whose domain and codomain are the spaces associated to the initial
and terminal vertex of the edge respectively.  Not all edges must be
specified; unspecified edges are automatically set to the zero map.
Keys of the dictionary that don&#8217;t correspond to edges are ignored.</li>
</ul>
<p>The second option is the <tt class="docutils literal"><span class="pre">paths</span></tt> option which creates a module by
generating a right ideal from a list of paths.  Thus the basis elements
of this module correspond to paths of the quiver and the maps are given
by right multiplication by the corresponding edge.  As above this can be
passed either as the next entry in the argument list or as a keyword.
The keyword is only checked if there is no entry in the argument list
after <tt class="docutils literal"><span class="pre">Q</span></tt>.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">basis</span></tt> - list; a nonempty list of paths in the quiver <tt class="docutils literal"><span class="pre">Q</span></tt>.
Entries that do not represent valid paths are ignored and duplicate
paths are deleted.  There must be at least one valid path in the list
or a <tt class="docutils literal"><span class="pre">ValueError</span></tt> is raised.  The closure of this list under right
multiplication forms the basis of the resulting representation.</li>
</ul>
<p>The third option is the <tt class="docutils literal"><span class="pre">dual</span> <span class="pre">paths</span></tt> option which creates the dual of
a left ideal in the quiver algebra.  Thus the basis elements of this
module correspond to paths of the quiver and the maps are given by
deleting the corresponding edge from the start of the path (the edge map
is zero on a path if that edge is not the initial edge of the path).
As above this can be passed either as the next entry in the argument
list or as a keyword.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">basis</span></tt> &#8211; list; a nonempty list of paths in the quiver <tt class="docutils literal"><span class="pre">Q</span></tt>.
Entries that do not represent valid paths are ignored and duplicate
paths are deleted.  There must be at least one valid path in the list
or a <tt class="docutils literal"><span class="pre">ValueError</span></tt> is raised.  The closure of this list under left
multiplication of edges forms the basis of  the resulting representation.</li>
</ul>
<p>Using the second and third options requires that the following keyword be
passed to the constructor.  This must be passed as a keyword.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">option</span></tt> - string (default: <tt class="docutils literal"><span class="pre">None</span></tt>), either <tt class="docutils literal"><span class="pre">'values'</span></tt> or
<tt class="docutils literal"><span class="pre">'paths'</span></tt> or <tt class="docutils literal"><span class="pre">'dual</span> <span class="pre">paths'</span></tt>. <tt class="docutils literal"><span class="pre">None</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">'values'</span></tt>.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q1</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
</pre></div>
</div>
<p>When the <tt class="docutils literal"><span class="pre">option</span></tt> keyword is not supplied the constructor uses the
<tt class="docutils literal"><span class="pre">'values'</span></tt> option and expects the spaces and maps to be specified.
If no maps or spaces are given the zero module is created:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The simple modules, indecomposable projectives, and indecomposable
injectives are examples of quiver representations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Various standard submodules can be computed, such as radicals and socles.
We can also form quotients and test for certain attributes such as
semisimplicity:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">radical</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">P</span><span class="o">/</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">is_simple</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">==</span> <span class="n">R</span>
<span class="go">False</span>
</pre></div>
</div>
<p>With the option <tt class="docutils literal"><span class="pre">'paths'</span></tt> the input data should be a list of
<tt class="xref py py-class docutils literal"><span class="pre">QuiverPaths</span></tt> or things that <tt class="xref py py-class docutils literal"><span class="pre">QuiverPaths</span></tt> can be
constructed from.  The resulting module is the submodule generated by
these paths in the quiver algebra, when considered as a right module
over itself:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>In the following example, the 3rd and 4th paths are actually the same,
so the duplicate is removed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>The dimension at each vertex equals the number of paths in the closed
basis whose terminal point is that vertex:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q2</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;d&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q2</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(0, 2, 2)</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Q2</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(0, 1, 2)</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.quivers.representation.QuiverRepFactory.create_key">
<tt class="descname">create_key</tt><big>(</big><em>k</em>, <em>P</em>, <em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRepFactory.create_key" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return a key for the specified module.</p>
<p>The key is a tuple.  The first and second entries are the base ring
<tt class="docutils literal"><span class="pre">k</span></tt> and the partial semigroup <tt class="docutils literal"><span class="pre">P</span></tt> formed by the paths of a quiver.
The third entry is the <tt class="docutils literal"><span class="pre">option</span></tt> and the remaining entries depend on
that option.  If the option is <tt class="docutils literal"><span class="pre">'values'</span></tt> and the quiver
has <span class="math">\(n\)</span> vertices then the next <span class="math">\(n\)</span> entries are the vector spaces
to be assigned to those vertices.  After that are the matrices of
the maps assigned to edges, listed in the same order that
<tt class="docutils literal"><span class="pre">Q.edges()</span></tt> uses.  If the option is <tt class="docutils literal"><span class="pre">'paths'</span></tt> or <tt class="docutils literal"><span class="pre">'dual</span> <span class="pre">paths'</span></tt>
then the next entry is a tuple containing a sorted list of the
paths that form a basis of the quiver.</p>
<p>INPUT:</p>
<p>See the class documentation.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>tuple</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.quivers.representation</span> <span class="kn">import</span> <span class="n">QuiverRep</span>
<span class="gp">sage: </span><span class="n">QuiverRep</span><span class="o">.</span><span class="n">create_key</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">P</span><span class="p">)</span>
<span class="go">(Finite Field of size 5,</span>
<span class="go"> Partial semigroup formed by the directed paths of Multi-digraph on 2 vertices,</span>
<span class="go"> &#39;values&#39;,</span>
<span class="go"> Vector space of dimension 0 over Finite Field of size 5,</span>
<span class="go"> Vector space of dimension 0 over Finite Field of size 5,</span>
<span class="go"> [])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRepFactory.create_object">
<tt class="descname">create_object</tt><big>(</big><em>version</em>, <em>key</em>, <em>**extra_args</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRepFactory.create_object" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#sage.quivers.representation.QuiverRep_generic" title="sage.quivers.representation.QuiverRep_generic"><tt class="xref py py-class docutils literal"><span class="pre">QuiverRep_generic</span></tt></a> or
<a class="reference internal" href="#sage.quivers.representation.QuiverRep_with_path_basis" title="sage.quivers.representation.QuiverRep_with_path_basis"><tt class="xref py py-class docutils literal"><span class="pre">QuiverRep_with_path_basis</span></tt></a> object from the key.</p>
<p>The key is a tuple.  The first and second entries are the base ring
<tt class="docutils literal"><span class="pre">k</span></tt> and the quiver <tt class="docutils literal"><span class="pre">Q</span></tt>.  The third entry is the
<tt class="docutils literal"><span class="pre">'option'</span></tt> and the remaining entries depend on that option.
If the option is <tt class="docutils literal"><span class="pre">'values'</span></tt> and the quiver has <span class="math">\(n\)</span>
vertices then the next <span class="math">\(n\)</span> entries are the vector spaces to be
assigned to those vertices.  After that are the matrices
of the maps assigned to edges, listed in the same order that
<tt class="docutils literal"><span class="pre">Q.edges()</span></tt> uses.  If the option is <tt class="docutils literal"><span class="pre">'paths'</span></tt> or <tt class="docutils literal"><span class="pre">'dual</span> <span class="pre">paths'</span></tt>
then the next entry is a tuple containing a sorted list of the
paths that form a basis of the quiver.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">version</span></tt> &#8211; the version of sage, this is currently ignored</li>
<li><tt class="docutils literal"><span class="pre">key</span></tt> &#8211; tuple</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference internal" href="#sage.quivers.representation.QuiverRep_generic" title="sage.quivers.representation.QuiverRep_generic"><tt class="xref py py-class docutils literal"><span class="pre">QuiverRep_generic</span></tt></a> or <a class="reference internal" href="#sage.quivers.representation.QuiverRep_with_path_basis" title="sage.quivers.representation.QuiverRep_with_path_basis"><tt class="xref py py-class docutils literal"><span class="pre">QuiverRep_with_path_basis</span></tt></a></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.quivers.representation</span> <span class="kn">import</span> <span class="n">QuiverRep</span>
<span class="gp">sage: </span><span class="n">key</span> <span class="o">=</span> <span class="n">QuiverRep</span><span class="o">.</span><span class="n">create_key</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">Q</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">QuiverRep</span><span class="o">.</span><span class="n">create_object</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">Representation with dimension vector (0, 0)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.quivers.representation.QuiverRep_generic">
<em class="property">class </em><tt class="descclassname">sage.quivers.representation.</tt><tt class="descname">QuiverRep_generic</tt><big>(</big><em>k</em>, <em>P</em>, <em>spaces</em>, <em>maps</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../misc/sage/misc/fast_methods.html#sage.misc.fast_methods.WithEqualityById" title="(in Sage Reference Manual: Miscellaneous v6.6)"><tt class="xref py py-class docutils literal"><span class="pre">sage.misc.fast_methods.WithEqualityById</span></tt></a>, <a class="reference external" href="../../../modules/sage/modules/module.html#sage.modules.module.Module" title="(in Sage Reference Manual: Modules v6.6)"><tt class="xref py py-class docutils literal"><span class="pre">sage.modules.module.Module</span></tt></a></p>
<p>A generic quiver representation.</p>
<p>This class should not be called by the user.</p>
<p>Call <tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt> with <tt class="docutils literal"><span class="pre">option='values'</span></tt> (which is the default)
instead.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">k</span></tt> &#8211; ring, the base ring of the representation</li>
<li><tt class="docutils literal"><span class="pre">P</span></tt> &#8211; the path semigroup of the quiver <span class="math">\(Q\)</span> of the representation</li>
<li><tt class="docutils literal"><span class="pre">spaces</span></tt> &#8211; dict (default: empty), a dictionary associating to each
vertex a free module over the base ring <span class="math">\(k\)</span>.  Not all vertices need
to be specified, unspecified vertices are automatically set to
<span class="math">\(k^0\)</span>.  Keys of the dictionary that don&#8217;t correspond to vertices are
ignored.</li>
<li><tt class="docutils literal"><span class="pre">maps</span></tt> &#8211; dict (default: empty), a dictionary associating to each
edge a map whose domain and codomain are the spaces associated to
the initial and terminal vertex of the edge respectively.  Not all
edges need to be specified, unspecified edges are automatically set
to the zero map.  Keys of the dictionary that don&#8217;t correspond to
edges are ignored.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">spaces</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">maps</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">Hom</span><span class="p">(</span><span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">identity</span><span class="p">(),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">):</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]}</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">spaces</span><span class="p">,</span> <span class="n">maps</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span> <span class="ow">in</span> <span class="n">P</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span> <span class="ow">in</span> <span class="n">P</span>
<span class="go">False</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.AR_translate">
<tt class="descname">AR_translate</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.AR_translate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the Auslander-Reiten translate of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">):</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">tauM</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">AR_translate</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">tauM</span>
<span class="go">Representation with dimension vector (1, 1)</span>
<span class="gp">sage: </span><span class="n">tauM</span><span class="o">.</span><span class="n">get_map</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">matrix</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">tauM</span><span class="o">.</span><span class="n">get_map</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">matrix</span><span class="p">()</span>
<span class="go">[0]</span>
</pre></div>
</div>
<p>The module <tt class="docutils literal"><span class="pre">M</span></tt> above is its own AR translate.  This is not
always true:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q2</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">3</span><span class="p">:{</span><span class="mi">1</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">5</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q2</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">AR_translate</span><span class="p">()</span>
<span class="go">Representation with dimension vector (0, 1, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.quivers.representation.QuiverRep_generic.Element">
<tt class="descname">Element</tt><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.Element" title="Permalink to this definition">Â¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.quivers.representation.QuiverRepElement" title="sage.quivers.representation.QuiverRepElement"><tt class="xref py py-class docutils literal"><span class="pre">QuiverRepElement</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.Hom">
<tt class="descname">Hom</tt><big>(</big><em>codomain</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.Hom" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the hom space from <tt class="docutils literal"><span class="pre">self</span></tt> to <tt class="docutils literal"><span class="pre">codomain</span></tt>.</p>
<p>For more information see the <tt class="xref py py-class docutils literal"><span class="pre">QuiverHomSpace</span></tt> documentation.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">Hom</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">Dimension 2 QuiverHomSpace</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.actor">
<tt class="descname">actor</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.actor" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the quiver path algebra acting on this representation.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a quiver path algebra</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
<span class="go">Finite Field of size 5</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">actor</span><span class="p">()</span>
<span class="go">Path algebra of Multi-digraph on 2 vertices over Finite Field of size 5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.algebraic_dual">
<tt class="descname">algebraic_dual</tt><big>(</big><em>basis=False</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.algebraic_dual" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Compute the algebraic dual <span class="math">\(Hom_Q(M, kQ)\)</span> of the module
<span class="math">\(M\)</span> = <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">basis</span></tt> &#8211; bool; if <tt class="docutils literal"><span class="pre">False</span></tt>, then only the module is
returned.  If <tt class="docutils literal"><span class="pre">True</span></tt>, then a tuple is returned.  The first
element is the <tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt> and the second element is a
dictionary which associates to each vertex a list.  The elements
of this list are the homomorphisms which correspond to the basis
elements of that vertex in the module.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt> or tuple</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Here <span class="math">\(kQ\)</span> is the path algebra considered as a right module
over itself.  If <span class="math">\(e\)</span> is an edge of the quiver <span class="math">\(Q\)</span> then we let
<span class="math">\((fe)(m) = ef(m)\)</span>.  This gives <span class="math">\(Hom_Q(M, kQ)\)</span> a module
structure over the opposite quiver <tt class="docutils literal"><span class="pre">Q.reverse()</span></tt>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;e&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">free_module</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span><span class="o">.</span><span class="n">algebraic_dual</span><span class="p">()</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(7, 2, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.an_element">
<tt class="descname">an_element</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.an_element" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return an element of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference internal" href="#sage.quivers.representation.QuiverRepElement" title="sage.quivers.representation.QuiverRepElement"><tt class="xref py py-class docutils literal"><span class="pre">QuiverRepElement</span></tt></a></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">Element of quiver representation</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.coordinates">
<tt class="descname">coordinates</tt><big>(</big><em>vector</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.coordinates" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the coordinates when <tt class="docutils literal"><span class="pre">vector</span></tt> is expressed in terms of
the gens.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">vector</span></tt> &#8211; <a class="reference internal" href="#sage.quivers.representation.QuiverRepElement" title="sage.quivers.representation.QuiverRepElement"><tt class="xref py py-class docutils literal"><span class="pre">QuiverRepElement</span></tt></a></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>list, the coefficients when the vector is expressed as a linear
combination of the generators of the module</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">gens</span><span class="p">(</span><span class="s">&#39;xyz&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
<span class="go">[1, -1, 1]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">an_element</span><span class="p">())</span>
<span class="go">[1, 1, 0]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span> <span class="o">==</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.dimension">
<tt class="descname">dimension</tt><big>(</big><em>vertex=None</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.dimension" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the dimension of the space associated to the given vertex
<tt class="docutils literal"><span class="pre">vertex</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">vertex</span></tt> &#8211; integer or <tt class="docutils literal"><span class="pre">None</span></tt> (default: <tt class="docutils literal"><span class="pre">None</span></tt>), the given
vertex</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>integer, the dimension over the base ring of the space
associated to the given vertex.  If <tt class="docutils literal"><span class="pre">vertex=None</span></tt> then the
dimension over the base ring of the module is returned</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The total dimension of the module is the sum of the dimensions
at each vertex:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.dimension_vector">
<tt class="descname">dimension_vector</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.dimension_vector" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the dimension vector of the representation.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>tuple</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The order of the entries in the tuple matches the order given
by calling the <tt class="docutils literal"><span class="pre">vertices()</span></tt> method on the quiver.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
<p>Each coordinate of the dimension vector is the dimension of the space
associated to that coordinate:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">get_space</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.direct_sum">
<tt class="descname">direct_sum</tt><big>(</big><em>modules</em>, <em>return_maps=False</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.direct_sum" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the direct sum of <tt class="docutils literal"><span class="pre">self</span></tt> with the given modules
<tt class="docutils literal"><span class="pre">modules</span></tt>.</p>
<p>The modules must be modules over the same quiver and base ring.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">modules</span></tt> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt> or list of <tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt>&#8216;s</li>
<li><tt class="docutils literal"><span class="pre">return_maps</span></tt> &#8211; Boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>); if <tt class="docutils literal"><span class="pre">False</span></tt>, then
the output is a single QuiverRep object which is the direct sum
of <tt class="docutils literal"><span class="pre">self</span></tt> with the given module or modules.  If <tt class="docutils literal"><span class="pre">True</span></tt>, then
the output is a list <tt class="docutils literal"><span class="pre">[sum,</span> <span class="pre">iota,</span> <span class="pre">pi]</span></tt>.  The first entry
<tt class="docutils literal"><span class="pre">sum</span></tt> is the direct sum of <tt class="docutils literal"><span class="pre">self</span></tt> with the given module or
modules.  Both <tt class="docutils literal"><span class="pre">iota</span></tt> and <tt class="docutils literal"><span class="pre">pi</span></tt> are lists of QuiverRepHoms
with one entry for each summand; <tt class="docutils literal"><span class="pre">iota[i]</span></tt> is the inclusion
map and <tt class="docutils literal"><span class="pre">pi[i]</span></tt> is the projection map of the <span class="math">\(i\)</span>-th summand.
The summands are ordered as given with <tt class="docutils literal"><span class="pre">self</span></tt> being the zeroth
summand.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt> or tuple</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">4</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]},</span> <span class="mi">3</span><span class="p">:{</span><span class="mi">4</span><span class="p">:[</span><span class="s">&#39;d&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">direct_sum</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(1, 1, 1, 2)</span>
<span class="gp">sage: </span><span class="n">P2</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(0, 1, 0, 1)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">dimension_vector</span><span class="p">()</span>
<span class="go">(1, 2, 1, 3)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">,</span> <span class="n">iota</span><span class="p">,</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">direct_sum</span><span class="p">(</span><span class="n">P2</span><span class="p">,</span> <span class="n">return_maps</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">iota</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P1</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">iota</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P1</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">pi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">iota</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">S</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">iota</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">S</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">S</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">pi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">S</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">iota</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">[1 0 0]</span>
<span class="go">[0 1 0]</span>
<span class="gp">sage: </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">[1 0]</span>
<span class="go">[0 1]</span>
<span class="go">[0 0]</span>
<span class="gp">sage: </span><span class="n">P1prime</span> <span class="o">=</span> <span class="n">S</span><span class="o">/</span><span class="n">iota</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">P1prime</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">iota</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">is_isomorphism</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.gens">
<tt class="descname">gens</tt><big>(</big><em>names='v'</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.gens" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return a list of generators of <tt class="docutils literal"><span class="pre">self</span></tt> as a <span class="math">\(k\)</span>-module.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">names</span></tt> &#8211; an iterable variable of length equal to the number
of generators, or a string (default: <tt class="docutils literal"><span class="pre">'v'</span></tt>); gives the names of
the generators either by giving a name to each generator or by
giving a name to which an index will be appended</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>list of <a class="reference internal" href="#sage.quivers.representation.QuiverRepElement" title="sage.quivers.representation.QuiverRepElement"><tt class="xref py py-class docutils literal"><span class="pre">QuiverRepElement</span></tt></a> objects, the linear generators
of the module (over the base ring)</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The generators are ordered first by vertex and then by the order
given by the <tt class="docutils literal"><span class="pre">gens()</span></tt> method of the space associated to
that vertex.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="go">[v_0, v_1, v_2]</span>
</pre></div>
</div>
<p>If a string is given then it is used as the name of each generator,
with the index of the generator appended in order to differentiate
them:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">gens</span><span class="p">(</span><span class="s">&#39;generator&#39;</span><span class="p">)</span>
<span class="go">[generator_0, generator_1, generator_2]</span>
</pre></div>
</div>
<p>If a list or other iterable variable is given then each generator
is named using the appropriate entry.  The length of the variable
must equal the number of generators (the dimension of the module):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">gens</span><span class="p">([</span><span class="s">&#39;w&#39;</span><span class="p">,</span> <span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="s">&#39;z&#39;</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">TypeError</span>: <span class="n-Identifier">can only concatenate list (not &quot;str&quot;) to list</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">gens</span><span class="p">([</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="s">&#39;z&#39;</span><span class="p">])</span>
<span class="go">[x, y, z]</span>
</pre></div>
</div>
<p>Strings are iterable, so if the length of the string is equal to the
number of generators then the characters of the string will be used
as the names:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">gens</span><span class="p">(</span><span class="s">&#39;xyz&#39;</span><span class="p">)</span>
<span class="go">[x, y, z]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.get_map">
<tt class="descname">get_map</tt><big>(</big><em>edge</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.get_map" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the map associated to the given edge <tt class="docutils literal"><span class="pre">edge</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">edge</span></tt> &#8211; tuple of the form
(initial vertex, terminal vertex, label) specifying the edge
whose map is returned</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">get_map</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">))</span>
<span class="go">Free module morphism defined by the matrix</span>
<span class="go">[1 0]</span>
<span class="go">Domain: Ambient free module of rank 1 over the principal ideal domain Integer Ring</span>
<span class="go">Codomain: Ambient free module of rank 2 over the principal ideal domain Integer Ring</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.get_space">
<tt class="descname">get_space</tt><big>(</big><em>vertex</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.get_space" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the module associated to the given vertex <tt class="docutils literal"><span class="pre">vertex</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">vertex</span></tt> &#8211; integer, a vertex of the quiver of the module</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">get_space</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Vector space of dimension 1 over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.is_semisimple">
<tt class="descname">is_semisimple</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.is_semisimple" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Test whether the representation is semisimple.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>bool</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">M</span><span class="o">/</span><span class="n">M</span><span class="o">.</span><span class="n">radical</span><span class="p">())</span><span class="o">.</span><span class="n">is_semisimple</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.is_simple">
<tt class="descname">is_simple</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.is_simple" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Test whether the representation is simple.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>bool</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">RR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_simple</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="n">RR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_simple</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.is_zero">
<tt class="descname">is_zero</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.is_zero" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Test whether the representation is zero.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>bool</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">M</span>
<span class="go">Representation with dimension vector (0, 0)</span>
<span class="gp">sage: </span><span class="n">N</span>
<span class="go">Representation with dimension vector (1, 0)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.linear_combination_of_basis">
<tt class="descname">linear_combination_of_basis</tt><big>(</big><em>coordinates</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.linear_combination_of_basis" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the linear combination of the basis for <tt class="docutils literal"><span class="pre">self</span></tt> given
by <tt class="docutils literal"><span class="pre">coordinates</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">coordinates</span></tt> &#8211; list; a list whose length is the dimension of
<tt class="docutils literal"><span class="pre">self</span></tt>.  The <span class="math">\(i\)</span>-th element of this list defines the
coefficient of the <span class="math">\(i\)</span>-th basis vector in the linear
combination.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference internal" href="#sage.quivers.representation.QuiverRepElement" title="sage.quivers.representation.QuiverRepElement"><tt class="xref py py-class docutils literal"><span class="pre">QuiverRepElement</span></tt></a></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">gens</span><span class="p">(</span><span class="s">&#39;xyz&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">[1, -1, 1]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">linear_combination_of_basis</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">e</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.linear_dual">
<tt class="descname">linear_dual</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.linear_dual" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Compute the linear dual <span class="math">\(Hom_k(M, k)\)</span> of the module
<span class="math">\(M =\)</span> <tt class="docutils literal"><span class="pre">self</span></tt> over the base ring <span class="math">\(k\)</span>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt>, the dual representation</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <span class="math">\(e\)</span> is an edge of the quiver <span class="math">\(Q\)</span> then we let
<span class="math">\((fe)(m) = f(me)\)</span>.  This gives <span class="math">\(Hom_k(M, k)\)</span> a module
structure over the opposite quiver <tt class="docutils literal"><span class="pre">Q.reverse()</span></tt>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">linear_dual</span><span class="p">()</span>
<span class="go">Representation with dimension vector (1, 2, 2)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">linear_dual</span><span class="p">()</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Q</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.projective_cover">
<tt class="descname">projective_cover</tt><big>(</big><em>return_maps=False</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.projective_cover" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the projective cover of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f1</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">projective_cover</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f1</span><span class="o">.</span><span class="n">is_surjective</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f1</span><span class="o">.</span><span class="n">_domain</span>
<span class="go">Representation with dimension vector (1, 2, 4)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Representation with dimension vector (1, 2, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.quiver">
<tt class="descname">quiver</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.quiver" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the quiver of the representation.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.6)"><tt class="xref py py-class docutils literal"><span class="pre">DiGraph</span></tt></a></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Q</span><span class="o">.</span><span class="n">quiver</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.quotient">
<tt class="descname">quotient</tt><big>(</big><em>sub</em>, <em>check=True</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.quotient" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the quotient of <tt class="docutils literal"><span class="pre">self</span></tt> by the submodule <tt class="docutils literal"><span class="pre">sub</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">sub</span></tt> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt>; this must be a submodule of <tt class="docutils literal"><span class="pre">self</span></tt>,
meaning the space associated to each vertex <span class="math">\(v\)</span> of <tt class="docutils literal"><span class="pre">sub</span></tt> is a
subspace of the space associated to <span class="math">\(v\)</span> in <tt class="docutils literal"><span class="pre">self</span></tt> and the map
associated to each edge <span class="math">\(e\)</span> of <tt class="docutils literal"><span class="pre">sub</span></tt> is the restriction of
the map associated to <span class="math">\(e\)</span> in <tt class="docutils literal"><span class="pre">self</span></tt></li>
<li><tt class="docutils literal"><span class="pre">check</span></tt> &#8211; bool; if <tt class="docutils literal"><span class="pre">True</span></tt> then <tt class="docutils literal"><span class="pre">sub</span></tt> is checked to verify
that it is indeed a submodule of <tt class="docutils literal"><span class="pre">self</span></tt> and an error is raised
if it is not</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt>, the quotient module <tt class="docutils literal"><span class="pre">self</span> <span class="pre">/</span> <span class="pre">sub</span></tt></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function returns only a QuiverRep object <tt class="docutils literal"><span class="pre">quot</span></tt>.  The
projection map from <tt class="docutils literal"><span class="pre">self</span></tt> to <tt class="docutils literal"><span class="pre">quot</span></tt> can be obtained by
calling <tt class="docutils literal"><span class="pre">quot.coerce_map_from(self)</span></tt>.</p>
</div>
<p>EXAMPLES:</p>
<blockquote>
<div>sage: Q = DiGraph({1:{2:[&#8216;a&#8217;,&#8217;b&#8217;]}, 2:{3:[&#8216;c&#8217;]}}).path_semigroup()
sage: M = Q.I(GF(3), 3)
sage: N = Q.S(GF(3), 3)
sage: M.quotient(N)
Representation with dimension vector (2, 1, 0)
sage: M.quotient(M.radical())
Representation with dimension vector (2, 0, 0)
sage: M.quotient(M)
Representation with dimension vector (0, 0, 0)</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.radical">
<tt class="descname">radical</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.radical" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the Jacobson radical of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt>, the Jacobson radical</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">radical</span><span class="p">()</span>
<span class="go">Representation with dimension vector (0, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.right_edge_action">
<tt class="descname">right_edge_action</tt><big>(</big><em>element</em>, <em>path</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.right_edge_action" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the result of <tt class="docutils literal"><span class="pre">element*path</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">element</span></tt> &#8211; <a class="reference internal" href="#sage.quivers.representation.QuiverRepElement" title="sage.quivers.representation.QuiverRepElement"><tt class="xref py py-class docutils literal"><span class="pre">QuiverRepElement</span></tt></a>, an element of <tt class="docutils literal"><span class="pre">self</span></tt></li>
<li><tt class="docutils literal"><span class="pre">path</span></tt> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">QuiverPath</span></tt> or list of tuples</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference internal" href="#sage.quivers.representation.QuiverRepElement" title="sage.quivers.representation.QuiverRepElement"><tt class="xref py py-class docutils literal"><span class="pre">QuiverRepElement</span></tt></a>, the result of <tt class="docutils literal"><span class="pre">element*path</span></tt> when
<tt class="docutils literal"><span class="pre">path</span></tt> is considered an element of the path algebra of the quiver</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">right_edge_action</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">right_edge_action</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">right_edge_action</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)])</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="go">[2]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">right_edge_action</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">))</span> <span class="o">==</span> <span class="n">M</span><span class="o">.</span><span class="n">right_edge_action</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.socle">
<tt class="descname">socle</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.socle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The socle of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt>, the socle</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">socle</span><span class="p">()</span>
<span class="go">Representation with dimension vector (0, 0, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.submodule">
<tt class="descname">submodule</tt><big>(</big><em>elements=</em>, <span class="optional">[</span><span class="optional">]</span><em>spaces=None</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.submodule" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns the submodule generated by the data.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">elements</span></tt> &#8211; a collection of QuiverRepElements (default:
empty list), each should be an element of <tt class="docutils literal"><span class="pre">self</span></tt></li>
<li><tt class="docutils literal"><span class="pre">spaces</span></tt> &#8211; dictionary (default: empty), this dictionary
should contain entries of the form <tt class="docutils literal"><span class="pre">{v:</span> <span class="pre">S}</span></tt> where <span class="math">\(v\)</span> is a
vertex of the quiver and <span class="math">\(S\)</span> is a subspace of the vector space
associated to <span class="math">\(v\)</span></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt>, the smallest subrepresentation of <tt class="docutils literal"><span class="pre">self</span></tt>
containing the given elements and the given subspaces</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function returns only a <tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt> object <tt class="docutils literal"><span class="pre">sub</span></tt>.
The inclusion map of <tt class="docutils literal"><span class="pre">sub</span></tt> into <tt class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">self</span></tt> can be obtained
by calling <tt class="docutils literal"><span class="pre">M.coerce_map_from(sub)</span></tt>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">spaces</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">maps</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">):</span> <span class="p">(</span><span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">Hom</span><span class="p">(</span><span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">identity</span><span class="p">(),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">):</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]}</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">spaces</span><span class="p">,</span> <span class="n">maps</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">submodule</span><span class="p">([</span><span class="n">v</span><span class="p">])</span>
<span class="go">Representation with dimension vector (1, 1, 1)</span>
</pre></div>
</div>
<p>The smallest submodule containing the vector space at vertex 1
also contains the entire vector space associated to vertex 3
because there is an isomorphism associated to the edge
<tt class="docutils literal"><span class="pre">(1,</span> <span class="pre">3,</span> <span class="pre">'a')</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">submodule</span><span class="p">(</span><span class="n">spaces</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">2</span><span class="p">})</span>
<span class="go">Representation with dimension vector (2, 0, 2)</span>
</pre></div>
</div>
<p>The smallest submodule containing the vector space at vertex 2
also contains the image of the rank 1 homomorphism associated to
the edge <tt class="docutils literal"><span class="pre">(2,</span> <span class="pre">3,</span> <span class="pre">'b')</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">submodule</span><span class="p">(</span><span class="n">spaces</span><span class="o">=</span><span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">3</span><span class="p">})</span>
<span class="go">Representation with dimension vector (0, 3, 1)</span>
</pre></div>
</div>
<p>As <tt class="docutils literal"><span class="pre">v</span></tt> is not already contained in this submodule, adding it as
a generator yields a larger submodule:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">submodule</span><span class="p">([</span><span class="n">v</span><span class="p">],</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">3</span><span class="p">})</span>
<span class="go">Representation with dimension vector (1, 3, 1)</span>
</pre></div>
</div>
<p>Giving no generating data yields the zero submodule:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">submodule</span><span class="p">()</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If the given data generates all of M then the result is M:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">submodule</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">gens</span><span class="p">())</span> <span class="ow">is</span> <span class="n">M</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.support">
<tt class="descname">support</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.support" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the support of <tt class="docutils literal"><span class="pre">self</span></tt> as a list.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>list, the vertices of the representation that have nonzero
spaces associated to them</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">]},</span> <span class="mi">3</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span>
<span class="go">Representation with dimension vector (0, 1, 1, 1)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">support</span><span class="p">()</span>
<span class="go">[2, 3, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.top">
<tt class="descname">top</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.top" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the top of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt>, the quotient of <tt class="docutils literal"><span class="pre">self</span></tt> by its radical</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">top</span><span class="p">()</span>
<span class="go">Representation with dimension vector (1, 0, 0)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">top</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span><span class="o">/</span><span class="n">M</span><span class="o">.</span><span class="n">radical</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.transpose">
<tt class="descname">transpose</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.transpose" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the transpose of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The transpose, <span class="math">\(\mbox{Tr} M\)</span>, of a module <span class="math">\(M\)</span> is defined as
follows.  Let <span class="math">\(p: P_1 \to P_2\)</span> be the second map in a minimal
projective presentation <span class="math">\(P_1 \to P_2 \to M \to 0\)</span> of <span class="math">\(M\)</span>.
If <span class="math">\(p^t\)</span> is the algebraic dual of <span class="math">\(p\)</span> then define
<span class="math">\(\mbox{Tr} M = \mbox{coker} p^t\)</span>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">):</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">Representation with dimension vector (1, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_generic.zero_submodule">
<tt class="descname">zero_submodule</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_generic.zero_submodule" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the zero submodule of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="xref py py-class docutils literal"><span class="pre">QuiverRep</span></tt>, the zero submodule of <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">zero_submodule</span><span class="p">()</span>
<span class="go">Representation with dimension vector (0, 0, 0)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">zero_submodule</span><span class="p">()</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.quivers.representation.QuiverRep_with_dual_path_basis">
<em class="property">class </em><tt class="descclassname">sage.quivers.representation.</tt><tt class="descname">QuiverRep_with_dual_path_basis</tt><big>(</big><em>k</em>, <em>P</em>, <em>basis</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_with_dual_path_basis" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.quivers.representation.QuiverRep_generic" title="sage.quivers.representation.QuiverRep_generic"><tt class="xref py py-class docutils literal"><span class="pre">sage.quivers.representation.QuiverRep_generic</span></tt></a></p>
<p>The basis of the module must be closed under left deletion of an edge; that
is, deleting any edge from the beginning of any path in the basis must
result in a path also contained in the basis of the module.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">k</span></tt> &#8211; ring; the base ring of the representation</li>
<li><tt class="docutils literal"><span class="pre">P</span></tt> &#8211; the path semigroup of the quiver <span class="math">\(Q\)</span> of the representation</li>
<li><tt class="docutils literal"><span class="pre">basis</span></tt> &#8211; list (default: empty); should be a list of paths (also
lists) in the quiver <span class="math">\(Q\)</span>.  Entries that do not represent valid paths
are ignored and duplicate paths are deleted.  The closure of this
list under left deletion forms the basis of the resulting
representation.</li>
</ul>
</dd></dl>

<dl class="class">
<dt id="sage.quivers.representation.QuiverRep_with_path_basis">
<em class="property">class </em><tt class="descclassname">sage.quivers.representation.</tt><tt class="descname">QuiverRep_with_path_basis</tt><big>(</big><em>k</em>, <em>P</em>, <em>basis</em><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_with_path_basis" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.quivers.representation.QuiverRep_generic" title="sage.quivers.representation.QuiverRep_generic"><tt class="xref py py-class docutils literal"><span class="pre">sage.quivers.representation.QuiverRep_generic</span></tt></a></p>
<p>The basis of the module must be closed under right multiplication by
an edge; that is, appending any edge to the end of any path in the
basis must result in either an invalid path or a valid path also
contained in the basis of the module.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">k</span></tt> &#8211; ring, the base ring of the representation</li>
<li><tt class="docutils literal"><span class="pre">P</span></tt> &#8211; the path semigroup of the quiver <span class="math">\(Q\)</span> of the representation</li>
<li><tt class="docutils literal"><span class="pre">basis</span></tt> &#8211; list (default: empty); should be a list of paths (also
lists) in the quiver <span class="math">\(Q\)</span>.  Entries that do not represent valid paths
are ignored and duplicate paths are deleted.  The closure of this
list under right multiplication forms the basis of the resulting
representation.</li>
</ul>
<dl class="method">
<dt id="sage.quivers.representation.QuiverRep_with_path_basis.is_left_module">
<tt class="descname">is_left_module</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.quivers.representation.QuiverRep_with_path_basis.is_left_module" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Test whether the basis is closed under left multiplication.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q1</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span><span class="o">.</span><span class="n">is_left_module</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The supplied basis is not closed under left multiplication, but it&#8217;s
not closed under right multiplication either.  When the closure under
right multiplication is taken the result is also closed under left
multiplication and therefore produces a left module structure:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">kQ</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">kQ</span><span class="o">.</span><span class="n">is_left_module</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Taking the right closure of a left closed set produces another
left closed set:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q2</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">1</span><span class="p">:{</span><span class="mi">2</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">]},</span> <span class="mi">2</span><span class="p">:{</span><span class="mi">3</span><span class="p">:[</span><span class="s">&#39;d&#39;</span><span class="p">]}})</span><span class="o">.</span><span class="n">path_semigroup</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Q2</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">is_left_module</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note that the second path is length 2, so even though the edge (1, 2, &#8216;a&#8217;)
appears in the input the path [(1, 2, &#8216;a&#8217;)] is not in the right closure:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Q2</span><span class="o">.</span><span class="n">representation</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">)]],</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;paths&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">is_left_module</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="path_semigroup.html"
                                  title="previous chapter">Path Semigroups</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/quivers/representation.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="path_semigroup.html" title="Path Semigroups"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Quivers</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2015, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>