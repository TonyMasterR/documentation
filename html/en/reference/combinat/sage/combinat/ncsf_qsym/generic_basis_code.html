<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Generic code for bases &mdash; Sage Reference Manual v7.0: Combinatorics</title>
    
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v7.0: Combinatorics" href="../../../index.html" />
    <link rel="up" title="Comprehensive Module list" href="../../../module_list.html" />
    <link rel="next" title="Non-Commutative Symmetric Functions" href="ncsf.html" />
    <link rel="prev" title="Common combinatorial tools" href="combinatorics.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ncsf.html" title="Non-Commutative Symmetric Functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="combinatorics.html" title="Common combinatorial tools"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">Combinatorics</a> &raquo;</li>

          <li><a href="../../../module_list.html" accesskey="U">Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="generic-code-for-bases">
<span id="sage-combinat-ncsf-qsym-generic-basis-code"></span><h1>Generic code for bases<a class="headerlink" href="#generic-code-for-bases" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.ncsf_qsym.generic_basis_code"></span><p>This is a collection of code that is shared by bases of noncommutative
symmetric functions and quasisymmetric functions.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li>Jason Bandlow</li>
<li>Franco Saliola</li>
<li>Chris Berg</li>
</ul>
<dl class="class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.AlgebraMorphism">
<em class="property">class </em><tt class="descclassname">sage.combinat.ncsf_qsym.generic_basis_code.</tt><tt class="descname">AlgebraMorphism</tt><big>(</big><em>domain</em>, <em>on_generators</em>, <em>position=0</em>, <em>codomain=None</em>, <em>category=None</em>, <em>anti=False</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.AlgebraMorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../modules/sage/modules/with_basis/morphism.html#sage.modules.with_basis.morphism.ModuleMorphismByLinearity" title="(in Sage Reference Manual: Modules v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">sage.modules.with_basis.morphism.ModuleMorphismByLinearity</span></tt></a></p>
<p>A class for algebra morphism defined on a free algebra from the image of the generators</p>
</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF">
<em class="property">class </em><tt class="descclassname">sage.combinat.ncsf_qsym.generic_basis_code.</tt><tt class="descname">BasesOfQSymOrNCSF</tt><big>(</big><em>parent_with_realization</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Sage Reference Manual: Category Framework v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.realizations.Category_realization_of_parent</span></tt></a></p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.realizations</span> <span class="kn">import</span> <span class="n">Category_realization_of_parent</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Sets</span><span class="p">()</span><span class="o">.</span><span class="n">WithRealizations</span><span class="p">()</span><span class="o">.</span><span class="n">example</span><span class="p">();</span> <span class="n">A</span>
<span class="go">The subset algebra of {1, 2, 3} over Rational Field</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">Realizations</span><span class="p">();</span> <span class="n">C</span>
<span class="go">Category of realizations of The subset algebra of {1, 2, 3} over Rational Field</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">Category_realization_of_parent</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">parent_with_realization</span>
<span class="go">The subset algebra of {1, 2, 3} over Rational Field</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">skip</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;_test_category_over_bases&quot;</span><span class="p">])</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Fix the failing test by making <tt class="docutils literal"><span class="pre">C</span></tt> a singleton
category. This will require some fiddling with the
assertion in <tt class="xref py py-meth docutils literal"><span class="pre">Category_singleton.__classcall__()</span></tt></p>
</div>
<dl class="class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods">
<em class="property">class </em><tt class="descname">ElementMethods</tt><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.degree">
<tt class="descname">degree</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.degree" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum of the degrees of the homogeneous summands.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-meth docutils literal"><span class="pre">homogeneous_degree()</span></tt></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">F</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">the zero element does not have a well-defined degree</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">F</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">the zero element does not have a well-defined degree</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.degree_negation">
<tt class="descname">degree_negation</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.degree_negation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <tt class="docutils literal"><span class="pre">self</span></tt> under the degree negation
automorphism of the parent of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The degree negation is the automorphism which scales every
homogeneous element of degree <span class="math">\(k\)</span> by <span class="math">\((-1)^k\)</span> (for all <span class="math">\(k\)</span>).</p>
<p>Calling <tt class="docutils literal"><span class="pre">degree_negation(self)</span></tt> is equivalent to calling
<tt class="docutils literal"><span class="pre">self.parent().degree_negation(self)</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">S</span><span class="p">[[]]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">()</span>
<span class="go">-3*S[] + 4*S[1, 1] + 5*S[1, 2] - 2*S[2, 1]</span>

<span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dI</span> <span class="o">=</span> <span class="n">QSym</span><span class="o">.</span><span class="n">dualImmaculate</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">dI</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">dI</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dI</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">()</span>
<span class="go">-2*dI[1] + 4*dI[2] + 3*dI[2, 1]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>The zero element behaves well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">();</span> <span class="n">a</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">Non-Commutative Symmetric Functions over the Integer Ring in the Complete basis</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">Generalize this to all graded vector spaces?</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.duality_pairing">
<tt class="descname">duality_pairing</tt><big>(</big><em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.duality_pairing" title="Permalink to this definition">¶</a></dt>
<dd><p>The duality pairing between elements of <span class="math">\(NSym\)</span> and elements
of <span class="math">\(QSym\)</span>.</p>
<p>The complete basis is dual to the monomial basis with respect
to this pairing.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">y</span></tt> &#8211; an element of the dual Hopf algebra of <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The result of pairing <tt class="docutils literal"><span class="pre">self</span></tt> with <tt class="docutils literal"><span class="pre">y</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Elementary</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.skew_by">
<tt class="descname">skew_by</tt><big>(</big><em>y</em>, <em>side='left'</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.skew_by" title="Permalink to this definition">¶</a></dt>
<dd><p>The operation which is dual to multiplication by <tt class="docutils literal"><span class="pre">y</span></tt>, where <tt class="docutils literal"><span class="pre">y</span></tt>
is an element of the dual space of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This is calculated through the coproduct of <tt class="docutils literal"><span class="pre">self</span></tt> and the
expansion of <tt class="docutils literal"><span class="pre">y</span></tt> in the dual basis.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">y</span></tt> &#8211; an element of the dual Hopf algebra of <tt class="docutils literal"><span class="pre">self</span></tt></li>
<li><tt class="docutils literal"><span class="pre">side</span></tt> &#8211; (Default=&#8217;left&#8217;) Either &#8216;left&#8217; or &#8216;right&#8217;</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The result of skewing <tt class="docutils literal"><span class="pre">self</span></tt> by <tt class="docutils literal"><span class="pre">y</span></tt>, on the side <tt class="docutils literal"><span class="pre">side</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<p>Skewing an element of NCSF by an element of QSym:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">R[1, 1, 2] + R[1, 2, 1] + R[1, 3] + R[2, 1, 1] + 2*R[2, 2] + R[3, 1] + R[4]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">R[1, 1, 2] + R[1, 2, 1] + R[1, 3] + R[2, 1, 1] + 3*R[2, 2] + R[3, 1] + R[4]</span>
</pre></div>
</div>
<p>Skewing an element of QSym by an element of NCSF:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">F</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s">&#39;right&#39;</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s">&#39;right&#39;</span><span class="p">)</span>
<span class="go">F[2]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s">&#39;right&#39;</span><span class="p">)</span>
<span class="go">F[2]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s">&#39;right&#39;</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">F[2]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">F[1, 2]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">F[2, 2]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s">&#39;right&#39;</span><span class="p">)</span>
<span class="go">M[3]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">M[2]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s">&#39;right&#39;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods">
<em class="property">class </em><tt class="descclassname">BasesOfQSymOrNCSF.</tt><tt class="descname">ParentMethods</tt><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.alternating_sum_of_compositions">
<tt class="descname">alternating_sum_of_compositions</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.alternating_sum_of_compositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternating sum over compositions of <tt class="docutils literal"><span class="pre">n</span></tt>.</p>
<p>Note that this differs from the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.alternating_sum_of_finer_compositions" title="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.alternating_sum_of_finer_compositions"><tt class="xref py py-meth docutils literal"><span class="pre">alternating_sum_of_finer_compositions()</span></tt></a> because the
coefficient of the composition <span class="math">\(1^n\)</span> is positive.  This
method is used in the expansion of the elementary generators
into the complete generators and vice versa.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; a positive integer</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The expansion of the complete generator indexed by <tt class="docutils literal"><span class="pre">n</span></tt>
into the elementary basis.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">L</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">alternating_sum_of_compositions</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">L[]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">alternating_sum_of_compositions</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">L[1]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">alternating_sum_of_compositions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">L[1, 1] - L[2]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">alternating_sum_of_compositions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">L[1, 1, 1] - L[1, 2] - L[2, 1] + L[3]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">alternating_sum_of_compositions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">S[1, 1, 1] - S[1, 2] - S[2, 1] + S[3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.alternating_sum_of_fatter_compositions">
<tt class="descname">alternating_sum_of_fatter_compositions</tt><big>(</big><em>composition</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.alternating_sum_of_fatter_compositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the alternating sum of fatter compositions in a basis of the
non-commutative symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">composition</span></tt> &#8211; a composition</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The alternating sum of the compositions fatter than <tt class="docutils literal"><span class="pre">composition</span></tt>,
in the basis <tt class="docutils literal"><span class="pre">self</span></tt>. The alternation is upon the length of the
compositions, and is normalized so that <tt class="docutils literal"><span class="pre">composition</span></tt> has
coefficient <span class="math">\(1\)</span>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NCSF</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">elementary</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">elementary</span><span class="o">.</span><span class="n">alternating_sum_of_fatter_compositions</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">L[2, 2, 1] - L[2, 3] - L[4, 1] + L[5]</span>
<span class="gp">sage: </span><span class="n">elementary</span><span class="o">.</span><span class="n">alternating_sum_of_fatter_compositions</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">L[1, 2] - L[3]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">complete</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">complete</span><span class="o">.</span><span class="n">alternating_sum_of_fatter_compositions</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">coefficients</span><span class="p">()]</span>
<span class="go">[Integer Ring, Integer Ring]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.alternating_sum_of_finer_compositions">
<tt class="descname">alternating_sum_of_finer_compositions</tt><big>(</big><em>composition</em>, <em>conjugate=False</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.alternating_sum_of_finer_compositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the alternating sum of finer compositions in a basis of the
non-commutative symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">composition</span></tt> &#8211; a composition</li>
<li><tt class="docutils literal"><span class="pre">conjugate</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a boolean</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The alternating sum of the compositions finer than <tt class="docutils literal"><span class="pre">composition</span></tt>,
in the basis <tt class="docutils literal"><span class="pre">self</span></tt>. The alternation is upon the length of the
compositions, and is normalized so that <tt class="docutils literal"><span class="pre">composition</span></tt> has
coefficient <span class="math">\(1\)</span>. If the variable <tt class="docutils literal"><span class="pre">conjugate</span></tt> is set to <tt class="docutils literal"><span class="pre">True</span></tt>,
then the conjugate of <tt class="docutils literal"><span class="pre">composition</span></tt> is used instead of
<tt class="docutils literal"><span class="pre">composition</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">elementary</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">elementary</span><span class="o">.</span><span class="n">alternating_sum_of_finer_compositions</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">L[1, 1, 1, 1, 1] - L[1, 1, 2, 1] - L[2, 1, 1, 1] + L[2, 2, 1]</span>
<span class="gp">sage: </span><span class="n">elementary</span><span class="o">.</span><span class="n">alternating_sum_of_finer_compositions</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">-L[1, 1, 1] + L[1, 2]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">complete</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">complete</span><span class="o">.</span><span class="n">alternating_sum_of_finer_compositions</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">coefficients</span><span class="p">()]</span>
<span class="go">[Integer Ring, Integer Ring]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.counit_on_basis">
<tt class="descname">counit_on_basis</tt><big>(</big><em>I</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.counit_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>The counit is defined by sending all elements of positive degree to zero.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">counit_on_basis</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">counit_on_basis</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">counit_on_basis</span><span class="p">([])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">counit_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([]))</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">counit_on_basis</span><span class="p">([])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">counit_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([]))</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.degree_negation">
<tt class="descname">degree_negation</tt><big>(</big><em>element</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.degree_negation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <tt class="docutils literal"><span class="pre">element</span></tt> under the degree negation
automorphism of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The degree negation is the automorphism which scales every
homogeneous element of degree <span class="math">\(k\)</span> by <span class="math">\((-1)^k\)</span> (for all <span class="math">\(k\)</span>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">element</span></tt> &#8211; element of <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">S</span><span class="p">[[]]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">-3*S[] + 4*S[1, 1] + 5*S[1, 2] - 2*S[2, 1]</span>

<span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dI</span> <span class="o">=</span> <span class="n">QSym</span><span class="o">.</span><span class="n">dualImmaculate</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">dI</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">dI</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dI</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">dI</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">-2*dI[1] + 4*dI[2] + 3*dI[2, 1]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Using <a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.degree_negation" title="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.degree_negation"><tt class="xref py py-meth docutils literal"><span class="pre">degree_negation()</span></tt></a> on an element of a different
basis works correctly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">-S[1, 1] + 2*S[2]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">-S[1, 1, 1] + 3/2*S[1, 2] + 3/2*S[2, 1] - 3*S[3]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">-1/6*Phi[1, 1, 1] - 1/4*Phi[1, 2] - 1/4*Phi[2, 1] - 1/3*Phi[3]</span>
</pre></div>
</div>
<p>The zero element behaves well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">Phi</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">zero</span><span class="p">());</span> <span class="n">a</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Phi basis</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">Generalize this to all graded vector spaces?</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.degree_on_basis">
<tt class="descname">degree_on_basis</tt><big>(</big><em>I</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.degree_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree of the basis element indexed by <span class="math">\(I\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">I</span></tt> &#8211; a composition</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The degree of the non-commutative symmetric function basis
element of <tt class="docutils literal"><span class="pre">self</span></tt> indexed by <tt class="docutils literal"><span class="pre">I</span></tt>. By definition, this is
the size of the composition <tt class="docutils literal"><span class="pre">I</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">degree_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">degree_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">degree_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([]))</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.duality_pairing">
<tt class="descname">duality_pairing</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.duality_pairing" title="Permalink to this definition">¶</a></dt>
<dd><p>The duality pairing between elements of <span class="math">\(NSym\)</span> and elements
of <span class="math">\(QSym\)</span>.</p>
<p>This is a default implementation that uses
<tt class="docutils literal"><span class="pre">self.realizations_of().a_realization()</span></tt> and its dual basis.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; an element of <tt class="docutils literal"><span class="pre">self</span></tt></li>
<li><tt class="docutils literal"><span class="pre">y</span></tt> &#8211; an element in the dual basis of <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The result of pairing the function <tt class="docutils literal"><span class="pre">x</span></tt> from <tt class="docutils literal"><span class="pre">self</span></tt> with the function
<tt class="docutils literal"><span class="pre">y</span></tt> from the dual basis of <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="go">1</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>The result has the right parent even if the sum is empty:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">zero</span><span class="p">(),</span> <span class="n">F</span><span class="o">.</span><span class="n">zero</span><span class="p">());</span> <span class="n">x</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.duality_pairing_by_coercion">
<tt class="descname">duality_pairing_by_coercion</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.duality_pairing_by_coercion" title="Permalink to this definition">¶</a></dt>
<dd><p>The duality pairing between elements of NSym and elements of QSym.</p>
<p>This is a default implementation that uses
<tt class="docutils literal"><span class="pre">self.realizations_of().a_realization()</span></tt> and its dual basis.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; an element of <tt class="docutils literal"><span class="pre">self</span></tt></li>
<li><tt class="docutils literal"><span class="pre">y</span></tt> &#8211; an element in the dual basis of <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The result of pairing the function <tt class="docutils literal"><span class="pre">x</span></tt> from <tt class="docutils literal"><span class="pre">self</span></tt> with
the function <tt class="docutils literal"><span class="pre">y</span></tt> from the dual basis of <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Elementary</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">duality_pairing_by_coercion</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">duality_pairing_by_coercion</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">duality_pairing_by_coercion</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">duality_pairing_by_coercion</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>The result has the right parent even if the sum is empty:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">duality_pairing_by_coercion</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">zero</span><span class="p">(),</span> <span class="n">L</span><span class="o">.</span><span class="n">zero</span><span class="p">());</span> <span class="n">x</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.duality_pairing_matrix">
<tt class="descname">duality_pairing_matrix</tt><big>(</big><em>basis</em>, <em>degree</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.duality_pairing_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The matrix of scalar products between elements of NSym and
elements of QSym.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">basis</span></tt> &#8211; A basis of the dual Hopf algebra</li>
<li><tt class="docutils literal"><span class="pre">degree</span></tt> &#8211; a non-negative integer</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The matrix of scalar products between the basis <tt class="docutils literal"><span class="pre">self</span></tt>
and the basis <tt class="docutils literal"><span class="pre">basis</span></tt> in the dual Hopf algebra in
degree <tt class="docutils literal"><span class="pre">degree</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<p>The ribbon basis of NCSF is dual to the fundamental basis of
QSym:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[1 0 0 0]</span>
<span class="go">[0 1 0 0]</span>
<span class="go">[0 0 1 0]</span>
<span class="go">[0 0 0 1]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[1 0 0 0]</span>
<span class="go">[0 1 0 0]</span>
<span class="go">[0 0 1 0]</span>
<span class="go">[0 0 0 1]</span>
</pre></div>
</div>
<p>The complete basis of NCSF is dual to the monomial basis of
QSym:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[1 0 0 0]</span>
<span class="go">[0 1 0 0]</span>
<span class="go">[0 0 1 0]</span>
<span class="go">[0 0 0 1]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[1 0 0 0]</span>
<span class="go">[0 1 0 0]</span>
<span class="go">[0 0 1 0]</span>
<span class="go">[0 0 0 1]</span>
</pre></div>
</div>
<p>The matrix between the ribbon basis of NCSF and the monomial
basis of QSym:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[ 1 -1 -1  1]</span>
<span class="go">[ 0  1  0 -1]</span>
<span class="go">[ 0  0  1 -1]</span>
<span class="go">[ 0  0  0  1]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[ 1  0  0  0]</span>
<span class="go">[-1  1  0  0]</span>
<span class="go">[-1  0  1  0]</span>
<span class="go">[ 1 -1 -1  1]</span>
</pre></div>
</div>
<p>The matrix between the complete basis of NCSF and the
fundamental basis of QSym:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[1 1 1 1]</span>
<span class="go">[0 1 0 1]</span>
<span class="go">[0 0 1 1]</span>
<span class="go">[0 0 0 1]</span>
</pre></div>
</div>
<p>A base case test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.one_basis">
<tt class="descname">one_basis</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.one_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the empty composition.</p>
<p>OUTPUT</p>
<ul class="simple">
<li>The empty composition.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">L</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">one_basis</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.skew">
<tt class="descname">skew</tt><big>(</big><em>x</em>, <em>y</em>, <em>side='left'</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.skew" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a function <tt class="docutils literal"><span class="pre">x</span></tt> in <tt class="docutils literal"><span class="pre">self</span></tt> skewed by a function
<tt class="docutils literal"><span class="pre">y</span></tt> in the Hopf dual of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; a non-commutative or quasi-symmetric function; it is
an element of <tt class="docutils literal"><span class="pre">self</span></tt></li>
<li><tt class="docutils literal"><span class="pre">y</span></tt> &#8211; a quasi-symmetric or non-commutative symmetric
function; it is an element of the dual algebra of <tt class="docutils literal"><span class="pre">self</span></tt></li>
<li><tt class="docutils literal"><span class="pre">side</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">'left'</span></tt>)
either <tt class="docutils literal"><span class="pre">'left'</span></tt> or <tt class="docutils literal"><span class="pre">'right'</span></tt></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The result of skewing the element <tt class="docutils literal"><span class="pre">x</span></tt> by the Hopf algebra
element <tt class="docutils literal"><span class="pre">y</span></tt> (either from the left or from the right, as
determined by <tt class="docutils literal"><span class="pre">side</span></tt>), written in the basis <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">S[1, 1, 2] + S[1, 2, 1] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">S[1, 1, 2] + S[1, 2, 1] + S[2, 1, 1] + 3*S[2, 2]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">R[1, 1, 2] + R[1, 2, 1] + R[1, 3] + R[2, 1, 1] + 2*R[2, 2] + R[3, 1] + R[4]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">R[1, 1, 2] + R[1, 2, 1] + R[1, 3] + R[2, 1, 1] + 3*R[2, 2] + R[3, 1] + R[4]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s">&#39;right&#39;</span><span class="p">)</span>
<span class="go">M[3]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">M[2]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s">&#39;right&#39;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">skew</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">x must be an element of Non-Commutative Symmetric Functions over the Rational Field</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">y must be an element of Quasisymmetric functions over the Rational Field</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">F</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">y must be an element of Non-Commutative Symmetric Functions over the Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.sum_of_fatter_compositions">
<tt class="descname">sum_of_fatter_compositions</tt><big>(</big><em>composition</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.sum_of_fatter_compositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of all fatter compositions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">composition</span></tt> &#8211; a composition</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the sum of all basis elements which are indexed by
compositions fatter (coarser?) than <tt class="docutils literal"><span class="pre">composition</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">L</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">sum_of_fatter_compositions</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">L[2, 1] + L[3]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">sum_of_fatter_compositions</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">R[1, 3] + R[4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.sum_of_finer_compositions">
<tt class="descname">sum_of_finer_compositions</tt><big>(</big><em>composition</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.sum_of_finer_compositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of all finer compositions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">composition</span></tt> &#8211; a composition</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The sum of all basis <tt class="docutils literal"><span class="pre">self</span></tt> elements which are indexed by
compositions finer than <tt class="docutils literal"><span class="pre">composition</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">L</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">sum_of_finer_compositions</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">L[1, 1, 1] + L[2, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">sum_of_finer_compositions</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">R[1, 1, 1, 1] + R[1, 1, 2] + R[1, 2, 1] + R[1, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.sum_of_partition_rearrangements">
<tt class="descname">sum_of_partition_rearrangements</tt><big>(</big><em>par</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.sum_of_partition_rearrangements" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of all basis elements indexed by compositions which can be
sorted to obtain a given partition.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">par</span></tt> &#8211; a partition</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The sum of all <tt class="docutils literal"><span class="pre">self</span></tt> basis elements indexed by compositions
which are permutations of <tt class="docutils literal"><span class="pre">par</span></tt> (without multiplicity).</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NCSF</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">elementary</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">elementary</span><span class="o">.</span><span class="n">sum_of_partition_rearrangements</span><span class="p">(</span><span class="n">Partition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">L[1, 2, 2] + L[2, 1, 2] + L[2, 2, 1]</span>
<span class="gp">sage: </span><span class="n">elementary</span><span class="o">.</span><span class="n">sum_of_partition_rearrangements</span><span class="p">(</span><span class="n">Partition</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">L[1, 2, 3] + L[1, 3, 2] + L[2, 1, 3] + L[2, 3, 1] + L[3, 1, 2] + L[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">elementary</span><span class="o">.</span><span class="n">sum_of_partition_rearrangements</span><span class="p">(</span><span class="n">Partition</span><span class="p">([]))</span>
<span class="go">L[]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.super_categories">
<tt class="descclassname">BasesOfQSymOrNCSF.</tt><tt class="descname">super_categories</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.ncsf_qsym.generic_basis_code</span> <span class="kn">import</span> <span class="n">BasesOfQSymOrNCSF</span>
<span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BasesOfQSymOrNCSF</span><span class="p">(</span><span class="n">QSym</span><span class="p">)</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of realizations of Quasisymmetric functions over the Rational Field,</span>
<span class="go"> Category of graded hopf algebras with basis over Rational Field,</span>
<span class="go"> Join of Category of realizations of hopf algebras over Rational Field and</span>
<span class="go"> Category of graded algebras over Rational Field]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct">
<em class="property">class </em><tt class="descclassname">sage.combinat.ncsf_qsym.generic_basis_code.</tt><tt class="descname">GradedModulesWithInternalProduct</tt><big>(</big><em>base</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/category_types.html#sage.categories.category_types.Category_over_base_ring" title="(in Sage Reference Manual: Category Framework v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.category_types.Category_over_base_ring</span></tt></a></p>
<p>Constructs the class of modules with internal product. This is used to give an internal
product structure to the non-commutative symmetric functions.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.ncsf_qsym.generic_basis_code</span> <span class="kn">import</span> <span class="n">GradedModulesWithInternalProduct</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="ow">in</span> <span class="n">GradedModulesWithInternalProduct</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods">
<em class="property">class </em><tt class="descname">ElementMethods</tt><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product">
<tt class="descname">internal_product</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal product of two non-commutative
symmetric functions.</p>
<p>The internal product on the algebra of non-commutative symmetric
functions is adjoint to the internal coproduct on the algebra of
quasisymmetric functions with respect to the duality pairing
between these two algebras. This means, explicitly, that any
two non-commutative symmetric functions <span class="math">\(f\)</span> and <span class="math">\(g\)</span> and any
quasi-symmetric function <span class="math">\(h\)</span> satisfy</p>
<div class="math">
\[\langle f * g, h \rangle
= \sum_i \left\langle f, h^{\prime}_i \right\rangle
\left\langle g, h^{\prime\prime}_i \right\rangle,\]</div>
<p>where we write <span class="math">\(\Delta^{\times}(h)\)</span> as <span class="math">\(\sum_i h^{\prime}_i
\otimes h^{\prime\prime}_i\)</span>. Here, <span class="math">\(f * g\)</span> denotes the internal
product of the non-commutative symmetric functions <span class="math">\(f\)</span> and <span class="math">\(g\)</span>.</p>
<p>If <span class="math">\(f\)</span> and <span class="math">\(g\)</span> are two homogeneous elements of <span class="math">\(NSym\)</span> having
distinct degrees, then the internal product <span class="math">\(f * g\)</span> is zero.</p>
<p>Explicit formulas can be given for internal products of
elements of the complete and the Psi bases. First, the formula
for the Complete basis (<a class="reference internal" href="qsym.html#ncsf1" id="id1">[NCSF1]</a> Proposition 5.1): If <span class="math">\(I\)</span> and
<span class="math">\(J\)</span> are two compositions of lengths <span class="math">\(p\)</span> and <span class="math">\(q\)</span>, respectively,
then the corresponding Complete homogeneous non-commutative
symmetric functions <span class="math">\(S^I\)</span> and <span class="math">\(S^J\)</span> have internal product</p>
<div class="math">
\[S^I * S^J = \sum S^{\operatorname*{comp}M},\]</div>
<p>where the sum ranges over all <span class="math">\(p \times q\)</span>-matrices
<span class="math">\(M \in \NN^{p \times q}\)</span> (with nonnegative integers as
entries) whose row sum vector is <span class="math">\(I\)</span> (that is, the sum of the
entries of the <span class="math">\(r\)</span>-th row is the <span class="math">\(r\)</span>-th part of <span class="math">\(I\)</span> for all
<span class="math">\(r\)</span>) and whose column sum vector is <span class="math">\(J\)</span> (that is, the sum of
all entries of the <span class="math">\(s\)</span>-th row is the <span class="math">\(s\)</span>-th part of <span class="math">\(J\)</span> for
all <span class="math">\(s\)</span>). Here, for any <span class="math">\(M \in \NN^{p \times q}\)</span>, we denote
by <span class="math">\(\operatorname*{comp}M\)</span> the composition obtained by
reading the entries of the matrix <span class="math">\(M\)</span> in the usual order
(row by row, proceeding left to right in each row,
traversing the rows from top to bottom).</p>
<p>The formula on the Psi basis (<a class="reference internal" href="qsym.html#ncsf2" id="id2">[NCSF2]</a> Lemma 3.10) is more
complicated. Let <span class="math">\(I\)</span> and <span class="math">\(J\)</span> be two compositions of lengths
<span class="math">\(p\)</span> and <span class="math">\(q\)</span>, respectively, having the same size <span class="math">\(|I| = |J|\)</span>.
We denote by <span class="math">\(\Psi^K\)</span> the element of the Psi basis
corresponding to any composition <span class="math">\(K\)</span>.</p>
<ul class="simple">
<li>If <span class="math">\(p &gt; q\)</span>, then <span class="math">\(\Psi^I * \Psi^J\)</span> is plainly <span class="math">\(0\)</span>.</li>
<li>Assume that <span class="math">\(p = q\)</span>. Let <span class="math">\(\widetilde{\delta}_{I, J}\)</span> denote
the integer <span class="math">\(1\)</span> if the compositions <span class="math">\(I\)</span> and <span class="math">\(J\)</span> are
permutations of each other, and the integer <span class="math">\(0\)</span> otherwise.
For every positive integer <span class="math">\(i\)</span>, let <span class="math">\(m_i\)</span> denote the number
of parts of <span class="math">\(I\)</span> equal to <span class="math">\(i\)</span>. Then, <span class="math">\(\Psi^I * \Psi^J\)</span> equals
<span class="math">\(\widetilde{\delta}_{I, J} \prod_{i&gt;0} i^{m_i} m_i! \Psi^I\)</span>.</li>
<li>Now assume that <span class="math">\(p &lt; q\)</span>. Write the composition <span class="math">\(I\)</span> as
<span class="math">\(I = (i_1, i_2, \ldots, i_p)\)</span>. For every nonempty
composition <span class="math">\(K = (k_1, k_2, \ldots, k_s)\)</span>, denote by
<span class="math">\(\Gamma_K\)</span> the non-commutative symmetric function
<span class="math">\(k_1 [\ldots [[\Psi_{k_1}, \Psi_{k_2}], \Psi_{k_3}],
\ldots \Psi_{k_s}]\)</span>. For any subset <span class="math">\(A\)</span> of
<span class="math">\(\{ 1, 2, \ldots, q \}\)</span>, let <span class="math">\(J_A\)</span> be the composition
obtained from <span class="math">\(J\)</span> by removing the <span class="math">\(r\)</span>-th parts for all
<span class="math">\(r \notin A\)</span> (while keeping the <span class="math">\(r\)</span>-th parts for all
<span class="math">\(r \in A\)</span> in order). Then, <span class="math">\(\Psi^I * \Psi^J\)</span> equals the
sum of <span class="math">\(\Gamma_{J_{K_1}} \Gamma_{J_{K_2}} \cdots
\Gamma_{J_{K_p}}\)</span> over all ordered set partitions
<span class="math">\((K_1, K_2, \ldots, K_p)\)</span> of <span class="math">\(\{ 1, 2, \ldots, q \}\)</span>
into <span class="math">\(p\)</span> parts such that each <span class="math">\(1 \leq k \leq p\)</span> satisfies
<span class="math">\(\left\lvert J_{K_k} \right\rvert = i_k\)</span>.
(See
<a class="reference internal" href="../set_partition_ordered.html#sage.combinat.set_partition_ordered.OrderedSetPartition" title="sage.combinat.set_partition_ordered.OrderedSetPartition"><tt class="xref py py-meth docutils literal"><span class="pre">OrderedSetPartition()</span></tt></a>
for the meaning of &#8220;ordered set partition&#8221;.)</li>
</ul>
<p>Aliases for <a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product"><tt class="xref py py-meth docutils literal"><span class="pre">internal_product()</span></tt></a> are <a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.itensor" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.itensor"><tt class="xref py py-meth docutils literal"><span class="pre">itensor()</span></tt></a> and
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.kronecker_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.kronecker_product"><tt class="xref py py-meth docutils literal"><span class="pre">kronecker_product()</span></tt></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; another non-commutative symmetric function</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The result of taking the internal product of <tt class="docutils literal"><span class="pre">self</span></tt> with
<tt class="docutils literal"><span class="pre">other</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*S[] + 2*S[1] + 3*S[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">3*S[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*S[1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">S[1, 1, 1] + S[1, 2]</span>
</pre></div>
</div>
<p>Let us check the duality between the inner product and the inner
coproduct in degree <span class="math">\(4\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_incopr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>  <span class="c"># computes \sum_i \left&lt; f, h&#39;_i \right&gt; \left&lt; g, h&#39;&#39;_i \right&gt;</span>
<span class="go">....:     result = h.base_ring().zero()</span>
<span class="go">....:     h_parent = h.parent()</span>
<span class="go">....:     for partition_pair, coeff in h.internal_coproduct().monomial_coefficients().items():</span>
<span class="go">....:         result += coeff * f.duality_pairing(h_parent[partition_pair[0]]) * g.duality_pairing(h_parent[partition_pair[1]])</span>
<span class="go">....:     return result</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">testall</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="go">....:     return all( all( all( tensor_incopr(S[u], S[v], M[w]) == (S[u].itensor(S[v])).duality_pairing(M[w])</span>
<span class="go">....:                           for w in Compositions(n) )</span>
<span class="go">....:                      for v in Compositions(n) )</span>
<span class="go">....:                 for u in Compositions(n) )</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c"># long time</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The internal product on the algebra of non-commutative symmetric
functions commutes with the canonical commutative projection on
the symmetric functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">int_pr_of_S_in_e</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">):</span>
<span class="go">....:     return (S[I].internal_product(S[J])).to_symmetric_function()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">int_pr_of_S_in_e</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="go">....:           == S[I].to_symmetric_function().internal_product(S[J].to_symmetric_function())</span>
<span class="go">....:           for I in Compositions(3) )</span>
<span class="go">....:      for J in Compositions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.itensor">
<tt class="descname">itensor</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.itensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal product of two non-commutative
symmetric functions.</p>
<p>The internal product on the algebra of non-commutative symmetric
functions is adjoint to the internal coproduct on the algebra of
quasisymmetric functions with respect to the duality pairing
between these two algebras. This means, explicitly, that any
two non-commutative symmetric functions <span class="math">\(f\)</span> and <span class="math">\(g\)</span> and any
quasi-symmetric function <span class="math">\(h\)</span> satisfy</p>
<div class="math">
\[\langle f * g, h \rangle
= \sum_i \left\langle f, h^{\prime}_i \right\rangle
\left\langle g, h^{\prime\prime}_i \right\rangle,\]</div>
<p>where we write <span class="math">\(\Delta^{\times}(h)\)</span> as <span class="math">\(\sum_i h^{\prime}_i
\otimes h^{\prime\prime}_i\)</span>. Here, <span class="math">\(f * g\)</span> denotes the internal
product of the non-commutative symmetric functions <span class="math">\(f\)</span> and <span class="math">\(g\)</span>.</p>
<p>If <span class="math">\(f\)</span> and <span class="math">\(g\)</span> are two homogeneous elements of <span class="math">\(NSym\)</span> having
distinct degrees, then the internal product <span class="math">\(f * g\)</span> is zero.</p>
<p>Explicit formulas can be given for internal products of
elements of the complete and the Psi bases. First, the formula
for the Complete basis (<a class="reference internal" href="qsym.html#ncsf1" id="id3">[NCSF1]</a> Proposition 5.1): If <span class="math">\(I\)</span> and
<span class="math">\(J\)</span> are two compositions of lengths <span class="math">\(p\)</span> and <span class="math">\(q\)</span>, respectively,
then the corresponding Complete homogeneous non-commutative
symmetric functions <span class="math">\(S^I\)</span> and <span class="math">\(S^J\)</span> have internal product</p>
<div class="math">
\[S^I * S^J = \sum S^{\operatorname*{comp}M},\]</div>
<p>where the sum ranges over all <span class="math">\(p \times q\)</span>-matrices
<span class="math">\(M \in \NN^{p \times q}\)</span> (with nonnegative integers as
entries) whose row sum vector is <span class="math">\(I\)</span> (that is, the sum of the
entries of the <span class="math">\(r\)</span>-th row is the <span class="math">\(r\)</span>-th part of <span class="math">\(I\)</span> for all
<span class="math">\(r\)</span>) and whose column sum vector is <span class="math">\(J\)</span> (that is, the sum of
all entries of the <span class="math">\(s\)</span>-th row is the <span class="math">\(s\)</span>-th part of <span class="math">\(J\)</span> for
all <span class="math">\(s\)</span>). Here, for any <span class="math">\(M \in \NN^{p \times q}\)</span>, we denote
by <span class="math">\(\operatorname*{comp}M\)</span> the composition obtained by
reading the entries of the matrix <span class="math">\(M\)</span> in the usual order
(row by row, proceeding left to right in each row,
traversing the rows from top to bottom).</p>
<p>The formula on the Psi basis (<a class="reference internal" href="qsym.html#ncsf2" id="id4">[NCSF2]</a> Lemma 3.10) is more
complicated. Let <span class="math">\(I\)</span> and <span class="math">\(J\)</span> be two compositions of lengths
<span class="math">\(p\)</span> and <span class="math">\(q\)</span>, respectively, having the same size <span class="math">\(|I| = |J|\)</span>.
We denote by <span class="math">\(\Psi^K\)</span> the element of the Psi basis
corresponding to any composition <span class="math">\(K\)</span>.</p>
<ul class="simple">
<li>If <span class="math">\(p &gt; q\)</span>, then <span class="math">\(\Psi^I * \Psi^J\)</span> is plainly <span class="math">\(0\)</span>.</li>
<li>Assume that <span class="math">\(p = q\)</span>. Let <span class="math">\(\widetilde{\delta}_{I, J}\)</span> denote
the integer <span class="math">\(1\)</span> if the compositions <span class="math">\(I\)</span> and <span class="math">\(J\)</span> are
permutations of each other, and the integer <span class="math">\(0\)</span> otherwise.
For every positive integer <span class="math">\(i\)</span>, let <span class="math">\(m_i\)</span> denote the number
of parts of <span class="math">\(I\)</span> equal to <span class="math">\(i\)</span>. Then, <span class="math">\(\Psi^I * \Psi^J\)</span> equals
<span class="math">\(\widetilde{\delta}_{I, J} \prod_{i&gt;0} i^{m_i} m_i! \Psi^I\)</span>.</li>
<li>Now assume that <span class="math">\(p &lt; q\)</span>. Write the composition <span class="math">\(I\)</span> as
<span class="math">\(I = (i_1, i_2, \ldots, i_p)\)</span>. For every nonempty
composition <span class="math">\(K = (k_1, k_2, \ldots, k_s)\)</span>, denote by
<span class="math">\(\Gamma_K\)</span> the non-commutative symmetric function
<span class="math">\(k_1 [\ldots [[\Psi_{k_1}, \Psi_{k_2}], \Psi_{k_3}],
\ldots \Psi_{k_s}]\)</span>. For any subset <span class="math">\(A\)</span> of
<span class="math">\(\{ 1, 2, \ldots, q \}\)</span>, let <span class="math">\(J_A\)</span> be the composition
obtained from <span class="math">\(J\)</span> by removing the <span class="math">\(r\)</span>-th parts for all
<span class="math">\(r \notin A\)</span> (while keeping the <span class="math">\(r\)</span>-th parts for all
<span class="math">\(r \in A\)</span> in order). Then, <span class="math">\(\Psi^I * \Psi^J\)</span> equals the
sum of <span class="math">\(\Gamma_{J_{K_1}} \Gamma_{J_{K_2}} \cdots
\Gamma_{J_{K_p}}\)</span> over all ordered set partitions
<span class="math">\((K_1, K_2, \ldots, K_p)\)</span> of <span class="math">\(\{ 1, 2, \ldots, q \}\)</span>
into <span class="math">\(p\)</span> parts such that each <span class="math">\(1 \leq k \leq p\)</span> satisfies
<span class="math">\(\left\lvert J_{K_k} \right\rvert = i_k\)</span>.
(See
<a class="reference internal" href="../set_partition_ordered.html#sage.combinat.set_partition_ordered.OrderedSetPartition" title="sage.combinat.set_partition_ordered.OrderedSetPartition"><tt class="xref py py-meth docutils literal"><span class="pre">OrderedSetPartition()</span></tt></a>
for the meaning of &#8220;ordered set partition&#8221;.)</li>
</ul>
<p>Aliases for <a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product"><tt class="xref py py-meth docutils literal"><span class="pre">internal_product()</span></tt></a> are <a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.itensor" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.itensor"><tt class="xref py py-meth docutils literal"><span class="pre">itensor()</span></tt></a> and
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.kronecker_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.kronecker_product"><tt class="xref py py-meth docutils literal"><span class="pre">kronecker_product()</span></tt></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; another non-commutative symmetric function</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The result of taking the internal product of <tt class="docutils literal"><span class="pre">self</span></tt> with
<tt class="docutils literal"><span class="pre">other</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*S[] + 2*S[1] + 3*S[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">3*S[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*S[1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">S[1, 1, 1] + S[1, 2]</span>
</pre></div>
</div>
<p>Let us check the duality between the inner product and the inner
coproduct in degree <span class="math">\(4\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_incopr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>  <span class="c"># computes \sum_i \left&lt; f, h&#39;_i \right&gt; \left&lt; g, h&#39;&#39;_i \right&gt;</span>
<span class="go">....:     result = h.base_ring().zero()</span>
<span class="go">....:     h_parent = h.parent()</span>
<span class="go">....:     for partition_pair, coeff in h.internal_coproduct().monomial_coefficients().items():</span>
<span class="go">....:         result += coeff * f.duality_pairing(h_parent[partition_pair[0]]) * g.duality_pairing(h_parent[partition_pair[1]])</span>
<span class="go">....:     return result</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">testall</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="go">....:     return all( all( all( tensor_incopr(S[u], S[v], M[w]) == (S[u].itensor(S[v])).duality_pairing(M[w])</span>
<span class="go">....:                           for w in Compositions(n) )</span>
<span class="go">....:                      for v in Compositions(n) )</span>
<span class="go">....:                 for u in Compositions(n) )</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c"># long time</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The internal product on the algebra of non-commutative symmetric
functions commutes with the canonical commutative projection on
the symmetric functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">int_pr_of_S_in_e</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">):</span>
<span class="go">....:     return (S[I].internal_product(S[J])).to_symmetric_function()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">int_pr_of_S_in_e</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="go">....:           == S[I].to_symmetric_function().internal_product(S[J].to_symmetric_function())</span>
<span class="go">....:           for I in Compositions(3) )</span>
<span class="go">....:      for J in Compositions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.kronecker_product">
<tt class="descname">kronecker_product</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.kronecker_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal product of two non-commutative
symmetric functions.</p>
<p>The internal product on the algebra of non-commutative symmetric
functions is adjoint to the internal coproduct on the algebra of
quasisymmetric functions with respect to the duality pairing
between these two algebras. This means, explicitly, that any
two non-commutative symmetric functions <span class="math">\(f\)</span> and <span class="math">\(g\)</span> and any
quasi-symmetric function <span class="math">\(h\)</span> satisfy</p>
<div class="math">
\[\langle f * g, h \rangle
= \sum_i \left\langle f, h^{\prime}_i \right\rangle
\left\langle g, h^{\prime\prime}_i \right\rangle,\]</div>
<p>where we write <span class="math">\(\Delta^{\times}(h)\)</span> as <span class="math">\(\sum_i h^{\prime}_i
\otimes h^{\prime\prime}_i\)</span>. Here, <span class="math">\(f * g\)</span> denotes the internal
product of the non-commutative symmetric functions <span class="math">\(f\)</span> and <span class="math">\(g\)</span>.</p>
<p>If <span class="math">\(f\)</span> and <span class="math">\(g\)</span> are two homogeneous elements of <span class="math">\(NSym\)</span> having
distinct degrees, then the internal product <span class="math">\(f * g\)</span> is zero.</p>
<p>Explicit formulas can be given for internal products of
elements of the complete and the Psi bases. First, the formula
for the Complete basis (<a class="reference internal" href="qsym.html#ncsf1" id="id5">[NCSF1]</a> Proposition 5.1): If <span class="math">\(I\)</span> and
<span class="math">\(J\)</span> are two compositions of lengths <span class="math">\(p\)</span> and <span class="math">\(q\)</span>, respectively,
then the corresponding Complete homogeneous non-commutative
symmetric functions <span class="math">\(S^I\)</span> and <span class="math">\(S^J\)</span> have internal product</p>
<div class="math">
\[S^I * S^J = \sum S^{\operatorname*{comp}M},\]</div>
<p>where the sum ranges over all <span class="math">\(p \times q\)</span>-matrices
<span class="math">\(M \in \NN^{p \times q}\)</span> (with nonnegative integers as
entries) whose row sum vector is <span class="math">\(I\)</span> (that is, the sum of the
entries of the <span class="math">\(r\)</span>-th row is the <span class="math">\(r\)</span>-th part of <span class="math">\(I\)</span> for all
<span class="math">\(r\)</span>) and whose column sum vector is <span class="math">\(J\)</span> (that is, the sum of
all entries of the <span class="math">\(s\)</span>-th row is the <span class="math">\(s\)</span>-th part of <span class="math">\(J\)</span> for
all <span class="math">\(s\)</span>). Here, for any <span class="math">\(M \in \NN^{p \times q}\)</span>, we denote
by <span class="math">\(\operatorname*{comp}M\)</span> the composition obtained by
reading the entries of the matrix <span class="math">\(M\)</span> in the usual order
(row by row, proceeding left to right in each row,
traversing the rows from top to bottom).</p>
<p>The formula on the Psi basis (<a class="reference internal" href="qsym.html#ncsf2" id="id6">[NCSF2]</a> Lemma 3.10) is more
complicated. Let <span class="math">\(I\)</span> and <span class="math">\(J\)</span> be two compositions of lengths
<span class="math">\(p\)</span> and <span class="math">\(q\)</span>, respectively, having the same size <span class="math">\(|I| = |J|\)</span>.
We denote by <span class="math">\(\Psi^K\)</span> the element of the Psi basis
corresponding to any composition <span class="math">\(K\)</span>.</p>
<ul class="simple">
<li>If <span class="math">\(p &gt; q\)</span>, then <span class="math">\(\Psi^I * \Psi^J\)</span> is plainly <span class="math">\(0\)</span>.</li>
<li>Assume that <span class="math">\(p = q\)</span>. Let <span class="math">\(\widetilde{\delta}_{I, J}\)</span> denote
the integer <span class="math">\(1\)</span> if the compositions <span class="math">\(I\)</span> and <span class="math">\(J\)</span> are
permutations of each other, and the integer <span class="math">\(0\)</span> otherwise.
For every positive integer <span class="math">\(i\)</span>, let <span class="math">\(m_i\)</span> denote the number
of parts of <span class="math">\(I\)</span> equal to <span class="math">\(i\)</span>. Then, <span class="math">\(\Psi^I * \Psi^J\)</span> equals
<span class="math">\(\widetilde{\delta}_{I, J} \prod_{i&gt;0} i^{m_i} m_i! \Psi^I\)</span>.</li>
<li>Now assume that <span class="math">\(p &lt; q\)</span>. Write the composition <span class="math">\(I\)</span> as
<span class="math">\(I = (i_1, i_2, \ldots, i_p)\)</span>. For every nonempty
composition <span class="math">\(K = (k_1, k_2, \ldots, k_s)\)</span>, denote by
<span class="math">\(\Gamma_K\)</span> the non-commutative symmetric function
<span class="math">\(k_1 [\ldots [[\Psi_{k_1}, \Psi_{k_2}], \Psi_{k_3}],
\ldots \Psi_{k_s}]\)</span>. For any subset <span class="math">\(A\)</span> of
<span class="math">\(\{ 1, 2, \ldots, q \}\)</span>, let <span class="math">\(J_A\)</span> be the composition
obtained from <span class="math">\(J\)</span> by removing the <span class="math">\(r\)</span>-th parts for all
<span class="math">\(r \notin A\)</span> (while keeping the <span class="math">\(r\)</span>-th parts for all
<span class="math">\(r \in A\)</span> in order). Then, <span class="math">\(\Psi^I * \Psi^J\)</span> equals the
sum of <span class="math">\(\Gamma_{J_{K_1}} \Gamma_{J_{K_2}} \cdots
\Gamma_{J_{K_p}}\)</span> over all ordered set partitions
<span class="math">\((K_1, K_2, \ldots, K_p)\)</span> of <span class="math">\(\{ 1, 2, \ldots, q \}\)</span>
into <span class="math">\(p\)</span> parts such that each <span class="math">\(1 \leq k \leq p\)</span> satisfies
<span class="math">\(\left\lvert J_{K_k} \right\rvert = i_k\)</span>.
(See
<a class="reference internal" href="../set_partition_ordered.html#sage.combinat.set_partition_ordered.OrderedSetPartition" title="sage.combinat.set_partition_ordered.OrderedSetPartition"><tt class="xref py py-meth docutils literal"><span class="pre">OrderedSetPartition()</span></tt></a>
for the meaning of &#8220;ordered set partition&#8221;.)</li>
</ul>
<p>Aliases for <a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product"><tt class="xref py py-meth docutils literal"><span class="pre">internal_product()</span></tt></a> are <a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.itensor" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.itensor"><tt class="xref py py-meth docutils literal"><span class="pre">itensor()</span></tt></a> and
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.kronecker_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.kronecker_product"><tt class="xref py py-meth docutils literal"><span class="pre">kronecker_product()</span></tt></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; another non-commutative symmetric function</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The result of taking the internal product of <tt class="docutils literal"><span class="pre">self</span></tt> with
<tt class="docutils literal"><span class="pre">other</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*S[] + 2*S[1] + 3*S[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">3*S[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*S[1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">S[1, 1, 1] + S[1, 2]</span>
</pre></div>
</div>
<p>Let us check the duality between the inner product and the inner
coproduct in degree <span class="math">\(4\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_incopr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>  <span class="c"># computes \sum_i \left&lt; f, h&#39;_i \right&gt; \left&lt; g, h&#39;&#39;_i \right&gt;</span>
<span class="go">....:     result = h.base_ring().zero()</span>
<span class="go">....:     h_parent = h.parent()</span>
<span class="go">....:     for partition_pair, coeff in h.internal_coproduct().monomial_coefficients().items():</span>
<span class="go">....:         result += coeff * f.duality_pairing(h_parent[partition_pair[0]]) * g.duality_pairing(h_parent[partition_pair[1]])</span>
<span class="go">....:     return result</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">testall</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="go">....:     return all( all( all( tensor_incopr(S[u], S[v], M[w]) == (S[u].itensor(S[v])).duality_pairing(M[w])</span>
<span class="go">....:                           for w in Compositions(n) )</span>
<span class="go">....:                      for v in Compositions(n) )</span>
<span class="go">....:                 for u in Compositions(n) )</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c"># long time</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The internal product on the algebra of non-commutative symmetric
functions commutes with the canonical commutative projection on
the symmetric functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">int_pr_of_S_in_e</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">):</span>
<span class="go">....:     return (S[I].internal_product(S[J])).to_symmetric_function()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">int_pr_of_S_in_e</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="go">....:           == S[I].to_symmetric_function().internal_product(S[J].to_symmetric_function())</span>
<span class="go">....:           for I in Compositions(3) )</span>
<span class="go">....:      for J in Compositions(3) )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods">
<em class="property">class </em><tt class="descclassname">GradedModulesWithInternalProduct.</tt><tt class="descname">ParentMethods</tt><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product">
<tt class="descname">internal_product</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product" title="Permalink to this definition">¶</a></dt>
<dd><p>The bilinear product inherited from the isomorphism with
the descent algebra.</p>
<p>This is constructed by extending the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product_on_basis" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product_on_basis"><tt class="xref py py-meth docutils literal"><span class="pre">internal_product_on_basis()</span></tt></a> bilinearly, if available,
or using the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods.internal_product_by_coercion" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods.internal_product_by_coercion"><tt class="xref py py-meth docutils literal"><span class="pre">internal_product_by_coercion()</span></tt></a>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The internal product map of the algebra the non-commutative
symmetric functions.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span>
<span class="go">Generic endomorphism of Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*S[1, 1, 1, 1] + S[1, 1, 2] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product</span>
<span class="go">&lt;bound method ....internal_product_by_coercion ...&gt;</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product_by_coercion</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">R[2]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product_on_basis">
<tt class="descname">internal_product_on_basis</tt><big>(</big><em>I</em>, <em>J</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>The internal product of the two basis elements indexed by <tt class="docutils literal"><span class="pre">I</span></tt> and
<tt class="docutils literal"><span class="pre">J</span></tt> (optional)</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">I</span></tt>, <tt class="docutils literal"><span class="pre">J</span></tt> &#8211; compositions indexing two elements of the basis of self</li>
</ul>
</div></blockquote>
<p>Returns the internal product of the corresponding basis elements.
If this method is implemented, the internal product is defined from
it by linearity.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product_on_basis</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*S[1, 1, 1, 1] + S[1, 1, 2] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product_on_basis</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.itensor">
<tt class="descname">itensor</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.itensor" title="Permalink to this definition">¶</a></dt>
<dd><p>The bilinear product inherited from the isomorphism with
the descent algebra.</p>
<p>This is constructed by extending the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product_on_basis" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product_on_basis"><tt class="xref py py-meth docutils literal"><span class="pre">internal_product_on_basis()</span></tt></a> bilinearly, if available,
or using the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods.internal_product_by_coercion" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods.internal_product_by_coercion"><tt class="xref py py-meth docutils literal"><span class="pre">internal_product_by_coercion()</span></tt></a>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The internal product map of the algebra the non-commutative
symmetric functions.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span>
<span class="go">Generic endomorphism of Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*S[1, 1, 1, 1] + S[1, 1, 2] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product</span>
<span class="go">&lt;bound method ....internal_product_by_coercion ...&gt;</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product_by_coercion</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">R[2]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.kronecker_product">
<tt class="descname">kronecker_product</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.kronecker_product" title="Permalink to this definition">¶</a></dt>
<dd><p>The bilinear product inherited from the isomorphism with
the descent algebra.</p>
<p>This is constructed by extending the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product_on_basis" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product_on_basis"><tt class="xref py py-meth docutils literal"><span class="pre">internal_product_on_basis()</span></tt></a> bilinearly, if available,
or using the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods.internal_product_by_coercion" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods.internal_product_by_coercion"><tt class="xref py py-meth docutils literal"><span class="pre">internal_product_by_coercion()</span></tt></a>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>The internal product map of the algebra the non-commutative
symmetric functions.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span>
<span class="go">Generic endomorphism of Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*S[1, 1, 1, 1] + S[1, 1, 2] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product</span>
<span class="go">&lt;bound method ....internal_product_by_coercion ...&gt;</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product_by_coercion</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">R[2]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations">
<em class="property">class </em><tt class="descclassname">GradedModulesWithInternalProduct.</tt><tt class="descname">Realizations</tt><big>(</big><em>category</em>, <em>*args</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.RealizationsCategory" title="(in Sage Reference Manual: Category Framework v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.realizations.RealizationsCategory</span></tt></a></p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.covariant_functorial_construction</span> <span class="kn">import</span> <span class="n">CovariantConstructionCategory</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">FooBars</span><span class="p">(</span><span class="n">CovariantConstructionCategory</span><span class="p">):</span>
<span class="go">....:     _functor_category = &quot;FooBars&quot;</span>
<span class="go">....:     _base_category_class = (Category,)</span>
<span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">FooBars</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="n">FooBars</span><span class="o">.</span><span class="n">category_of</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">FooBars</span><span class="p">(</span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">ZZ</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">Category of foo bars of modules with basis over Integer Ring</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">base_category</span><span class="p">()</span>
<span class="go">Category of modules with basis over Integer Ring</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">\mathbf{FooBars}(\mathbf{ModulesWithBasis}_{\Bold{Z}})</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span><span class="p">;</span> <span class="n">__main__</span><span class="o">.</span><span class="n">FooBars</span> <span class="o">=</span> <span class="n">FooBars</span> <span class="c"># Fake FooBars being defined in a python module</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods">
<em class="property">class </em><tt class="descname">ParentMethods</tt><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods.internal_product_by_coercion">
<tt class="descname">internal_product_by_coercion</tt><big>(</big><em>left</em>, <em>right</em><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods.internal_product_by_coercion" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal product of <tt class="docutils literal"><span class="pre">left</span></tt> and <tt class="docutils literal"><span class="pre">right</span></tt>.</p>
<p>This is a default implementation that computes
the internal product in the realization specified
by <tt class="docutils literal"><span class="pre">self.realization_of().a_realization()</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">left</span></tt> &#8211; an element of the non-commutative symmetric functions</li>
<li><tt class="docutils literal"><span class="pre">right</span></tt> &#8211; an element of the non-commutative symmetric functions</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The internal product of <tt class="docutils literal"><span class="pre">left</span></tt> and <tt class="docutils literal"><span class="pre">right</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product_by_coercion</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">S[2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product_by_coercion</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.super_categories">
<tt class="descclassname">GradedModulesWithInternalProduct.</tt><tt class="descname">super_categories</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.ncsf_qsym.generic_basis_code</span> <span class="kn">import</span> <span class="n">GradedModulesWithInternalProduct</span>
<span class="gp">sage: </span><span class="n">GradedModulesWithInternalProduct</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of graded modules over Integer Ring]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="combinatorics.html"
                                  title="previous chapter">Common combinatorial tools</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="ncsf.html"
                                  title="next chapter">Non-Commutative Symmetric Functions</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../../_sources/sage/combinat/ncsf_qsym/generic_basis_code.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ncsf.html" title="Non-Commutative Symmetric Functions"
             >next</a> |</li>
        <li class="right" >
          <a href="combinatorics.html" title="Common combinatorial tools"
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">Combinatorics</a> &raquo;</li>

          <li><a href="../../../module_list.html" >Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>