<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Finite State Machines, Automata, Transducers &mdash; Sage Reference Manual v6.9: Combinatorics</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '6.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v6.9: Combinatorics" href="../../index.html" />
    <link rel="up" title="Comprehensive Module list" href="../../module_list.html" />
    <link rel="next" title="Common Automata and Transducers (Finite State Machines Generators)" href="finite_state_machine_generators.html" />
    <link rel="prev" title="Finite combinatorial classes" href="finite_class.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="finite_state_machine_generators.html" title="Common Automata and Transducers (Finite State Machines Generators)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="finite_class.html" title="Finite combinatorial classes"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Combinatorics</a> &raquo;</li>

          <li><a href="../../module_list.html" accesskey="U">Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="finite-state-machines-automata-transducers">
<span id="sage-combinat-finite-state-machine"></span><h1>Finite State Machines, Automata, Transducers<a class="headerlink" href="#finite-state-machines-automata-transducers" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.finite_state_machine"></span><p>This module adds support for finite state machines, automata and
transducers.</p>
<p>For creating automata and transducers you can use classes</p>
<ul class="simple">
<li><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton" title="sage.combinat.finite_state_machine.Automaton"><tt class="xref py py-class docutils literal"><span class="pre">Automaton</span></tt></a> and <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer" title="sage.combinat.finite_state_machine.Transducer"><tt class="xref py py-class docutils literal"><span class="pre">Transducer</span></tt></a>
(or the more general class <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>)</li>
</ul>
<p>or the generators</p>
<ul class="simple">
<li><a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.AutomatonGenerators" title="sage.combinat.finite_state_machine_generators.AutomatonGenerators"><tt class="xref py py-class docutils literal"><span class="pre">automata</span></tt></a> and
<a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.TransducerGenerators" title="sage.combinat.finite_state_machine_generators.TransducerGenerators"><tt class="xref py py-class docutils literal"><span class="pre">transducers</span></tt></a></li>
</ul>
<p>which contain <a class="reference internal" href="finite_state_machine_generators.html"><em>preconstructed and commonly used automata and transducers</em></a>. See also the
<a class="reference internal" href="#finite-state-machine-examples"><em>examples</em></a> below.</p>
<div class="section" id="contents">
<h2>Contents<a class="headerlink" href="#contents" title="Permalink to this headline">¶</a></h2>
<div class="section" id="finitestatemachine-and-derived-classes-transducer-and-automaton">
<h3><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a> and derived classes <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer" title="sage.combinat.finite_state_machine.Transducer"><tt class="xref py py-class docutils literal"><span class="pre">Transducer</span></tt></a> and <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton" title="sage.combinat.finite_state_machine.Automaton"><tt class="xref py py-class docutils literal"><span class="pre">Automaton</span></tt></a><a class="headerlink" href="#finitestatemachine-and-derived-classes-transducer-and-automaton" title="Permalink to this headline">¶</a></h3>
<div class="section" id="accessing-parts-of-a-finite-state-machine">
<h4>Accessing parts of a finite state machine<a class="headerlink" href="#accessing-parts-of-a-finite-state-machine" title="Permalink to this headline">¶</a></h4>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.state" title="sage.combinat.finite_state_machine.FiniteStateMachine.state"><tt class="xref py py-meth docutils literal"><span class="pre">state()</span></tt></a></td>
<td>Get a state by its label</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.states" title="sage.combinat.finite_state_machine.FiniteStateMachine.states"><tt class="xref py py-meth docutils literal"><span class="pre">states()</span></tt></a></td>
<td>List of states</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_states" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_states"><tt class="xref py py-meth docutils literal"><span class="pre">iter_states()</span></tt></a></td>
<td>Iterator over the states</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.initial_states" title="sage.combinat.finite_state_machine.FiniteStateMachine.initial_states"><tt class="xref py py-meth docutils literal"><span class="pre">initial_states()</span></tt></a></td>
<td>List of initial states</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_initial_states" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_initial_states"><tt class="xref py py-meth docutils literal"><span class="pre">iter_initial_states()</span></tt></a></td>
<td>Iterator over initial states</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.final_states" title="sage.combinat.finite_state_machine.FiniteStateMachine.final_states"><tt class="xref py py-meth docutils literal"><span class="pre">final_states()</span></tt></a></td>
<td>List of final states</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_final_states" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_final_states"><tt class="xref py py-meth docutils literal"><span class="pre">iter_final_states()</span></tt></a></td>
<td>Iterator over final states</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.transition" title="sage.combinat.finite_state_machine.FiniteStateMachine.transition"><tt class="xref py py-meth docutils literal"><span class="pre">transition()</span></tt></a></td>
<td>Get a transition by its states and labels</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.transitions" title="sage.combinat.finite_state_machine.FiniteStateMachine.transitions"><tt class="xref py py-meth docutils literal"><span class="pre">transitions()</span></tt></a></td>
<td>List of transitions</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_transitions" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_transitions"><tt class="xref py py-meth docutils literal"><span class="pre">iter_transitions()</span></tt></a></td>
<td>Iterator over the transitions</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.predecessors" title="sage.combinat.finite_state_machine.FiniteStateMachine.predecessors"><tt class="xref py py-meth docutils literal"><span class="pre">predecessors()</span></tt></a></td>
<td>List of predecessors of a state</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.induced_sub_finite_state_machine" title="sage.combinat.finite_state_machine.FiniteStateMachine.induced_sub_finite_state_machine"><tt class="xref py py-meth docutils literal"><span class="pre">induced_sub_finite_state_machine()</span></tt></a></td>
<td>Induced sub-machine</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components"><tt class="xref py py-meth docutils literal"><span class="pre">accessible_components()</span></tt></a></td>
<td>Accessible components</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.final_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.final_components"><tt class="xref py py-meth docutils literal"><span class="pre">final_components()</span></tt></a></td>
<td>Final components (connected components which cannot be left again)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="modified-copies">
<h4>(Modified) Copies<a class="headerlink" href="#modified-copies" title="Permalink to this headline">¶</a></h4>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.empty_copy" title="sage.combinat.finite_state_machine.FiniteStateMachine.empty_copy"><tt class="xref py py-meth docutils literal"><span class="pre">empty_copy()</span></tt></a></td>
<td>Returns an empty deep copy</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.deepcopy" title="sage.combinat.finite_state_machine.FiniteStateMachine.deepcopy"><tt class="xref py py-meth docutils literal"><span class="pre">deepcopy()</span></tt></a></td>
<td>Returns a deep copy</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.relabeled" title="sage.combinat.finite_state_machine.FiniteStateMachine.relabeled"><tt class="xref py py-meth docutils literal"><span class="pre">relabeled()</span></tt></a></td>
<td>Returns a relabeled deep copy</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.with_output" title="sage.combinat.finite_state_machine.Automaton.with_output"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.with_output()</span></tt></a></td>
<td>Extends an automaton to a transducer</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="manipulation">
<h4>Manipulation<a class="headerlink" href="#manipulation" title="Permalink to this headline">¶</a></h4>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_state" title="sage.combinat.finite_state_machine.FiniteStateMachine.add_state"><tt class="xref py py-meth docutils literal"><span class="pre">add_state()</span></tt></a></td>
<td>Add a state</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_states" title="sage.combinat.finite_state_machine.FiniteStateMachine.add_states"><tt class="xref py py-meth docutils literal"><span class="pre">add_states()</span></tt></a></td>
<td>Add states</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.delete_state" title="sage.combinat.finite_state_machine.FiniteStateMachine.delete_state"><tt class="xref py py-meth docutils literal"><span class="pre">delete_state()</span></tt></a></td>
<td>Delete a state</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_transition" title="sage.combinat.finite_state_machine.FiniteStateMachine.add_transition"><tt class="xref py py-meth docutils literal"><span class="pre">add_transition()</span></tt></a></td>
<td>Add a transition</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_transitions_from_function" title="sage.combinat.finite_state_machine.FiniteStateMachine.add_transitions_from_function"><tt class="xref py py-meth docutils literal"><span class="pre">add_transitions_from_function()</span></tt></a></td>
<td>Add transitions</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.input_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.input_alphabet"><tt class="xref py py-attr docutils literal"><span class="pre">input_alphabet</span></tt></a></td>
<td>Input alphabet</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.output_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.output_alphabet"><tt class="xref py py-attr docutils literal"><span class="pre">output_alphabet</span></tt></a></td>
<td>Output alphabet</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition" title="sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition"><tt class="xref py py-attr docutils literal"><span class="pre">on_duplicate_transition</span></tt></a></td>
<td>Hook for handling duplicate transitions</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_from_transition_function" title="sage.combinat.finite_state_machine.FiniteStateMachine.add_from_transition_function"><tt class="xref py py-meth docutils literal"><span class="pre">add_from_transition_function()</span></tt></a></td>
<td>Add transitions by a transition function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.delete_transition" title="sage.combinat.finite_state_machine.FiniteStateMachine.delete_transition"><tt class="xref py py-meth docutils literal"><span class="pre">delete_transition()</span></tt></a></td>
<td>Delete a transition</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.remove_epsilon_transitions" title="sage.combinat.finite_state_machine.FiniteStateMachine.remove_epsilon_transitions"><tt class="xref py py-meth docutils literal"><span class="pre">remove_epsilon_transitions()</span></tt></a></td>
<td>Remove epsilon transitions (not implemented)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.split_transitions" title="sage.combinat.finite_state_machine.FiniteStateMachine.split_transitions"><tt class="xref py py-meth docutils literal"><span class="pre">split_transitions()</span></tt></a></td>
<td>Split transitions with input words of length <tt class="docutils literal"><span class="pre">&gt;</span> <span class="pre">1</span></tt></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a></td>
<td>Determines input and output alphabets</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out"><tt class="xref py py-meth docutils literal"><span class="pre">construct_final_word_out()</span></tt></a></td>
<td>Construct final output by implicitly reading trailing letters; cf. <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out"><tt class="xref py py-meth docutils literal"><span class="pre">with_final_word_out()</span></tt></a></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="properties">
<h4>Properties<a class="headerlink" href="#properties" title="Permalink to this headline">¶</a></h4>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_state" title="sage.combinat.finite_state_machine.FiniteStateMachine.has_state"><tt class="xref py py-meth docutils literal"><span class="pre">has_state()</span></tt></a></td>
<td>Checks for a state</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_initial_state" title="sage.combinat.finite_state_machine.FiniteStateMachine.has_initial_state"><tt class="xref py py-meth docutils literal"><span class="pre">has_initial_state()</span></tt></a></td>
<td>Checks for an initial state</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_initial_states" title="sage.combinat.finite_state_machine.FiniteStateMachine.has_initial_states"><tt class="xref py py-meth docutils literal"><span class="pre">has_initial_states()</span></tt></a></td>
<td>Checks for initial states</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_final_state" title="sage.combinat.finite_state_machine.FiniteStateMachine.has_final_state"><tt class="xref py py-meth docutils literal"><span class="pre">has_final_state()</span></tt></a></td>
<td>Checks for an final state</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_final_states" title="sage.combinat.finite_state_machine.FiniteStateMachine.has_final_states"><tt class="xref py py-meth docutils literal"><span class="pre">has_final_states()</span></tt></a></td>
<td>Checks for final states</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_transition" title="sage.combinat.finite_state_machine.FiniteStateMachine.has_transition"><tt class="xref py py-meth docutils literal"><span class="pre">has_transition()</span></tt></a></td>
<td>Checks for a transition</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_deterministic" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_deterministic"><tt class="xref py py-meth docutils literal"><span class="pre">is_deterministic()</span></tt></a></td>
<td>Checks for a deterministic machine</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_complete" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_complete"><tt class="xref py py-meth docutils literal"><span class="pre">is_complete()</span></tt></a></td>
<td>Checks for a complete machine</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_connected" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_connected"><tt class="xref py py-meth docutils literal"><span class="pre">is_connected()</span></tt></a></td>
<td>Checks for a connected machine</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.is_equivalent" title="sage.combinat.finite_state_machine.Automaton.is_equivalent"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.is_equivalent()</span></tt></a></td>
<td>Checks for equivalent automata</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_Markov_chain" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_Markov_chain"><tt class="xref py py-meth docutils literal"><span class="pre">is_Markov_chain()</span></tt></a></td>
<td>Checks for a Markov chain</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_monochromatic" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_monochromatic"><tt class="xref py py-meth docutils literal"><span class="pre">is_monochromatic()</span></tt></a></td>
<td>Checks whether the colors of all states are equal</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.asymptotic_moments" title="sage.combinat.finite_state_machine.FiniteStateMachine.asymptotic_moments"><tt class="xref py py-meth docutils literal"><span class="pre">asymptotic_moments()</span></tt></a></td>
<td>Main terms of expectation and variance of sums of labels</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.moments_waiting_time" title="sage.combinat.finite_state_machine.FiniteStateMachine.moments_waiting_time"><tt class="xref py py-meth docutils literal"><span class="pre">moments_waiting_time()</span></tt></a></td>
<td>Moments of the waiting time for first true output</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.epsilon_successors" title="sage.combinat.finite_state_machine.FiniteStateMachine.epsilon_successors"><tt class="xref py py-meth docutils literal"><span class="pre">epsilon_successors()</span></tt></a></td>
<td>Epsilon successors of a state</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.shannon_parry_markov_chain" title="sage.combinat.finite_state_machine.Automaton.shannon_parry_markov_chain"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.shannon_parry_markov_chain()</span></tt></a></td>
<td>Compute Markov chain with Parry measure</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="operations">
<h4>Operations<a class="headerlink" href="#operations" title="Permalink to this headline">¶</a></h4>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.disjoint_union" title="sage.combinat.finite_state_machine.FiniteStateMachine.disjoint_union"><tt class="xref py py-meth docutils literal"><span class="pre">disjoint_union()</span></tt></a></td>
<td>Disjoint union</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.concatenation" title="sage.combinat.finite_state_machine.FiniteStateMachine.concatenation"><tt class="xref py py-meth docutils literal"><span class="pre">concatenation()</span></tt></a></td>
<td>Concatenation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.kleene_star" title="sage.combinat.finite_state_machine.FiniteStateMachine.kleene_star"><tt class="xref py py-meth docutils literal"><span class="pre">kleene_star()</span></tt></a></td>
<td>Kleene star</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.complement" title="sage.combinat.finite_state_machine.Automaton.complement"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.complement()</span></tt></a></td>
<td>Complement of an automaton</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.intersection" title="sage.combinat.finite_state_machine.Automaton.intersection"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.intersection()</span></tt></a></td>
<td>Intersection of automata</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.intersection" title="sage.combinat.finite_state_machine.Transducer.intersection"><tt class="xref py py-meth docutils literal"><span class="pre">Transducer.intersection()</span></tt></a></td>
<td>Intersection of transducers</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.cartesian_product" title="sage.combinat.finite_state_machine.Transducer.cartesian_product"><tt class="xref py py-meth docutils literal"><span class="pre">Transducer.cartesian_product()</span></tt></a></td>
<td>Cartesian product of a transducer with another finite state machine</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.product_FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine.product_FiniteStateMachine"><tt class="xref py py-meth docutils literal"><span class="pre">product_FiniteStateMachine()</span></tt></a></td>
<td>Product of finite state machines</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.composition" title="sage.combinat.finite_state_machine.FiniteStateMachine.composition"><tt class="xref py py-meth docutils literal"><span class="pre">composition()</span></tt></a></td>
<td>Composition (output of other is input of self)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a></td>
<td>Composition with other finite state machine</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.input_projection" title="sage.combinat.finite_state_machine.FiniteStateMachine.input_projection"><tt class="xref py py-meth docutils literal"><span class="pre">input_projection()</span></tt></a></td>
<td>Input projection (output is deleted)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.output_projection" title="sage.combinat.finite_state_machine.FiniteStateMachine.output_projection"><tt class="xref py py-meth docutils literal"><span class="pre">output_projection()</span></tt></a></td>
<td>Output projection (old output is new input)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.projection" title="sage.combinat.finite_state_machine.FiniteStateMachine.projection"><tt class="xref py py-meth docutils literal"><span class="pre">projection()</span></tt></a></td>
<td>Input or output projection</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.transposition" title="sage.combinat.finite_state_machine.FiniteStateMachine.transposition"><tt class="xref py py-meth docutils literal"><span class="pre">transposition()</span></tt></a></td>
<td>Transposition (all transitions are reversed)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out"><tt class="xref py py-meth docutils literal"><span class="pre">with_final_word_out()</span></tt></a></td>
<td>Machine with final output constructed by implicitly reading trailing letters, cf. <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out"><tt class="xref py py-meth docutils literal"><span class="pre">construct_final_word_out()</span></tt></a> for inplace version</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.determinisation" title="sage.combinat.finite_state_machine.Automaton.determinisation"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.determinisation()</span></tt></a></td>
<td>Determinisation of an automaton</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.completion" title="sage.combinat.finite_state_machine.FiniteStateMachine.completion"><tt class="xref py py-meth docutils literal"><span class="pre">completion()</span></tt></a></td>
<td>Completion of a finite state machine</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">process()</span></tt></a></td>
<td>Process input</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a></td>
<td>Process input with shortened output</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></tt></a></td>
<td>Process input of an automaton (output differs from general case)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><tt class="xref py py-meth docutils literal"><span class="pre">Transducer.process()</span></tt></a></td>
<td>Process input of a transducer (output differs from general case)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><tt class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></tt></a></td>
<td>Return process iterator</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.language" title="sage.combinat.finite_state_machine.FiniteStateMachine.language"><tt class="xref py py-meth docutils literal"><span class="pre">language()</span></tt></a></td>
<td>Return all possible output words</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.language" title="sage.combinat.finite_state_machine.Automaton.language"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.language()</span></tt></a></td>
<td>Return all possible accepted words</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="simplification">
<h4>Simplification<a class="headerlink" href="#simplification" title="Permalink to this headline">¶</a></h4>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.prepone_output" title="sage.combinat.finite_state_machine.FiniteStateMachine.prepone_output"><tt class="xref py py-meth docutils literal"><span class="pre">prepone_output()</span></tt></a></td>
<td>Prepone output where possible</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.equivalence_classes" title="sage.combinat.finite_state_machine.FiniteStateMachine.equivalence_classes"><tt class="xref py py-meth docutils literal"><span class="pre">equivalence_classes()</span></tt></a></td>
<td>List of equivalent states</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.quotient" title="sage.combinat.finite_state_machine.FiniteStateMachine.quotient"><tt class="xref py py-meth docutils literal"><span class="pre">quotient()</span></tt></a></td>
<td>Quotient with respect to equivalence classes</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.merged_transitions" title="sage.combinat.finite_state_machine.FiniteStateMachine.merged_transitions"><tt class="xref py py-meth docutils literal"><span class="pre">merged_transitions()</span></tt></a></td>
<td>Merge transitions while adding input</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.markov_chain_simplification" title="sage.combinat.finite_state_machine.FiniteStateMachine.markov_chain_simplification"><tt class="xref py py-meth docutils literal"><span class="pre">markov_chain_simplification()</span></tt></a></td>
<td>Simplification of a Markov chain</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.minimization" title="sage.combinat.finite_state_machine.Automaton.minimization"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.minimization()</span></tt></a></td>
<td>Minimization of an automaton</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.simplification" title="sage.combinat.finite_state_machine.Transducer.simplification"><tt class="xref py py-meth docutils literal"><span class="pre">Transducer.simplification()</span></tt></a></td>
<td>Simplification of a transducer</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="conversion">
<h4>Conversion<a class="headerlink" href="#conversion" title="Permalink to this headline">¶</a></h4>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.adjacency_matrix" title="sage.combinat.finite_state_machine.FiniteStateMachine.adjacency_matrix"><tt class="xref py py-meth docutils literal"><span class="pre">adjacency_matrix()</span></tt></a></td>
<td>(Weighted) adjacency <a class="reference external" href="../../../matrices/sage/matrix/constructor.html#sage.matrix.constructor.MatrixFactory" title="(in Sage Reference Manual: Matrices and Spaces of Matrices v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">matrix</span></tt></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.graph" title="sage.combinat.finite_state_machine.FiniteStateMachine.graph"><tt class="xref py py-meth docutils literal"><span class="pre">graph()</span></tt></a></td>
<td>Underlying <a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">DiGraph</span></tt></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.plot" title="sage.combinat.finite_state_machine.FiniteStateMachine.plot"><tt class="xref py py-meth docutils literal"><span class="pre">plot()</span></tt></a></td>
<td>Plot</td>
</tr>
</tbody>
</table>
<div class="section" id="latex-output">
<h5>LaTeX output<a class="headerlink" href="#latex-output" title="Permalink to this headline">¶</a></h5>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.latex_options" title="sage.combinat.finite_state_machine.FiniteStateMachine.latex_options"><tt class="xref py py-meth docutils literal"><span class="pre">latex_options()</span></tt></a></td>
<td>Set options</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.set_coordinates" title="sage.combinat.finite_state_machine.FiniteStateMachine.set_coordinates"><tt class="xref py py-meth docutils literal"><span class="pre">set_coordinates()</span></tt></a></td>
<td>Set coordinates of the states</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label" title="sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label"><tt class="xref py py-meth docutils literal"><span class="pre">default_format_transition_label()</span></tt></a></td>
<td>Default formatting of words in transition labels</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_letter_negative" title="sage.combinat.finite_state_machine.FiniteStateMachine.format_letter_negative"><tt class="xref py py-meth docutils literal"><span class="pre">format_letter_negative()</span></tt></a></td>
<td>Format negative numbers as overlined number</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label_reversed" title="sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label_reversed"><tt class="xref py py-meth docutils literal"><span class="pre">format_transition_label_reversed()</span></tt></a></td>
<td>Format words in transition labels in reversed order</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#finite-state-machine-latex-output"><em>LaTeX output</em></a></p>
</div>
</div>
</div>
</div>
<div class="section" id="fsmstate">
<h3><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><tt class="xref py py-class docutils literal"><span class="pre">FSMState</span></tt></a><a class="headerlink" href="#fsmstate" title="Permalink to this headline">¶</a></h3>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.final_word_out" title="sage.combinat.finite_state_machine.FSMState.final_word_out"><tt class="xref py py-attr docutils literal"><span class="pre">final_word_out</span></tt></a></td>
<td>Final output of a state</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.is_final" title="sage.combinat.finite_state_machine.FSMState.is_final"><tt class="xref py py-attr docutils literal"><span class="pre">is_final</span></tt></a></td>
<td>Describes whether a state is final or not</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.is_initial" title="sage.combinat.finite_state_machine.FSMState.is_initial"><tt class="xref py py-attr docutils literal"><span class="pre">is_initial</span></tt></a></td>
<td>Describes whether a state is initial or not</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.initial_probability" title="sage.combinat.finite_state_machine.FSMState.initial_probability"><tt class="xref py py-attr docutils literal"><span class="pre">initial_probability</span></tt></a></td>
<td>Probability of starting in this state as part of a Markov chain</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.label" title="sage.combinat.finite_state_machine.FSMState.label"><tt class="xref py py-meth docutils literal"><span class="pre">label()</span></tt></a></td>
<td>Label of a state</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.relabeled" title="sage.combinat.finite_state_machine.FSMState.relabeled"><tt class="xref py py-meth docutils literal"><span class="pre">relabeled()</span></tt></a></td>
<td>Returns a relabeled deep copy of a state</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.fully_equal" title="sage.combinat.finite_state_machine.FSMState.fully_equal"><tt class="xref py py-meth docutils literal"><span class="pre">fully_equal()</span></tt></a></td>
<td>Checks whether two states are fully equal (including all attributes)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="fsmtransition">
<h3><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><tt class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></tt></a><a class="headerlink" href="#fsmtransition" title="Permalink to this headline">¶</a></h3>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition.from_state" title="sage.combinat.finite_state_machine.FSMTransition.from_state"><tt class="xref py py-attr docutils literal"><span class="pre">from_state</span></tt></a></td>
<td>State in which transition starts</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition.to_state" title="sage.combinat.finite_state_machine.FSMTransition.to_state"><tt class="xref py py-attr docutils literal"><span class="pre">to_state</span></tt></a></td>
<td>State in which transition ends</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition.word_in" title="sage.combinat.finite_state_machine.FSMTransition.word_in"><tt class="xref py py-attr docutils literal"><span class="pre">word_in</span></tt></a></td>
<td>Input word of the transition</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition.word_out" title="sage.combinat.finite_state_machine.FSMTransition.word_out"><tt class="xref py py-attr docutils literal"><span class="pre">word_out</span></tt></a></td>
<td>Output word of the transition</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition.deepcopy" title="sage.combinat.finite_state_machine.FSMTransition.deepcopy"><tt class="xref py py-meth docutils literal"><span class="pre">deepcopy()</span></tt></a></td>
<td>Returns a deep copy of the transition</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="fsmprocessiterator">
<h3><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a><a class="headerlink" href="#fsmprocessiterator" title="Permalink to this headline">¶</a></h3>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator.next" title="sage.combinat.finite_state_machine.FSMProcessIterator.next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a></td>
<td>Makes one step in processing the input tape</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator.preview_word" title="sage.combinat.finite_state_machine.FSMProcessIterator.preview_word"><tt class="xref py py-meth docutils literal"><span class="pre">preview_word()</span></tt></a></td>
<td>Reads a word from the input tape</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator.result" title="sage.combinat.finite_state_machine.FSMProcessIterator.result"><tt class="xref py py-meth docutils literal"><span class="pre">result()</span></tt></a></td>
<td>Returns the finished branches during process</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="helper-functions">
<h3>Helper Functions<a class="headerlink" href="#helper-functions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.equal" title="sage.combinat.finite_state_machine.equal"><tt class="xref py py-func docutils literal"><span class="pre">equal()</span></tt></a></td>
<td>Checks whether all elements of <tt class="docutils literal"><span class="pre">iterator</span></tt> are equal</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.full_group_by" title="sage.combinat.finite_state_machine.full_group_by"><tt class="xref py py-func docutils literal"><span class="pre">full_group_by()</span></tt></a></td>
<td>Group iterable by values of some key</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.startswith" title="sage.combinat.finite_state_machine.startswith"><tt class="xref py py-func docutils literal"><span class="pre">startswith()</span></tt></a></td>
<td>Determine whether list starts with the given prefix</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMLetterSymbol" title="sage.combinat.finite_state_machine.FSMLetterSymbol"><tt class="xref py py-func docutils literal"><span class="pre">FSMLetterSymbol()</span></tt></a></td>
<td>Returns a string associated to the input letter</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMWordSymbol" title="sage.combinat.finite_state_machine.FSMWordSymbol"><tt class="xref py py-func docutils literal"><span class="pre">FSMWordSymbol()</span></tt></a></td>
<td>Returns a string associated to a word</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.is_FSMState" title="sage.combinat.finite_state_machine.is_FSMState"><tt class="xref py py-func docutils literal"><span class="pre">is_FSMState()</span></tt></a></td>
<td>Tests whether an object inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><tt class="xref py py-class docutils literal"><span class="pre">FSMState</span></tt></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.is_FSMTransition" title="sage.combinat.finite_state_machine.is_FSMTransition"><tt class="xref py py-func docutils literal"><span class="pre">is_FSMTransition()</span></tt></a></td>
<td>Tests whether an object inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><tt class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></tt></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.is_FiniteStateMachine" title="sage.combinat.finite_state_machine.is_FiniteStateMachine"><tt class="xref py py-func docutils literal"><span class="pre">is_FiniteStateMachine()</span></tt></a></td>
<td>Tests whether an object inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.duplicate_transition_ignore" title="sage.combinat.finite_state_machine.duplicate_transition_ignore"><tt class="xref py py-func docutils literal"><span class="pre">duplicate_transition_ignore()</span></tt></a></td>
<td>Default function for handling duplicate transitions</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.duplicate_transition_raise_error" title="sage.combinat.finite_state_machine.duplicate_transition_raise_error"><tt class="xref py py-func docutils literal"><span class="pre">duplicate_transition_raise_error()</span></tt></a></td>
<td>Raise error when inserting a duplicate transition</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.duplicate_transition_add_input" title="sage.combinat.finite_state_machine.duplicate_transition_add_input"><tt class="xref py py-func docutils literal"><span class="pre">duplicate_transition_add_input()</span></tt></a></td>
<td>Add input when inserting a duplicate transition</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="examples">
<span id="finite-state-machine-examples"></span><h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>We start with a general <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>. Later there will
be also an <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton" title="sage.combinat.finite_state_machine.Automaton"><tt class="xref py py-class docutils literal"><span class="pre">Automaton</span></tt></a> and a <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer" title="sage.combinat.finite_state_machine.Transducer"><tt class="xref py py-class docutils literal"><span class="pre">Transducer</span></tt></a>.</p>
<div class="section" id="a-simple-finite-state-machine">
<h3>A simple finite state machine<a class="headerlink" href="#a-simple-finite-state-machine" title="Permalink to this headline">¶</a></h3>
<p>We can easily create a finite state machine by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">fsm</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">fsm</span>
<span class="go">Empty finite state machine</span>
</pre></div>
</div>
<p>By default this is the empty finite state machine, so not very
interesting. Let&#8217;s create and add some states and transitions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">day</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="s">&#39;day&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">night</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="s">&#39;night&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sunrise</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">night</span><span class="p">,</span> <span class="n">day</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sunset</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">day</span><span class="p">,</span> <span class="n">night</span><span class="p">)</span>
</pre></div>
</div>
<p>Let us look at <tt class="docutils literal"><span class="pre">sunset</span></tt> more closely:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">sunset</span>
<span class="go">Transition from &#39;day&#39; to &#39;night&#39;: -|-</span>
</pre></div>
</div>
<p>Note that could also have created and added the transitions directly
by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="s">&#39;day&#39;</span><span class="p">,</span> <span class="s">&#39;night&#39;</span><span class="p">)</span>
<span class="go">Transition from &#39;day&#39; to &#39;night&#39;: -|-</span>
</pre></div>
</div>
<p>This would have had added the states automatically, since they are
present in the transitions.</p>
<p>Anyhow, we got the following finite state machine:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">fsm</span>
<span class="go">Finite state machine with 2 states</span>
</pre></div>
</div>
<p>We can also obtain the underlying <a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">directed</span> <span class="pre">graph</span></tt></a> by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 2 vertices</span>
</pre></div>
</div>
<p>To visualize a finite state machine, we can use
<a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.latex" title="(in Sage Reference Manual: Utilities v6.9)"><tt class="xref py py-func docutils literal"><span class="pre">latex()</span></tt></a> and run the result through LaTeX,
see the section on <a class="reference internal" href="#finite-state-machine-latex-output"><em>LaTeX output</em></a>
below.</p>
<p>Alternatively, we could have created the finite state machine above
simply by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s">&#39;night&#39;</span><span class="p">,</span> <span class="s">&#39;day&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;day&#39;</span><span class="p">,</span> <span class="s">&#39;night&#39;</span><span class="p">)])</span>
<span class="go">Finite state machine with 2 states</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a> for a lot of possibilities to create
finite state machines.</p>
</div>
<div class="section" id="a-simple-automaton-recognizing-nafs">
<span id="finite-state-machine-recognizing-nafs-example"></span><h3>A simple Automaton (recognizing NAFs)<a class="headerlink" href="#a-simple-automaton-recognizing-nafs" title="Permalink to this headline">¶</a></h3>
<p>We want to build an automaton which recognizes non-adjacent forms
(NAFs), i.e., sequences which have no adjacent non-zeros.
We use <span class="math">\(0\)</span>, <span class="math">\(1\)</span>, and <span class="math">\(-1\)</span> as digits:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">(</span>
<span class="go">....:     {&#39;A&#39;: [(&#39;A&#39;, 0), (&#39;B&#39;, 1), (&#39;B&#39;, -1)], &#39;B&#39;: [(&#39;A&#39;, 0)]})</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">NAF</span>
<span class="go">Automaton with 2 states</span>
</pre></div>
</div>
<p>Of course, we could have specified the initial and final states
directly in the definition of <tt class="docutils literal"><span class="pre">NAF</span></tt> by <tt class="docutils literal"><span class="pre">initial_states=['A']</span></tt> and
<tt class="docutils literal"><span class="pre">final_states=['A',</span> <span class="pre">'B']</span></tt>.</p>
<p>So let&#8217;s test the automaton with some input:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NAF</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Alternatively, we could call that by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(True, &#39;B&#39;)</span>
</pre></div>
</div>
<p>which gives additionally the state in which we arrived.</p>
<p>We can also let an automaton act on a <a class="reference internal" href="words/words.html"><em>word</em></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">Words</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span> <span class="n">W</span>
<span class="go">Words over {-1, 0, 1}</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">W</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]);</span> <span class="n">w</span>
<span class="go">word: 1,0,1,0,-1</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="section" id="recognizing-nafs-via-automata-operations">
<h4>Recognizing NAFs via Automata Operations<a class="headerlink" href="#recognizing-nafs-via-automata-operations" title="Permalink to this headline">¶</a></h4>
<p>Alternatively, we can use automata operations to recognize NAFs; for
simplicity, we only use the input alphabet <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">1]</span></tt>. On the one
hand, we can construct such an automaton by forbidding the word
<tt class="docutils literal"><span class="pre">11</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">forbidden</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">ContainsWord</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">input_alphabet</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">NAF_negative</span> <span class="o">=</span> <span class="n">forbidden</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">NAF_negative</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">NAF_negative</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>On the other hand, we can write this as a regular expression and
translate that into automata operations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">zero</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">Word</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">one</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">Word</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">epsilon</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">EmptyWord</span><span class="p">(</span><span class="n">input_alphabet</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">NAF_positive</span> <span class="o">=</span> <span class="p">(</span><span class="n">zero</span> <span class="o">+</span> <span class="n">one</span><span class="o">*</span><span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">kleene_star</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">epsilon</span> <span class="o">+</span> <span class="n">one</span><span class="p">)</span>
</pre></div>
</div>
<p>We check that the two approaches are equivalent:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NAF_negative</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">NAF_positive</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.AutomatonGenerators.ContainsWord" title="sage.combinat.finite_state_machine_generators.AutomatonGenerators.ContainsWord"><tt class="xref py py-meth docutils literal"><span class="pre">ContainsWord()</span></tt></a>,
<a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.AutomatonGenerators.Word" title="sage.combinat.finite_state_machine_generators.AutomatonGenerators.Word"><tt class="xref py py-meth docutils literal"><span class="pre">Word()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.complement" title="sage.combinat.finite_state_machine.Automaton.complement"><tt class="xref py py-meth docutils literal"><span class="pre">complement()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.kleene_star" title="sage.combinat.finite_state_machine.FiniteStateMachine.kleene_star"><tt class="xref py py-meth docutils literal"><span class="pre">kleene_star()</span></tt></a>,
<a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.AutomatonGenerators.EmptyWord" title="sage.combinat.finite_state_machine_generators.AutomatonGenerators.EmptyWord"><tt class="xref py py-meth docutils literal"><span class="pre">EmptyWord()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.is_equivalent" title="sage.combinat.finite_state_machine.Automaton.is_equivalent"><tt class="xref py py-meth docutils literal"><span class="pre">is_equivalent()</span></tt></a>.</p>
</div>
</div>
</div>
<div class="section" id="finite-state-machine-latex-output">
<span id="id1"></span><h3>LaTeX output<a class="headerlink" href="#finite-state-machine-latex-output" title="Permalink to this headline">¶</a></h3>
<p>We can visualize a finite state machine by converting it to LaTeX by
using the usual function <a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.latex" title="(in Sage Reference Manual: Utilities v6.9)"><tt class="xref py py-func docutils literal"><span class="pre">latex()</span></tt></a>. Within LaTeX,
TikZ is used for typesetting the graphics, see the
<a class="reference external" href="https://en.wikipedia.org/wiki/PGF/TikZ">Wikipedia article PGF/TikZ</a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">print</span> <span class="n">latex</span><span class="p">(</span><span class="n">NAF</span><span class="p">)</span>
<span class="go">\begin{tikzpicture}[auto, initial text=, &gt;=latex]</span>
<span class="go">\node[state, accepting, initial] (v0) at (3.000000, 0.000000) {$\text{\texttt{A}}$};</span>
<span class="go">\node[state, accepting] (v1) at (-3.000000, 0.000000) {$\text{\texttt{B}}$};</span>
<span class="go">\path[-&gt;] (v0) edge[loop above] node {$0$} ();</span>
<span class="go">\path[-&gt;] (v0.185.00) edge node[rotate=360.00, anchor=north] {$1, -1$} (v1.355.00);</span>
<span class="go">\path[-&gt;] (v1.5.00) edge node[rotate=0.00, anchor=south] {$0$} (v0.175.00);</span>
<span class="go">\end{tikzpicture}</span>
</pre></div>
</div>
<p>We can turn this into a graphical representation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">view</span><span class="p">(</span><span class="n">NAF</span><span class="p">)</span> <span class="c"># not tested</span>
</pre></div>
</div>
<p>To actually see this, use the live documentation in the Sage notebook
and execute the cells in this and the previous section.</p>
<p>Several options can be set to customize the output, see
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.latex_options" title="sage.combinat.finite_state_machine.FiniteStateMachine.latex_options"><tt class="xref py py-meth docutils literal"><span class="pre">latex_options()</span></tt></a> for details. In particular,
we use <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_letter_negative" title="sage.combinat.finite_state_machine.FiniteStateMachine.format_letter_negative"><tt class="xref py py-meth docutils literal"><span class="pre">format_letter_negative()</span></tt></a> to format
<span class="math">\(-1\)</span> as <span class="math">\(\overline{1}\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span>
<span class="go">....:     coordinates={&#39;A&#39;: (0, 0),</span>
<span class="go">....:                  &#39;B&#39;: (6, 0)},</span>
<span class="go">....:     initial_where={&#39;A&#39;: &#39;below&#39;},</span>
<span class="go">....:     format_letter=NAF.format_letter_negative,</span>
<span class="go">....:     format_state_label=lambda x:</span>
<span class="go">....:         r&#39;\mathcal{%s}&#39; % x.label()</span>
<span class="go">....: )</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="n">latex</span><span class="p">(</span><span class="n">NAF</span><span class="p">)</span>
<span class="go">\begin{tikzpicture}[auto, initial text=, &gt;=latex]</span>
<span class="go">\node[state, accepting, initial, initial where=below] (v0) at (0.000000, 0.000000) {$\mathcal{A}$};</span>
<span class="go">\node[state, accepting] (v1) at (6.000000, 0.000000) {$\mathcal{B}$};</span>
<span class="go">\path[-&gt;] (v0) edge[loop above] node {$0$} ();</span>
<span class="go">\path[-&gt;] (v0.5.00) edge node[rotate=0.00, anchor=south] {$1, \overline{1}$} (v1.175.00);</span>
<span class="go">\path[-&gt;] (v1.185.00) edge node[rotate=360.00, anchor=north] {$0$} (v0.355.00);</span>
<span class="go">\end{tikzpicture}</span>
<span class="gp">sage: </span><span class="n">view</span><span class="p">(</span><span class="n">NAF</span><span class="p">)</span> <span class="c"># not tested</span>
</pre></div>
</div>
<p>To use the output of <a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.latex" title="(in Sage Reference Manual: Utilities v6.9)"><tt class="xref py py-func docutils literal"><span class="pre">latex()</span></tt></a> in your own
<span class="math">\(\LaTeX\)</span> file, you have to include</p>
<div class="highlight-latex"><div class="highlight"><pre><span class="k">\usepackage</span><span class="nb">{</span>tikz<span class="nb">}</span>
<span class="k">\usetikzlibrary</span><span class="nb">{</span>automata<span class="nb">}</span>
</pre></div>
</div>
<p>into the preamble of your file.</p>
</div>
<div class="section" id="a-simple-transducer-binary-inverter">
<h3>A simple transducer (binary inverter)<a class="headerlink" href="#a-simple-transducer-binary-inverter" title="Permalink to this headline">¶</a></h3>
<p>Let&#8217;s build a simple transducer, which rewrites a binary word by
iverting each bit:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
</pre></div>
</div>
<p>We can look at the states and transitions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">inverter</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">inverter</span><span class="o">.</span><span class="n">transitions</span><span class="p">():</span>
<span class="go">....:     print t</span>
<span class="go">Transition from &#39;A&#39; to &#39;A&#39;: 0|1</span>
<span class="go">Transition from &#39;A&#39; to &#39;A&#39;: 1|0</span>
</pre></div>
</div>
<p>Now we apply a word to it and see what the transducer does:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">inverter</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">True</span></tt> means, that we landed in a final state, that state is labeled
<tt class="docutils literal"><span class="pre">'A'</span></tt>, and we also got an output.</p>
</div>
<div class="section" id="transducers-and-in-finite-words">
<span id="finite-state-machine-division-by-3-example"></span><h3>Transducers and (in)finite Words<a class="headerlink" href="#transducers-and-in-finite-words" title="Permalink to this headline">¶</a></h3>
<p>A transducer can also act on everything iterable, in particular, on
Sage&#8217;s <a class="reference internal" href="words/words.html"><em>words</em></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">Words</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span> <span class="n">W</span>
<span class="go">Words over {0, 1}</span>
</pre></div>
</div>
<p>Let us take the inverter from the previous section and feed some
finite word into it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">W</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span> <span class="n">w</span>
<span class="go">word: 1101</span>
<span class="gp">sage: </span><span class="n">inverter</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go">word: 0010</span>
</pre></div>
</div>
<p>We see that the output is again a word (this is a consequence of
calling <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><tt class="xref py py-meth docutils literal"><span class="pre">process()</span></tt></a> with <tt class="docutils literal"><span class="pre">automatic_output_type</span></tt>).</p>
<p>We can even input something infinite like an infinite word:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">tm</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="n">ThueMorseWord</span><span class="p">();</span> <span class="n">tm</span>
<span class="go">word: 0110100110010110100101100110100110010110...</span>
<span class="gp">sage: </span><span class="n">inverter</span><span class="p">(</span><span class="n">tm</span><span class="p">)</span>
<span class="go">word: 1001011001101001011010011001011001101001...</span>
</pre></div>
</div>
</div>
<div class="section" id="a-transducer-which-performs-division-by-in-binary">
<h3>A transducer which performs division by <span class="math">\(3\)</span> in binary<a class="headerlink" href="#a-transducer-which-performs-division-by-in-binary" title="Permalink to this headline">¶</a></h3>
<p>Now we build a transducer, which divides a binary number by <span class="math">\(3\)</span>.
The labels of the states are the remainder of the division.
The transition function is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">state_from</span><span class="p">,</span> <span class="n">read</span><span class="p">):</span>
<span class="go">....:     if state_from + read &lt;= 1:</span>
<span class="go">....:         state_to = 2*state_from + read</span>
<span class="go">....:         write = 0</span>
<span class="go">....:     else:</span>
<span class="go">....:         state_to = 2*state_from + read - 3</span>
<span class="go">....:         write = 1</span>
<span class="go">....:     return (state_to, write)</span>
</pre></div>
</div>
<p>which assumes reading a binary number from left to right.
We get the transducer with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">final_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="go">....:                input_alphabet=[0, 1])</span>
</pre></div>
</div>
<p>Let us try to divide <span class="math">\(12\)</span> by <span class="math">\(3\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">D</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[0, 1, 0, 0]</span>
</pre></div>
</div>
<p>Now we want to divide <span class="math">\(13\)</span> by <span class="math">\(3\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">D</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
</pre></div>
</div>
<p>The raised <tt class="docutils literal"><span class="pre">ValueError</span></tt>
means <span class="math">\(13\)</span> is not divisible by <span class="math">\(3\)</span>.</p>
</div>
<div class="section" id="gray-code">
<span id="finite-state-machine-gray-code-example"></span><h3>Gray Code<a class="headerlink" href="#gray-code" title="Permalink to this headline">¶</a></h3>
<p>The Gray code is a binary <a class="reference external" href="https://en.wikipedia.org/wiki/Numeral_system">numeral system</a>
where two successive values differ in only one bit, cf. the
<a class="reference external" href="https://en.wikipedia.org/wiki/Gray_code">Wikipedia article Gray_code</a>. The Gray code of an integer <span class="math">\(n\)</span> is obtained by
a bitwise xor between the binary expansion of <span class="math">\(n\)</span> and the binary
expansion of <span class="math">\(\lfloor n/2\rfloor\)</span>; the latter corresponds to a
shift by one position in binary.</p>
<p>The purpose of this example is to construct a transducer converting the
standard binary expansion to the Gray code by translating this
construction into operations with transducers.</p>
<p>For this construction, the least significant digit is at
the left-most position.
Note that it is easier to shift everything to
the right first, i.e., multiply by <span class="math">\(2\)</span> instead of building
<span class="math">\(\lfloor n/2\rfloor\)</span>. Then, we take the input xor with the right
shift of the input and forget the first letter.</p>
<p>We first construct a transducer shifting the binary expansion to the
right. This requires storing the previously read digit in a state.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">shift_right_transition</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">digit</span><span class="p">):</span>
<span class="go">....:     if state == &#39;I&#39;:</span>
<span class="go">....:         return (digit, None)</span>
<span class="go">....:     else:</span>
<span class="go">....:         return (digit, state)</span>
<span class="gp">sage: </span><span class="n">shift_right_transducer</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span>
<span class="go">....:     shift_right_transition,</span>
<span class="go">....:     initial_states=[&#39;I&#39;],</span>
<span class="go">....:     input_alphabet=[0, 1],</span>
<span class="go">....:     final_states=[0])</span>
<span class="gp">sage: </span><span class="n">shift_right_transducer</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;I&#39; to 0: 0|-,</span>
<span class="go"> Transition from &#39;I&#39; to 1: 1|-,</span>
<span class="go"> Transition from 0 to 0: 0|0,</span>
<span class="go"> Transition from 0 to 1: 1|0,</span>
<span class="go"> Transition from 1 to 0: 0|1,</span>
<span class="go"> Transition from 1 to 1: 1|1]</span>
<span class="gp">sage: </span><span class="n">shift_right_transducer</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[0, 1, 1]</span>
<span class="gp">sage: </span><span class="n">shift_right_transducer</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[1, 0]</span>
</pre></div>
</div>
<p>The output of the shifts above look a bit weird (from a right-shift
transducer, we would expect, for example, that <tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0]</span></tt> was
mapped to <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">0]</span></tt>), since we write <tt class="docutils literal"><span class="pre">None</span></tt> instead of the zero
at the left. Further, note that only <span class="math">\(0\)</span> is listed as a final state
as we have to enforce that a most significant zero is read as the last
input letter in order to flush the last digit:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">shift_right_transducer</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
</pre></div>
</div>
<p>Next, we construct the transducer performing the xor operation. We also
have to take <tt class="docutils literal"><span class="pre">None</span></tt> into account as our <tt class="docutils literal"><span class="pre">shift_right_transducer</span></tt>
waits one iteration until it starts writing output. This corresponds
with our intention to forget the first letter.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">xor_transition</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">digits</span><span class="p">):</span>
<span class="go">....:    if digits[0] is None or digits[1] is None:</span>
<span class="go">....:        return (0, None)</span>
<span class="go">....:    else:</span>
<span class="go">....:        return (0, digits[0].__xor__(digits[1]))</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="gp">sage: </span><span class="n">xor_transducer</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span>
<span class="go">....:    xor_transition,</span>
<span class="go">....:    initial_states=[0],</span>
<span class="go">....:    final_states=[0],</span>
<span class="go">....:    input_alphabet=list(product([None, 0, 1], [0, 1])))</span>
<span class="gp">sage: </span><span class="n">xor_transducer</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: (None, 0)|-,</span>
<span class="go"> Transition from 0 to 0: (None, 1)|-,</span>
<span class="go"> Transition from 0 to 0: (0, 0)|0,</span>
<span class="go"> Transition from 0 to 0: (0, 1)|1,</span>
<span class="go"> Transition from 0 to 0: (1, 0)|1,</span>
<span class="go"> Transition from 0 to 0: (1, 1)|0]</span>
<span class="gp">sage: </span><span class="n">xor_transducer</span><span class="p">([(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="go">[0, 1, 1, 0]</span>
<span class="gp">sage: </span><span class="n">xor_transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">)])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
</pre></div>
</div>
<p>The transducer computing the Gray code is then constructed as a
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.cartesian_product" title="sage.combinat.finite_state_machine.Transducer.cartesian_product"><tt class="xref py py-meth docutils literal"><span class="pre">cartesian</span> <span class="pre">product</span></tt></a> between the
shifted version and the original input (represented here by the
<tt class="docutils literal"><span class="pre">shift_right_transducer</span></tt> and the <a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.TransducerGenerators.Identity" title="sage.combinat.finite_state_machine_generators.TransducerGenerators.Identity"><tt class="xref py py-meth docutils literal"><span class="pre">identity</span> <span class="pre">transducer</span></tt></a>,
respectively). This cartesian product is then fed into the
<tt class="docutils literal"><span class="pre">xor_transducer</span></tt> as a <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.composition" title="sage.combinat.finite_state_machine.FiniteStateMachine.composition"><tt class="xref py py-meth docutils literal"><span class="pre">composition</span></tt></a> of transducers.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">product_transducer</span> <span class="o">=</span> <span class="n">shift_right_transducer</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">transducers</span><span class="o">.</span><span class="n">Identity</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">Gray_transducer</span> <span class="o">=</span> <span class="n">xor_transducer</span><span class="p">(</span><span class="n">product_transducer</span><span class="p">)</span>
</pre></div>
</div>
<p>We use <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out"><tt class="xref py py-meth docutils literal"><span class="pre">construct_final_word_out()</span></tt></a> to make sure that all output
is written; otherwise, we would have to make sure that a sufficient number of trailing
zeros is read.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Gray_transducer</span><span class="o">.</span><span class="n">construct_final_word_out</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Gray_transducer</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from ((&#39;I&#39;, 0), 0) to ((0, 0), 0): 0|-,</span>
<span class="go"> Transition from ((&#39;I&#39;, 0), 0) to ((1, 0), 0): 1|-,</span>
<span class="go"> Transition from ((0, 0), 0) to ((0, 0), 0): 0|0,</span>
<span class="go"> Transition from ((0, 0), 0) to ((1, 0), 0): 1|1,</span>
<span class="go"> Transition from ((1, 0), 0) to ((0, 0), 0): 0|1,</span>
<span class="go"> Transition from ((1, 0), 0) to ((1, 0), 0): 1|0]</span>
</pre></div>
</div>
<p>There is a <a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.TransducerGenerators.GrayCode" title="sage.combinat.finite_state_machine_generators.TransducerGenerators.GrayCode"><tt class="xref py py-meth docutils literal"><span class="pre">prepackaged</span> <span class="pre">transducer</span></tt></a>
for Gray code, let&#8217;s see whether they agree. We have to use
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.relabeled" title="sage.combinat.finite_state_machine.FiniteStateMachine.relabeled"><tt class="xref py py-meth docutils literal"><span class="pre">relabeled()</span></tt></a> to relabel our states with
integers.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">constructed</span> <span class="o">=</span> <span class="n">Gray_transducer</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">packaged</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">GrayCode</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">constructed</span> <span class="o">==</span> <span class="n">packaged</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Finally, we check that this indeed computes the Gray code of the first
10 non-negative integers.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">srange</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
<span class="go">....:     Gray_transducer(n.bits())</span>
<span class="go">[]</span>
<span class="go">[1]</span>
<span class="go">[1, 1]</span>
<span class="go">[0, 1]</span>
<span class="go">[0, 1, 1]</span>
<span class="go">[1, 1, 1]</span>
<span class="go">[1, 0, 1]</span>
<span class="go">[0, 0, 1]</span>
<span class="go">[0, 0, 1, 1]</span>
<span class="go">[1, 0, 1, 1]</span>
</pre></div>
</div>
</div>
<div class="section" id="using-the-hook-functions">
<h3>Using the hook-functions<a class="headerlink" href="#using-the-hook-functions" title="Permalink to this headline">¶</a></h3>
<p>Let&#8217;s use the <a class="reference internal" href="#finite-state-machine-division-by-3-example"><em>previous example &#8220;divison by
3&#8221;</em></a> to demonstrate the optional
state and transition parameters <tt class="docutils literal"><span class="pre">hook</span></tt>.</p>
<p>First, we define what those functions should do. In our case, this is
just saying in which state we are and which transition we take</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">state_hook</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
<span class="go">....:     print &quot;We are now in State %s.&quot; % (state.label(),)</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMWordSymbol</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">transition_hook</span><span class="p">(</span><span class="n">transition</span><span class="p">,</span> <span class="n">process</span><span class="p">):</span>
<span class="go">....:     print (&quot;Currently we go from %s to %s, &quot;</span>
<span class="go">....:            &quot;reading %s and writing %s.&quot; % (</span>
<span class="go">....:                transition.from_state, transition.to_state,</span>
<span class="go">....:                FSMWordSymbol(transition.word_in),</span>
<span class="go">....:                FSMWordSymbol(transition.word_out)))</span>
</pre></div>
</div>
<p>Now, let&#8217;s add these hook-functions to the existing transducer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">iter_states</span><span class="p">():</span>
<span class="go">....:     s.hook = state_hook</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">iter_transitions</span><span class="p">():</span>
<span class="go">....:     t.hook = transition_hook</span>
</pre></div>
</div>
<p>Rerunning the process again now gives the following output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">check_epsilon_transitions</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">We are now in State 0.</span>
<span class="go">Currently we go from 0 to 1, reading 1 and writing 0.</span>
<span class="go">We are now in State 1.</span>
<span class="go">Currently we go from 1 to 0, reading 1 and writing 1.</span>
<span class="go">We are now in State 0.</span>
<span class="go">Currently we go from 0 to 0, reading 0 and writing 0.</span>
<span class="go">We are now in State 0.</span>
<span class="go">Currently we go from 0 to 1, reading 1 and writing 0.</span>
<span class="go">We are now in State 1.</span>
<span class="go">(False, 1, [0, 1, 0, 0])</span>
</pre></div>
</div>
<p>The example above just explains the basic idea of using
hook-functions. In the following, we will use those hooks more
seriously.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The hooks of the states are also called while exploring the epsilon
successors of a state (during processing). In the example above, we
used <tt class="docutils literal"><span class="pre">check_epsilon_transitions=False</span></tt> to avoid this (and also
therefore got a cleaner output).</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The arguments used when calling a hook have changed in
<a class="reference external" href="http://trac.sagemath.org/16538">trac ticket #16538</a> from <tt class="docutils literal"><span class="pre">hook(state,</span> <span class="pre">process)</span></tt> to
<tt class="docutils literal"><span class="pre">hook(process,</span> <span class="pre">state,</span> <span class="pre">output)</span></tt>. If you are using
an old-style hook, a deprecation warning is displayed.</p>
</div>
</div>
<div class="section" id="detecting-sequences-with-same-number-of-and">
<h3>Detecting sequences with same number of <span class="math">\(0\)</span> and <span class="math">\(1\)</span><a class="headerlink" href="#detecting-sequences-with-same-number-of-and" title="Permalink to this headline">¶</a></h3>
<p>Suppose we have a binary input and want to accept all sequences with
the same number of <span class="math">\(0\)</span> and <span class="math">\(1\)</span>. This cannot be done with a finite
automaton. Anyhow, we can make usage of the hook functions to extend
our finite automaton by a counter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span><span class="p">,</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">update_counter</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
<span class="go">....:     l = process.preview_word()</span>
<span class="go">....:     process.fsm.counter += 1 if l == 1 else -1</span>
<span class="go">....:     if process.fsm.counter &gt; 0:</span>
<span class="go">....:         next_state = &#39;positive&#39;</span>
<span class="go">....:     elif process.fsm.counter &lt; 0:</span>
<span class="go">....:         next_state = &#39;negative&#39;</span>
<span class="go">....:     else:</span>
<span class="go">....:         next_state = &#39;zero&#39;</span>
<span class="go">....:     return FSMTransition(state, process.fsm.state(next_state),</span>
<span class="go">....:                          l, process.fsm.counter)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;zero&#39;</span><span class="p">,</span> <span class="n">hook</span><span class="o">=</span><span class="n">update_counter</span><span class="p">,</span>
<span class="go">....:             is_initial=True, is_final=True))</span>
<span class="go">&#39;zero&#39;</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;positive&#39;</span><span class="p">,</span> <span class="n">hook</span><span class="o">=</span><span class="n">update_counter</span><span class="p">))</span>
<span class="go">&#39;positive&#39;</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;negative&#39;</span><span class="p">,</span> <span class="n">hook</span><span class="o">=</span><span class="n">update_counter</span><span class="p">))</span>
<span class="go">&#39;negative&#39;</span>
</pre></div>
</div>
<p>Now, let&#8217;s input some sequence:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">C</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">(False, &#39;positive&#39;, [1, 2, 3, 4, 3, 2])</span>
</pre></div>
</div>
<p>The result is False, since there are four <span class="math">\(1\)</span> but only two <span class="math">\(0\)</span>. We
land in the state <tt class="docutils literal"><span class="pre">positive</span></tt> and we can also see the values of the
counter in each step.</p>
<p>Let&#8217;s try some other examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">C</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">(True, &#39;zero&#39;, [1, 2, 1, 0])</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">C</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">(False, &#39;negative&#39;, [-1, 0, -1, -2])</span>
</pre></div>
</div>
<p>See also methods <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></tt></a> and
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><tt class="xref py py-meth docutils literal"><span class="pre">Transducer.process()</span></tt></a> (or even
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></tt></a>), the explanation of the parameter
<tt class="docutils literal"><span class="pre">hook</span></tt> and the examples in <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><tt class="xref py py-class docutils literal"><span class="pre">FSMState</span></tt></a> and
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><tt class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></tt></a>, and the description and examples in
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a> for more information on processing and
hooks.</p>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="hkp2015" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[HKP2015]</a></td><td>Clemens Heuberger, Sara Kropf, and Helmut Prodinger,
<em>Output sum of transducers: Limiting distribution and periodic
fluctuation</em>,
<a class="reference external" href="http://www.combinatorics.org/ojs/index.php/eljc/article/view/v22i2p19">Electron. J. Combin. 22 (2015), #P2.19</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="hkw2015" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[HKW2015]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id6">2</a>, <a class="fn-backref" href="#id9">3</a>, <a class="fn-backref" href="#id10">4</a>, <a class="fn-backref" href="#id11">5</a>, <a class="fn-backref" href="#id12">6</a>, <a class="fn-backref" href="#id13">7</a>, <a class="fn-backref" href="#id14">8</a>, <a class="fn-backref" href="#id16">9</a>)</em> Clemens Heuberger, Sara Kropf and Stephan Wagner,
<em>Variances and Covariances in the Central Limit Theorem for the Output
of a Transducer</em>, European J. Combin. 49 (2015), 167-187,
<a class="reference external" href="https://dx.doi.org/10.1016/j.ejc.2015.03.004">doi:10.1016/j.ejc.2015.03.004</a>.</td></tr>
</tbody>
</table>
<p>AUTHORS:</p>
<ul>
<li><p class="first">Daniel Krenn (2012-03-27): initial version</p>
</li>
<li><p class="first">Clemens Heuberger (2012-04-05): initial version</p>
</li>
<li><p class="first">Sara Kropf (2012-04-17): initial version</p>
</li>
<li><p class="first">Clemens Heuberger (2013-08-21): release candidate for Sage patch</p>
</li>
<li><p class="first">Daniel Krenn (2013-08-21): release candidate for Sage patch</p>
</li>
<li><p class="first">Sara Kropf (2013-08-21): release candidate for Sage patch</p>
</li>
<li><p class="first">Clemens Heuberger (2013-09-02): documentation improved</p>
</li>
<li><p class="first">Daniel Krenn (2013-09-13): comments from trac worked in</p>
</li>
<li><dl class="first docutils">
<dt>Clemens Heuberger (2013-11-03): output (labels) of determinisation,</dt>
<dd><p class="first last">product, composition, etc. changed (for consistency),
representation of state changed, documentation improved</p>
</dd>
</dl>
</li>
<li><p class="first">Daniel Krenn (2013-11-04): whitespaces in documentation corrected</p>
</li>
<li><p class="first">Clemens Heuberger (2013-11-04): full_group_by added</p>
</li>
<li><p class="first">Daniel Krenn (2013-11-04): next release candidate for Sage patch</p>
</li>
<li><p class="first">Sara Kropf (2013-11-08): fix for adjacency matrix</p>
</li>
<li><p class="first">Clemens Heuberger (2013-11-11): fix for prepone_output</p>
</li>
<li><dl class="first docutils">
<dt>Daniel Krenn (2013-11-11): comments from <a class="reference external" href="http://trac.sagemath.org/15078">trac ticket #15078</a> included:</dt>
<dd><p class="first last">docstring of FiniteStateMachine rewritten, Automaton and Transducer
inherited from FiniteStateMachine</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Daniel Krenn (2013-11-25): documentation improved according to</dt>
<dd><p class="first last">comments from <a class="reference external" href="http://trac.sagemath.org/15078">trac ticket #15078</a></p>
</dd>
</dl>
</li>
<li><p class="first">Clemens Heuberger, Daniel Krenn, Sara Kropf (2014-02-21&#8211;2014-07-18):
A huge bunch of improvements. Details see
<a class="reference external" href="http://trac.sagemath.org/15841">trac ticket #15841</a>, <a class="reference external" href="http://trac.sagemath.org/15847">trac ticket #15847</a>, <a class="reference external" href="http://trac.sagemath.org/15848">trac ticket #15848</a>, <a class="reference external" href="http://trac.sagemath.org/15849">trac ticket #15849</a>, <a class="reference external" href="http://trac.sagemath.org/15850">trac ticket #15850</a>, <a class="reference external" href="http://trac.sagemath.org/15922">trac ticket #15922</a>, <a class="reference external" href="http://trac.sagemath.org/15923">trac ticket #15923</a>, <a class="reference external" href="http://trac.sagemath.org/15924">trac ticket #15924</a>,
<a class="reference external" href="http://trac.sagemath.org/15925">trac ticket #15925</a>, <a class="reference external" href="http://trac.sagemath.org/15928">trac ticket #15928</a>, <a class="reference external" href="http://trac.sagemath.org/15960">trac ticket #15960</a>, <a class="reference external" href="http://trac.sagemath.org/15961">trac ticket #15961</a>, <a class="reference external" href="http://trac.sagemath.org/15962">trac ticket #15962</a>, <a class="reference external" href="http://trac.sagemath.org/15963">trac ticket #15963</a>, <a class="reference external" href="http://trac.sagemath.org/15975">trac ticket #15975</a>, <a class="reference external" href="http://trac.sagemath.org/16016">trac ticket #16016</a>,
<a class="reference external" href="http://trac.sagemath.org/16024">trac ticket #16024</a>, <a class="reference external" href="http://trac.sagemath.org/16061">trac ticket #16061</a>, <a class="reference external" href="http://trac.sagemath.org/16128">trac ticket #16128</a>, <a class="reference external" href="http://trac.sagemath.org/16132">trac ticket #16132</a>, <a class="reference external" href="http://trac.sagemath.org/16138">trac ticket #16138</a>, <a class="reference external" href="http://trac.sagemath.org/16139">trac ticket #16139</a>, <a class="reference external" href="http://trac.sagemath.org/16140">trac ticket #16140</a>, <a class="reference external" href="http://trac.sagemath.org/16143">trac ticket #16143</a>,
<a class="reference external" href="http://trac.sagemath.org/16144">trac ticket #16144</a>, <a class="reference external" href="http://trac.sagemath.org/16145">trac ticket #16145</a>, <a class="reference external" href="http://trac.sagemath.org/16146">trac ticket #16146</a>, <a class="reference external" href="http://trac.sagemath.org/16191">trac ticket #16191</a>, <a class="reference external" href="http://trac.sagemath.org/16200">trac ticket #16200</a>, <a class="reference external" href="http://trac.sagemath.org/16205">trac ticket #16205</a>, <a class="reference external" href="http://trac.sagemath.org/16206">trac ticket #16206</a>, <a class="reference external" href="http://trac.sagemath.org/16207">trac ticket #16207</a>,
<a class="reference external" href="http://trac.sagemath.org/16229">trac ticket #16229</a>, <a class="reference external" href="http://trac.sagemath.org/16253">trac ticket #16253</a>, <a class="reference external" href="http://trac.sagemath.org/16254">trac ticket #16254</a>, <a class="reference external" href="http://trac.sagemath.org/16255">trac ticket #16255</a>, <a class="reference external" href="http://trac.sagemath.org/16266">trac ticket #16266</a>, <a class="reference external" href="http://trac.sagemath.org/16355">trac ticket #16355</a>, <a class="reference external" href="http://trac.sagemath.org/16357">trac ticket #16357</a>, <a class="reference external" href="http://trac.sagemath.org/16387">trac ticket #16387</a>,
<a class="reference external" href="http://trac.sagemath.org/16425">trac ticket #16425</a>, <a class="reference external" href="http://trac.sagemath.org/16539">trac ticket #16539</a>, <a class="reference external" href="http://trac.sagemath.org/16555">trac ticket #16555</a>, <a class="reference external" href="http://trac.sagemath.org/16557">trac ticket #16557</a>, <a class="reference external" href="http://trac.sagemath.org/16588">trac ticket #16588</a>, <a class="reference external" href="http://trac.sagemath.org/16589">trac ticket #16589</a>, <a class="reference external" href="http://trac.sagemath.org/16666">trac ticket #16666</a>, <a class="reference external" href="http://trac.sagemath.org/16668">trac ticket #16668</a>,
<a class="reference external" href="http://trac.sagemath.org/16674">trac ticket #16674</a>, <a class="reference external" href="http://trac.sagemath.org/16675">trac ticket #16675</a>, <a class="reference external" href="http://trac.sagemath.org/16677">trac ticket #16677</a>.</p>
</li>
<li><p class="first">Daniel Krenn (2015-09-14): cleanup <a class="reference external" href="http://trac.sagemath.org/18227">trac ticket #18227</a></p>
</li>
</ul>
<p>ACKNOWLEDGEMENT:</p>
<ul class="simple">
<li>Clemens Heuberger, Daniel Krenn and Sara Kropf are supported by the
Austrian Science Fund (FWF): P 24644-N26.</li>
</ul>
</div>
</div>
<div class="section" id="methods">
<h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sage.combinat.finite_state_machine.Automaton">
<em class="property">class </em><tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">Automaton</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.finite_state_machine.FiniteStateMachine</span></tt></a></p>
<p>This creates an automaton, which is a finite state machine, whose
transitions have input labels.</p>
<p>An automaton has additional features like creating a deterministic
and a minimized automaton.</p>
<p>See class <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a> for more information.</p>
<p>EXAMPLES:</p>
<p>We can create an automaton recognizing even numbers (given in
binary and read from left to right) in the following way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                (&#39;Q&#39;, &#39;P&#39;, 1), (&#39;Q&#39;, &#39;Q&#39;, 0)],</span>
<span class="go">....:               initial_states=[&#39;P&#39;], final_states=[&#39;Q&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span>
<span class="go">Automaton with 2 states</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that the full output of the commands can be obtained by
calling <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><tt class="xref py py-meth docutils literal"><span class="pre">process()</span></tt></a> and looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(False, &#39;P&#39;)</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Automaton</span><span class="p">()</span>
<span class="go">Empty automaton</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.cartesian_product">
<tt class="descname">cartesian_product</tt><big>(</big><em>other</em>, <em>only_accessible_components=True</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.cartesian_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new automaton which accepts an input if it is
accepted by both given automata.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; an automaton</li>
<li><tt class="docutils literal"><span class="pre">only_accessible_components</span></tt> &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt> (default), then
the result is piped through <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components"><tt class="xref py py-meth docutils literal"><span class="pre">accessible_components()</span></tt></a>. If no
<tt class="docutils literal"><span class="pre">new_input_alphabet</span></tt> is given, it is determined by
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>A new automaton which computes the intersection
(see below) of the languages of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>The set of states of the new automaton is the cartesian product of the
set of states of both given automata. There is a transition <span class="math">\(((A, B),
(C, D), a)\)</span> in the new automaton if there are transitions <span class="math">\((A, C, a)\)</span>
and <span class="math">\((B, D, a)\)</span> in the old automata.</p>
<p>The methods <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.intersection" title="sage.combinat.finite_state_machine.Automaton.intersection"><tt class="xref py py-meth docutils literal"><span class="pre">intersection()</span></tt></a> and
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.cartesian_product" title="sage.combinat.finite_state_machine.Automaton.cartesian_product"><tt class="xref py py-meth docutils literal"><span class="pre">cartesian_product()</span></tt></a> are the same (for automata).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">aut1</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                   (&#39;2&#39;, &#39;2&#39;, 1),</span>
<span class="go">....:                   (&#39;2&#39;, &#39;2&#39;, 0)],</span>
<span class="go">....:                  initial_states=[&#39;1&#39;],</span>
<span class="go">....:                  final_states=[&#39;2&#39;],</span>
<span class="go">....:                  determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">aut2</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                   (&#39;A&#39;, &#39;B&#39;, 0),</span>
<span class="go">....:                   (&#39;B&#39;, &#39;B&#39;, 0),</span>
<span class="go">....:                   (&#39;B&#39;, &#39;A&#39;, 1)],</span>
<span class="go">....:                  initial_states=[&#39;A&#39;],</span>
<span class="go">....:                  final_states=[&#39;B&#39;],</span>
<span class="go">....:                  determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">res</span> <span class="o">=</span> <span class="n">aut1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">aut2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">aut1</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">aut2</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">res</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">(True, False, False)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">aut1</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">aut2</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">res</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="go">(True, True, True)</span>
<span class="gp">sage: </span><span class="n">res</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;1&#39;, &#39;A&#39;) to (&#39;2&#39;, &#39;A&#39;): 1|-,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;A&#39;) to (&#39;2&#39;, &#39;B&#39;): 0|-,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;A&#39;) to (&#39;2&#39;, &#39;A&#39;): 1|-,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;B&#39;) to (&#39;2&#39;, &#39;B&#39;): 0|-,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;B&#39;) to (&#39;2&#39;, &#39;A&#39;): 1|-]</span>
</pre></div>
</div>
<p>For automata with epsilon-transitions, intersection is not well
defined. But for any finite state machine, epsilon-transitions can be
removed by <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.remove_epsilon_transitions" title="sage.combinat.finite_state_machine.FiniteStateMachine.remove_epsilon_transitions"><tt class="xref py py-meth docutils literal"><span class="pre">remove_epsilon_transitions()</span></tt></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a1</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                 (0, 1, None),</span>
<span class="go">....:                 (1, 1, 1),</span>
<span class="go">....:                 (1, 2, 1)],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[1],</span>
<span class="go">....:                 determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">a2</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[1],</span>
<span class="go">....:                 determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">a1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">An epsilon-transition (with empty input)</span>
<span class="go">was found.</span>
<span class="gp">sage: </span><span class="n">a1</span><span class="o">.</span><span class="n">remove_epsilon_transitions</span><span class="p">()</span>  <span class="c"># not tested (since not implemented yet)</span>
<span class="gp">sage: </span><span class="n">a1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>  <span class="c"># not tested</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.complement">
<tt class="descname">complement</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.complement" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complement of this automaton.</p>
<p>OUTPUT:</p>
<p>An <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton" title="sage.combinat.finite_state_machine.Automaton"><tt class="xref py py-class docutils literal"><span class="pre">Automaton</span></tt></a>.</p>
<p>If this automaton recognizes language <span class="math">\(\mathcal{L}\)</span> over an
input alphabet <span class="math">\(\mathcal{A}\)</span>, then the complement recognizes
<span class="math">\(\mathcal{A}\setminus\mathcal{L}\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">Word</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span>
<span class="go">....:  [], [0], [1], [0, 0], [0, 1], [1, 0], [1, 1]</span>
<span class="go">....:  if A(w)]</span>
<span class="go">[[0, 1]]</span>
<span class="gp">sage: </span><span class="n">Ac</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Ac</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|-,</span>
<span class="go"> Transition from 0 to 3: 1|-,</span>
<span class="go"> Transition from 2 to 3: 0|-,</span>
<span class="go"> Transition from 2 to 3: 1|-,</span>
<span class="go"> Transition from 1 to 2: 1|-,</span>
<span class="go"> Transition from 1 to 3: 0|-,</span>
<span class="go"> Transition from 3 to 3: 0|-,</span>
<span class="go"> Transition from 3 to 3: 1|-]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span>
<span class="go">....:  [], [0], [1], [0, 0], [0, 1], [1, 0], [1, 1]</span>
<span class="go">....:  if Ac(w)]</span>
<span class="go">[[], [0], [1], [0, 0], [1, 0], [1, 1]]</span>
</pre></div>
</div>
<p>The automaton must be deterministic:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">Word</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">automata</span><span class="o">.</span><span class="n">Word</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The finite state machine must be deterministic.</span>
<span class="gp">sage: </span><span class="n">Ac</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span>
<span class="go">....:  [], [0], [1], [0, 0], [0, 1], [1, 0], [1, 1]</span>
<span class="go">....:  if Ac(w)]</span>
<span class="go">[[], [0], [1], [0, 0], [1, 0], [1, 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.determinisation">
<tt class="descname">determinisation</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.determinisation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deterministic automaton which accepts the same input
words as the original one.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A new automaton, which is deterministic.</p>
<p>The labels of the states of the new automaton are frozensets
of states of <tt class="docutils literal"><span class="pre">self</span></tt>. The color of a new state is the
frozenset of colors of the constituent states of <tt class="docutils literal"><span class="pre">self</span></tt>.
Therefore, the colors of the constituent states have to be
hashable. However, if all constituent states have color
<tt class="docutils literal"><span class="pre">None</span></tt>, then the resulting color is <tt class="docutils literal"><span class="pre">None</span></tt>, too.</p>
<p>The input alphabet must be specified.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">aut</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                 initial_states=[&#39;A&#39;], final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">aut</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from frozenset([&#39;A&#39;])</span>
<span class="go">              to frozenset([&#39;A&#39;]): 0|-,</span>
<span class="go"> Transition from frozenset([&#39;A&#39;])</span>
<span class="go">              to frozenset([&#39;B&#39;]): 1|-,</span>
<span class="go"> Transition from frozenset([&#39;B&#39;])</span>
<span class="go">              to frozenset([]): 0|-,</span>
<span class="go"> Transition from frozenset([&#39;B&#39;])</span>
<span class="go">              to frozenset([&#39;B&#39;]): 1|-,</span>
<span class="go"> Transition from frozenset([])</span>
<span class="go">              to frozenset([]): 0|-,</span>
<span class="go"> Transition from frozenset([])</span>
<span class="go">              to frozenset([]): 1|-]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                (&#39;B&#39;, &#39;C&#39;, 0), (&#39;C&#39;, &#39;C&#39;, 1), (&#39;C&#39;, &#39;C&#39;, 0)],</span>
<span class="go">....:               initial_states=[&#39;A&#39;], final_states=[&#39;C&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[frozenset([&#39;A&#39;]), frozenset([&#39;A&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;A&#39;, &#39;C&#39;]), frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;])]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
<span class="go">....:                (1, 0, -1), (2, 0, -2), (3, 0, -3)],</span>
<span class="go">....:               initial_states=[0], final_states=[0, 1, 2, 3])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">to_state</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span>
<span class="go">....:     B.state(2).transitions)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_final</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">delete_state</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c"># this is a sink</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from 0 to 1: 1|-,</span>
<span class="go"> Transition from 1 to 0: -1|-,</span>
<span class="go"> Transition from 1 to 3: 1|-,</span>
<span class="go"> Transition from 3 to 0: -2|-,</span>
<span class="go"> Transition from 3 to 4: 1|-,</span>
<span class="go"> Transition from 4 to 0: -3|-]</span>
</pre></div>
</div>
<p>Note that colors of states have to be hashable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">unhashable type: &#39;list&#39;</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span>
<span class="go">Automaton with 1 state</span>
</pre></div>
</div>
<p>If the colors of all constituent states are <tt class="docutils literal"><span class="pre">None</span></tt>,
the resulting color is <tt class="docutils literal"><span class="pre">None</span></tt>, too (<a class="reference external" href="http://trac.sagemath.org/19199">trac ticket #19199</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0],</span>
<span class="go">....:               final_states=[0])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">color</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span><span class="o">.</span><span class="n">iter_states</span><span class="p">()]</span>
<span class="go">[None]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>This is from <a class="reference external" href="http://trac.sagemath.org/15078">trac ticket #15078</a>, comment 13.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">)],</span>
<span class="go">....:      &#39;C&#39;: [], &#39;B&#39;: [(&#39;C&#39;, &#39;b&#39;)]}</span>
<span class="gp">sage: </span><span class="n">auto</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">],</span> <span class="n">final_states</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">auto</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">auto</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s">&#39;aaab&#39;</span><span class="p">))</span>
<span class="go">[(False, &#39;A&#39;), (True, &#39;C&#39;)]</span>
<span class="gp">sage: </span><span class="n">auto</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]</span>
<span class="gp">sage: </span><span class="n">Ddet</span> <span class="o">=</span> <span class="n">auto</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Ddet</span>
<span class="go">Automaton with 3 states</span>
<span class="gp">sage: </span><span class="n">Ddet</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Ddet</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from frozenset([&#39;A&#39;]) to frozenset([&#39;A&#39;, &#39;B&#39;]): &#39;a&#39;|-,</span>
<span class="go"> Transition from frozenset([&#39;A&#39;]) to frozenset([&#39;A&#39;]): &#39;b&#39;|-,</span>
<span class="go"> Transition from frozenset([&#39;A&#39;, &#39;B&#39;]) to frozenset([&#39;A&#39;, &#39;B&#39;]): &#39;a&#39;|-,</span>
<span class="go"> Transition from frozenset([&#39;A&#39;, &#39;B&#39;]) to frozenset([&#39;A&#39;, &#39;C&#39;]): &#39;b&#39;|-,</span>
<span class="go"> Transition from frozenset([&#39;A&#39;, &#39;C&#39;]) to frozenset([&#39;A&#39;, &#39;B&#39;]): &#39;a&#39;|-,</span>
<span class="go"> Transition from frozenset([&#39;A&#39;, &#39;C&#39;]) to frozenset([&#39;A&#39;]): &#39;b&#39;|-]</span>
<span class="gp">sage: </span><span class="n">Ddet</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[frozenset([&#39;A&#39;])]</span>
<span class="gp">sage: </span><span class="n">Ddet</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[frozenset([&#39;A&#39;, &#39;C&#39;])]</span>
<span class="gp">sage: </span><span class="n">Ddet</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s">&#39;aaab&#39;</span><span class="p">))</span>
<span class="go">(True, frozenset([&#39;A&#39;, &#39;C&#39;]))</span>
</pre></div>
</div>
<p>Test that <a class="reference external" href="http://trac.sagemath.org/18992">trac ticket #18992</a> is fixed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[]),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0], final_states=[1])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[frozenset([0, 1])]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[frozenset([0, 1]), frozenset([1])]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from frozenset([0, 1]) to frozenset([1]): 0|-,</span>
<span class="go">Transition from frozenset([1]) to frozenset([1]): 0|-]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">minimization</span><span class="p">()</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: 0|-]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.intersection">
<tt class="descname">intersection</tt><big>(</big><em>other</em>, <em>only_accessible_components=True</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new automaton which accepts an input if it is
accepted by both given automata.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; an automaton</li>
<li><tt class="docutils literal"><span class="pre">only_accessible_components</span></tt> &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt> (default), then
the result is piped through <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components"><tt class="xref py py-meth docutils literal"><span class="pre">accessible_components()</span></tt></a>. If no
<tt class="docutils literal"><span class="pre">new_input_alphabet</span></tt> is given, it is determined by
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>A new automaton which computes the intersection
(see below) of the languages of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>The set of states of the new automaton is the cartesian product of the
set of states of both given automata. There is a transition <span class="math">\(((A, B),
(C, D), a)\)</span> in the new automaton if there are transitions <span class="math">\((A, C, a)\)</span>
and <span class="math">\((B, D, a)\)</span> in the old automata.</p>
<p>The methods <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.intersection" title="sage.combinat.finite_state_machine.Automaton.intersection"><tt class="xref py py-meth docutils literal"><span class="pre">intersection()</span></tt></a> and
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.cartesian_product" title="sage.combinat.finite_state_machine.Automaton.cartesian_product"><tt class="xref py py-meth docutils literal"><span class="pre">cartesian_product()</span></tt></a> are the same (for automata).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">aut1</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                   (&#39;2&#39;, &#39;2&#39;, 1),</span>
<span class="go">....:                   (&#39;2&#39;, &#39;2&#39;, 0)],</span>
<span class="go">....:                  initial_states=[&#39;1&#39;],</span>
<span class="go">....:                  final_states=[&#39;2&#39;],</span>
<span class="go">....:                  determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">aut2</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                   (&#39;A&#39;, &#39;B&#39;, 0),</span>
<span class="go">....:                   (&#39;B&#39;, &#39;B&#39;, 0),</span>
<span class="go">....:                   (&#39;B&#39;, &#39;A&#39;, 1)],</span>
<span class="go">....:                  initial_states=[&#39;A&#39;],</span>
<span class="go">....:                  final_states=[&#39;B&#39;],</span>
<span class="go">....:                  determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">res</span> <span class="o">=</span> <span class="n">aut1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">aut2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">aut1</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">aut2</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">res</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">(True, False, False)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">aut1</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">aut2</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">res</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="go">(True, True, True)</span>
<span class="gp">sage: </span><span class="n">res</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;1&#39;, &#39;A&#39;) to (&#39;2&#39;, &#39;A&#39;): 1|-,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;A&#39;) to (&#39;2&#39;, &#39;B&#39;): 0|-,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;A&#39;) to (&#39;2&#39;, &#39;A&#39;): 1|-,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;B&#39;) to (&#39;2&#39;, &#39;B&#39;): 0|-,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;B&#39;) to (&#39;2&#39;, &#39;A&#39;): 1|-]</span>
</pre></div>
</div>
<p>For automata with epsilon-transitions, intersection is not well
defined. But for any finite state machine, epsilon-transitions can be
removed by <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.remove_epsilon_transitions" title="sage.combinat.finite_state_machine.FiniteStateMachine.remove_epsilon_transitions"><tt class="xref py py-meth docutils literal"><span class="pre">remove_epsilon_transitions()</span></tt></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a1</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                 (0, 1, None),</span>
<span class="go">....:                 (1, 1, 1),</span>
<span class="go">....:                 (1, 2, 1)],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[1],</span>
<span class="go">....:                 determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">a2</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[1],</span>
<span class="go">....:                 determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">a1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">An epsilon-transition (with empty input)</span>
<span class="go">was found.</span>
<span class="gp">sage: </span><span class="n">a1</span><span class="o">.</span><span class="n">remove_epsilon_transitions</span><span class="p">()</span>  <span class="c"># not tested (since not implemented yet)</span>
<span class="gp">sage: </span><span class="n">a1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>  <span class="c"># not tested</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.is_equivalent">
<tt class="descname">is_equivalent</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.is_equivalent" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether two automata are equivalent, i.e., accept the same
language.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; an <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton" title="sage.combinat.finite_state_machine.Automaton"><tt class="xref py py-class docutils literal"><span class="pre">Automaton</span></tt></a>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0],</span>
<span class="go">....:               final_states=[0])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:               initial_states=[&#39;a&#39;],</span>
<span class="go">....:               final_states=[&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">Transition from &#39;b&#39; to &#39;a&#39;: 0|-</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.language">
<tt class="descname">language</tt><big>(</big><em>max_length=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.language" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all words accepted by this automaton.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">max_length</span></tt> &#8211; an integer or <tt class="docutils literal"><span class="pre">None</span></tt> (default). Only
inputs of length at most <tt class="docutils literal"><span class="pre">max_length</span></tt> will be
considered. If <tt class="docutils literal"><span class="pre">None</span></tt>, then this iterates over all
possible words without length restrictions.</li>
<li><tt class="docutils literal"><span class="pre">kwargs</span></tt> &#8211; will be passed on to to the <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">process</span>
<span class="pre">iterator</span></tt></a>. See <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><tt class="xref py py-meth docutils literal"><span class="pre">process()</span></tt></a> for a
description.</li>
</ul>
<p>OUTPUT:</p>
<p>An iterator.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">(</span>
<span class="go">....:     {&#39;A&#39;: [(&#39;A&#39;, 0), (&#39;B&#39;, 1), (&#39;B&#39;, -1)],</span>
<span class="go">....:      &#39;B&#39;: [(&#39;A&#39;, 0)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">NAF</span><span class="o">.</span><span class="n">language</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[[],</span>
<span class="go"> [0], [-1], [1],</span>
<span class="go"> [-1, 0], [0, 0], [1, 0], [0, -1], [0, 1],</span>
<span class="go"> [-1, 0, 0], [0, -1, 0], [0, 0, 0], [0, 1, 0], [1, 0, 0],</span>
<span class="go"> [-1, 0, -1], [-1, 0, 1], [0, 0, -1],</span>
<span class="go"> [0, 0, 1], [1, 0, -1], [1, 0, 1]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.language" title="sage.combinat.finite_state_machine.FiniteStateMachine.language"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.language()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><tt class="xref py py-meth docutils literal"><span class="pre">process()</span></tt></a>.</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">R</span><span class="p">(</span><span class="n">ell</span><span class="p">):</span>
<span class="go">....:     return (2^(ell+2)-(-1)^ell)/3</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">NAFs</span><span class="p">))</span> <span class="o">==</span> <span class="n">R</span><span class="p">(</span><span class="n">ell</span><span class="p">)</span> <span class="k">for</span> <span class="n">ell</span><span class="p">,</span> <span class="n">NAFs</span> <span class="ow">in</span>
<span class="go">....:     itertools.groupby(NAF.language(5), key=len))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.minimization">
<tt class="descname">minimization</tt><big>(</big><em>algorithm=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.minimization" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the minimization of the input automaton as a new automaton.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; Either Moore&#8217;s algorithm (by
<tt class="docutils literal"><span class="pre">algorithm='Moore'</span></tt> or as default for deterministic
automata) or Brzozowski&#8217;s algorithm (when
<tt class="docutils literal"><span class="pre">algorithm='Brzozowski'</span></tt> or when the automaton is not
deterministic) is used.</li>
</ul>
<p>OUTPUT:</p>
<p>A new automaton.</p>
<p>The resulting automaton is deterministic and has a minimal
number of states.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                (&#39;B&#39;, &#39;C&#39;, 0), (&#39;C&#39;, &#39;C&#39;, 1), (&#39;C&#39;, &#39;C&#39;, 0)],</span>
<span class="go">....:               initial_states=[&#39;A&#39;], final_states=[&#39;C&#39;])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">minimization</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;Brzozowski&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">transitions</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">states</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[Transition from frozenset([frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;C&#39;, &#39;B&#39;]), frozenset([&#39;A&#39;, &#39;C&#39;])]) to</span>
<span class="go">frozenset([frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]), frozenset([&#39;C&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;A&#39;, &#39;C&#39;]), frozenset([&#39;C&#39;])]): 0|-,</span>
<span class="go">Transition from frozenset([frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;C&#39;, &#39;B&#39;]), frozenset([&#39;A&#39;, &#39;C&#39;])]) to</span>
<span class="go">frozenset([frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]), frozenset([&#39;C&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;A&#39;, &#39;C&#39;])]): 1|-]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">states</span><span class="p">())</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">minimization</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;Brzozowski&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">states</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[Transition from frozenset([frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;C&#39;, &#39;B&#39;]), frozenset([&#39;A&#39;, &#39;C&#39;])]) to</span>
<span class="go">frozenset([frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]), frozenset([&#39;C&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;A&#39;, &#39;C&#39;]), frozenset([&#39;C&#39;])]): 0|-,</span>
<span class="go">Transition from frozenset([frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;C&#39;, &#39;B&#39;]), frozenset([&#39;A&#39;, &#39;C&#39;])]) to</span>
<span class="go">frozenset([frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]), frozenset([&#39;C&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;A&#39;, &#39;C&#39;])]): 1|-]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">states</span><span class="p">())</span>
<span class="go">3</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">aut</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="s">&#39;3&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                  (&#39;3&#39;, &#39;2&#39;, &#39;a&#39;), (&#39;2&#39;, &#39;1&#39;, &#39;b&#39;),</span>
<span class="go">....:                  (&#39;3&#39;, &#39;4&#39;, &#39;a&#39;), (&#39;4&#39;, &#39;3&#39;, &#39;b&#39;)],</span>
<span class="go">....:                  initial_states=[&#39;1&#39;], final_states=[&#39;1&#39;])</span>
<span class="gp">sage: </span><span class="nb">min</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">minimization</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;Brzozowski&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nb">min</span><span class="o">.</span><span class="n">states</span><span class="p">()),</span> <span class="nb">len</span><span class="p">(</span><span class="n">aut</span><span class="o">.</span><span class="n">states</span><span class="p">())]</span>
<span class="go">[3, 4]</span>
<span class="gp">sage: </span><span class="nb">min</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">minimization</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;Moore&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">Minimization via Moore&#39;s Algorithm is only</span>
<span class="go">implemented for deterministic finite state machines</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.process">
<tt class="descname">process</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the automaton accepts the input and the state
where the computation stops.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">input_tape</span></tt> &#8211; the input tape can be a list or an
iterable with entries from the input alphabet. If we are
working with a multi-tape machine (see parameter
<tt class="docutils literal"><span class="pre">use_multitape_input</span></tt> and notes below), then the tape is a
list or tuple of tracks, each of which can be a list or an
iterable with entries from the input alphabet.</li>
<li><tt class="docutils literal"><span class="pre">initial_state</span></tt> or <tt class="docutils literal"><span class="pre">initial_states</span></tt> &#8211; the initial
state(s) in which the machine starts. Either specify a
single one with <tt class="docutils literal"><span class="pre">initial_state</span></tt> or a list of them with
<tt class="docutils literal"><span class="pre">initial_states</span></tt>. If both are given, <tt class="docutils literal"><span class="pre">initial_state</span></tt>
will be appended to <tt class="docutils literal"><span class="pre">initial_states</span></tt>. If neither is
specified, the initial states of the finite state machine
are taken.</li>
<li><tt class="docutils literal"><span class="pre">list_of_outputs</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a boolean or
<tt class="docutils literal"><span class="pre">None</span></tt>. If <tt class="docutils literal"><span class="pre">True</span></tt>, then the outputs are given in list form
(even if we have no or only one single output). If
<tt class="docutils literal"><span class="pre">False</span></tt>, then the result is never a list (an exception is
raised if the result cannot be returned). If
<tt class="docutils literal"><span class="pre">list_of_outputs=None</span></tt> the method determines automatically
what to do (e.g. if a non-deterministic machine returns more
than one path, then the output is returned in list form).</li>
<li><tt class="docutils literal"><span class="pre">only_accepted</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a boolean. If set,
then the first argument in the output is guaranteed to be
<tt class="docutils literal"><span class="pre">True</span></tt> (if the output is a list, then the first argument
of each element will be <tt class="docutils literal"><span class="pre">True</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">full_output</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) a boolean. If set,
then the full output is given, otherwise only whether the
sequence is accepted or not (the first entry below only).</li>
<li><tt class="docutils literal"><span class="pre">always_include_output</span></tt> &#8211; if set (not by default), always
return a triple containing the (non-existing) output. This
is in order to obtain output compatible with that of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></tt></a>. If this parameter is set,
<tt class="docutils literal"><span class="pre">full_output</span></tt> has no effect.</li>
<li><tt class="docutils literal"><span class="pre">format_output</span></tt> &#8211; a function that translates the written
output (which is in form of a list) to something more
readable. By default (<tt class="docutils literal"><span class="pre">None</span></tt>) identity is used here.</li>
<li><tt class="docutils literal"><span class="pre">check_epsilon_transitions</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) a
boolean. If <tt class="docutils literal"><span class="pre">False</span></tt>, then epsilon transitions are not
taken into consideration during process.</li>
<li><tt class="docutils literal"><span class="pre">write_final_word_out</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) a boolean
specifying whether the final output words should be written
or not.</li>
<li><tt class="docutils literal"><span class="pre">use_multitape_input</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a
boolean. If <tt class="docutils literal"><span class="pre">True</span></tt>, then the multi-tape mode of the
process iterator is activated. See also the notes below for
multi-tape machines.</li>
<li><tt class="docutils literal"><span class="pre">process_all_prefixes_of_input</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a
boolean. If <tt class="docutils literal"><span class="pre">True</span></tt>, then each prefix of the input word is
processed (instead of processing the whole input word at
once). Consequently, there is an output generated for each
of these prefixes.</li>
<li><tt class="docutils literal"><span class="pre">process_iterator_class</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a class
inherited from <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a>. If <tt class="docutils literal"><span class="pre">None</span></tt>,
then <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a> is taken. An instance of this
class is created and is used during the processing.</li>
</ul>
<p>OUTPUT:</p>
<p>The full output is a pair (or a list of pairs,
cf. parameter <tt class="docutils literal"><span class="pre">list_of_outputs</span></tt>), where</p>
<ul class="simple">
<li>the first entry is <tt class="docutils literal"><span class="pre">True</span></tt> if the input string is accepted and</li>
<li>the second gives the state reached after processing the
input tape (This is a state with label <tt class="docutils literal"><span class="pre">None</span></tt> if the input
could not be processed, i.e., if at one point no
transition to go on could be found.).</li>
</ul>
<p>If <tt class="docutils literal"><span class="pre">full_output</span></tt> is <tt class="docutils literal"><span class="pre">False</span></tt>, then only the first entry
is returned.</p>
<p>If <tt class="docutils literal"><span class="pre">always_include_output</span></tt> is set, an additional third entry
<tt class="docutils literal"><span class="pre">[]</span></tt> is included.</p>
<p>Note that in the case the automaton is not
deterministic, all possible paths are taken into account.
You can use <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.determinisation" title="sage.combinat.finite_state_machine.Automaton.determinisation"><tt class="xref py py-meth docutils literal"><span class="pre">determinisation()</span></tt></a> to get a deterministic
automaton machine.</p>
<p>This function uses an iterator which, in its simplest form, goes
from one state to another in each step. To decide which way to
go, it uses the input words of the outgoing transitions and
compares them to the input tape. More precisely, in each step,
the iterator takes an outgoing transition of the current state,
whose input label equals the input letter of the tape.</p>
<p>If the choice of the outgoing transition is not unique (i.e.,
we have a non-deterministic finite state machine), all
possibilites are followed. This is done by splitting the
process into several branches, one for each of the possible
outgoing transitions.</p>
<p>The process (iteration) stops if all branches are finished,
i.e., for no branch, there is any transition whose input word
coincides with the processed input tape. This can simply
happen when the entire tape was read.</p>
<p>Also see <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a> for a
version of <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><tt class="xref py py-meth docutils literal"><span class="pre">process()</span></tt></a> with shortened output.</p>
<p>Internally this function creates and works with an instance of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a>. This iterator can also be obtained
with <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><tt class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></tt></a>.</p>
<p>If working with multi-tape finite state machines, all input
words of transitions are words of <span class="math">\(k\)</span>-tuples of letters.
Moreover, the input tape has to consist of <span class="math">\(k\)</span> tracks, i.e.,
be a list or tuple of <span class="math">\(k\)</span> iterators, one for each track.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Working with multi-tape finite state machines is still
experimental and can lead to wrong outputs.</p>
</div>
<p>EXAMPLES:</p>
<p>In the following examples, we construct an automaton which
accepts non-adjacent forms (see also the example on
<a class="reference internal" href="#finite-state-machine-recognizing-nafs-example"><em>non-adjacent forms</em></a>
in the documentation of the module
<a class="reference internal" href=""><em>Finite State Machines, Automata, Transducers</em></a>)
and then test it by feeding it with several binary digit
expansions.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">(</span>
<span class="go">....:     {&#39;_&#39;: [(&#39;_&#39;, 0), (&#39;1&#39;, 1)], &#39;1&#39;: [(&#39;_&#39;, 0)]},</span>
<span class="go">....:     initial_states=[&#39;_&#39;], final_states=[&#39;_&#39;, &#39;1&#39;])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">NAF</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                           [0, 1, 1, 1, 0], [1, 0, 0, 1, 1]]]</span>
<span class="go">[(True, &#39;_&#39;), (True, &#39;1&#39;), (False, None),</span>
<span class="go"> (True, &#39;1&#39;), (False, None), (False, None)]</span>
</pre></div>
</div>
<p>If we just want a condensed output, we use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="p">[</span><span class="n">NAF</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">....:     for w in [[0], [0, 1], [1, 1], [0, 1, 0, 1],</span>
<span class="go">....:               [0, 1, 1, 1, 0], [1, 0, 0, 1, 1]]]</span>
<span class="go">[True, True, False, True, False, False]</span>
</pre></div>
</div>
<p>It is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="p">[</span><span class="n">NAF</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                   [0, 1, 1, 1, 0], [1, 0, 0, 1, 1]]]</span>
<span class="go">[True, True, False, True, False, False]</span>
</pre></div>
</div>
<p>The following example illustrates the difference between
non-existing paths and reaching a non-final state:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(False, None)</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="s">&#39;_&#39;</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">Transition from &#39;_&#39; to &#39;s&#39;: 2|-</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(False, &#39;s&#39;)</span>
</pre></div>
</div>
<p>A simple example of a (non-deterministic) multi-tape automaton is the
following: It checks whether the two input tapes have the same number
of ones:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;=&#39;</span><span class="p">,</span> <span class="s">&#39;=&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
<span class="go">....:                (&#39;=&#39;, &#39;=&#39;, (None, 0)),</span>
<span class="go">....:                (&#39;=&#39;, &#39;=&#39;, (0, None)),</span>
<span class="go">....:                (&#39;=&#39;, &#39;&lt;&#39;, (None, 1)),</span>
<span class="go">....:                (&#39;&lt;&#39;, &#39;&lt;&#39;, (None, 1)),</span>
<span class="go">....:                (&#39;&lt;&#39;, &#39;&lt;&#39;, (None, 0)),</span>
<span class="go">....:                (&#39;=&#39;, &#39;&gt;&#39;, (1, None)),</span>
<span class="go">....:                (&#39;&gt;&#39;, &#39;&gt;&#39;, (1, None)),</span>
<span class="go">....:                (&#39;&gt;&#39;, &#39;&gt;&#39;, (0, None))],</span>
<span class="go">....:               initial_states=[&#39;=&#39;],</span>
<span class="go">....:               final_states=[&#39;=&#39;])</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">process</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">use_multitape_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, &#39;&gt;&#39;)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">process</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">use_multitape_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, &#39;&lt;&#39;)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">process</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
<span class="go">....:           use_multitape_input=True)</span>
<span class="go">(True, &#39;=&#39;)</span>
</pre></div>
</div>
<p>Alternatively, we can use the following (non-deterministic)
multi-tape automaton for the same check:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;=&#39;</span><span class="p">,</span> <span class="s">&#39;=&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
<span class="go">....:                (&#39;=&#39;, &#39;&lt;&#39;, (None, 1)),</span>
<span class="go">....:                (&#39;&lt;&#39;, &#39;&lt;&#39;, (0, None)),</span>
<span class="go">....:                (&#39;&lt;&#39;, &#39;=&#39;, (1, None)),</span>
<span class="go">....:                (&#39;=&#39;, &#39;&gt;&#39;, (1, None)),</span>
<span class="go">....:                (&#39;&gt;&#39;, &#39;&gt;&#39;, (None, 0)),</span>
<span class="go">....:                (&#39;&gt;&#39;, &#39;=&#39;, (None, 1))],</span>
<span class="go">....:               initial_states=[&#39;=&#39;],</span>
<span class="go">....:               final_states=[&#39;=&#39;])</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">process</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">use_multitape_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, &#39;&gt;&#39;)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">process</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">use_multitape_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, &#39;&lt;&#39;)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">process</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
<span class="go">....:           use_multitape_input=True)</span>
<span class="go">(True, &#39;=&#39;)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><tt class="xref py py-meth docutils literal"><span class="pre">Transducer.process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><tt class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.shannon_parry_markov_chain">
<tt class="descname">shannon_parry_markov_chain</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.shannon_parry_markov_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a time homogeneous Markov chain such that all words of a
given length recognized by the original automaton occur as the
output with the same weight; the transition probabilities
correspond to the Parry measure.</p>
<p>OUTPUT:</p>
<p>A Markov chain. Its input labels are the transition probabilities, the
output labels the labels of the original automaton. In order to obtain
equal weight for all words of the same length, an &#8220;exit weight&#8221; is
needed. It is stored in the attribute <tt class="docutils literal"><span class="pre">color</span></tt> of the states of the
Markov chain. The weights of the words of the same length sum up to one
up to an exponentially small error.</p>
<p>The stationary distribution of this Markov chain is
saved as the initial probabilities of the states.</p>
<p>The transition probabilities correspond to the Parry measure
(see <a class="reference internal" href="#s1948" id="id2">[S1948]</a> and <a class="reference internal" href="#p1964" id="id3">[P1964]</a>).</p>
<p>The automaton is assumed to be deterministic, irreducible and
aperiodic. All states must be final.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
<span class="go">....:                  (1, 0, 0)], initial_states=[0],</span>
<span class="go">....:                 final_states=[0, 1])</span>
<span class="gp">sage: </span><span class="n">P_NAF</span> <span class="o">=</span> <span class="n">NAF</span><span class="o">.</span><span class="n">shannon_parry_markov_chain</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P_NAF</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: 1/2|0,</span>
<span class="go"> Transition from 0 to 1: 1/4|1,</span>
<span class="go"> Transition from 0 to 1: 1/4|-1,</span>
<span class="go"> Transition from 1 to 0: 1|0]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">P_NAF</span><span class="o">.</span><span class="n">iter_states</span><span class="p">():</span>
<span class="go">....:     print s.color</span>
<span class="go">3/4</span>
<span class="go">3/2</span>
</pre></div>
</div>
<p>The stationary distribution is also computed and saved as the
initial probabilities of the returned Markov chain:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">P_NAF</span><span class="o">.</span><span class="n">states</span><span class="p">():</span>
<span class="go">....:     print s, s.initial_probability</span>
<span class="go">0 2/3</span>
<span class="go">1 1/3</span>
</pre></div>
</div>
<p>The automaton is assumed to be deterministic, irreducible and aperiodic:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">shannon_parry_markov_chain</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">Automaton must be strongly connected.</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">shannon_parry_markov_chain</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">Automaton must be deterministic.</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">shannon_parry_markov_chain</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">Automaton must be aperiodic.</span>
</pre></div>
</div>
<p>All states must be final:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">shannon_parry_markov_chain</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">All states must be final.</span>
</pre></div>
</div>
<p>ALGORITHM:</p>
<p>See <a class="reference internal" href="#hkp2015a" id="id4">[HKP2015a]</a>, Lemma 4.1.</p>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="hkp2015a" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[HKP2015a]</a></td><td>Clemens Heuberger, Sara Kropf, and Helmut
Prodinger, <em>Analysis of Carries in Signed Digit Expansions</em>,
<a class="reference external" href="http://arxiv.org/abs/1503.08816">Arxiv 1503.08816</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="p1964" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[P1964]</a></td><td>William Parry, <em>Intrinsic Markov chains</em>, Transactions
of the American Mathematical Society 112, 1964, pp. 55-66.
<a class="reference external" href="https://dx.doi.org/10.1090/S0002-9947-1964-0161372-1">doi:10.1090/S0002-9947-1964-0161372-1</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="s1948" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[S1948]</a></td><td>Claude E. Shannon, <em>A mathematical theory of communication</em>,
The Bell System Technical Journal 27, 1948, 379-423,
<a class="reference external" href="https://dx.doi.org/10.1002/j.1538-7305.1948.tb01338.x">doi:10.1002/j.1538-7305.1948.tb01338.x</a>.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.with_output">
<tt class="descname">with_output</tt><big>(</big><em>word_out_function=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.with_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a transducer out of this automaton.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">word_out_function</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a function. It
transforms a <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><tt class="xref py py-class docutils literal"><span class="pre">transition</span></tt></a> to the
output word for this transition.</p>
<p>If this is <tt class="docutils literal"><span class="pre">None</span></tt>, then the output word will be equal to
the input word of each transition.</p>
</li>
</ul>
<p>OUTPUT:</p>
<p>A transducer.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">with_output</span><span class="p">();</span> <span class="n">T</span>
<span class="go">Transducer with 3 states</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: &#39;A&#39;|&#39;A&#39;,</span>
<span class="go"> Transition from 0 to 1: &#39;B&#39;|&#39;B&#39;,</span>
<span class="go"> Transition from 1 to 2: &#39;C&#39;|&#39;C&#39;]</span>
</pre></div>
</div>
<p>This result is in contrast to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Transducer</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: &#39;A&#39;|-,</span>
<span class="go"> Transition from 0 to 1: &#39;B&#39;|-,</span>
<span class="go"> Transition from 1 to 2: &#39;C&#39;|-]</span>
</pre></div>
</div>
<p>where no output labels are created.</p>
<p>Here is another example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T2</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">with_output</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">word_in</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T2</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: &#39;A&#39;|&#39;a&#39;,</span>
<span class="go"> Transition from 0 to 1: &#39;B&#39;|&#39;b&#39;,</span>
<span class="go"> Transition from 1 to 2: &#39;C&#39;|&#39;c&#39;]</span>
</pre></div>
</div>
<p>We can obtain the same result by composing two transducers. As inner
transducer of the composition, we use <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.with_output" title="sage.combinat.finite_state_machine.Automaton.with_output"><tt class="xref py py-meth docutils literal"><span class="pre">with_output()</span></tt></a>
without the optional argument
<tt class="docutils literal"><span class="pre">word_out_function</span></tt> (which makes the output of each
transition equal to its input); as outer transducer we use a
<a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.TransducerGenerators.map" title="sage.combinat.finite_state_machine_generators.TransducerGenerators.map"><tt class="xref py py-meth docutils literal"><span class="pre">map-transducer</span></tt></a>
(for converting to lower case).
This gives</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">with_output</span><span class="p">())</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: &#39;A&#39;|&#39;a&#39;,</span>
<span class="go"> Transition from 0 to 1: &#39;B&#39;|&#39;b&#39;,</span>
<span class="go"> Transition from 1 to 2: &#39;C&#39;|&#39;c&#39;]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.input_projection" title="sage.combinat.finite_state_machine.FiniteStateMachine.input_projection"><tt class="xref py py-meth docutils literal"><span class="pre">input_projection()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.output_projection" title="sage.combinat.finite_state_machine.FiniteStateMachine.output_projection"><tt class="xref py py-meth docutils literal"><span class="pre">output_projection()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer" title="sage.combinat.finite_state_machine.Transducer"><tt class="xref py py-class docutils literal"><span class="pre">Transducer</span></tt></a>,
<a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.TransducerGenerators.map" title="sage.combinat.finite_state_machine_generators.TransducerGenerators.map"><tt class="xref py py-meth docutils literal"><span class="pre">transducers.map()</span></tt></a>.</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">with_output</span><span class="p">()</span><span class="o">.</span><span class="n">input_projection</span><span class="p">()</span> <span class="o">==</span> <span class="n">A</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">(</span>
<span class="go">....:     {&#39;A&#39;: [(&#39;A&#39;, 0), (&#39;B&#39;, 1), (&#39;B&#39;, -1)], &#39;B&#39;: [(&#39;A&#39;, 0)]})</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">with_output</span><span class="p">()</span><span class="o">.</span><span class="n">input_projection</span><span class="p">()</span> <span class="o">==</span> <span class="n">NAF</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">(</span>
<span class="go">....:     {0: [(0, &#39;a&#39;), (1, [&#39;b&#39;, &#39;c&#39;]), (2, [&#39;d&#39;, &#39;e&#39;])],</span>
<span class="go">....:      1: [(0, [&#39;f&#39;, &#39;g&#39;]), (1, &#39;h&#39;), (2, None)],</span>
<span class="go">....:      2: [(0, None), (1, None), (2, [&#39;i&#39;, &#39;j&#39;])]},</span>
<span class="go">....:     initial_states=[1, 2], final_states=[0])</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">with_output</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">word_in</span><span class="p">])</span><span class="o">.</span><span class="n">input_projection</span><span class="p">()</span> <span class="o">==</span> <span class="n">B</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.FSMLetterSymbol">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">FSMLetterSymbol</tt><big>(</big><em>letter</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMLetterSymbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string associated to the input letter.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">letter</span></tt> &#8211; the input letter or <tt class="docutils literal"><span class="pre">None</span></tt> (representing the
empty word).</li>
</ul>
<p>OUTPUT:</p>
<p>If <tt class="docutils literal"><span class="pre">letter</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt> the symbol for the empty word
<tt class="docutils literal"><span class="pre">FSMEmptyWordSymbol</span></tt> is returned, otherwise the string
associated to the letter.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMLetterSymbol</span>
<span class="gp">sage: </span><span class="n">FSMLetterSymbol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;0&#39;</span>
<span class="gp">sage: </span><span class="n">FSMLetterSymbol</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="go">&#39;-&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator">
<em class="property">class </em><tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">FSMProcessIterator</tt><big>(</big><em>fsm</em>, <em>input_tape=None</em>, <em>initial_state=None</em>, <em>initial_states=</em>, <span class="optional">[</span><span class="optional">]</span><em>use_multitape_input=False</em>, <em>check_epsilon_transitions=True</em>, <em>write_final_word_out=True</em>, <em>format_output=None</em>, <em>process_all_prefixes_of_input=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.sage_object.SageObject</span></tt></a>, <tt class="xref py py-class docutils literal"><span class="pre">_abcoll.Iterator</span></tt></p>
<p>This class takes an input, feeds it into a finite state machine
(automaton or transducer, in particular), tests whether this was
successful and calculates the written output.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">fsm</span></tt> &#8211; the finite state machine on which the input should be
processed.</li>
<li><tt class="docutils literal"><span class="pre">input_tape</span></tt> &#8211; the input tape can be a list or an
iterable with entries from the input alphabet. If we are
working with a multi-tape machine (see parameter
<tt class="docutils literal"><span class="pre">use_multitape_input</span></tt> and notes below), then the tape is a
list or tuple of tracks, each of which can be a list or an
iterable with entries from the input alphabet.</li>
<li><tt class="docutils literal"><span class="pre">initial_state</span></tt> or <tt class="docutils literal"><span class="pre">initial_states</span></tt> &#8211; the initial
state(s) in which the machine starts. Either specify a
single one with <tt class="docutils literal"><span class="pre">initial_state</span></tt> or a list of them with
<tt class="docutils literal"><span class="pre">initial_states</span></tt>. If both are given, <tt class="docutils literal"><span class="pre">initial_state</span></tt>
will be appended to <tt class="docutils literal"><span class="pre">initial_states</span></tt>. If neither is
specified, the initial states of the finite state machine
are taken.</li>
<li><tt class="docutils literal"><span class="pre">format_output</span></tt> &#8211; a function that translates the written
output (which is in form of a list) to something more
readable. By default (<tt class="docutils literal"><span class="pre">None</span></tt>) identity is used here.</li>
<li><tt class="docutils literal"><span class="pre">check_epsilon_transitions</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) a
boolean. If <tt class="docutils literal"><span class="pre">False</span></tt>, then epsilon transitions are not
taken into consideration during process.</li>
<li><tt class="docutils literal"><span class="pre">write_final_word_out</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) a boolean
specifying whether the final output words should be written
or not.</li>
<li><tt class="docutils literal"><span class="pre">use_multitape_input</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a
boolean. If <tt class="docutils literal"><span class="pre">True</span></tt>, then the multi-tape mode of the
process iterator is activated. See also the notes below for
multi-tape machines.</li>
<li><tt class="docutils literal"><span class="pre">process_all_prefixes_of_input</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a
boolean. If <tt class="docutils literal"><span class="pre">True</span></tt>, then each prefix of the input word is
processed (instead of processing the whole input word at
once). Consequently, there is an output generated for each
of these prefixes.</li>
</ul>
<p>OUTPUT:</p>
<p>An iterator.</p>
<p>In its simplest form, it behaves like an iterator which, in
each step, goes from one state to another. To decide which way
to go, it uses the input words of the outgoing transitions and
compares them to the input tape. More precisely, in each step,
the process iterator takes an outgoing transition of the
current state, whose input label equals the input letter of
the tape. The output label of the transition, if present, is
written on the output tape.</p>
<p>If the choice of the outgoing transition is not unique (i.e.,
we have a non-deterministic finite state machine), all
possibilites are followed. This is done by splitting the
process into several branches, one for each of the possible
outgoing transitions.</p>
<p>The process (iteration) stops if all branches are finished,
i.e., for no branch, there is any transition whose input word
coincides with the processed input tape. This can simply
happen when the entire tape was read.
When the process stops, a <tt class="docutils literal"><span class="pre">StopIteration</span></tt> exception is thrown.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Processing an input tape of length <span class="math">\(n\)</span> usually takes at least <span class="math">\(n+1\)</span>
iterations, since there will be <span class="math">\(n+1\)</span> states visited (in the
case the taken transitions have input words consisting of single
letters).</p>
</div>
<p>An instance of this class is generated when
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></tt></a> or
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.iter_process()</span></tt></a> of a finite state machine,
an automaton, or a transducer is invoked.</p>
<p>When working with multi-tape finite state machines, all input
words of transitions are words of <span class="math">\(k\)</span>-tuples of letters.
Moreover, the input tape has to consist of <span class="math">\(k\)</span> tracks, i.e.,
be a list or tuple of <span class="math">\(k\)</span> iterators, one for each track.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Working with multi-tape finite state machines is still
experimental and can lead to wrong outputs.</p>
</div>
<p>EXAMPLES:</p>
<p>The following transducer reads binary words and outputs a word,
where blocks of ones are replaced by just a single one. Further
only words that end with a zero are accepted.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">)],</span>
<span class="go">....:                 &#39;B&#39;: [(&#39;B&#39;, 1, None), (&#39;A&#39;, 0, [1, 0])]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="nb">input</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
<span class="go">(True, &#39;A&#39;, [1, 0, 0, 1, 0, 1, 0])</span>
</pre></div>
</div>
<p>The function <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></tt></a> (internally) uses a
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a>. We can do that manually, too, and get full
access to the iteration process:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMProcessIterator</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">FSMProcessIterator</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">input_tape</span><span class="o">=</span><span class="nb">input</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">current</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     print current</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;B&#39;</span>
<span class="go">+-- tape at 1, [[]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;B&#39;</span>
<span class="go">+-- tape at 2, [[]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 3, [[1, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 4, [[1, 0, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;B&#39;</span>
<span class="go">+-- tape at 5, [[1, 0, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 6, [[1, 0, 0, 1, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;B&#39;</span>
<span class="go">+-- tape at 7, [[1, 0, 0, 1, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;B&#39;</span>
<span class="go">+-- tape at 8, [[1, 0, 0, 1, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;B&#39;</span>
<span class="go">+-- tape at 9, [[1, 0, 0, 1, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 10, [[1, 0, 0, 1, 0, 1, 0]]</span>
<span class="go">process (0 branches)</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="go">[Branch(accept=True, state=&#39;A&#39;, output=[1, 0, 0, 1, 0, 1, 0])]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                 (1, 2, 1, &#39;c&#39;), (2, 0, 0, &#39;d&#39;),</span>
<span class="go">....:                 (2, 1, None, &#39;d&#39;)],</span>
<span class="go">....:                initial_states=[0], final_states=[2])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
<span class="go">[(False, 1, &#39;abcd&#39;), (True, 2, &#39;abc&#39;)]</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">FSMProcessIterator</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                         format_output=lambda o: &#39;&#39;.join(o))</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">current</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     print current</span>
<span class="go">process (2 branches)</span>
<span class="go">+ at state 0</span>
<span class="go">+-- tape at 1, [[&#39;a&#39;]]</span>
<span class="go">+ at state 1</span>
<span class="go">+-- tape at 1, [[&#39;b&#39;]]</span>
<span class="go">process (2 branches)</span>
<span class="go">+ at state 0</span>
<span class="go">+-- tape at 2, [[&#39;a&#39;, &#39;a&#39;]]</span>
<span class="go">+ at state 1</span>
<span class="go">+-- tape at 2, [[&#39;a&#39;, &#39;b&#39;]]</span>
<span class="go">process (2 branches)</span>
<span class="go">+ at state 1</span>
<span class="go">+-- tape at 3, [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]]</span>
<span class="go">+ at state 2</span>
<span class="go">+-- tape at 3, [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]]</span>
<span class="go">process (0 branches)</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="go">[Branch(accept=False, state=1, output=&#39;abcd&#39;),</span>
<span class="go"> Branch(accept=True, state=2, output=&#39;abc&#39;)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><tt class="xref py py-meth docutils literal"><span class="pre">Transducer.process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.iter_process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.__call__()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator.next" title="sage.combinat.finite_state_machine.FSMProcessIterator.next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a>.</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No state is initial.</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([])</span>
<span class="go">[(False, 0, []), (False, 1, [])]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
<span class="go">....:                initial_states=[0], final_states=[0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">(True, 0, [0, 42])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">write_final_word_out</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">(True, 0, [0])</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.Current">
<em class="property">class </em><tt class="descname">Current</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.Current" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></p>
<p>This class stores the branches which have to be processed
during iteration and provides a nicer formatting of them.</p>
<p>This class is derived from <tt class="docutils literal"><span class="pre">dict</span></tt>. It is returned by the
<tt class="docutils literal"><span class="pre">next</span></tt>-function during iteration.</p>
<p>EXAMPLES:</p>
<p>In the following example you can see the dict directly and
then the nicer output provided by this class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMProcessIterator</span>
<span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">FSMProcessIterator</span><span class="p">(</span><span class="n">inverter</span><span class="p">,</span> <span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">current</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     print dict(current)</span>
<span class="go">....:     print current</span>
<span class="go">{((1, 0),): {&#39;A&#39;: Branch(tape_cache=tape at 1, outputs=[[1]])}}</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 1, [[1]]</span>
<span class="go">{((2, 0),): {&#39;A&#39;: Branch(tape_cache=tape at 2, outputs=[[1, 0]])}}</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 2, [[1, 0]]</span>
<span class="go">{}</span>
<span class="go">process (0 branches)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.FinishedBranch">
<em class="property">class </em><tt class="descclassname">FSMProcessIterator.</tt><tt class="descname">FinishedBranch</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.FinishedBranch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/functions.html#tuple" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></a></p>
<p>A <a class="reference external" href="https://docs.python.org/library/collections.html#collections.namedtuple" title="(in Python v2.7)"><tt class="xref py py-func docutils literal"><span class="pre">named</span> <span class="pre">tuple</span></tt></a> representing the
attributes of a branch, once
it is fully processed.</p>
<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.FinishedBranch.accept">
<tt class="descname">accept</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.FinishedBranch.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.FinishedBranch.output">
<tt class="descname">output</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.FinishedBranch.output" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.FinishedBranch.state">
<tt class="descname">state</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.FinishedBranch.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.accept_input">
<tt class="descclassname">FSMProcessIterator.</tt><tt class="descname">accept_input</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.accept_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Is <tt class="docutils literal"><span class="pre">True</span></tt> if the reached state is accepted. This is only available
at the end of the iteration process.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This attribute is deprecated and should not be used any
longer (it may return a wrong result for non-deterministic
finite state machines).</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     pass</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="go">[Branch(accept=True, state=&#39;A&#39;, output=[1, 0, 0])]</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">accept_input</span>
<span class="go">doctest:...: DeprecationWarning: This attribute will be removed</span>
<span class="go">in future releases. Use result() at the end of our iteration</span>
<span class="go">or the output of next().</span>
<span class="go">See http://trac.sagemath.org/16538 for details.</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.current_state">
<tt class="descclassname">FSMProcessIterator.</tt><tt class="descname">current_state</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.current_state" title="Permalink to this definition">¶</a></dt>
<dd><p>The current/reached state in the process.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This attribute is deprecated and should not be used any
longer (it may return a wrong result for non-deterministic
finite state machines).</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">current</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     s = it.current_state</span>
<span class="go">....:     print current</span>
<span class="go">....:     print &#39;current state:&#39;, s</span>
<span class="go">doctest:...: DeprecationWarning: This attribute will be</span>
<span class="go">removed in future releases. Use result() at the end of our</span>
<span class="go">iteration or the output of next().</span>
<span class="go">See http://trac.sagemath.org/16538 for details.</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 1, [[1]]</span>
<span class="go">current state: &#39;A&#39;</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 2, [[1, 0]]</span>
<span class="go">current state: &#39;A&#39;</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 3, [[1, 0, 0]]</span>
<span class="go">current state: &#39;A&#39;</span>
<span class="go">process (0 branches)</span>
<span class="go">current state: None</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.next">
<tt class="descclassname">FSMProcessIterator.</tt><tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes one step in processing the input tape.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>It returns the current status of the iterator (see below). A
<tt class="docutils literal"><span class="pre">StopIteration</span></tt> exception is thrown when there is/was
nothing to do (i.e. all branches ended with previous call
of <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator.next" title="sage.combinat.finite_state_machine.FSMProcessIterator.next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a>).</p>
<p>The current status is a dictionary (encapsulated into an instance of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator.Current" title="sage.combinat.finite_state_machine.FSMProcessIterator.Current"><tt class="xref py py-class docutils literal"><span class="pre">Current</span></tt></a>).
The keys are positions on
the tape. The value corresponding to such a position is again
a dictionary, where each entry represents a branch of the
process. This dictionary maps the current state of a branch to
a pair consisting of a tape cache and a list of output words,
which were written during reaching this current state.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMProcessIterator</span>
<span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">FSMProcessIterator</span><span class="p">(</span><span class="n">inverter</span><span class="p">,</span> <span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 1, [[1]]</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 2, [[1, 0]]</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">process (0 branches)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><tt class="xref py py-meth docutils literal"><span class="pre">Transducer.process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.iter_process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.__call__()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a>.</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">process</span><span class="p">([])</span>
<span class="go">(True, 0, [1, 2])</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">FSMProcessIterator</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">input_tape</span><span class="o">=</span><span class="p">[])</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">process (0 branches)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">h_old</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">process</span><span class="p">):</span>
<span class="go">....:     print state, process</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">hook</span> <span class="o">=</span> <span class="n">h_old</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">doctest:...: DeprecationWarning: The hook of state 0 cannot</span>
<span class="go">be processed: It seems that you are using an old-style hook,</span>
<span class="go">which is deprecated.</span>
<span class="go">See http://trac.sagemath.org/16538 for details.</span>
<span class="go">(False, 0, [1, 1])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">h_new</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
<span class="go">....:     print state, outputs</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">hook</span> <span class="o">=</span> <span class="n">h_new</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">check_epsilon_transitions</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">0 [[]]</span>
<span class="go">0 [[1]]</span>
<span class="go">0 [[1, 1]]</span>
<span class="go">(False, 0, [1, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.output_tape">
<tt class="descclassname">FSMProcessIterator.</tt><tt class="descname">output_tape</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.output_tape" title="Permalink to this definition">¶</a></dt>
<dd><p>The written output.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This attribute is deprecated and should not be used any
longer (it may return a wrong result for non-deterministic
finite state machines).</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">current</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     t = it.output_tape</span>
<span class="go">....:     print current</span>
<span class="go">....:     print &#39;output:&#39;, t</span>
<span class="go">doctest:...: DeprecationWarning: This attribute will be removed</span>
<span class="go">in future releases. Use result() at the end of our iteration</span>
<span class="go">or the output of next().</span>
<span class="go">See http://trac.sagemath.org/16538 for details.</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 1, [[1]]</span>
<span class="go">output: [1]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 2, [[1, 0]]</span>
<span class="go">output: [1, 0]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 3, [[1, 0, 0]]</span>
<span class="go">output: [1, 0, 0]</span>
<span class="go">process (0 branches)</span>
<span class="go">output: None</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.preview_word">
<tt class="descclassname">FSMProcessIterator.</tt><tt class="descname">preview_word</tt><big>(</big><em>track_number=None</em>, <em>length=1</em>, <em>return_word=False</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.preview_word" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a word from the input tape.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">track_number</span></tt> &#8211; an integer or <tt class="docutils literal"><span class="pre">None</span></tt>. If <tt class="docutils literal"><span class="pre">None</span></tt>,
then a tuple of words (one from each track) is returned.</li>
<li><tt class="docutils literal"><span class="pre">length</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">1</span></tt>) the length of the word(s).</li>
<li><tt class="docutils literal"><span class="pre">return_word</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a boolean. If set,
then a word is returned, otherwise a single letter (in which
case <tt class="docutils literal"><span class="pre">length</span></tt> has to be <tt class="docutils literal"><span class="pre">1</span></tt>).</li>
</ul>
<p>OUTPUT:</p>
<p>A single letter or a word.</p>
<p>An exception <tt class="docutils literal"><span class="pre">StopIteration</span></tt> is thrown if the tape (at least
one track) has reached its end.</p>
<p>Typically, this method is called from a hook-function of a
state.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;one&#39;</span><span class="p">),</span>
<span class="go">....:                              (&#39;A&#39;, 1, &#39;zero&#39;)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">state_hook</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
<span class="go">....:     print &quot;We are now in state %s.&quot; % (state.label(),)</span>
<span class="go">....:     print &quot;Next on the tape is a %s.&quot; % (</span>
<span class="go">....:         process.preview_word(),)</span>
<span class="gp">sage: </span><span class="n">inverter</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hook</span> <span class="o">=</span> <span class="n">state_hook</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span>
<span class="go">....:     input_tape=[0, 1, 1],</span>
<span class="go">....:     check_epsilon_transitions=False)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     pass</span>
<span class="go">We are now in state A.</span>
<span class="go">Next on the tape is a 0.</span>
<span class="go">We are now in state A.</span>
<span class="go">Next on the tape is a 1.</span>
<span class="go">We are now in state A.</span>
<span class="go">Next on the tape is a 1.</span>
<span class="go">We are now in state A.</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="go">[Branch(accept=True, state=&#39;A&#39;, output=[&#39;one&#39;, &#39;zero&#39;, &#39;zero&#39;])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.result">
<tt class="descclassname">FSMProcessIterator.</tt><tt class="descname">result</tt><big>(</big><em>format_output=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.result" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the already finished branches during process.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">format_output</span></tt> &#8211; a function converting the output from
list form to something more readable (default: output the
list directly).</li>
</ul>
<p>OUTPUT:</p>
<p>A list of triples <tt class="docutils literal"><span class="pre">(accepted,</span> <span class="pre">state,</span> <span class="pre">output)</span></tt>.</p>
<p>See also the parameter <tt class="docutils literal"><span class="pre">format_output</span></tt> of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;one&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;zero&#39;</span><span class="p">)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     pass</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="go">[Branch(accept=True, state=&#39;A&#39;, output=[&#39;one&#39;, &#39;zero&#39;, &#39;zero&#39;])]</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="k">lambda</span> <span class="n">L</span><span class="p">:</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>
<span class="go">[(True, &#39;A&#39;, &#39;one, zero, zero&#39;)]</span>
</pre></div>
</div>
<p>Using both the parameter <tt class="docutils literal"><span class="pre">format_output</span></tt> of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a> and the parameter <tt class="docutils literal"><span class="pre">format_output</span></tt>
of <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator.result" title="sage.combinat.finite_state_machine.FSMProcessIterator.result"><tt class="xref py py-meth docutils literal"><span class="pre">result()</span></tt></a> leads to concatenation of the two
functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                            format_output=lambda L: &#39;, &#39;.join(L))</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     pass</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="go">[Branch(accept=True, state=&#39;A&#39;, output=&#39;one, zero, zero&#39;)]</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="k">lambda</span> <span class="n">L</span><span class="p">:</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>
<span class="go">[(True, &#39;A&#39;, &#39;o, n, e, ,,  , z, e, r, o, ,,  , z, e, r, o&#39;)]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.finite_state_machine.FSMState">
<em class="property">class </em><tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">FSMState</tt><big>(</big><em>label</em>, <em>word_out=None</em>, <em>is_initial=False</em>, <em>is_final=False</em>, <em>final_word_out=None</em>, <em>initial_probability=None</em>, <em>hook=None</em>, <em>color=None</em>, <em>allow_label_None=False</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.sage_object.SageObject</span></tt></a></p>
<p>Class for a state of a finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">label</span></tt> &#8211; the label of the state.</li>
<li><tt class="docutils literal"><span class="pre">word_out</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a word that is written when
the state is reached.</li>
<li><tt class="docutils literal"><span class="pre">is_initial</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">is_final</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">final_word_out</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a word that is written when
the state is reached as the last state of some input; only for final
states.</li>
<li><tt class="docutils literal"><span class="pre">initial_probability</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) The probability of
starting in this state if it is a state of a Markov chain.</li>
<li><tt class="docutils literal"><span class="pre">hook</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) A function which is called when
the state is reached during processing input. It takes two input
parameters: the first is the current state (to allow using the same
hook for several states), the second is the current process
iterator object (to have full access to everything; e.g. the
next letter from the input tape can be read in). It can output
the next transition, i.e. the transition to take next. If it
returns <tt class="docutils literal"><span class="pre">None</span></tt> the process iterator chooses. Moreover, this
function can raise a <tt class="docutils literal"><span class="pre">StopIteration</span></tt> exception to stop
processing of a finite state machine the input immediately. See
also the example below.</li>
<li><tt class="docutils literal"><span class="pre">color</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) In order to distinguish states,
they can be given an arbitrary &#8220;color&#8221; (an arbitrary object).
This is used in <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.equivalence_classes" title="sage.combinat.finite_state_machine.FiniteStateMachine.equivalence_classes"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.equivalence_classes()</span></tt></a>:
states of different colors are never considered to be
equivalent. Note that <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.determinisation" title="sage.combinat.finite_state_machine.Automaton.determinisation"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.determinisation()</span></tt></a> requires
that <tt class="docutils literal"><span class="pre">color</span></tt> is hashable.</li>
<li><tt class="docutils literal"><span class="pre">allow_label_None</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) If <tt class="docutils literal"><span class="pre">True</span></tt> allows also
<tt class="docutils literal"><span class="pre">None</span></tt> as label. Note that a state with label <tt class="docutils literal"><span class="pre">None</span></tt> is used in
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>Returns a state of a finite state machine.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;state 1&#39;</span><span class="p">,</span> <span class="n">word_out</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">is_initial</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span>
<span class="go">&#39;state 1&#39;</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
<span class="go">&#39;state 1&#39;</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;state 2&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">==</span> <span class="n">B</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can also define a final output word of a final state which is
used if the input of a transducer leads to this state. Such final
output words are used in subsequential transducers.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;state 3&#39;</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">final_word_out</span><span class="o">=</span><span class="s">&#39;end&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[&#39;end&#39;]</span>
</pre></div>
</div>
<p>The final output word can be a single letter, <tt class="docutils literal"><span class="pre">None</span></tt> or a list of
letters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[2]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[2, 3]</span>
</pre></div>
</div>
<p>Only final states can have a final output word which is not
<tt class="docutils literal"><span class="pre">None</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">final_word_out</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Only final states can have a final output word,</span>
<span class="go">but state B is not final.</span>
</pre></div>
</div>
<p>Setting the <tt class="docutils literal"><span class="pre">final_word_out</span></tt> of a final state to <tt class="docutils literal"><span class="pre">None</span></tt> is the
same as setting it to <tt class="docutils literal"><span class="pre">[]</span></tt> and is also the default for a final
state:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>It is not allowed to use <tt class="docutils literal"><span class="pre">None</span></tt> as a label:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">FSMState</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Label None reserved for a special state,</span>
<span class="go">choose another label.</span>
</pre></div>
</div>
<p>This can be overridden by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FSMState</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">allow_label_None</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.determinisation" title="sage.combinat.finite_state_machine.Automaton.determinisation"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.determinisation()</span></tt></a> requires that <tt class="docutils literal"><span class="pre">color</span></tt>
is hashable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">unhashable type: &#39;list&#39;</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span>
<span class="go">Automaton with 1 state</span>
</pre></div>
</div>
<p>We can use a hook function of a state to stop processing. This is
done by raising a <tt class="docutils literal"><span class="pre">StopIteration</span></tt> exception. The following code
demonstrates this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                 (2, 3, 9, &#39;c&#39;), (3, 4, 9, &#39;d&#39;)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[4],</span>
<span class="go">....:                input_alphabet=[9])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
<span class="go">....:     raise StopIteration()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">hook</span> <span class="o">=</span> <span class="n">stop</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">(False, 3, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMState.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a (shallow) copy of the state.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A new state.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="s">&#39;green&#39;</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">initial_probability</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">fully_equal</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="ow">is</span> <span class="n">B</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_initial</span> <span class="ow">is</span> <span class="n">B</span><span class="o">.</span><span class="n">is_initial</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_final</span> <span class="ow">is</span> <span class="n">B</span><span class="o">.</span><span class="n">is_final</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span> <span class="ow">is</span> <span class="n">B</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">color</span> <span class="ow">is</span> <span class="n">B</span><span class="o">.</span><span class="n">color</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">initial_probability</span> <span class="ow">is</span> <span class="n">B</span><span class="o">.</span><span class="n">initial_probability</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMState.deepcopy">
<tt class="descname">deepcopy</tt><big>(</big><em>memo=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deep copy of the state.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">memo</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a dictionary storing already
processed elements.</li>
</ul>
<p>OUTPUT:</p>
<p>A new state.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="go">....:              is_final=True, final_word_out=3,</span>
<span class="go">....:              initial_probability=1/3)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span>
<span class="go">(1, 3)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">label</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="n">A</span><span class="o">.</span><span class="n">label</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">color</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">color</span> <span class="ow">is</span> <span class="n">A</span><span class="o">.</span><span class="n">color</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_final</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">is_final</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_final</span> <span class="ow">is</span> <span class="n">A</span><span class="o">.</span><span class="n">is_final</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">final_word_out</span> <span class="ow">is</span> <span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">initial_probability</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">initial_probability</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">initial_probability</span> <span class="ow">is</span> <span class="n">A</span><span class="o">.</span><span class="n">initial_probability</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMState.final_word_out">
<tt class="descname">final_word_out</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.final_word_out" title="Permalink to this definition">¶</a></dt>
<dd><p>The final output word of a final state which is written if the
state is reached as the last state of the input of the finite
state machine. For a non-final state, the value is <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">final_word_out</span></tt> can be a single letter, a list or <tt class="docutils literal"><span class="pre">None</span></tt>,
but for a final-state, it is always saved as a list.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">final_word_out</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[2]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[3]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[3, 4]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">final_word_out</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A non-final state cannot have a final output word:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Only final states can have a final</span>
<span class="go">output word, but state B is not final.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMState.fully_equal">
<tt class="descname">fully_equal</tt><big>(</big><em>left</em>, <em>right</em>, <em>compare_color=True</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.fully_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether two states are fully equal, i.e., including all
attributes except <tt class="docutils literal"><span class="pre">hook</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">left</span></tt> &#8211; a state.</li>
<li><tt class="docutils literal"><span class="pre">right</span></tt> &#8211; a state.</li>
<li><tt class="docutils literal"><span class="pre">compare_color</span></tt> &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt> (default) colors are
compared as well, otherwise not.</li>
</ul>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<p>Note that usual comparison by <tt class="docutils literal"><span class="pre">==</span></tt> does only compare the labels.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="n">is_initial</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">fully_equal</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">==</span> <span class="n">B</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span><span class="p">;</span> <span class="n">A</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="s">&#39;green&#39;</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">fully_equal</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">fully_equal</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">compare_color</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMState.initial_probability">
<tt class="descname">initial_probability</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.initial_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>The probability of starting in this state if it is part of a Markov chain.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;state&#39;</span><span class="p">,</span> <span class="n">initial_probability</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">initial_probability</span>
<span class="go">1/3</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMState.is_final">
<tt class="descname">is_final</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.is_final" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes whether the state is final or not.</p>
<p><tt class="docutils literal"><span class="pre">True</span></tt> if the state is final and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">final_word_out</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_final</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">State A cannot be non-final, because it has a</span>
<span class="go">final output word. Only final states can have a final output</span>
<span class="go">word.</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_final</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMState.is_initial">
<tt class="descname">is_initial</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.is_initial" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes whether the state is initial.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMState.label">
<tt class="descname">label</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.label" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the label of the state.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>The label of the state.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;state&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
<span class="go">&#39;state&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMState.relabeled">
<tt class="descname">relabeled</tt><big>(</big><em>label</em>, <em>memo=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.relabeled" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deep copy of the state with a new label.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">label</span></tt> &#8211; the label of new state.</li>
<li><tt class="docutils literal"><span class="pre">memo</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a dictionary storing already
processed elements.</li>
</ul>
<p>OUTPUT:</p>
<p>A new state.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">relabeled</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span>
<span class="go">&#39;B&#39;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.finite_state_machine.FSMTransition">
<em class="property">class </em><tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">FSMTransition</tt><big>(</big><em>from_state</em>, <em>to_state</em>, <em>word_in=None</em>, <em>word_out=None</em>, <em>hook=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMTransition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.sage_object.SageObject</span></tt></a></p>
<p>Class for a transition of a finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">from_state</span></tt> &#8211; state from which transition starts.</li>
<li><tt class="docutils literal"><span class="pre">to_state</span></tt> &#8211; state in which transition ends.</li>
<li><tt class="docutils literal"><span class="pre">word_in</span></tt> &#8211; the input word of the transitions (when the
finite state machine is used as automaton)</li>
<li><tt class="docutils literal"><span class="pre">word_out</span></tt> &#8211; the output word of the transitions (when the
finite state machine is used as transducer)</li>
</ul>
<p>OUTPUT:</p>
<p>A transition of a finite state machine.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span><span class="p">,</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">==</span> <span class="n">S</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">U</span> <span class="o">==</span> <span class="n">T</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMTransition.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMTransition.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a (shallow) copy of the transition.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A new transition.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">copy</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|-</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMTransition.deepcopy">
<tt class="descname">deepcopy</tt><big>(</big><em>memo=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMTransition.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deep copy of the transition.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">memo</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a dictionary storing already
processed elements.</li>
</ul>
<p>OUTPUT:</p>
<p>A new transition.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">deepcopy</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|-</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMTransition.from_state">
<tt class="descname">from_state</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMTransition.from_state" title="Permalink to this definition">¶</a></dt>
<dd><p>State from which the transition starts. Read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMTransition.to_state">
<tt class="descname">to_state</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMTransition.to_state" title="Permalink to this definition">¶</a></dt>
<dd><p>State in which the transition ends. Read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMTransition.word_in">
<tt class="descname">word_in</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMTransition.word_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Input word of the transition. Read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMTransition.word_out">
<tt class="descname">word_out</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMTransition.word_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Output word of the transition. Read-only.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.FSMWordSymbol">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">FSMWordSymbol</tt><big>(</big><em>word</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMWordSymbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string of <tt class="docutils literal"><span class="pre">word</span></tt>. It may returns the symbol of the
empty word <tt class="docutils literal"><span class="pre">FSMEmptyWordSymbol</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">word</span></tt> &#8211; the input word.</li>
</ul>
<p>OUTPUT:</p>
<p>A string of <tt class="docutils literal"><span class="pre">word</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMWordSymbol</span>
<span class="gp">sage: </span><span class="n">FSMWordSymbol</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">&#39;0,1,1&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine">
<em class="property">class </em><tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">FiniteStateMachine</tt><big>(</big><em>data=None</em>, <em>initial_states=None</em>, <em>final_states=None</em>, <em>input_alphabet=None</em>, <em>output_alphabet=None</em>, <em>determine_alphabets=None</em>, <em>with_final_word_out=None</em>, <em>store_states_dict=True</em>, <em>on_duplicate_transition=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.sage_object.SageObject</span></tt></a></p>
<p>Class for a finite state machine.</p>
<p>A finite state machine is a finite set of states connected by
transitions.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">data</span></tt> &#8211; can be any of the following:</p>
<ol class="arabic simple">
<li>a dictionary of dictionaries (of transitions),</li>
<li>a dictionary of lists (of states or transitions),</li>
<li>a list (of transitions),</li>
<li>a function (transition function),</li>
<li>an other instance of a finite state machine.</li>
</ol>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">initial_states</span></tt> and <tt class="docutils literal"><span class="pre">final_states</span></tt> &#8211; the initial and
final states of this machine</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">input_alphabet</span></tt> and <tt class="docutils literal"><span class="pre">output_alphabet</span></tt> &#8211; the input and
output alphabets of this machine</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">determine_alphabets</span></tt> &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt>, then the function
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a> is called after <tt class="docutils literal"><span class="pre">data</span></tt> was read and
processed, if <tt class="docutils literal"><span class="pre">False</span></tt>, then not. If it is <tt class="docutils literal"><span class="pre">None</span></tt>, then it is
decided during the construction of the finite state machine
whether <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a> should be called.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">with_final_word_out</span></tt> &#8211; If given (not <tt class="docutils literal"><span class="pre">None</span></tt>), then the
function <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out"><tt class="xref py py-meth docutils literal"><span class="pre">with_final_word_out()</span></tt></a> (more precisely, its inplace
pendant <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out"><tt class="xref py py-meth docutils literal"><span class="pre">construct_final_word_out()</span></tt></a>) is called with input
<tt class="docutils literal"><span class="pre">letters=with_final_word_out</span></tt> at the end of the creation
process.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">store_states_dict</span></tt> &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt>, then additionally the states
are stored in an interal dictionary for speed up.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">on_duplicate_transition</span></tt> &#8211; A function which is called when a
transition is inserted into <tt class="docutils literal"><span class="pre">self</span></tt> which already existed (same
<tt class="docutils literal"><span class="pre">from_state</span></tt>, same <tt class="docutils literal"><span class="pre">to_state</span></tt>, same <tt class="docutils literal"><span class="pre">word_in</span></tt>, same <tt class="docutils literal"><span class="pre">word_out</span></tt>).</p>
<p>This function is assumed to take two arguments, the first being
the already existing transition, the second being the new
transition (as an <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><tt class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></tt></a>). The function must
return the (possibly modified) original transition.</p>
<p>By default, we have <tt class="docutils literal"><span class="pre">on_duplicate_transition=None</span></tt>, which is
interpreted as
<tt class="docutils literal"><span class="pre">on_duplicate_transition=duplicate_transition_ignore</span></tt>, where
<tt class="docutils literal"><span class="pre">duplicate_transition_ignore</span></tt> is a predefined function
ignoring the occurrence. Other such predefined functions are
<tt class="docutils literal"><span class="pre">duplicate_transition_raise_error</span></tt> and
<tt class="docutils literal"><span class="pre">duplicate_transition_add_input</span></tt>.</p>
</li>
</ul>
<p>OUTPUT:</p>
<p>A finite state machine.</p>
<p>The object creation of <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton" title="sage.combinat.finite_state_machine.Automaton"><tt class="xref py py-class docutils literal"><span class="pre">Automaton</span></tt></a> and <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer" title="sage.combinat.finite_state_machine.Transducer"><tt class="xref py py-class docutils literal"><span class="pre">Transducer</span></tt></a>
is the same as the one described here (i.e. just replace the word
<tt class="docutils literal"><span class="pre">FiniteStateMachine</span></tt> by <tt class="docutils literal"><span class="pre">Automaton</span></tt> or <tt class="docutils literal"><span class="pre">Transducer</span></tt>).</p>
<p>Each transition of an automaton has an input label. Automata can,
for example, be determinised (see
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.determinisation" title="sage.combinat.finite_state_machine.Automaton.determinisation"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.determinisation()</span></tt></a>) and minimized (see
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.minimization" title="sage.combinat.finite_state_machine.Automaton.minimization"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.minimization()</span></tt></a>). Each transition of a transducer
has an input and an output label. Transducers can, for example, be
simplified (see <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.simplification" title="sage.combinat.finite_state_machine.Transducer.simplification"><tt class="xref py py-meth docutils literal"><span class="pre">Transducer.simplification()</span></tt></a>).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span><span class="p">,</span> <span class="n">FSMTransition</span>
</pre></div>
</div>
<p>See documentation for more examples.</p>
<p>We illustrate the different input formats:</p>
<ol class="arabic">
<li><p class="first">The input-data can be a dictionary of dictionaries, where</p>
<ul class="simple">
<li>the keys of the outer dictionary are state-labels (from-states of
transitions),</li>
<li>the keys of the inner dictionaries are state-labels (to-states of
transitions),</li>
<li>the values of the inner dictionaries specify the transition
more precisely.</li>
</ul>
<p>The easiest is to use a tuple consisting of an input and an
output word:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:{</span><span class="s">&#39;b&#39;</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s">&#39;c&#39;</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}})</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
<p>Instead of the tuple anything iterable (e.g. a list) can be
used as well.</p>
<p>If you want to use the arguments of <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><tt class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></tt></a>
directly, you can use a dictionary:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:{</span><span class="s">&#39;b&#39;</span><span class="p">:{</span><span class="s">&#39;word_in&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#39;word_out&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span>
<span class="go">....:                          &#39;c&#39;:{&#39;word_in&#39;:1, &#39;word_out&#39;:1}}})</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
<p>In the case you already have instances of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><tt class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></tt></a>, it is possible to use them directly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:{</span><span class="s">&#39;b&#39;</span><span class="p">:</span><span class="n">FSMTransition</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                          &#39;c&#39;:FSMTransition(&#39;a&#39;, &#39;c&#39;, 1, 1)}})</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
</li>
<li><p class="first">The input-data can be a dictionary of lists, where the keys
are states or label of states.</p>
<p>The list-elements can be states:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">({</span><span class="n">a</span><span class="p">:[</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]})</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
<p>Or the list-elements can simply be labels of states:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">]})</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
<p>The list-elements can also be transitions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:[</span><span class="n">FSMTransition</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                          FSMTransition(&#39;a&#39;, &#39;c&#39;, 1, 1)]})</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
<p>Or they can be tuples of a label, an input word and an output
word specifying a transition:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:[(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]})</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
</li>
<li><p class="first">The input-data can be a list, where its elements specify
transitions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">([</span><span class="n">FSMTransition</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                     FSMTransition(&#39;a&#39;, &#39;c&#39;, 1, 1)])</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
<p>It is possible to skip <tt class="docutils literal"><span class="pre">FSMTransition</span></tt> in the example above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
<p>The parameters of the transition are given in tuples. Anyhow,
anything iterable (e.g. a list) is possible.</p>
<p>You can also name the parameters of the transition. For this
purpose you take a dictionary:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">([{</span><span class="s">&#39;from_state&#39;</span><span class="p">:</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;to_state&#39;</span><span class="p">:</span><span class="s">&#39;b&#39;</span><span class="p">,</span>
<span class="go">....:                      &#39;word_in&#39;:0, &#39;word_out&#39;:1},</span>
<span class="go">....:                     {&#39;from_state&#39;:&#39;a&#39;, &#39;to_state&#39;:&#39;c&#39;,</span>
<span class="go">....:                      &#39;word_in&#39;:1, &#39;word_out&#39;:1}])</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
<p>Other arguments, which <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><tt class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></tt></a> accepts, can be
added, too.</p>
</li>
<li><p class="first">The input-data can also be function acting as transition
function:</p>
<p>This function has two input arguments:</p>
<ol class="arabic simple">
<li>a label of a state (from which the transition starts),</li>
<li>a letter of the (input-)alphabet (as input-label of the transition).</li>
</ol>
<p>It returns a tuple with the following entries:</p>
<ol class="arabic simple">
<li>a label of a state (to which state the transition goes),</li>
<li>a letter of or a word over the (output-)alphabet (as
output-label of the transition).</li>
</ol>
<p>It may also output a list of such tuples if several
transitions from the from-state and the input letter exist
(this means that the finite state machine is
non-deterministic).</p>
<p>If the transition does not exist, the function should raise a
<tt class="docutils literal"><span class="pre">LookupError</span></tt> or return an empty list.</p>
<p>When constructing a finite state machine in this way, some
inital states and an input alphabet have to be specified.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">state_from</span><span class="p">,</span> <span class="n">read</span><span class="p">):</span>
<span class="go">....:     if int(state_from) + read &lt;= 2:</span>
<span class="go">....:         state_to = 2*int(state_from)+read</span>
<span class="go">....:         write = 0</span>
<span class="go">....:     else:</span>
<span class="go">....:         state_to = 2*int(state_from) + read - 5</span>
<span class="go">....:         write = 1</span>
<span class="go">....:     return (str(state_to), write)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">input_alphabet</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                        initial_states=[&#39;0&#39;],</span>
<span class="go">....:                        final_states=[&#39;0&#39;])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(True, &#39;0&#39;, [0, 0, 1])</span>
</pre></div>
</div>
</li>
<li><p class="first">The input-data can be an other instance of a finite state machine:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">F</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The other parameters cannot be specified in that case. If you
want to change these, use the attributes
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.is_initial" title="sage.combinat.finite_state_machine.FSMState.is_initial"><tt class="xref py py-attr docutils literal"><span class="pre">FSMState.is_initial</span></tt></a>, <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.is_final" title="sage.combinat.finite_state_machine.FSMState.is_final"><tt class="xref py py-attr docutils literal"><span class="pre">FSMState.is_final</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.input_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.input_alphabet"><tt class="xref py py-attr docutils literal"><span class="pre">input_alphabet</span></tt></a>, <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.output_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.output_alphabet"><tt class="xref py py-attr docutils literal"><span class="pre">output_alphabet</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition" title="sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition"><tt class="xref py py-attr docutils literal"><span class="pre">on_duplicate_transition</span></tt></a> and methods
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out"><tt class="xref py py-meth docutils literal"><span class="pre">construct_final_word_out()</span></tt></a> on the new machine,
respectively.</p>
</li>
</ol>
<p>The following examples demonstrate the use of <tt class="docutils literal"><span class="pre">on_duplicate_transition</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;a&#39; to &#39;a&#39;: 1/2|-]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_raise_error</span>
<span class="gp">sage: </span><span class="n">F1</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]],</span>
<span class="go">....:                         on_duplicate_transition=duplicate_transition_raise_error)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Attempting to re-insert transition Transition from &#39;a&#39; to &#39;a&#39;: 1/2|-</span>
</pre></div>
</div>
<p>Use <tt class="docutils literal"><span class="pre">duplicate_transition_add_input</span></tt> to emulate a Markov chain,
the input labels are considered as transition probabilities:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_add_input</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]],</span>
<span class="go">....:                        on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;a&#39; to &#39;a&#39;: 1|-]</span>
</pre></div>
</div>
<p>Use <tt class="docutils literal"><span class="pre">with_final_word_out</span></tt> to construct final output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0],</span>
<span class="go">....:                with_final_word_out=0)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">iter_final_states</span><span class="p">():</span>
<span class="go">....:     print s, s.final_word_out</span>
<span class="go">0 []</span>
<span class="go">1 [0]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;S_a&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;S_b&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;S_c&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;S_d&#39;</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">({</span><span class="n">a</span><span class="p">:[</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span> <span class="n">b</span><span class="p">:[</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">],</span>
<span class="go">....:                     c:[a, b], d:[a, c]})</span>
<span class="go">Finite state machine with 4 states</span>
</pre></div>
</div>
<p>We have several constructions which lead to the same finite
state machine:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">FSM1</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span>
<span class="go">....:  {A:{B:{&#39;word_in&#39;:0, &#39;word_out&#39;:1},</span>
<span class="go">....:   C:{&#39;word_in&#39;:1, &#39;word_out&#39;:1}}})</span>
<span class="gp">sage: </span><span class="n">FSM2</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">({</span><span class="n">A</span><span class="p">:{</span><span class="n">B</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">C</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}})</span>
<span class="gp">sage: </span><span class="n">FSM3</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span>
<span class="go">....:  {A:{B:FSMTransition(A, B, 0, 1),</span>
<span class="go">....:      C:FSMTransition(A, C, 1, 1)}})</span>
<span class="gp">sage: </span><span class="n">FSM4</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">({</span><span class="n">A</span><span class="p">:[(</span><span class="n">B</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]})</span>
<span class="gp">sage: </span><span class="n">FSM5</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span>
<span class="go">....:  {A:[FSMTransition(A, B, 0, 1), FSMTransition(A, C, 1, 1)]})</span>
<span class="gp">sage: </span><span class="n">FSM6</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span>
<span class="go">....:  [{&#39;from_state&#39;:A, &#39;to_state&#39;:B, &#39;word_in&#39;:0, &#39;word_out&#39;:1},</span>
<span class="go">....:   {&#39;from_state&#39;:A, &#39;to_state&#39;:C, &#39;word_in&#39;:1, &#39;word_out&#39;:1}])</span>
<span class="gp">sage: </span><span class="n">FSM7</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">FSM8</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span>
<span class="go">....:  [FSMTransition(A, B, 0, 1), FSMTransition(A, C, 1, 1)])</span>

<span class="gp">sage: </span><span class="n">FSM1</span> <span class="o">==</span> <span class="n">FSM2</span> <span class="o">==</span> <span class="n">FSM3</span> <span class="o">==</span> <span class="n">FSM4</span> <span class="o">==</span> <span class="n">FSM5</span> <span class="o">==</span> <span class="n">FSM6</span> <span class="o">==</span> <span class="n">FSM7</span> <span class="o">==</span> <span class="n">FSM8</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It is possible to skip <tt class="docutils literal"><span class="pre">FSMTransition</span></tt> in the example above.</p>
<p>Some more tests for different input-data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:{</span><span class="s">&#39;a&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s">&#39;b&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]},</span>
<span class="go">....:                     &#39;b&#39;:{&#39;b&#39;:[1, 0]}})</span>
<span class="go">Finite state machine with 2 states</span>

<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;S_a&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;S_b&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;S_c&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;S_d&#39;</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t3</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t4</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">([</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span><span class="p">,</span> <span class="n">t4</span><span class="p">])</span>
<span class="go">Finite state machine with 4 states</span>
</pre></div>
</div>
<p>We test that no input parameter is allowed when creating a finite
state machine from an existing instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">initial_states cannot be specified when</span>
<span class="go">copying another finite state machine.</span>
<span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">final_states</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">final_states cannot be specified when</span>
<span class="go">copying another finite state machine.</span>
<span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">input_alphabet</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">input_alphabet cannot be specified when</span>
<span class="go">copying another finite state machine.</span>
<span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">output_alphabet</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">output_alphabet cannot be specified when</span>
<span class="go">copying another finite state machine.</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="p">(</span>
<span class="go">....:     duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">F</span><span class="p">,</span>
<span class="go">....:     on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">on_duplicate_transition cannot be specified when</span>
<span class="go">copying another finite state machine.</span>
<span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">determine_alphabets</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">determine_alphabets cannot be specified when</span>
<span class="go">copying another finite state machine.</span>
<span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">with_final_word_out</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">with_final_word_out cannot be specified when</span>
<span class="go">copying another finite state machine.</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.__call__">
<tt class="descname">__call__</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Call either method <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.composition" title="sage.combinat.finite_state_machine.FiniteStateMachine.composition"><tt class="xref py py-meth docutils literal"><span class="pre">composition()</span></tt></a> or <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">process()</span></tt></a>
(with <tt class="docutils literal"><span class="pre">full_output=False</span></tt>). If the input is not finite
(<tt class="docutils literal"><span class="pre">is_finite</span></tt> of input is <tt class="docutils literal"><span class="pre">False</span></tt>), then
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><tt class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></tt></a> (with <tt class="docutils literal"><span class="pre">iterator_type='simple'</span></tt>) is
called. Moreover, the flag <tt class="docutils literal"><span class="pre">automatic_output_type</span></tt> is set
(unless <tt class="docutils literal"><span class="pre">format_output</span></tt> is specified).
See the documentation of these functions for possible
parameters.</p>
<p>EXAMPLES:</p>
<p>The following code performs a <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.composition" title="sage.combinat.finite_state_machine.FiniteStateMachine.composition"><tt class="xref py py-meth docutils literal"><span class="pre">composition()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;B&#39;, 0, 0)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;], final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                 (2, 2, 0, 1), (2, 1, 1, 1)],</span>
<span class="go">....:                initial_states=[1], final_states=[1])</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[(&#39;A&#39;, 1), (&#39;B&#39;, 1), (&#39;B&#39;, 2)]</span>
</pre></div>
</div>
<p>An automaton or transducer can also act on an input (an list
or other iterable of letters):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">binary_inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:                              initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">binary_inverter</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[1, 0, 1, 1, 0, 0]</span>
</pre></div>
</div>
<p>We can also let them act on <a class="reference internal" href="words/words.html"><em>words</em></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">Words</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span> <span class="n">W</span>
<span class="go">Words over {0, 1}</span>
<span class="gp">sage: </span><span class="n">binary_inverter</span><span class="p">(</span><span class="n">W</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">word: 100100</span>
</pre></div>
</div>
<p>Infinite words work as well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">()</span>
<span class="go">word: 0100101001001010010100100101001001010010...</span>
<span class="gp">sage: </span><span class="n">binary_inverter</span><span class="p">(</span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">())</span>
<span class="go">word: 1011010110110101101011011010110110101101...</span>
</pre></div>
</div>
<p>When only one successful path is found in a non-deterministic
transducer, the result of that path is returned.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0], final_states=[1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[(True, 1, [1]), (False, 2, [2])]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[1]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.composition" title="sage.combinat.finite_state_machine.FiniteStateMachine.composition"><tt class="xref py py-meth docutils literal"><span class="pre">composition()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><tt class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><tt class="xref py py-meth docutils literal"><span class="pre">Transducer.process()</span></tt></a>.</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">)],</span>
<span class="go">....:                        initial_states=[0],</span>
<span class="go">....:                        final_states=[1])</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0],</span>
<span class="go">....:               final_states=[1])</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">(True, 1, [&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[&#39;a&#39;]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(False, 2, [&#39;b&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">(False, None, None)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                         (11, 13, 3, &#39;c&#39;), (11, 14, 4, &#39;d&#39;),</span>
<span class="go">....:                         (12, 13, 3, &#39;e&#39;), (12, 13, 3, &#39;f&#39;),</span>
<span class="go">....:                         (12, 14, 4, &#39;g&#39;), (12, 14, 4, &#39;h&#39;),</span>
<span class="go">....:                         (12, 13, 2, &#39;i&#39;), (12, 14, 2, &#39;j&#39;)],</span>
<span class="go">....:                        initial_states=[11],</span>
<span class="go">....:                        final_states=[13])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="go">....:     return &#39;&#39;.join(o)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">(False, None, None)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">(True, 13, &#39;c&#39;)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">(False, 14, &#39;d&#39;)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Got more than one output, but only allowed to show</span>
<span class="go">one. Change list_of_outputs option.</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[(True, 13, &#39;bi&#39;), (False, 14, &#39;bj&#39;)]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Got more than one output, but only allowed to show</span>
<span class="go">one. Change list_of_outputs option.</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[(True, 13, &#39;be&#39;), (True, 13, &#39;bf&#39;)]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Got more than one output, but only allowed to show</span>
<span class="go">one. Change list_of_outputs option.</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[(False, 14, &#39;bg&#39;), (False, 14, &#39;bh&#39;)]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="go">....:                (11, 13, 3), (11, 14, 4),</span>
<span class="go">....:                (12, 13, 3), (12, 14, 4),</span>
<span class="go">....:                (12, 32, 3), (12, 42, 4),</span>
<span class="go">....:                (12, 13, 2), (12, 14, 2)],</span>
<span class="go">....:               initial_states=[11],</span>
<span class="go">....:               final_states=[13, 32])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="go">....:     return &#39;&#39;.join(o)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[True, False]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[True, True]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[False, False]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                 (11, 13, 3, &#39;c&#39;), (11, 14, 4, &#39;d&#39;),</span>
<span class="go">....:                 (12, 13, 3, &#39;e&#39;), (12, 13, 3, &#39;f&#39;),</span>
<span class="go">....:                 (12, 14, 4, &#39;g&#39;), (12, 14, 4, &#39;h&#39;),</span>
<span class="go">....:                 (12, 13, 2, &#39;i&#39;), (12, 14, 2, &#39;j&#39;)],</span>
<span class="go">....:                initial_states=[11],</span>
<span class="go">....:                final_states=[13])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="go">....:     return &#39;&#39;.join(o)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">&#39;c&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">&#39;bi&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[&#39;bi&#39;, None]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
<span class="go">....:   list_of_outputs=True, only_accepted=True)</span>
<span class="go">[&#39;bi&#39;]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[(True, 13, &#39;bi&#39;), (False, 14, &#39;bj&#39;)]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Found more than one accepting path.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[&#39;be&#39;, &#39;bf&#39;]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[None, None]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
<span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">inverter</span><span class="p">(</span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">())</span>
<span class="go">word: 1011010110110101101011011010110110101101...</span>
<span class="gp">sage: </span><span class="n">inverter</span><span class="p">(</span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">(),</span> <span class="n">automatic_output_type</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">word: 1011010110110101101011011010110110101101...</span>
<span class="gp">sage: </span><span class="nb">tuple</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">inverter</span><span class="p">(</span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">(),</span>
<span class="go">....:                       automatic_output_type=False), 10))</span>
<span class="go">(1, 0, 1, 1, 0, 1, 0, 1, 1, 0)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">inverter</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:               automatic_output_type=False))</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">inverter</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:               automatic_output_type=True))</span>
<span class="go">&lt;type &#39;tuple&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components">
<tt class="descname">accessible_components</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new finite state machine with the accessible states
of self and all transitions between those states.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A finite state machine with the accessible states of self and
all transitions between those states.</p>
<p>A state is accessible if there is a directed path from an
initial state to the state. If self has no initial states then
a copy of the finite state machine self is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">accessible_components</span><span class="p">()</span>
<span class="go">Automaton with 2 states</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">accessible_components</span><span class="p">()</span>
<span class="go">Automaton with 1 state</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Check whether input of length &gt; 1 works:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">accessible_components</span><span class="p">()</span>
<span class="go">Automaton with 3 states</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.add_from_transition_function">
<tt class="descname">add_from_transition_function</tt><big>(</big><em>function</em>, <em>initial_states=None</em>, <em>explore_existing_states=True</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_from_transition_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a finite state machine from a transition function.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">function</span></tt> may return a tuple (new_state, output_word) or a
list of such tuples.</li>
<li><tt class="docutils literal"><span class="pre">initial_states</span></tt> &#8211; If no initial states are given, the
already existing initial states of self are taken.</li>
<li>If <tt class="docutils literal"><span class="pre">explore_existing_states</span></tt> is True (default), then
already existing states in self (e.g. already given final
states) will also be processed if they are reachable from
the initial states.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">],</span>
<span class="go">....:                        input_alphabet=[0, 1])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
<span class="go">....:     return [(&#39;A&#39;, input), (&#39;B&#39;, 1-input)]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_from_transition_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;A&#39;: 0|0,</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|1,</span>
<span class="go">Transition from &#39;A&#39; to &#39;A&#39;: 1|1,</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 1|0,</span>
<span class="go">Transition from &#39;B&#39; to &#39;A&#39;: 0|0,</span>
<span class="go">Transition from &#39;B&#39; to &#39;B&#39;: 0|1,</span>
<span class="go">Transition from &#39;B&#39; to &#39;A&#39;: 1|1,</span>
<span class="go">Transition from &#39;B&#39; to &#39;B&#39;: 1|0]</span>
</pre></div>
</div>
<p>Initial states can also be given as a parameter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">input_alphabet</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
<span class="go">....:     return [(&#39;A&#39;, input), (&#39;B&#39;, 1-input)]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_from_transition_function</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;]</span>
</pre></div>
</div>
<p>Already existing states in the finite state machine (the final
states in the example below) are also explored:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="go">....:                        final_states=[1],</span>
<span class="go">....:                        input_alphabet=[0])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">transition_function</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">letter</span><span class="p">):</span>
<span class="go">....:     return(1-state, [])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_from_transition_function</span><span class="p">(</span><span class="n">transition_function</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|-,</span>
<span class="go"> Transition from 1 to 0: 0|-]</span>
</pre></div>
</div>
<p>If <tt class="docutils literal"><span class="pre">explore_existing_states=False</span></tt>, however, this behavior
is turned off, i.e., already existing states are not
explored:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="go">....:                        final_states=[1],</span>
<span class="go">....:                        input_alphabet=[0])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">transition_function</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">letter</span><span class="p">):</span>
<span class="go">....:     return(1-state, [])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_from_transition_function</span><span class="p">(</span><span class="n">transition_function</span><span class="p">,</span>
<span class="go">....:                                explore_existing_states=False)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|-]</span>
</pre></div>
</div>
<p>TEST:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
<span class="go">....:     return [(&#39;A&#39;, input), (&#39;B&#39;, 1-input)]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_from_transition_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No input alphabet is given.</span>
<span class="go">Try calling determine_alphabets().</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">transition</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">where</span><span class="p">):</span>
<span class="go">....:     return (vector([0, 0]), 1)</span>
<span class="gp">sage: </span><span class="n">Transducer</span><span class="p">(</span><span class="n">transition</span><span class="p">,</span> <span class="n">input_alphabet</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">mutable vectors are unhashable</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.add_state">
<tt class="descname">add_state</tt><big>(</big><em>state</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a state to the finite state machine and returns the new
state. If the state already exists, that existing state is
returned.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">state</span></tt> is either an instance of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><tt class="xref py py-class docutils literal"><span class="pre">FSMState</span></tt></a> or,
otherwise, a label of a state.</li>
</ul>
<p>OUTPUT:</p>
<p>The new or existing state.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="n">is_initial</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">&#39;A&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.add_states">
<tt class="descname">add_states</tt><big>(</big><em>states</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds several states. See add_state for more information.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">states</span></tt> &#8211; a list of states or iterator over states.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_states</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;, &#39;B&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.add_transition">
<tt class="descname">add_transition</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a transition to the finite state machine and returns the
new transition.</p>
<p>If the transition already exists, the return value of
<tt class="docutils literal"><span class="pre">self.on_duplicate_transition</span></tt> is returned. See the
documentation of <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>.</p>
<p>INPUT:</p>
<p>The following forms are all accepted:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span><span class="p">,</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">FSMTransition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|1</span>

<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|1</span>

<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">word_in</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">word_out</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|1</span>

<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;word_in&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;word_out&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: {&#39;word_in&#39;: 0, &#39;word_out&#39;: 1}|-</span>

<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">from_state</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">to_state</span><span class="o">=</span><span class="n">B</span><span class="p">,</span>
<span class="go">....:                    word_in=0, word_out=1)</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|1</span>

<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">add_transition</span><span class="p">({</span><span class="s">&#39;from_state&#39;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="s">&#39;to_state&#39;</span><span class="p">:</span> <span class="n">B</span><span class="p">,</span>
<span class="go">....:                    &#39;word_in&#39;: 0, &#39;word_out&#39;: 1})</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|1</span>

<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|1</span>

<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">add_transition</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|1</span>
</pre></div>
</div>
<p>If the states <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> are not instances of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><tt class="xref py py-class docutils literal"><span class="pre">FSMState</span></tt></a>, then it is assumed that they are labels of
states.</p>
<p>OUTPUT:</p>
<p>The new transition.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.add_transitions_from_function">
<tt class="descname">add_transitions_from_function</tt><big>(</big><em>function</em>, <em>labels_as_input=True</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_transitions_from_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds one or more transitions if <tt class="docutils literal"><span class="pre">function(state,</span> <span class="pre">state)</span></tt>
says that there are some.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">function</span></tt> &#8211; a transition function. Given two states
<tt class="docutils literal"><span class="pre">from_state</span></tt> and <tt class="docutils literal"><span class="pre">to_state</span></tt> (or their labels if
<tt class="docutils literal"><span class="pre">label_as_input</span></tt> is true), this function shall return a
tuple <tt class="docutils literal"><span class="pre">(word_in,</span> <span class="pre">word_out)</span></tt> to add a transition from
<tt class="docutils literal"><span class="pre">from_state</span></tt> to <tt class="docutils literal"><span class="pre">to_state</span></tt> with input and output labels
<tt class="docutils literal"><span class="pre">word_in</span></tt> and <tt class="docutils literal"><span class="pre">word_out</span></tt>, respectively. If no such
addition is to be added, the transition function shall
return <tt class="docutils literal"><span class="pre">None</span></tt>. The transition function may also return
a list of such tuples in order to add multiple transitions
between the pair of states.</li>
<li><tt class="docutils literal"><span class="pre">label_as_input</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>)</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_states</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">):</span>
<span class="go">....:     if state1 == &#39;C&#39;:</span>
<span class="go">....:         return None</span>
<span class="go">....:     return (0, 1)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_transitions_from_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">6</span>
</pre></div>
</div>
<p>Multiple transitions are also possible:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_states</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">):</span>
<span class="go">....:     if state1 != state2:</span>
<span class="go">....:          return [(0, 1), (1, 0)]</span>
<span class="go">....:     else:</span>
<span class="go">....:          return None</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_transitions_from_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|1,</span>
<span class="go"> Transition from 0 to 1: 1|0,</span>
<span class="go"> Transition from 1 to 0: 0|1,</span>
<span class="go"> Transition from 1 to 0: 1|0]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">):</span>
<span class="go">....:     return 1</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_transitions_from_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The callback function for add_transitions_from_function</span>
<span class="go">is expected to return a pair (word_in, word_out) or a list of such</span>
<span class="go">pairs. For states 0 and 0 however, it returned 1,</span>
<span class="go">which is not acceptable.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.adjacency_matrix">
<tt class="descname">adjacency_matrix</tt><big>(</big><em>input=None</em>, <em>entry=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.adjacency_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the adjacency matrix of the underlying graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">input</span></tt> &#8211; Only transitions with input label <tt class="docutils literal"><span class="pre">input</span></tt> are
respected.</li>
<li><tt class="docutils literal"><span class="pre">entry</span></tt> &#8211; The function <tt class="docutils literal"><span class="pre">entry</span></tt> takes a transition and the
return value is written in the matrix as the entry
<tt class="docutils literal"><span class="pre">(transition.from_state,</span> <span class="pre">transition.to_state)</span></tt>. The default
value (<tt class="docutils literal"><span class="pre">None</span></tt>) of entry takes the variable <tt class="docutils literal"><span class="pre">x</span></tt> to the
power of the sum of the output word of the transition.</li>
</ul>
<p>OUTPUT:</p>
<p>A matrix.</p>
<p>If any label of a state is not an integer, the finite state
machine is relabeled at the beginning.  If there are more than
one transitions between two states, then the different return
values of <tt class="docutils literal"><span class="pre">entry</span></tt> are added up.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">({</span><span class="mi">0</span><span class="p">:{</span><span class="mi">0</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s">&#39;a&#39;</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)},</span>
<span class="go">....:                         &#39;a&#39;:{2:(0, 0), 3:(1, 0)},</span>
<span class="go">....:                         2:{0:(1, 1), 4:(0, 0)},</span>
<span class="go">....:                         3:{&#39;a&#39;:(0, 1), 2:(1, 1)},</span>
<span class="go">....:                         4:{4:(1, 1), 3:(0, 1)}},</span>
<span class="go">....:                        initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[1 1 0 0 0]</span>
<span class="go">[0 0 1 1 0]</span>
<span class="go">[x 0 0 0 1]</span>
<span class="go">[0 x x 0 0]</span>
<span class="go">[0 0 0 x x]</span>
</pre></div>
</div>
<p>This is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">matrix</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[1 1 0 0 0]</span>
<span class="go">[0 0 1 1 0]</span>
<span class="go">[x 0 0 0 1]</span>
<span class="go">[0 x x 0 0]</span>
<span class="go">[0 0 0 x x]</span>
</pre></div>
</div>
<p>It is also possible to use other entries in the adjacency matrix:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">entry</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">transition</span><span class="p">:</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">[1 1 0 0 0]</span>
<span class="go">[0 0 1 1 0]</span>
<span class="go">[1 0 0 0 1]</span>
<span class="go">[0 1 1 0 0]</span>
<span class="go">[0 0 0 1 1]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">transition</span><span class="p">:</span>
<span class="go">....:     exp(I*transition.word_out[0]*var(&#39;t&#39;))))</span>
<span class="go">[      0       1       0       0       0]</span>
<span class="go">[      0       0       0       1       0]</span>
<span class="go">[e^(I*t)       0       0       0       0]</span>
<span class="go">[      0       0 e^(I*t)       0       0]</span>
<span class="go">[      0       0       0       0 e^(I*t)]</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                (1, 2, 0),</span>
<span class="go">....:                (2, 0, 1),</span>
<span class="go">....:                (2, 1, 0)],</span>
<span class="go">....:               initial_states=[0],</span>
<span class="go">....:               final_states=[0])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 1 0]</span>
<span class="go">[0 0 1]</span>
<span class="go">[1 1 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.asymptotic_moments">
<tt class="descname">asymptotic_moments</tt><big>(</big><em>variable=n</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.asymptotic_moments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the main terms of expectation and variance of the sum
of output labels and its covariance with the sum of input
labels.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">variable</span></tt> &#8211; a symbol denoting the length of the input,
by default <span class="math">\(n\)</span>.</li>
</ul>
<p>OUTPUT:</p>
<p>A dictionary consisting of</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">expectation</span></tt> &#8211; <span class="math">\(e n + \operatorname{Order}(1)\)</span>,</li>
<li><tt class="docutils literal"><span class="pre">variance</span></tt> &#8211; <span class="math">\(v n + \operatorname{Order}(1)\)</span>,</li>
<li><tt class="docutils literal"><span class="pre">covariance</span></tt> &#8211; <span class="math">\(c n + \operatorname{Order}(1)\)</span></li>
</ul>
<p>for suitable constants <span class="math">\(e\)</span>, <span class="math">\(v\)</span> and <span class="math">\(c\)</span>.</p>
<p>Assume that all input and output labels are numbers and that
<tt class="docutils literal"><span class="pre">self</span></tt> is complete and has only one final component. Assume
further that this final component is aperiodic. Furthermore,
assume that there is exactly one initial state and that all
states are final.</p>
<p>Denote by <span class="math">\(X_n\)</span> the sum of output labels written by the
finite state machine when reading a random input word of
length <span class="math">\(n\)</span> over the input alphabet (assuming
equidistribution).</p>
<p>Then the expectation of <span class="math">\(X_n\)</span> is <span class="math">\(en+O(1)\)</span>, the variance
of <span class="math">\(X_n\)</span> is <span class="math">\(vn+O(1)\)</span> and the covariance of <span class="math">\(X_n\)</span> and
the sum of input labels is <span class="math">\(cn+O(1)\)</span>, cf. <a class="reference internal" href="#hkw2015" id="id5">[HKW2015]</a>,
Theorem 3.9.</p>
<p>In the case of non-integer input or output labels, performance
degrades significantly. For rational input and output labels,
consider rescaling to integers. This limitation comes from the
fact that determinants over polynomial rings can be computed
much more efficiently than over the symbolic ring. In fact, we
compute (parts) of a trivariate generating function where the
input and output labels are exponents of some indeterminates,
see <a class="reference internal" href="#hkw2015" id="id6">[HKW2015]</a>, Theorem 3.9 for details. If those exponents are
integers, we can use a polynomial ring.</p>
<p>EXAMPLES:</p>
<ol class="arabic">
<li><p class="first">A trivial example: write the negative of the input:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[0, -1, -1]</span>
<span class="gp">sage: </span><span class="n">moments</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">-1/2*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;variance&#39;</span><span class="p">]</span>
<span class="go">1/4*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;covariance&#39;</span><span class="p">]</span>
<span class="go">-1/4*n + Order(1)</span>
</pre></div>
</div>
</li>
<li><p class="first">For the case of the Hamming weight of the non-adjacent-form
(NAF) of integers, cf. the <a class="reference external" href="https://en.wikipedia.org/wiki/Non-adjacent_form">Wikipedia article Non-adjacent_form</a>
and the <a class="reference internal" href="#finite-state-machine-recognizing-nafs-example"><em>example on recognizing NAFs</em></a>, the
following agrees with the results in <a class="reference internal" href="#hp2007" id="id7">[HP2007]</a>.</p>
<p>We first use the transducer to convert the standard binary
expansion to the NAF given in <a class="reference internal" href="#hp2007" id="id8">[HP2007]</a>. We use the parameter
<tt class="docutils literal"><span class="pre">with_final_word_out</span></tt> such that we do not have to add
sufficiently many trailing zeros:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                   (0, &#39;.1&#39;, 1, None),</span>
<span class="go">....:                   (&#39;.1&#39;, 0, 0, [1, 0]),</span>
<span class="go">....:                   (&#39;.1&#39;, 1, 1, [-1, 0]),</span>
<span class="go">....:                   (1, 1, 1, 0),</span>
<span class="go">....:                   (1, &#39;.1&#39;, 0, None)],</span>
<span class="go">....:                  initial_states=[0],</span>
<span class="go">....:                  final_states=[0],</span>
<span class="go">....:                  with_final_word_out=[0])</span>
</pre></div>
</div>
<p>As an example, we compute the NAF of <span class="math">\(27\)</span> by this
transducer.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">binary_27</span> <span class="o">=</span> <span class="mf">27.</span><span class="n">bits</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">binary_27</span>
<span class="go">[1, 1, 0, 1, 1]</span>
<span class="gp">sage: </span><span class="n">NAF_27</span> <span class="o">=</span> <span class="n">NAF</span><span class="p">(</span><span class="n">binary_27</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">NAF_27</span>
<span class="go">[-1, 0, -1, 0, 0, 1, 0]</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="n">NAF_27</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">27</span>
</pre></div>
</div>
<p>Next, we are only interested in the Hamming weight:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">weight</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
<span class="go">....:     if input is None:</span>
<span class="go">....:         result = 0</span>
<span class="go">....:     else:</span>
<span class="go">....:         result = ZZ(input != 0)</span>
<span class="go">....:     return (0, result)</span>
<span class="gp">sage: </span><span class="n">weight_transducer</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span>
<span class="go">....:                                input_alphabet=[-1, 0, 1],</span>
<span class="go">....:                                initial_states=[0],</span>
<span class="go">....:                                final_states=[0])</span>
<span class="gp">sage: </span><span class="n">NAFweight</span> <span class="o">=</span> <span class="n">weight_transducer</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">NAF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">NAFweight</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (0, 0) to (0, 0): 0|0,</span>
<span class="go"> Transition from (0, 0) to (&#39;.1&#39;, 0): 1|-,</span>
<span class="go"> Transition from (&#39;.1&#39;, 0) to (0, 0): 0|1,0,</span>
<span class="go"> Transition from (&#39;.1&#39;, 0) to (1, 0): 1|1,0,</span>
<span class="go"> Transition from (1, 0) to (&#39;.1&#39;, 0): 0|-,</span>
<span class="go"> Transition from (1, 0) to (1, 0): 1|0]</span>
<span class="gp">sage: </span><span class="n">NAFweight</span><span class="p">(</span><span class="n">binary_27</span><span class="p">)</span>
<span class="go">[1, 0, 1, 0, 0, 1, 0]</span>
</pre></div>
</div>
<p>Now, we actually compute the asymptotic moments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">moments</span> <span class="o">=</span> <span class="n">NAFweight</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">1/3*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;variance&#39;</span><span class="p">]</span>
<span class="go">2/27*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;covariance&#39;</span><span class="p">]</span>
<span class="go">Order(1)</span>
</pre></div>
</div>
</li>
<li><p class="first">This is Example 3.16 in <a class="reference internal" href="#hkw2015" id="id9">[HKW2015]</a>, where a transducer with
variable output labels is given. There, the aim was to
choose the output labels of this very simple transducer such
that the input and output sum are asymptotically
independent, i.e., the constant <span class="math">\(c\)</span> vanishes.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s">&#39;a_1, a_2, a_3, a_4&#39;</span><span class="p">)</span>
<span class="go">(a_1, a_2, a_3, a_4)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a_1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a_3</span><span class="p">],</span>
<span class="go">....:                 [1, 0, 0, a_4], [1, 1, 1, a_2]],</span>
<span class="go">....:                initial_states=[0], final_states=[0, 1])</span>
<span class="gp">sage: </span><span class="n">moments</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="go">verbose 0 (...) Non-integer output weights lead to</span>
<span class="go">significant performance degradation.</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">1/4*(a_1 + a_2 + a_3 + a_4)*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;covariance&#39;</span><span class="p">]</span>
<span class="go">-1/4*(a_1 - a_2)*n + Order(1)</span>
</pre></div>
</div>
<p>Therefore, the asymptotic covariance vanishes if and only if
<span class="math">\(a_2=a_1\)</span>.</p>
</li>
<li><p class="first">This is Example 4.3 in <a class="reference internal" href="#hkw2015" id="id10">[HKW2015]</a>, dealing with the
transducer converting the binary expansion of an integer
into Gray code (cf. the <a class="reference external" href="https://en.wikipedia.org/wiki/Gray_code">Wikipedia article Gray_code</a> and the
<a class="reference internal" href="#finite-state-machine-gray-code-example"><em>example on Gray code</em></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">moments</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">GrayCode</span><span class="p">()</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">1/2*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;variance&#39;</span><span class="p">]</span>
<span class="go">1/4*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;covariance&#39;</span><span class="p">]</span>
<span class="go">Order(1)</span>
</pre></div>
</div>
</li>
<li><p class="first">This is the first part of Example 4.4 in <a class="reference internal" href="#hkw2015" id="id11">[HKW2015]</a>,
counting the number of 10 blocks in the standard binary
expansion. The least significant digit is at the left-most
position:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">block10</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">(</span>
<span class="go">....:     [1, 0],</span>
<span class="go">....:     input_alphabet=[0, 1])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">block10</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from () to (): 0|0,</span>
<span class="go"> Transition from () to (1,): 1|0,</span>
<span class="go"> Transition from (1,) to (): 0|1,</span>
<span class="go"> Transition from (1,) to (1,): 1|0]</span>
<span class="gp">sage: </span><span class="n">moments</span> <span class="o">=</span> <span class="n">block10</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">1/4*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;variance&#39;</span><span class="p">]</span>
<span class="go">1/16*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;covariance&#39;</span><span class="p">]</span>
<span class="go">Order(1)</span>
</pre></div>
</div>
</li>
<li><p class="first">This is the second part of Example 4.4 in <a class="reference internal" href="#hkw2015" id="id12">[HKW2015]</a>,
counting the number of 11 blocks in the standard binary
expansion. The least significant digit is at the left-most
position:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">block11</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">(</span>
<span class="go">....:     [1, 1],</span>
<span class="go">....:     input_alphabet=[0, 1])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">block11</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from () to (): 0|0,</span>
<span class="go"> Transition from () to (1,): 1|0,</span>
<span class="go"> Transition from (1,) to (): 0|0,</span>
<span class="go"> Transition from (1,) to (1,): 1|1]</span>
<span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s">&#39;N&#39;</span><span class="p">)</span>
<span class="go">N</span>
<span class="gp">sage: </span><span class="n">moments</span> <span class="o">=</span> <span class="n">block11</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">1/4*N + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;variance&#39;</span><span class="p">]</span>
<span class="go">5/16*N + Order(1)</span>
<span class="gp">sage: </span><span class="n">correlation</span> <span class="o">=</span> <span class="p">(</span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;covariance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">coefficient</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span>
<span class="go">....:                (1/2 * sqrt(moments[&#39;variance&#39;].coefficient(N))))</span>
<span class="gp">sage: </span><span class="n">correlation</span>
<span class="go">2/5*sqrt(5)</span>
</pre></div>
</div>
</li>
<li><p class="first">This is Example 4.5 in <a class="reference internal" href="#hkw2015" id="id13">[HKW2015]</a>, counting the number of
01 blocks minus the number of 10 blocks in the standard binary
expansion. The least significant digit is at the left-most
position:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">block01</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">(</span>
<span class="go">....:     [0, 1],</span>
<span class="go">....:     input_alphabet=[0, 1])</span>
<span class="gp">sage: </span><span class="n">product_01x10</span> <span class="o">=</span> <span class="n">block01</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">block10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">block_difference</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])(</span><span class="n">product_01x10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">block_difference</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|-1,</span>
<span class="go"> Transition from 0 to 0: 1|0,</span>
<span class="go"> Transition from 1 to 1: 0|0,</span>
<span class="go"> Transition from 1 to 0: 1|1,</span>
<span class="go"> Transition from 2 to 1: 0|0,</span>
<span class="go"> Transition from 2 to 0: 1|0]</span>
<span class="gp">sage: </span><span class="n">moments</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;variance&#39;</span><span class="p">]</span>
<span class="go">Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;covariance&#39;</span><span class="p">]</span>
<span class="go">Order(1)</span>
</pre></div>
</div>
</li>
<li><p class="first">The finite state machine must have a unique final component:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (-1, -1, -1, -1), (-1, -1, 1, -1),</span>
<span class="go">....:                 (1, 1, -1, 1), (1, 1, 1, 1)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0, 1, -1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">asymptotic_moments is only</span>
<span class="go">implemented for finite state machines with one final</span>
<span class="go">component.</span>
</pre></div>
</div>
<p>In this particular example, the first letter of the input
decides whether we reach the loop at <span class="math">\(-1\)</span> or the loop at
<span class="math">\(1\)</span>. In the first case, we have <span class="math">\(X_n = -n\)</span>, while we have
<span class="math">\(X_n = n\)</span> in the second case. Therefore, the expectation
<span class="math">\(E(X_n)\)</span> of <span class="math">\(X_n\)</span> is <span class="math">\(E(X_n) = 0\)</span>. We get <span class="math">\((X_n-E(X_n))^2 =
n^2\)</span> in all cases, which results in a variance of <span class="math">\(n^2\)</span>.</p>
<p>So this example shows that the variance may be non-linear if
there is more than one final component.</p>
</li>
</ol>
<p>TESTS:</p>
<ol class="arabic">
<li><p class="first">An input alphabet must be given:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
<span class="go">....:                initial_states=[0], final_states=[0],</span>
<span class="go">....:                determine_alphabets=False)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No input alphabet is given.</span>
<span class="go">Try calling determine_alphabets().</span>
</pre></div>
</div>
</li>
<li><p class="first">The finite state machine must have a unique initial state:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">A unique initial state is required.</span>
</pre></div>
</div>
</li>
<li><p class="first">The finite state machine must be complete:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
<span class="go">....:                initial_states=[0], final_states=[0],</span>
<span class="go">....:                input_alphabet=[0, 1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">This finite state machine is</span>
<span class="go">not complete.</span>
</pre></div>
</div>
</li>
<li><p class="first">The final component of the finite state machine must be
aperiodic:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0], final_states=[0, 1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">asymptotic_moments is only</span>
<span class="go">implemented for finite state machines whose unique final</span>
<span class="go">component is aperiodic.</span>
</pre></div>
</div>
</li>
<li><p class="first">Non-integer input or output labels lead to a warning:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]],</span>
<span class="go">....:                initial_states=[0], final_states=[0])</span>
<span class="gp">sage: </span><span class="n">moments</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="go">verbose 0 (...) Non-integer output weights lead to</span>
<span class="go">significant performance degradation.</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">-1/4*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;variance&#39;</span><span class="p">]</span>
<span class="go">1/16*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;covariance&#39;</span><span class="p">]</span>
<span class="go">-1/8*n + Order(1)</span>
</pre></div>
</div>
<p>This warning can be silenced by <a class="reference external" href="../../../misc/sage/misc/misc.html#sage.misc.misc.set_verbose" title="(in Sage Reference Manual: Utilities v6.9)"><tt class="xref py py-func docutils literal"><span class="pre">set_verbose()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">set_verbose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;finite_state_machine.py&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">moments</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">-1/4*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;variance&#39;</span><span class="p">]</span>
<span class="go">1/16*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s">&#39;covariance&#39;</span><span class="p">]</span>
<span class="go">-1/8*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">set_verbose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;finite_state_machine.py&quot;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Check whether <tt class="docutils literal"><span class="pre">word_out</span></tt> of <tt class="docutils literal"><span class="pre">FSMState</span></tt> are correctly
dealt with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">word_out</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="go">....:              is_initial=True,</span>
<span class="go">....:              is_final=True)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                initial_states=[s], final_states=[s])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[2, 1, 2, 1, 2]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()[</span><span class="s">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">3*n + Order(1)</span>
</pre></div>
</div>
<p>The same test for non-integer output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">word_out</span><span class="o">=</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)],</span>
<span class="go">....:                initial_states=[s], final_states=[s])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()[</span><span class="s">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">verbose 0 (...) Non-integer output weights lead to</span>
<span class="go">significant performance degradation.</span>
<span class="go">7/6*n + Order(1)</span>
</pre></div>
</div>
</li>
<li><p class="first">All states of <tt class="docutils literal"><span class="pre">self</span></tt> have to be final:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Not all states are final.</span>
</pre></div>
</div>
</li>
</ol>
<p>ALGORITHM:</p>
<p>See <a class="reference internal" href="#hkw2015" id="id14">[HKW2015]</a>, Theorem 3.9.</p>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="hp2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[HP2007]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id8">2</a>)</em> Clemens Heuberger and Helmut Prodinger, <em>The Hamming
Weight of the Non-Adjacent-Form under Various Input Statistics</em>,
Periodica Mathematica Hungarica Vol. 55 (1), 2007, pp. 81–96,
<a class="reference external" href="https://dx.doi.org/10.1007/s10998-007-3081-z">doi:10.1007/s10998-007-3081-z</a>.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.completion">
<tt class="descname">completion</tt><big>(</big><em>sink=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.completion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a completion of this finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">sink</span></tt> &#8211; either an instance of <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><tt class="xref py py-class docutils literal"><span class="pre">FSMState</span></tt></a> or a label
for the sink (default: <tt class="docutils literal"><span class="pre">None</span></tt>). If <tt class="docutils literal"><span class="pre">None</span></tt>, the least
available non-zero integer is used.</li>
</ul>
<p>OUTPUT:</p>
<p>A <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a> of the same type as this finite
state machine.</p>
<p>The resulting finite state machine is a complete version of this
finite state machine.  A finite state machine is considered to
be complete if each transition has an input label of length one
and for each pair <span class="math">\((q, a)\)</span> where <span class="math">\(q\)</span> is a state and <span class="math">\(a\)</span> is an
element of the input alphabet, there is exactly one transition
from <span class="math">\(q\)</span> with input label <span class="math">\(a\)</span>.</p>
<p>If this finite state machine is already complete, a deep copy is
returned. Otherwise, a new non-final state (usually called a
sink) is created and transitions to this sink are introduced as
appropriate.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                         (0, 1, 1, 1),</span>
<span class="go">....:                         (1, 1, 0, 0)])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">completion</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: 0|0,</span>
<span class="go"> Transition from 0 to 1: 1|1,</span>
<span class="go"> Transition from 1 to 1: 0|0,</span>
<span class="go"> Transition from 1 to 2: 1|-,</span>
<span class="go"> Transition from 2 to 2: 0|-,</span>
<span class="go"> Transition from 2 to 2: 1|-]</span>
<span class="gp">sage: </span><span class="n">G2</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">completion</span><span class="p">(</span><span class="s">&#39;Sink&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G2</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G2</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: 0|0,</span>
<span class="go"> Transition from 0 to 1: 1|1,</span>
<span class="go"> Transition from 1 to 1: 0|0,</span>
<span class="go"> Transition from 1 to &#39;Sink&#39;: 1|-,</span>
<span class="go"> Transition from &#39;Sink&#39; to &#39;Sink&#39;: 0|-,</span>
<span class="go"> Transition from &#39;Sink&#39; to &#39;Sink&#39;: 1|-]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">completion</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The finite state machine already contains a state</span>
<span class="go">&#39;1&#39;.</span>
</pre></div>
</div>
<p>An input alphabet must be given:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                         (0, 1, 1, 1),</span>
<span class="go">....:                         (1, 1, 0, 0)],</span>
<span class="go">....:                        determine_alphabets=False)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No input alphabet is given. Try calling</span>
<span class="go">determine_alphabets().</span>
</pre></div>
</div>
<p>Non-deterministic machines are not allowed.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">completion</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The finite state machine must be deterministic.</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">completion</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The finite state machine must be deterministic.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_complete" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_complete"><tt class="xref py py-meth docutils literal"><span class="pre">is_complete()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.split_transitions" title="sage.combinat.finite_state_machine.FiniteStateMachine.split_transitions"><tt class="xref py py-meth docutils literal"><span class="pre">split_transitions()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_deterministic" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_deterministic"><tt class="xref py py-meth docutils literal"><span class="pre">is_deterministic()</span></tt></a>.</p>
</div>
<p>TESTS:</p>
<p>Test the use of an <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><tt class="xref py py-class docutils literal"><span class="pre">FSMState</span></tt></a> as sink:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                         (0, 1, 1, 1),</span>
<span class="go">....:                         (1, 1, 0, 0)])</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">completion</span><span class="p">(</span><span class="n">FSMState</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The finite state machine already contains a state</span>
<span class="go">&#39;1&#39;.</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">completion</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="ow">is</span> <span class="n">s</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.composition">
<tt class="descname">composition</tt><big>(</big><em>other</em>, <em>algorithm=None</em>, <em>only_accessible_components=True</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.composition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new transducer which is the composition of <tt class="docutils literal"><span class="pre">self</span></tt>
and <tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; a transducer</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; can be one of the following</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">direct</span></tt> &#8211; The composition is calculated directly.</p>
<p>There can be arbitrarily many initial and final states,
but the input and output labels must have length <span class="math">\(1\)</span>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The output of <tt class="docutils literal"><span class="pre">other</span></tt> is fed into <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">explorative</span></tt> &#8211; An explorative algorithm is used.</p>
<p>The input alphabet of self has to be specified.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The output of <tt class="docutils literal"><span class="pre">other</span></tt> is fed into <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
</div>
</li>
</ul>
<p>If algorithm is <tt class="docutils literal"><span class="pre">None</span></tt>, then the algorithm is chosen
automatically (at the moment always <tt class="docutils literal"><span class="pre">direct</span></tt>, except when
there are output words of <tt class="docutils literal"><span class="pre">other</span></tt> or input words of <tt class="docutils literal"><span class="pre">self</span></tt>
of length greater than <span class="math">\(1\)</span>).</p>
</li>
</ul>
<p>OUTPUT:</p>
<p>A new transducer.</p>
<p>The labels of the new finite state machine are pairs of states
of the original finite state machines. The color of a new
state is the tuple of colors of the constituent states.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;, &#39;B&#39;], final_states=[&#39;B&#39;],</span>
<span class="go">....:                determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (2, 2, 1, 1), (2, 2, 0, 0)],</span>
<span class="go">....:                initial_states=[1], final_states=[2],</span>
<span class="go">....:                determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Hd</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[(1, &#39;B&#39;), (1, &#39;A&#39;)]</span>
<span class="gp">sage: </span><span class="n">Hd</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (1, &#39;B&#39;) to (1, &#39;A&#39;): 1|1,</span>
<span class="go"> Transition from (1, &#39;A&#39;) to (2, &#39;B&#39;): 0|0,</span>
<span class="go"> Transition from (2, &#39;B&#39;) to (2, &#39;A&#39;): 0|1,</span>
<span class="go"> Transition from (2, &#39;A&#39;) to (2, &#39;B&#39;): 1|0]</span>
<span class="gp">sage: </span><span class="n">He</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">He</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[(1, &#39;A&#39;), (1, &#39;B&#39;)]</span>
<span class="gp">sage: </span><span class="n">He</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (1, &#39;A&#39;) to (2, &#39;B&#39;): 0|0,</span>
<span class="go"> Transition from (1, &#39;B&#39;) to (1, &#39;A&#39;): 1|1,</span>
<span class="go"> Transition from (2, &#39;B&#39;) to (2, &#39;A&#39;): 0|1,</span>
<span class="go"> Transition from (2, &#39;A&#39;) to (2, &#39;B&#39;): 1|0]</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">==</span> <span class="n">He</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The following example has output of length <span class="math">\(&gt; 1\)</span>, so the
explorative algorithm has to be used (and is selected
automatically).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;B&#39;, 0, 0)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;], final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                 (2, 2, 0, 1), (2, 1, 1, 1)],</span>
<span class="go">....:                initial_states=[1], final_states=[1])</span>
<span class="gp">sage: </span><span class="n">He</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">He</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;A&#39;, 1) to (&#39;B&#39;, 2): 1|0,1,</span>
<span class="go"> Transition from (&#39;B&#39;, 2) to (&#39;B&#39;, 2): 0|1,</span>
<span class="go"> Transition from (&#39;B&#39;, 2) to (&#39;B&#39;, 1): 1|1,</span>
<span class="go"> Transition from (&#39;B&#39;, 1) to (&#39;B&#39;, 1): 0|0,</span>
<span class="go"> Transition from (&#39;B&#39;, 1) to (&#39;B&#39;, 2): 1|0]</span>
<span class="gp">sage: </span><span class="n">Ha</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Ha</span> <span class="o">==</span> <span class="n">He</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Final output words are also considered:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;, &#39;B&#39;],</span>
<span class="go">....:                final_states=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (2, 2, 1, 1), (2, 2, 0, 0)],</span>
<span class="go">....:                initial_states=[1], final_states=[2])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Hd</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[(2, &#39;B&#39;)]</span>
<span class="gp">sage: </span><span class="n">He</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">He</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[(2, &#39;B&#39;)]</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">(2,</span> <span class="pre">'A')</span></tt> is not final, as the final output <span class="math">\(0\)</span>
of state <span class="math">\(2\)</span> of <span class="math">\(G\)</span> cannot be processed in state <tt class="docutils literal"><span class="pre">'A'</span></tt> of
<span class="math">\(F\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">final_word_out</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Hd</span><span class="o">.</span><span class="n">final_states</span><span class="p">()]</span>
<span class="go">[[1, 0]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">final_word_out</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">He</span><span class="o">.</span><span class="n">final_states</span><span class="p">()]</span>
<span class="go">[[1, 0]]</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">==</span> <span class="n">He</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Here is a non-deterministic example with intermediate output
length <span class="math">\(&gt;1\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">]),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                 (2, 1, 2, &#39;a&#39;), (2, 2, 2, &#39;b&#39;)],</span>
<span class="go">....:                initial_states=[1, 2])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;i&#39;</span><span class="p">),</span>
<span class="go">....:                 (&#39;A&#39;, &#39;B&#39;, &#39;a&#39;, &#39;l&#39;),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;B&#39;, &#39;b&#39;, &#39;e&#39;)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (1, &#39;A&#39;) to (1, &#39;A&#39;): 1|&#39;i&#39;,&#39;i&#39;,</span>
<span class="go"> Transition from (1, &#39;A&#39;) to (1, &#39;B&#39;): 1|&#39;i&#39;,&#39;l&#39;,</span>
<span class="go"> Transition from (1, &#39;B&#39;) to (2, &#39;B&#39;): 1|&#39;e&#39;,</span>
<span class="go"> Transition from (2, &#39;A&#39;) to (1, &#39;A&#39;): 2|&#39;i&#39;,</span>
<span class="go"> Transition from (2, &#39;A&#39;) to (1, &#39;B&#39;): 2|&#39;l&#39;,</span>
<span class="go"> Transition from (2, &#39;B&#39;) to (2, &#39;B&#39;): 2|&#39;e&#39;]</span>
</pre></div>
</div>
<p>Be aware that after composition, different transitions may
share the same output label (same python object):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="s">&#39;B&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;],</span>
<span class="go">....:                final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">word_out</span> <span class="ow">is</span> <span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">word_out</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;C&#39;</span><span class="p">,</span><span class="s">&#39;C&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)],)</span>
<span class="go">....:                initial_states=[&#39;C&#39;],</span>
<span class="go">....:                final_states=[&#39;C&#39;])</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">transitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">word_out</span> <span class="ow">is</span> <span class="n">H</span><span class="o">.</span><span class="n">transitions</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">word_out</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>In the explorative algorithm, transducers with non-empty final
output words are implemented in <a class="reference external" href="http://trac.sagemath.org/16548">trac ticket #16548</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">GrayCode</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">abs</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;explorative&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (0, 0) to (0, 1): 0|-,</span>
<span class="go"> Transition from (0, 0) to (0, 2): 1|-,</span>
<span class="go"> Transition from (0, 1) to (0, 1): 0|0,</span>
<span class="go"> Transition from (0, 1) to (0, 2): 1|1,</span>
<span class="go"> Transition from (0, 2) to (0, 1): 0|1,</span>
<span class="go"> Transition from (0, 2) to (0, 2): 1|0]</span>
</pre></div>
</div>
<p>Similarly, the explorative algorithm can handle
non-deterministic finite state machines as of <a class="reference external" href="http://trac.sagemath.org/16548">trac ticket #16548</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">Identity</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;explorative&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (0, 0) to (0, 0): 0|0,</span>
<span class="go"> Transition from (0, 0) to (0, 1): 0|0]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;explorative&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (0, 0) to (0, 0): 0|0,</span>
<span class="go"> Transition from (0, 0) to (1, 0): 0|0]</span>
</pre></div>
</div>
<p>In the following example, <tt class="docutils literal"><span class="pre">algorithm='direct'</span></tt> is inappropriate
as there are edges with output labels of length greater than 1:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;B&#39;, 0, 0)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;], final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                 (2, 2, 0, 1), (2, 1, 1, 1)],</span>
<span class="go">....:                initial_states=[1], final_states=[1])</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In the following examples, we compose transducers and automata
and check whether the types are correct.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="p">(</span>
<span class="go">....:     is_Automaton, is_Transducer)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">is_Transducer</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_Transducer</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;explorative&#39;</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Composition with automaton is not possible.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Composition with automaton is not possible.</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Composition with automaton is not possible.</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Composition with automaton is not possible.</span>
<span class="gp">sage: </span><span class="n">is_Automaton</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_Automaton</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;explorative&#39;</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Non-deterministic final output cannot be handeled:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;I&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">42</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;I&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">42</span><span class="p">)],</span>
<span class="go">....:                initial_states=[&#39;I&#39;],</span>
<span class="go">....:                final_states=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="go">....:                final_states=[0],</span>
<span class="go">....:                input_alphabet=[0])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">H</span><span class="o">.</span><span class="n">final_states</span><span class="p">():</span>
<span class="go">....:     print s, s.final_word_out</span>
<span class="go">(0, &#39;I&#39;) [42]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="s">&#39;a&#39;</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="s">&#39;b&#39;</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">Stopping in state (0, &#39;I&#39;) leads to</span>
<span class="go">non-deterministic final output.</span>
</pre></div>
</div>
<p>Check that the output and input alphabets are set correctly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                determine_alphabets=False)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)],</span>
<span class="go">....:                initial_states=[2],</span>
<span class="go">....:                determine_alphabets=False)</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Hd</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">Hd</span><span class="o">.</span><span class="n">output_alphabet</span>
<span class="go">([1], [&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">He</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No input alphabet is given. Try calling</span>
<span class="go">determine_alphabets().</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Hd</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">Hd</span><span class="o">.</span><span class="n">output_alphabet</span>
<span class="go">([1], [&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">He</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">He</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">He</span><span class="o">.</span><span class="n">output_alphabet</span>
<span class="go">([1], None)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">output_alphabet</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Hd</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">Hd</span><span class="o">.</span><span class="n">output_alphabet</span>
<span class="go">([1], [&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">He</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">He</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">He</span><span class="o">.</span><span class="n">output_alphabet</span>
<span class="go">([1], [&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">==</span> <span class="n">He</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Hd</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">Hd</span><span class="o">.</span><span class="n">output_alphabet</span>
<span class="go">([1], [&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">He</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No input alphabet is given. Try calling</span>
<span class="go">determine_alphabets().</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.concatenation">
<tt class="descname">concatenation</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.concatenation" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate this finite state machine with another finite
state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; a <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>A <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a> of the same type as this finite
state machine.</p>
<p>Assume that both finite state machines are automata. If
<span class="math">\(\mathcal{L}_1\)</span> is the language accepted by this automaton and
<span class="math">\(\mathcal{L}_2\)</span> is the language accepted by the other automaton,
then the language accepted by the concatenated automaton is
<span class="math">\(\{ w_1w_2 \mid w_1\in\mathcal{L}_1, w_2\in\mathcal{L}_2\}\)</span> where
<span class="math">\(w_1w_2\)</span> denotes the concatenation of the words <span class="math">\(w_1\)</span> and <span class="math">\(w_2\)</span>.</p>
<p>Assume that both finite state machines are transducers and that
this transducer maps words <span class="math">\(w_1\in\mathcal{L}_1\)</span> to words
<span class="math">\(f_1(w_1)\)</span> and that the other transducer maps words
<span class="math">\(w_2\in\mathcal{L}_2\)</span> to words <span class="math">\(f_2(w_2)\)</span>. Then the concatenated
transducer maps words <span class="math">\(w_1w_2\)</span> with <span class="math">\(w_1\in\mathcal{L}_1\)</span> and
<span class="math">\(w_2\in\mathcal{L}_2\)</span> to <span class="math">\(f_1(w_1)f_2(w_2)\)</span>. Here, <span class="math">\(w_1w_2\)</span> and
<span class="math">\(f_1(w_1)f_2(w_2)\)</span> again denote concatenation of words.</p>
<p>The input alphabet is the union of the input alphabets (if
possible) and <tt class="docutils literal"><span class="pre">None</span></tt> otherwise. In the latter case, try
calling <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a>.</p>
<p>Instead of <tt class="docutils literal"><span class="pre">A.concatenation(B)</span></tt>, the notation <tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">B</span></tt> can be
used.</p>
<p>EXAMPLES:</p>
<p>Concatenation of two automata:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">Word</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">Word</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">concatenation</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (0, 0) to (0, 1): 0|-,</span>
<span class="go"> Transition from (0, 1) to (1, 0): -|-,</span>
<span class="go"> Transition from (1, 0) to (1, 1): 1|-]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">w</span>
<span class="go">....:  for w in ([0, 0], [0, 1], [1, 0], [1, 1])</span>
<span class="go">....:  if C(w)]</span>
<span class="go">[[0, 1]]</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="p">(</span>
<span class="go">....:     is_Automaton, is_Transducer)</span>
<span class="gp">sage: </span><span class="n">is_Automaton</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Concatenation of two transducers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">concatenation</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (0, 0) to (0, 1): 0|1,</span>
<span class="go"> Transition from (0, 0) to (0, 1): 1|2,</span>
<span class="go"> Transition from (0, 1) to (1, 0): -|-,</span>
<span class="go"> Transition from (1, 0) to (1, 1): 0|1,</span>
<span class="go"> Transition from (1, 0) to (1, 1): 1|0]</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">w</span><span class="p">,</span> <span class="n">C</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])]</span>
<span class="go">[([0, 0], [1, 1]),</span>
<span class="go"> ([0, 1], [1, 0]),</span>
<span class="go"> ([1, 0], [2, 1]),</span>
<span class="go"> ([1, 1], [2, 0])]</span>
<span class="gp">sage: </span><span class="n">is_Transducer</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Alternative notation as multiplication:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">==</span> <span class="n">A</span> <span class="o">*</span> <span class="n">B</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Final output words are taken into account:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">B</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[1, 2, 3, 4]</span>
</pre></div>
</div>
<p>Handling of the input alphabet:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">input_alphabet</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">determine_alphabets</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])],</span> <span class="n">input_alphabet</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[1, 2]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[[0, 0]]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.disjoint_union" title="sage.combinat.finite_state_machine.FiniteStateMachine.disjoint_union"><tt class="xref py py-meth docutils literal"><span class="pre">disjoint_union()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a>.</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">*</span> <span class="n">F</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Cannot concatenate finite state machines of</span>
<span class="go">different types.</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">*</span> <span class="n">A</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Cannot concatenate finite state machines of</span>
<span class="go">different types.</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">*</span> <span class="mi">5</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">A finite state machine can only be concatenated</span>
<span class="go">with a another finite state machine.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out">
<tt class="descname">construct_final_word_out</tt><big>(</big><em>letters</em>, <em>allow_non_final=True</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an inplace version of <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out"><tt class="xref py py-meth docutils literal"><span class="pre">with_final_word_out()</span></tt></a>. See
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out"><tt class="xref py py-meth docutils literal"><span class="pre">with_final_word_out()</span></tt></a> for documentation and examples.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0])</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">construct_final_word_out</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">==</span> <span class="n">F</span>  <span class="c"># indirect doctest</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">)],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a (shallow) copy of the finite state machine.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A new finite state machine.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">copy</span><span class="p">(</span><span class="n">FiniteStateMachine</span><span class="p">())</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.deepcopy">
<tt class="descname">deepcopy</tt><big>(</big><em>memo=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deep copy of the finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">memo</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a dictionary storing already
processed elements.</li>
</ul>
<p>OUTPUT:</p>
<p>A new finite state machine.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">deepcopy</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="go">Finite state machine with 1 state</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Make sure that the links between transitions and states
are still intact:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">from_state</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_state</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.default_format_letter">
<tt class="descname">default_format_letter</tt><big>(</big><em>x</em>, <em>combine_all=False</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.default_format_letter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.LatexExpr" title="(in Sage Reference Manual: Utilities v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">LatexExpr</span></tt></a> built out of the argument <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; a Sage object</li>
<li><tt class="docutils literal"><span class="pre">combine_all</span></tt> &#8211; boolean (Default: <tt class="docutils literal"><span class="pre">False</span></tt>) If <tt class="docutils literal"><span class="pre">combine_all</span></tt>
is <tt class="docutils literal"><span class="pre">True</span></tt> and the input is a tuple, then it does not return a
tuple and instead returns a string with all the elements separated by
a single space.</li>
</ul>
<p>OUTPUT:</p>
<p>A <a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.LatexExpr" title="(in Sage Reference Manual: Utilities v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">LatexExpr</span></tt></a> built from <tt class="docutils literal"><span class="pre">x</span></tt></p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">Integer</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>  <span class="c"># indirect doctest</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="mi">1</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
<span class="go">\mathrm{False}</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="n">latex</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">\left[x, 2\right]</span>
</pre></div>
</div>
<p>Check that <a class="reference external" href="http://trac.sagemath.org/11775">trac ticket #11775</a> is fixed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">latex</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">combine_all</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">x 2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label">
<tt class="descname">default_format_transition_label</tt><big>(</big><em>word</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Default formatting of words in transition labels for LaTeX output.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">word</span></tt> &#8211; list of letters</p>
<p>OUTPUT:</p>
<p>String representation of <tt class="docutils literal"><span class="pre">word</span></tt> suitable to be typeset in
mathematical mode.</p>
<ul class="simple">
<li>For a non-empty word: Concatenation of the letters, piped through
<tt class="docutils literal"><span class="pre">self.format_letter</span></tt> and separated by blanks.</li>
<li>For an empty word:
<tt class="docutils literal"><span class="pre">sage.combinat.finite_state_machine.EmptyWordLaTeX</span></tt>.</li>
</ul>
<p>There is also a variant <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label_reversed" title="sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label_reversed"><tt class="xref py py-meth docutils literal"><span class="pre">format_transition_label_reversed()</span></tt></a>
writing the words in reversed order.</p>
<p>EXAMPLES:</p>
<ol class="arabic">
<li><p class="first">Example of a non-empty word:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">(</span>
<span class="go">....:    [&#39;a&#39;, &#39;alpha&#39;, &#39;a_1&#39;, &#39;0&#39;, 0, (0, 1)])</span>
<span class="go">\text{\texttt{a}} \text{\texttt{alpha}}</span>
<span class="go">\text{\texttt{a{\char`\_}1}} 0 0 \left(0, 1\right)</span>
</pre></div>
</div>
</li>
<li><p class="first">In the example above, <tt class="docutils literal"><span class="pre">'a'</span></tt> and <tt class="docutils literal"><span class="pre">'alpha'</span></tt> should perhaps
be symbols:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s">&#39;a alpha a_1&#39;</span><span class="p">)</span>
<span class="go">(a, alpha, a_1)</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">a_1</span><span class="p">])</span>
<span class="go">a \alpha a_{1}</span>
</pre></div>
</div>
</li>
<li><p class="first">Example of an empty word:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">print</span> <span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">([])</span>
<span class="go">\varepsilon</span>
</pre></div>
</div>
<p>We can change this by setting
<tt class="docutils literal"><span class="pre">sage.combinat.finite_state_machine.EmptyWordLaTeX</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">finite_state_machine</span><span class="o">.</span><span class="n">EmptyWordLaTeX</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">([])</span>
<span class="go">&#39;&#39;</span>
</pre></div>
</div>
<p>Finally, we restore the default value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">finite_state_machine</span><span class="o">.</span><span class="n">EmptyWordLaTeX</span> <span class="o">=</span> <span class="s">r&#39;\varepsilon&#39;</span>
</pre></div>
</div>
</li>
<li><p class="first">This method is the default value for
<tt class="docutils literal"><span class="pre">FiniteStateMachine.format_transition_label</span></tt>. That can be changed to be
any other function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">custom_format_transition_label</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
<span class="go">....:     return &quot;t&quot;</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">format_transition_label</span><span class="o">=</span><span class="n">custom_format_transition_label</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="n">latex</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">\begin{tikzpicture}[auto, initial text=, &gt;=latex]</span>
<span class="go">\node[state] (v0) at (3.000000, 0.000000) {$0$};</span>
<span class="go">\node[state] (v1) at (-3.000000, 0.000000) {$1$};</span>
<span class="go">\path[-&gt;] (v0) edge node[rotate=360.00, anchor=south] {$t$} (v1);</span>
<span class="go">\end{tikzpicture}</span>
</pre></div>
</div>
</li>
</ol>
<p>TEST:</p>
<p>Check that <a class="reference external" href="http://trac.sagemath.org/16357">trac ticket #16357</a> is fixed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">([])</span>
<span class="go">&#39;\\varepsilon&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">(</span><span class="nb">iter</span><span class="p">([]))</span>
<span class="go">&#39;\\varepsilon&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.delete_state">
<tt class="descname">delete_state</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.delete_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a state and all transitions coming or going to this state.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">s</span></tt> &#8211; a label of a state or an <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><tt class="xref py py-class docutils literal"><span class="pre">FSMState</span></tt></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">delete_state</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;B&#39; to &#39;B&#39;: 1|-]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>This shows that <a class="reference external" href="http://trac.sagemath.org/16024">trac ticket #16024</a> is fixed.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">_states_</span>
<span class="go">[&#39;B&#39;]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">_states_dict_</span>
<span class="go">{&#39;B&#39;: &#39;B&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.delete_transition">
<tt class="descname">delete_transition</tt><big>(</big><em>t</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.delete_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a transition by removing it from the list of transitions of
the state, where the transition starts.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">t</span></tt> &#8211; a transition.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">delete_transition</span><span class="p">((</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;B&#39; to &#39;A&#39;: 1|-]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets">
<tt class="descname">determine_alphabets</tt><big>(</big><em>reset=True</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the input and output alphabet according to the
transitions in self.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">reset</span></tt> &#8211; If reset is <tt class="docutils literal"><span class="pre">True</span></tt>, then the existing input
and output alphabets are erased, otherwise new letters are
appended to the existing alphabets.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>After this operation the input alphabet and the output
alphabet of self are a list of letters.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">At the moment, the letters of the alphabets need to be hashable.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (2, 2, 1, 1), (2, 2, 0, 0)],</span>
<span class="go">....:                final_states=[1],</span>
<span class="go">....:                determine_alphabets=False)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">output_alphabet</span><span class="p">)</span>
<span class="go">(None, None)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">determine_alphabets</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">output_alphabet</span><span class="p">)</span>
<span class="go">([0, 1, 2], [0, 1, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.digraph">
<tt class="descname">digraph</tt><big>(</big><em>edge_labels='words_in_out'</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.digraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the graph of the finite state machine with labeled
vertices and labeled edges.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">edge_label</span></tt>: (default: <tt class="docutils literal"><span class="pre">'words_in_out'</span></tt>) can be</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">'words_in_out'</span></tt> (labels will be strings <tt class="docutils literal"><span class="pre">'i|o'</span></tt>)</li>
<li>a function with which takes as input a transition
and outputs (returns) the label</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>OUTPUT:</p>
<p>A <a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">directed</span> <span class="pre">graph</span></tt></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">&#39;A&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">Transition from &#39;A&#39; to &#39;A&#39;: 0|1</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 1 vertex</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">DiGraph</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.disjoint_union">
<tt class="descname">disjoint_union</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.disjoint_union" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the disjoint union of this and another finite state
machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; a <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>A finite state machine of the same type as this finite state
machine.</p>
<p>In general, the disjoint union of two finite state machines is
non-deterministic. In the case of a automata, the language
accepted by the disjoint union is the union of the languages
accepted by the constituent automata. In the case of
transducer, for each successful path in one of the constituent
transducers, there will be one successful path with the same input
and output labels in the disjoint union.</p>
<p>The labels of the states of the disjoint union are pairs <tt class="docutils literal"><span class="pre">(i,</span>
<span class="pre">s)</span></tt>: for each state <tt class="docutils literal"><span class="pre">s</span></tt> of this finite state machine, there
is a state <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">s)</span></tt> in the disjoint union; for each state
<tt class="docutils literal"><span class="pre">s</span></tt> of the other finite state machine, there is a state <tt class="docutils literal"><span class="pre">(1,</span>
<span class="pre">s)</span></tt> in the disjoint union.</p>
<p>The input alphabet is the union of the input alphabets (if
possible) and <tt class="docutils literal"><span class="pre">None</span></tt> otherwise. In the latter case, try
calling <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a>.</p>
<p>The disjoint union can also be written as <tt class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">B</span></tt> or <tt class="docutils literal"><span class="pre">A</span> <span class="pre">|</span> <span class="pre">B</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0],</span>
<span class="go">....:               final_states=[0])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0],</span>
<span class="go">....:               final_states=[0])</span>
<span class="gp">sage: </span><span class="n">B</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">Automaton with 5 states</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (0, 0) to (0, 1): 0|-,</span>
<span class="go"> Transition from (0, 1) to (0, 0): 1|-,</span>
<span class="go"> Transition from (1, 0) to (1, 1): 0|-,</span>
<span class="go"> Transition from (1, 1) to (1, 2): 0|-,</span>
<span class="go"> Transition from (1, 2) to (1, 0): 1|-]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[(0, 0), (1, 0)]</span>
</pre></div>
</div>
<p>Instead of <tt class="docutils literal"><span class="pre">.disjoint_union</span></tt>, alternative notations are
available:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C1</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">B</span>
<span class="gp">sage: </span><span class="n">C1</span> <span class="o">==</span> <span class="n">C</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C2</span> <span class="o">=</span> <span class="n">A</span> <span class="o">|</span> <span class="n">B</span>
<span class="gp">sage: </span><span class="n">C2</span> <span class="o">==</span> <span class="n">C</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In general, the disjoint union is not deterministic.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span><span class="o">.</span><span class="n">minimization</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:    (1, 7, 0), (1, 0, 1), (2, 6, 0), (2, 0, 1),</span>
<span class="go">....:    (3, 5, 0), (3, 0, 1), (4, 0, 0), (4, 2, 1),</span>
<span class="go">....:    (5, 0, 0), (5, 3, 1), (6, 4, 0), (6, 0, 1),</span>
<span class="go">....:    (7, 4, 0), (7, 3, 1)],</span>
<span class="go">....:    initial_states=[1],</span>
<span class="go">....:    final_states=[1, 2, 3]))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Disjoint union of transducers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T1</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[0])</span>
<span class="gp">sage: </span><span class="n">T2</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[0])</span>
<span class="gp">sage: </span><span class="n">T1</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">T2</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[2]</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">T1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Found more than one accepting path.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[(True, (1, 0), [2]), (True, (0, 0), [1])]</span>
</pre></div>
</div>
<p>Handling of the input alphabet (see <a class="reference external" href="http://trac.sagemath.org/18989">trac ticket #18989</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">input_alphabet</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">determine_alphabets</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])],</span> <span class="n">input_alphabet</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[1, 2]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[[0, 0]]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">D</span><span class="p">)</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.intersection" title="sage.combinat.finite_state_machine.Automaton.intersection"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.intersection()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.intersection" title="sage.combinat.finite_state_machine.Transducer.intersection"><tt class="xref py py-meth docutils literal"><span class="pre">Transducer.intersection()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.empty_copy">
<tt class="descname">empty_copy</tt><big>(</big><em>memo=None</em>, <em>new_class=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.empty_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an empty deep copy of the finite state machine, i.e.,
<tt class="docutils literal"><span class="pre">input_alphabet</span></tt>, <tt class="docutils literal"><span class="pre">output_alphabet</span></tt>, <tt class="docutils literal"><span class="pre">on_duplicate_transition</span></tt>
are preserved, but states and transitions are not.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">memo</span></tt> &#8211; a dictionary storing already processed elements.</li>
<li><tt class="docutils literal"><span class="pre">new_class</span></tt> &#8211; a class for the copy. By default
(<tt class="docutils literal"><span class="pre">None</span></tt>), the class of <tt class="docutils literal"><span class="pre">self</span></tt> is used.</li>
</ul>
<p>OUTPUT:</p>
<p>A new finite state machine.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_raise_error</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span>
<span class="go">....:                        input_alphabet=[0, 1],</span>
<span class="go">....:                        output_alphabet=[2, 3],</span>
<span class="go">....:                        on_duplicate_transition=duplicate_transition_raise_error)</span>
<span class="gp">sage: </span><span class="n">FE</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">();</span> <span class="n">FE</span>
<span class="go">Empty finite state machine</span>
<span class="gp">sage: </span><span class="n">FE</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[0, 1]</span>
<span class="gp">sage: </span><span class="n">FE</span><span class="o">.</span><span class="n">output_alphabet</span>
<span class="go">[2, 3]</span>
<span class="gp">sage: </span><span class="n">FE</span><span class="o">.</span><span class="n">on_duplicate_transition</span> <span class="o">==</span> <span class="n">duplicate_transition_raise_error</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">())</span>
<span class="go">&lt;class &#39;sage.combinat.finite_state_machine.Transducer&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">(</span><span class="n">new_class</span><span class="o">=</span><span class="n">Automaton</span><span class="p">))</span>
<span class="go">&lt;class &#39;sage.combinat.finite_state_machine.Automaton&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.epsilon_successors">
<tt class="descname">epsilon_successors</tt><big>(</big><em>state</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.epsilon_successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the dictionary with states reachable from <tt class="docutils literal"><span class="pre">state</span></tt>
without reading anything from an input tape as keys. The
values are lists of outputs.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">state</span></tt> &#8211; the state whose epsilon successors should be
determined.</li>
</ul>
<p>OUTPUT:</p>
<p>A dictionary mapping states to a list of output words.</p>
<p>The states in the output are the epsilon successors of
<tt class="docutils literal"><span class="pre">state</span></tt>. Each word of the list of output words is a word
written when taking a path from <tt class="docutils literal"><span class="pre">state</span></tt> to the corresponding
state.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">epsilon_successors</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">{1: [[&#39;a&#39;]], 2: [[&#39;a&#39;, &#39;b&#39;]]}</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">epsilon_successors</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">{2: [[&#39;b&#39;]]}</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">epsilon_successors</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">{}</span>
</pre></div>
</div>
<p>If there is a cycle with only epsilon transitions, then this
cycle is only processed once and there is no infinite loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">epsilon_successors</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">{0: [[&#39;a&#39;, &#39;b&#39;]], 1: [[&#39;a&#39;]]}</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">epsilon_successors</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">{0: [[&#39;b&#39;]], 1: [[&#39;b&#39;, &#39;a&#39;]]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.equivalence_classes">
<tt class="descname">equivalence_classes</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.equivalence_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of equivalence classes of states.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A list of equivalence classes of states.</p>
<p>Two states <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are equivalent if and only if there is
a bijection <span class="math">\(\varphi\)</span> between paths starting at <span class="math">\(a\)</span> and paths
starting at <span class="math">\(b\)</span> with the following properties: Let <span class="math">\(p_a\)</span> be a
path from <span class="math">\(a\)</span> to <span class="math">\(a'\)</span> and <span class="math">\(p_b\)</span> a path from <span class="math">\(b\)</span> to <span class="math">\(b'\)</span> such
that <span class="math">\(\varphi(p_a)=p_b\)</span>, then</p>
<ul class="simple">
<li><span class="math">\(p_a.\mathit{word}_\mathit{in}=p_b.\mathit{word}_\mathit{in}\)</span>,</li>
<li><span class="math">\(p_a.\mathit{word}_\mathit{out}=p_b.\mathit{word}_\mathit{out}\)</span>,</li>
<li><span class="math">\(a'\)</span> and <span class="math">\(b'\)</span> have the same output label, and</li>
<li><span class="math">\(a'\)</span> and <span class="math">\(b'\)</span> are both final or both non-final and have the
same final output word.</li>
</ul>
<p>The function <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.equivalence_classes" title="sage.combinat.finite_state_machine.FiniteStateMachine.equivalence_classes"><tt class="xref py py-meth docutils literal"><span class="pre">equivalence_classes()</span></tt></a> returns a list of
the equivalence classes to this equivalence relation.</p>
<p>This is one step of Moore&#8217;s minimization algorithm.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.minimization" title="sage.combinat.finite_state_machine.Automaton.minimization"><tt class="xref py py-meth docutils literal"><span class="pre">minimization()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">fsm</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (&quot;B&quot;, &quot;C&quot;, 0, 0), (&quot;B&quot;, &quot;C&quot;, 1, 1),</span>
<span class="go">....:                           (&quot;C&quot;, &quot;D&quot;, 0, 1), (&quot;C&quot;, &quot;D&quot;, 1, 0),</span>
<span class="go">....:                           (&quot;D&quot;, &quot;A&quot;, 0, 0), (&quot;D&quot;, &quot;A&quot;, 1, 1)])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">equivalence_classes</span><span class="p">())</span>
<span class="go">[[&#39;A&#39;, &#39;C&#39;], [&#39;B&#39;, &#39;D&#39;]]</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">equivalence_classes</span><span class="p">())</span>
<span class="go">[[&#39;A&#39;], [&#39;B&#39;], [&#39;C&#39;], [&#39;D&#39;]]</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">equivalence_classes</span><span class="p">())</span>
<span class="go">[[&#39;A&#39;, &#39;C&#39;], [&#39;B&#39;, &#39;D&#39;]]</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">equivalence_classes</span><span class="p">())</span>
<span class="go">[[&#39;A&#39;], [&#39;B&#39;], [&#39;C&#39;], [&#39;D&#39;]]</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">equivalence_classes</span><span class="p">())</span>
<span class="go">[[&#39;A&#39;, &#39;C&#39;], [&#39;B&#39;, &#39;D&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.final_components">
<tt class="descname">final_components</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.final_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the final components of a finite state machine as finite
state machines.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A list of finite state machines, each representing a final
component of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>A final component of a transducer <tt class="docutils literal"><span class="pre">T</span></tt> is a strongly connected
component <tt class="docutils literal"><span class="pre">C</span></tt> such that there are no transitions of <tt class="docutils literal"><span class="pre">T</span></tt>
leaving <tt class="docutils literal"><span class="pre">C</span></tt>.</p>
<p>The final components are the only parts of a transducer which
influence the main terms of the asympotic behaviour of the sum
of output labels of a transducer, see <a class="reference internal" href="#hkp2015" id="id15">[HKP2015]</a> and <a class="reference internal" href="#hkw2015" id="id16">[HKW2015]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                 [&#39;C&#39;, &#39;B&#39;, 0, 1], [&#39;A&#39;, &#39;D&#39;, 1, 0],</span>
<span class="go">....:                 [&#39;D&#39;, &#39;D&#39;, 0, 0], [&#39;D&#39;, &#39;B&#39;, 1, 0],</span>
<span class="go">....:                 [&#39;A&#39;, &#39;E&#39;, 2, 0], [&#39;E&#39;, &#39;E&#39;, 0, 0]])</span>
<span class="gp">sage: </span><span class="n">FC</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">final_components</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">FC</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from &#39;B&#39; to &#39;C&#39;: 0|1,</span>
<span class="go"> Transition from &#39;C&#39; to &#39;B&#39;: 0|1]</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;E&#39; to &#39;E&#39;: 0|0]</span>
</pre></div>
</div>
<p>Another example (cycle of length 2):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">final_components</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">final_components</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|-,</span>
<span class="go"> Transition from 1 to 0: 0|-]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.final_states">
<tt class="descname">final_states</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.final_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all final states.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A list of all final states.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="n">is_initial</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;, &#39;C&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.format_letter">
<tt class="descname">format_letter</tt><big>(</big><em>x</em>, <em>combine_all=False</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_letter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.LatexExpr" title="(in Sage Reference Manual: Utilities v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">LatexExpr</span></tt></a> built out of the argument <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; a Sage object</li>
<li><tt class="docutils literal"><span class="pre">combine_all</span></tt> &#8211; boolean (Default: <tt class="docutils literal"><span class="pre">False</span></tt>) If <tt class="docutils literal"><span class="pre">combine_all</span></tt>
is <tt class="docutils literal"><span class="pre">True</span></tt> and the input is a tuple, then it does not return a
tuple and instead returns a string with all the elements separated by
a single space.</li>
</ul>
<p>OUTPUT:</p>
<p>A <a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.LatexExpr" title="(in Sage Reference Manual: Utilities v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">LatexExpr</span></tt></a> built from <tt class="docutils literal"><span class="pre">x</span></tt></p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">Integer</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>  <span class="c"># indirect doctest</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="mi">1</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
<span class="go">\mathrm{False}</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="n">latex</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">\left[x, 2\right]</span>
</pre></div>
</div>
<p>Check that <a class="reference external" href="http://trac.sagemath.org/11775">trac ticket #11775</a> is fixed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">latex</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">combine_all</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">x 2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.format_letter_negative">
<tt class="descname">format_letter_negative</tt><big>(</big><em>letter</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_letter_negative" title="Permalink to this definition">¶</a></dt>
<dd><p>Format negative numbers as overlined numbers, everything
else by standard LaTeX formatting.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">letter</span></tt> &#8211; anything.</p>
<p>OUTPUT:</p>
<p>Overlined absolute value if letter is a negative integer,
<a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.latex" title="(in Sage Reference Manual: Utilities v6.9)"><tt class="xref py py-func docutils literal"><span class="pre">latex(letter)</span></tt></a> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="nb">map</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">format_letter_negative</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">])</span>
<span class="go"> [&#39;\\overline{1}&#39;, 0, 1, \text{\texttt{a}}, \mbox{\rm None}]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">format_letter</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">format_letter_negative</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">latex</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="go">\begin{tikzpicture}[auto, initial text=, &gt;=latex]</span>
<span class="go">\node[state] (v0) at (3.000000, 0.000000) {$0$};</span>
<span class="go">\path[-&gt;] (v0) edge[loop above] node {$\overline{1}$} ();</span>
<span class="go">\end{tikzpicture}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label">
<tt class="descname">format_transition_label</tt><big>(</big><em>word</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Default formatting of words in transition labels for LaTeX output.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">word</span></tt> &#8211; list of letters</p>
<p>OUTPUT:</p>
<p>String representation of <tt class="docutils literal"><span class="pre">word</span></tt> suitable to be typeset in
mathematical mode.</p>
<ul class="simple">
<li>For a non-empty word: Concatenation of the letters, piped through
<tt class="docutils literal"><span class="pre">self.format_letter</span></tt> and separated by blanks.</li>
<li>For an empty word:
<tt class="docutils literal"><span class="pre">sage.combinat.finite_state_machine.EmptyWordLaTeX</span></tt>.</li>
</ul>
<p>There is also a variant <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label_reversed" title="sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label_reversed"><tt class="xref py py-meth docutils literal"><span class="pre">format_transition_label_reversed()</span></tt></a>
writing the words in reversed order.</p>
<p>EXAMPLES:</p>
<ol class="arabic">
<li><p class="first">Example of a non-empty word:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">(</span>
<span class="go">....:    [&#39;a&#39;, &#39;alpha&#39;, &#39;a_1&#39;, &#39;0&#39;, 0, (0, 1)])</span>
<span class="go">\text{\texttt{a}} \text{\texttt{alpha}}</span>
<span class="go">\text{\texttt{a{\char`\_}1}} 0 0 \left(0, 1\right)</span>
</pre></div>
</div>
</li>
<li><p class="first">In the example above, <tt class="docutils literal"><span class="pre">'a'</span></tt> and <tt class="docutils literal"><span class="pre">'alpha'</span></tt> should perhaps
be symbols:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s">&#39;a alpha a_1&#39;</span><span class="p">)</span>
<span class="go">(a, alpha, a_1)</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">a_1</span><span class="p">])</span>
<span class="go">a \alpha a_{1}</span>
</pre></div>
</div>
</li>
<li><p class="first">Example of an empty word:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">print</span> <span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">([])</span>
<span class="go">\varepsilon</span>
</pre></div>
</div>
<p>We can change this by setting
<tt class="docutils literal"><span class="pre">sage.combinat.finite_state_machine.EmptyWordLaTeX</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">finite_state_machine</span><span class="o">.</span><span class="n">EmptyWordLaTeX</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">([])</span>
<span class="go">&#39;&#39;</span>
</pre></div>
</div>
<p>Finally, we restore the default value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">finite_state_machine</span><span class="o">.</span><span class="n">EmptyWordLaTeX</span> <span class="o">=</span> <span class="s">r&#39;\varepsilon&#39;</span>
</pre></div>
</div>
</li>
<li><p class="first">This method is the default value for
<tt class="docutils literal"><span class="pre">FiniteStateMachine.format_transition_label</span></tt>. That can be changed to be
any other function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">custom_format_transition_label</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
<span class="go">....:     return &quot;t&quot;</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">format_transition_label</span><span class="o">=</span><span class="n">custom_format_transition_label</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="n">latex</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">\begin{tikzpicture}[auto, initial text=, &gt;=latex]</span>
<span class="go">\node[state] (v0) at (3.000000, 0.000000) {$0$};</span>
<span class="go">\node[state] (v1) at (-3.000000, 0.000000) {$1$};</span>
<span class="go">\path[-&gt;] (v0) edge node[rotate=360.00, anchor=south] {$t$} (v1);</span>
<span class="go">\end{tikzpicture}</span>
</pre></div>
</div>
</li>
</ol>
<p>TEST:</p>
<p>Check that <a class="reference external" href="http://trac.sagemath.org/16357">trac ticket #16357</a> is fixed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">([])</span>
<span class="go">&#39;\\varepsilon&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">(</span><span class="nb">iter</span><span class="p">([]))</span>
<span class="go">&#39;\\varepsilon&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label_reversed">
<tt class="descname">format_transition_label_reversed</tt><big>(</big><em>word</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label_reversed" title="Permalink to this definition">¶</a></dt>
<dd><p>Format words in transition labels in reversed order.</p>
<p>INPUT:</p>
<p><tt class="docutils literal"><span class="pre">word</span></tt> &#8211; list of letters.</p>
<p>OUTPUT:</p>
<p>String representation of <tt class="docutils literal"><span class="pre">word</span></tt> suitable to be typeset in
mathematical mode, letters are written in reversed order.</p>
<p>This is the reversed version of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label" title="sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label"><tt class="xref py py-meth docutils literal"><span class="pre">default_format_transition_label()</span></tt></a>.</p>
<p>In digit expansions, digits are frequently processed from the
least significant to the most significant position, but it is
customary to write the least significant digit at the
right-most position. Therefore, the labels have to be
reversed.</p>
<p>EXAMPLE:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">format_transition_label_reversed</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">&#39;3 2 1&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">format_transition_label</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">format_transition_label_reversed</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="n">latex</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">\begin{tikzpicture}[auto, initial text=, &gt;=latex]</span>
<span class="go">\node[state] (v0) at (3.000000, 0.000000) {$0$};</span>
<span class="go">\path[-&gt;] (v0) edge[loop above] node {$0\mid 3 2 1$} ();</span>
<span class="go">\end{tikzpicture}</span>
</pre></div>
</div>
<p>TEST:</p>
<p>Check that <a class="reference external" href="http://trac.sagemath.org/16357">trac ticket #16357</a> is fixed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">format_transition_label_reversed</span><span class="p">([])</span>
<span class="go">&#39;\\varepsilon&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.graph">
<tt class="descname">graph</tt><big>(</big><em>edge_labels='words_in_out'</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the graph of the finite state machine with labeled
vertices and labeled edges.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">edge_label</span></tt>: (default: <tt class="docutils literal"><span class="pre">'words_in_out'</span></tt>) can be</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">'words_in_out'</span></tt> (labels will be strings <tt class="docutils literal"><span class="pre">'i|o'</span></tt>)</li>
<li>a function with which takes as input a transition
and outputs (returns) the label</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>OUTPUT:</p>
<p>A <a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">directed</span> <span class="pre">graph</span></tt></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">&#39;A&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">Transition from &#39;A&#39; to &#39;A&#39;: 0|1</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 1 vertex</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">DiGraph</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.has_final_state">
<tt class="descname">has_final_state</tt><big>(</big><em>state</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_final_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <tt class="docutils literal"><span class="pre">state</span></tt> is one of the final states of the
finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">state</span></tt> can be a <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><tt class="xref py py-class docutils literal"><span class="pre">FSMState</span></tt></a> or a label.</li>
</ul>
<p>OUTPUT:</p>
<p>True or False.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">final_states</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">has_final_state</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.has_final_states">
<tt class="descname">has_final_states</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_final_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the finite state machine has a final state.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>True or False.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">()</span><span class="o">.</span><span class="n">has_final_states</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.has_initial_state">
<tt class="descname">has_initial_state</tt><big>(</big><em>state</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_initial_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <tt class="docutils literal"><span class="pre">state</span></tt> is one of the initial states of the
finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">state</span></tt> can be a <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><tt class="xref py py-class docutils literal"><span class="pre">FSMState</span></tt></a> or a label.</li>
</ul>
<p>OUTPUT:</p>
<p>True or False.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">)],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">has_initial_state</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.has_initial_states">
<tt class="descname">has_initial_states</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_initial_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the finite state machine has an initial state.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>True or False.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">()</span><span class="o">.</span><span class="n">has_initial_states</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.has_state">
<tt class="descname">has_state</tt><big>(</big><em>state</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <tt class="docutils literal"><span class="pre">state</span></tt> is one of the states of the finite
state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">state</span></tt> can be a <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><tt class="xref py py-class docutils literal"><span class="pre">FSMState</span></tt></a> or a label of a state.</li>
</ul>
<p>OUTPUT:</p>
<p>True or False.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">()</span><span class="o">.</span><span class="n">has_state</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.has_transition">
<tt class="descname">has_transition</tt><big>(</big><em>transition</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <tt class="docutils literal"><span class="pre">transition</span></tt> is one of the transitions of
the finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">transition</span></tt> has to be a <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><tt class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></tt></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>True or False.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">()</span><span class="o">.</span><span class="n">has_transition</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">()</span><span class="o">.</span><span class="n">has_transition</span><span class="p">((</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Transition is not an instance of FSMTransition.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.induced_sub_finite_state_machine">
<tt class="descname">induced_sub_finite_state_machine</tt><big>(</big><em>states</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.induced_sub_finite_state_machine" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sub-finite-state-machine of the finite state machine
induced by the given states.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">states</span></tt> &#8211; a list (or an iterator) of states (either labels or
instances of <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><tt class="xref py py-class docutils literal"><span class="pre">FSMState</span></tt></a>) of the sub-finite-state-machine.</li>
</ul>
<p>OUTPUT:</p>
<p>A new finite state machine. It consists (of deep copies) of
the given states and (deep copies) of all transitions of <tt class="docutils literal"><span class="pre">self</span></tt>
between these states.</p>
<p>EXAMPLE:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (1, 2, 0), (2, 0, 0)])</span>
<span class="gp">sage: </span><span class="n">sub_FSM</span> <span class="o">=</span> <span class="n">FSM</span><span class="o">.</span><span class="n">induced_sub_finite_state_machine</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">sub_FSM</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[0, 1]</span>
<span class="gp">sage: </span><span class="n">sub_FSM</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|-]</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">induced_sub_finite_state_machine</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">3 is not a state of this finite state machine.</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Make sure that the links between transitions and states
are still intact:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">sub_FSM</span><span class="o">.</span><span class="n">transitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">from_state</span> <span class="ow">is</span> <span class="n">sub_FSM</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.initial_states">
<tt class="descname">initial_states</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.initial_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all initial states.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A list of all initial states.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="n">is_initial</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.input_alphabet">
<tt class="descname">input_alphabet</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.input_alphabet" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of letters representing the input alphabet of the finite
state machine.</p>
<p>It can be set by the parameter <tt class="docutils literal"><span class="pre">input_alphabet</span></tt> when initializing
a finite state machine, see <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>.</p>
<p>It can also be set by the method <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>, <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.output_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.output_alphabet"><tt class="xref py py-attr docutils literal"><span class="pre">output_alphabet</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.input_projection">
<tt class="descname">input_projection</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.input_projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an automaton where the output of each transition of
self is deleted.</p>
<p>INPUT:</p>
<p>Nothing</p>
<p>OUTPUT:</p>
<p>An automaton.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                         (&#39;B&#39;, &#39;B&#39;, 1, 0)])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">input_projection</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;B&#39;: 0|-,</span>
<span class="go"> Transition from &#39;A&#39; to &#39;A&#39;: 1|-,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;B&#39;: 1|-]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.intersection">
<tt class="descname">intersection</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">()</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">FiniteStateMachine</span><span class="p">())</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.is_Markov_chain">
<tt class="descname">is_Markov_chain</tt><big>(</big><em>is_zero=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_Markov_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether <tt class="docutils literal"><span class="pre">self</span></tt> is a Markov chain where the transition
probabilities are modeled as input labels.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">is_zero</span></tt> &#8211; by default (<tt class="docutils literal"><span class="pre">is_zero=None</span></tt>), checking for
zero is simply done by
<a class="reference external" href="../../../structure/sage/structure/element.html#sage.structure.element.Element.is_zero" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-meth docutils literal"><span class="pre">is_zero()</span></tt></a>.  This
parameter can be used to provide a more sophisticated check
for zero, e.g. in the case of symbolic probabilities, see
the examples below.</li>
</ul>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<p><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition" title="sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition"><tt class="xref py py-attr docutils literal"><span class="pre">on_duplicate_transition</span></tt></a> must be
<a class="reference internal" href="#sage.combinat.finite_state_machine.duplicate_transition_add_input" title="sage.combinat.finite_state_machine.duplicate_transition_add_input"><tt class="xref py py-func docutils literal"><span class="pre">duplicate_transition_add_input()</span></tt></a>, the sum of the input weights
of the transitions leaving a state must add up to 1 and the sum of
initial probabilities must add up to 1 (or all be <tt class="docutils literal"><span class="pre">None</span></tt>).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_add_input</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                 [1, 0, 1/2, 0], [1, 1, 1/2, 1]],</span>
<span class="go">....:                on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition" title="sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition"><tt class="xref py py-attr docutils literal"><span class="pre">on_duplicate_transition</span></tt></a> must be
<a class="reference internal" href="#sage.combinat.finite_state_machine.duplicate_transition_add_input" title="sage.combinat.finite_state_machine.duplicate_transition_add_input"><tt class="xref py py-func docutils literal"><span class="pre">duplicate_transition_add_input()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                 [1, 0, 1/2, 0], [1, 1, 1/2, 1]])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Sum of input labels of the transitions leaving states must be 1:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                 [1, 0, 1/2, 0]],</span>
<span class="go">....:                on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The initial probabilities of all states must be <tt class="docutils literal"><span class="pre">None</span></tt> or they must
sum up to 1. The initial probabilities of all states have to be set in the latter case:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                 [1, 0, 1, 0]],</span>
<span class="go">....:                on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">initial_probability</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">initial_probability</span> <span class="o">=</span> <span class="mi">7</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">initial_probability</span> <span class="o">=</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If the probabilities are variables in the symbolic ring,
<a class="reference external" href="../../../calculus/sage/symbolic/assumptions.html#sage.symbolic.assumptions.assume" title="(in Sage Reference Manual: Symbolic Calculus v6.9)"><tt class="xref py py-func docutils literal"><span class="pre">assume()</span></tt></a> will do the trick:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s">&#39;p q&#39;</span><span class="p">)</span>
<span class="go">(p, q)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">assume</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">forget</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">del</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
<p>If the probabilities are variables in some polynomial ring,
the parameter <tt class="docutils literal"><span class="pre">is_zero</span></tt> can be used:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">is_zero_polynomial</span><span class="p">(</span><span class="n">polynomial</span><span class="p">):</span>
<span class="go">....:     return polynomial in (p + q - 1)*R</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">initial_probability</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">(</span><span class="n">is_zero_polynomial</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.is_complete">
<tt class="descname">is_complete</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the finite state machine is complete.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<p>A finite state machine is considered to be complete if
each transition has an input label of length one and for each
pair <span class="math">\((q, a)\)</span> where <span class="math">\(q\)</span> is a state and <span class="math">\(a\)</span> is an element of the
input alphabet, there is exactly one transition from <span class="math">\(q\)</span> with
input label <span class="math">\(a\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">fsm</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (0, 1, 1, 1),</span>
<span class="go">....:                           (1, 1, 0, 0)],</span>
<span class="go">....:                          determine_alphabets=False)</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No input alphabet is given. Try calling determine_alphabets().</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">Transition from 1 to 1: 1|1</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">Transition from 0 to 0: 1|0</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.is_connected">
<tt class="descname">is_connected</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">()</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.is_deterministic">
<tt class="descname">is_deterministic</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_deterministic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the finite finite state machine is deterministic.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<p>A finite state machine is considered to be deterministic if
each transition has input label of length one and for each
pair <span class="math">\((q,a)\)</span> where <span class="math">\(q\)</span> is a state and <span class="math">\(a\)</span> is an element of the
input alphabet, there is at most one transition from <span class="math">\(q\)</span> with
input label <span class="math">\(a\)</span>. Furthermore, the finite state may not have
more than one initial state.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">fsm</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]))</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|-</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]))</span>
<span class="go">Transition from &#39;A&#39; to &#39;C&#39;: 0|-</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[]))</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0,1|-</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Check that <a class="reference external" href="http://trac.sagemath.org/18556">trac ticket #18556</a> is fixed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Automaton</span><span class="p">()</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Automaton</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Automaton</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.is_monochromatic">
<tt class="descname">is_monochromatic</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_monochromatic" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the colors of all states are equal.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">GrayCode</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">color</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">iter_states</span><span class="p">()]</span>
<span class="go">[None, None, None]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_monochromatic</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="s">&#39;blue&#39;</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_monochromatic</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.iter_final_states">
<tt class="descname">iter_final_states</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_final_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator of the final states.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>An iterator over all initial states.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="n">is_initial</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">iter_final_states</span><span class="p">()]</span>
<span class="go">[&#39;A&#39;, &#39;C&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.iter_initial_states">
<tt class="descname">iter_initial_states</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_initial_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator of the initial states.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>An iterator over all initial states.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="n">is_initial</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">iter_initial_states</span><span class="p">()]</span>
<span class="go">[&#39;A&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process">
<tt class="descname">iter_process</tt><big>(</big><em>input_tape=None</em>, <em>initial_state=None</em>, <em>process_iterator_class=None</em>, <em>iterator_type=None</em>, <em>automatic_output_type=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns an iterator for processing the input.
See <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">process()</span></tt></a> (which runs this iterator until the end)
for more information.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">iterator_type</span></tt> &#8211; If <tt class="docutils literal"><span class="pre">None</span></tt> (default), then
an instance of <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a> is returned. If
this is <tt class="docutils literal"><span class="pre">'simple'</span></tt> only an iterator over one output is
returned (an exception is raised if this is not the case, i.e.,
if the process has branched).</li>
</ul>
<p>See <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">process()</span></tt></a> for a description of the other parameters.</p>
<p>OUTPUT:</p>
<p>An iterator.</p>
<p>EXAMPLES:</p>
<p>We can use <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><tt class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></tt></a> to deal with infinite words:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">()</span>
<span class="go">word: 0100101001001010010100100101001001010010...</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span>
<span class="go">....:     words.FibonacciWord(), iterator_type=&#39;simple&#39;)</span>
<span class="gp">sage: </span><span class="n">Words</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])(</span><span class="n">it</span><span class="p">)</span>
<span class="go">word: 1011010110110101101011011010110110101101...</span>
</pre></div>
</div>
<p>This can also be done by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">(),</span>
<span class="go">....:                       iterator_type=&#39;simple&#39;,</span>
<span class="go">....:                       automatic_output_type=True)</span>
<span class="go">word: 1011010110110101101011011010110110101101...</span>
</pre></div>
</div>
<p>or even simpler by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">inverter</span><span class="p">(</span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">())</span>
<span class="go">word: 1011010110110101101011011010110110101101...</span>
</pre></div>
</div>
<p>To see what is going on, we use <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><tt class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></tt></a> without
arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">())</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">current</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
<span class="go">....:     print current</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 1, [[1]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 2, [[1, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 3, [[1, 0, 1]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 4, [[1, 0, 1, 1]]</span>
</pre></div>
</div>
<p>The following show the difference between using the <tt class="docutils literal"><span class="pre">'simple'</span></tt>-option
and not using it. With this option, we have</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                            iterator_type=&#39;simple&#39;)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
<span class="go">....:     print &#39;step %s: output %s&#39; % (i, o)</span>
<span class="go">step 0: output 1</span>
<span class="go">step 1: output 0</span>
<span class="go">step 2: output 0</span>
</pre></div>
</div>
<p>So <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><tt class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></tt></a> is a generator expression which gives
a new output letter in each step (and not more). In many cases
this is sufficient.</p>
<p>Doing the same without the <tt class="docutils literal"><span class="pre">'simple'</span></tt>-option does not give
the output directly; it has to be extracted first. On the
other hand, additional information is presented:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">current</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     print current</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 1, [[1]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 2, [[1, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 3, [[1, 0, 0]]</span>
<span class="go">process (0 branches)</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="go">[Branch(accept=True, state=&#39;A&#39;, output=[1, 0, 0])]</span>
</pre></div>
</div>
<p>One can see the growing of the output (the list of lists at
the end of each entry).</p>
<p>Even if the transducer has transitions with empty or multiletter
output, the simple iterator returns one new output letter in
each step:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]),</span>
<span class="go">....:                 (0, 0, 1, [1]),</span>
<span class="go">....:                 (0, 0, 2, [2, 2])],</span>
<span class="go">....:                initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="go">....:                     iterator_type=&#39;simple&#39;)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
<span class="go">....:     print &#39;step %s: output %s&#39; % (i, o)</span>
<span class="go">step 0: output 1</span>
<span class="go">step 1: output 2</span>
<span class="go">step 2: output 2</span>
<span class="go">step 3: output 1</span>
<span class="go">step 4: output 2</span>
<span class="go">step 5: output 2</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><tt class="xref py py-meth docutils literal"><span class="pre">Transducer.process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.iter_states">
<tt class="descname">iter_states</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator of the states.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>An iterator of the states of the finite state machine.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">FSM</span><span class="o">.</span><span class="n">iter_states</span><span class="p">()]</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.iter_transitions">
<tt class="descname">iter_transitions</tt><big>(</big><em>from_state=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_transitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator of all transitions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">from_state</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) If <tt class="docutils literal"><span class="pre">from_state</span></tt> is
given, then a list of transitions starting there is given.</li>
</ul>
<p>OUTPUT:</p>
<p>An iterator of all transitions.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">t</span><span class="o">.</span><span class="n">from_state</span><span class="o">.</span><span class="n">label</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">to_state</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>
<span class="go">....:     for t in FSM.iter_transitions(&#39;1&#39;)]</span>
<span class="go">[(&#39;1&#39;, &#39;2&#39;)]</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">t</span><span class="o">.</span><span class="n">from_state</span><span class="o">.</span><span class="n">label</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">to_state</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>
<span class="go">....:     for t in FSM.iter_transitions(&#39;2&#39;)]</span>
<span class="go">[(&#39;2&#39;, &#39;2&#39;)]</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">t</span><span class="o">.</span><span class="n">from_state</span><span class="o">.</span><span class="n">label</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">to_state</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>
<span class="go">....:     for t in FSM.iter_transitions()]</span>
<span class="go">[(&#39;1&#39;, &#39;2&#39;), (&#39;2&#39;, &#39;2&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.kleene_star">
<tt class="descname">kleene_star</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.kleene_star" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Kleene closure of this finite state machine.</p>
<p>OUTPUT:</p>
<p>A <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a> of the same type as this finite
state machine.</p>
<p>Assume that this finite state machine is an automaton
recognizing the language <span class="math">\(\mathcal{L}\)</span>.  Then the Kleene star
recognizes the language <span class="math">\(\mathcal{L}^*=\{ w_1\ldots w_n \mid
n\ge 0, w_j\in\mathcal{L} \text{ for all } j\}\)</span>.</p>
<p>Assume that this finite state machine is a transducer realizing
a function <span class="math">\(f\)</span> on some alphabet <span class="math">\(\mathcal{L}\)</span>. Then the Kleene
star realizes a function <span class="math">\(g\)</span> on <span class="math">\(\mathcal{L}^*\)</span> with
<span class="math">\(g(w_1\ldots w_n)=f(w_1)\ldots f(w_n)\)</span>.</p>
<p>EXAMPLES:</p>
<p>Kleene star of an automaton:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">Word</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">kleene_star</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|-,</span>
<span class="go"> Transition from 2 to 0: -|-,</span>
<span class="go"> Transition from 1 to 2: 1|-]</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="p">(</span>
<span class="go">....:     is_Automaton, is_Transducer)</span>
<span class="gp">sage: </span><span class="n">is_Automaton</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">([],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">....:  if B(w)]</span>
<span class="go">[[],</span>
<span class="go"> [0, 1],</span>
<span class="go"> [0, 1, 0, 1]]</span>
</pre></div>
</div>
<p>Kleene star of a transducer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">kleene_star</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|1,</span>
<span class="go"> Transition from 0 to 1: 1|0,</span>
<span class="go"> Transition from 1 to 0: -|-]</span>
<span class="gp">sage: </span><span class="n">is_Transducer</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">([],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
<span class="go">....:     print w, S.process(w)</span>
<span class="go">[]     (True, 0, [])</span>
<span class="go">[0]    [(True, 0, [1]), (True, 1, [1])]</span>
<span class="go">[1]    [(True, 0, [0]), (True, 1, [0])]</span>
<span class="go">[0, 0] [(True, 0, [1, 1]), (True, 1, [1, 1])]</span>
<span class="go">[0, 1] [(True, 0, [1, 0]), (True, 1, [1, 0])]</span>
</pre></div>
</div>
<p>Final output words are taken into account:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">kleene_star</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[(True, 0, [1, 2, 1, 2]), (True, 1, [1, 2, 1, 2])]</span>
</pre></div>
</div>
<p>Final output words may lead to undesirable situations if initial
states and final states coincide:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">final_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([])</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">kleene_star</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">([])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RuntimeError</span>: <span class="n">State 0 is in an epsilon cycle (no input), but</span>
<span class="go">output is written.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.language">
<tt class="descname">language</tt><big>(</big><em>max_length=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.language" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all words that can be written by this transducer.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">max_length</span></tt> &#8211; an integer or <tt class="docutils literal"><span class="pre">None</span></tt> (default). Only
output words which come from inputs of length at most
<tt class="docutils literal"><span class="pre">max_length</span></tt> will be considered. If <tt class="docutils literal"><span class="pre">None</span></tt>, then this
iterates over all possible words without length restrictions.</li>
<li><tt class="docutils literal"><span class="pre">kwargs</span></tt> &#8211; will be passed on to to the <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">process</span>
<span class="pre">iterator</span></tt></a>. See <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">process()</span></tt></a> for a
description.</li>
</ul>
<p>OUTPUT:</p>
<p>An iterator.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;I&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;I&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
<span class="go">....:                   (0, 0, 0, 0), (0, 1, 1, 0),</span>
<span class="go">....:                   (1, 0, 0, 1), (1, 2, 1, -1),</span>
<span class="go">....:                   (2, 1, 0, 0), (2, 2, 1, 0)],</span>
<span class="go">....:                  initial_states=[&#39;I&#39;], final_states=[0],</span>
<span class="go">....:                  input_alphabet=[0, 1])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">NAF</span><span class="o">.</span><span class="n">language</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
<span class="go">....:        key=lambda o: (ZZ(o, base=2), len(o)))</span>
<span class="go">[[], [0], [0, 0], [0, 0, 0],</span>
<span class="go"> [1], [1, 0], [1, 0, 0],</span>
<span class="go"> [0, 1], [0, 1, 0],</span>
<span class="go"> [-1, 0, 1],</span>
<span class="go"> [0, 0, 1],</span>
<span class="go"> [1, 0, 1]]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">iterator</span> <span class="o">=</span> <span class="n">NAF</span><span class="o">.</span><span class="n">language</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">[0, 0]</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">[0, 1]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.language" title="sage.combinat.finite_state_machine.Automaton.language"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.language()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">process()</span></tt></a>.</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0], final_states=[0, 1, 2])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">determine_alphabets</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">language</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[], [&#39;a&#39;], [&#39;a&#39;, &#39;b&#39;]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">language</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[[], [&#39;a&#39;], [&#39;a&#39;, &#39;b&#39;]]</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span>  <span class="n">_FSMProcessIteratorAll_</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span>
<span class="go">....:     process_iterator_class=_FSMProcessIteratorAll_,</span>
<span class="go">....:     max_length=3,</span>
<span class="go">....:     process_all_prefixes_of_input=True)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">current</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     print current</span>
<span class="go">....:     print &quot;finished:&quot;, [branch.output for branch in it._finished_]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state 1</span>
<span class="go">+-- tape at 1, [[&#39;a&#39;]]</span>
<span class="go">finished: [[]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state 2</span>
<span class="go">+-- tape at 2, [[&#39;a&#39;, &#39;b&#39;]]</span>
<span class="go">finished: [[], [&#39;a&#39;]]</span>
<span class="go">process (0 branches)</span>
<span class="go">finished: [[], [&#39;a&#39;], [&#39;a&#39;, &#39;b&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.latex_options">
<tt class="descname">latex_options</tt><big>(</big><em>coordinates=None</em>, <em>format_state_label=None</em>, <em>format_letter=None</em>, <em>format_transition_label=None</em>, <em>loop_where=None</em>, <em>initial_where=None</em>, <em>accepting_style=None</em>, <em>accepting_distance=None</em>, <em>accepting_where=None</em>, <em>accepting_show_empty=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.latex_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Set options for LaTeX output via
<a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.latex" title="(in Sage Reference Manual: Utilities v6.9)"><tt class="xref py py-func docutils literal"><span class="pre">latex()</span></tt></a> and therefore
<a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.view" title="(in Sage Reference Manual: Utilities v6.9)"><tt class="xref py py-func docutils literal"><span class="pre">view()</span></tt></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">coordinates</span></tt> &#8211; a dictionary or a function mapping labels
of states to pairs interpreted as coordinates. If no
coordinates are given, states a placed equidistantly on a
circle of radius <span class="math">\(3\)</span>. See also <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.set_coordinates" title="sage.combinat.finite_state_machine.FiniteStateMachine.set_coordinates"><tt class="xref py py-meth docutils literal"><span class="pre">set_coordinates()</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">format_state_label</span></tt> &#8211; a function mapping labels of
states to a string suitable for typesetting in LaTeX&#8217;s
mathematics mode. If not given, <a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.latex" title="(in Sage Reference Manual: Utilities v6.9)"><tt class="xref py py-func docutils literal"><span class="pre">latex()</span></tt></a>
is used.</li>
<li><tt class="docutils literal"><span class="pre">format_letter</span></tt> &#8211; a function mapping letters of the input
and output alphabets to a string suitable for typesetting in
LaTeX&#8217;s mathematics mode. If not given,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label" title="sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label"><tt class="xref py py-meth docutils literal"><span class="pre">default_format_transition_label()</span></tt></a> uses
<a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.latex" title="(in Sage Reference Manual: Utilities v6.9)"><tt class="xref py py-func docutils literal"><span class="pre">latex()</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">format_transition_label</span></tt> &#8211; a function mapping words over
the input and output alphabets to a string suitable for
typesetting in LaTeX&#8217;s mathematics mode. If not given,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label" title="sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label"><tt class="xref py py-meth docutils literal"><span class="pre">default_format_transition_label()</span></tt></a> is used.</li>
<li><tt class="docutils literal"><span class="pre">loop_where</span></tt> &#8211; a dictionary or a function mapping labels of
initial states to one of <tt class="docutils literal"><span class="pre">'above'</span></tt>, <tt class="docutils literal"><span class="pre">'left'</span></tt>, <tt class="docutils literal"><span class="pre">'below'</span></tt>,
<tt class="docutils literal"><span class="pre">'right'</span></tt>. If not given, <tt class="docutils literal"><span class="pre">'above'</span></tt> is used.</li>
<li><tt class="docutils literal"><span class="pre">initial_where</span></tt> &#8211; a dictionary or a function mapping
labels of initial states to one of <tt class="docutils literal"><span class="pre">'above'</span></tt>, <tt class="docutils literal"><span class="pre">'left'</span></tt>,
<tt class="docutils literal"><span class="pre">'below'</span></tt>, <tt class="docutils literal"><span class="pre">'right'</span></tt>. If not given, TikZ&#8217; default
(currently <tt class="docutils literal"><span class="pre">'left'</span></tt>) is used.</li>
<li><tt class="docutils literal"><span class="pre">accepting_style</span></tt> &#8211; one of <tt class="docutils literal"><span class="pre">'accepting</span> <span class="pre">by</span> <span class="pre">double'</span></tt> and
<tt class="docutils literal"><span class="pre">'accepting</span> <span class="pre">by</span> <span class="pre">arrow'</span></tt>. If not given, <tt class="docutils literal"><span class="pre">'accepting</span> <span class="pre">by</span>
<span class="pre">double'</span></tt> is used unless there are non-empty final output
words.</li>
<li><tt class="docutils literal"><span class="pre">accepting_distance</span></tt> &#8211; a string giving a LaTeX length
used for the length of the arrow leading from a final state.
If not given, TikZ&#8217; default (currently <tt class="docutils literal"><span class="pre">'3ex'</span></tt>) is used
unless there are non-empty final output words, in which case
<tt class="docutils literal"><span class="pre">'7ex'</span></tt> is used.</li>
<li><tt class="docutils literal"><span class="pre">accepting_where</span></tt> &#8211; a dictionary or a function mapping
labels of final states to one of <tt class="docutils literal"><span class="pre">'above'</span></tt>, <tt class="docutils literal"><span class="pre">'left'</span></tt>,
<tt class="docutils literal"><span class="pre">'below'</span></tt>, <tt class="docutils literal"><span class="pre">'right'</span></tt>. If not given, TikZ&#8217; default
(currently <tt class="docutils literal"><span class="pre">'right'</span></tt>) is used. If the final state has a
final output word, it is also possible to give an angle
in degrees.</li>
<li><tt class="docutils literal"><span class="pre">accepting_show_empty</span></tt> &#8211; if <tt class="docutils literal"><span class="pre">True</span></tt> the arrow of an
empty final output word is labeled as well. Note that this
implicitly implies <tt class="docutils literal"><span class="pre">accepting_style='accepting</span> <span class="pre">by</span>
<span class="pre">arrow'</span></tt>. If not given, the default <tt class="docutils literal"><span class="pre">False</span></tt> is used.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>As TikZ (cf. the <a class="reference external" href="https://en.wikipedia.org/wiki/PGF/TikZ">Wikipedia article PGF/TikZ</a>) is used to typeset
the graphics, the syntax is oriented on TikZ&#8217; syntax.</p>
<p>This is a convenience function collecting all options for
LaTeX output. All of its functionality can also be achieved by
directly setting the attributes</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">coordinates</span></tt>, <tt class="docutils literal"><span class="pre">format_label</span></tt>, <tt class="docutils literal"><span class="pre">loop_where</span></tt>,
<tt class="docutils literal"><span class="pre">initial_where</span></tt>, and <tt class="docutils literal"><span class="pre">accepting_where</span></tt> of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><tt class="xref py py-class docutils literal"><span class="pre">FSMState</span></tt></a> (here, <tt class="docutils literal"><span class="pre">format_label</span></tt> is a callable
without arguments, everything else is a specific value);</li>
<li><tt class="docutils literal"><span class="pre">format_label</span></tt> of <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><tt class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></tt></a> (<tt class="docutils literal"><span class="pre">format_label</span></tt>
is a callable without arguments);</li>
<li><tt class="docutils literal"><span class="pre">format_state_label</span></tt>, <tt class="docutils literal"><span class="pre">format_letter</span></tt>,
<tt class="docutils literal"><span class="pre">format_transition_label</span></tt>, <tt class="docutils literal"><span class="pre">accepting_style</span></tt>,
<tt class="docutils literal"><span class="pre">accepting_distance</span></tt>, and <tt class="docutils literal"><span class="pre">accepting_show_empty</span></tt>
of <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>.</li>
</ul>
<p>This function, however, also (somewhat) checks its input and
serves to collect documentation on all these options.</p>
<p>The function can be called several times, only those arguments
which are not <tt class="docutils literal"><span class="pre">None</span></tt> are taken into account. By the same
means, it can be combined with directly setting some
attributes as outlined above.</p>
<p>EXAMPLES:</p>
<p>See also the section on <a class="reference internal" href="#finite-state-machine-latex-output"><em>LaTeX output</em></a>
in the introductory examples of this module.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
<span class="go">....:     final_states=[0, 3])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">srange</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
<span class="go">....:     T.add_transition(4, j, 0, [0, j])</span>
<span class="go">....:     T.add_transition(j, 4, 0, [0, -j])</span>
<span class="go">....:     T.add_transition(j, j, 0, 0)</span>
<span class="go">Transition from 4 to 0: 0|0,0</span>
<span class="go">Transition from 0 to 4: 0|0,0</span>
<span class="go">Transition from 0 to 0: 0|0</span>
<span class="go">Transition from 4 to 1: 0|0,1</span>
<span class="go">Transition from 1 to 4: 0|0,-1</span>
<span class="go">Transition from 1 to 1: 0|0</span>
<span class="go">Transition from 4 to 2: 0|0,2</span>
<span class="go">Transition from 2 to 4: 0|0,-2</span>
<span class="go">Transition from 2 to 2: 0|0</span>
<span class="go">Transition from 4 to 3: 0|0,3</span>
<span class="go">Transition from 3 to 4: 0|0,-3</span>
<span class="go">Transition from 3 to 3: 0|0</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">Transition from 4 to 4: 0|0</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span>
<span class="go">....:     coordinates={4: (0, 0),</span>
<span class="go">....:                  0: (-6, 3),</span>
<span class="go">....:                  1: (-2, 3),</span>
<span class="go">....:                  2: (2, 3),</span>
<span class="go">....:                  3: (6, 3)},</span>
<span class="go">....:     format_state_label=lambda x: r&#39;\mathbf{%s}&#39; % x,</span>
<span class="go">....:     format_letter=lambda x: r&#39;w_{%s}&#39; % x,</span>
<span class="go">....:     format_transition_label=lambda x:</span>
<span class="go">....:         r&quot;{\scriptstyle %s}&quot; % T.default_format_transition_label(x),</span>
<span class="go">....:     loop_where={4: &#39;below&#39;, 0: &#39;left&#39;, 1: &#39;above&#39;,</span>
<span class="go">....:                 2: &#39;right&#39;, 3:&#39;below&#39;},</span>
<span class="go">....:     initial_where=lambda x: &#39;above&#39;,</span>
<span class="go">....:     accepting_style=&#39;accepting by double&#39;,</span>
<span class="go">....:     accepting_distance=&#39;10ex&#39;,</span>
<span class="go">....:     accepting_where={0: &#39;left&#39;, 3: 45}</span>
<span class="go">....:     )</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">format_label</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="s">r&#39;\mathcal{I}&#39;</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">\begin{tikzpicture}[auto, initial text=, &gt;=latex]</span>
<span class="go">\node[state, initial, initial where=above] (v0) at (0.000000, 0.000000) {$\mathcal{I}$};</span>
<span class="go">\node[state, accepting, accepting where=left] (v1) at (-6.000000, 3.000000) {$\mathbf{0}$};</span>
<span class="go">\node[state, accepting, accepting where=45] (v2) at (6.000000, 3.000000) {$\mathbf{3}$};</span>
<span class="go">\path[-&gt;] (v2.45.00) edge node[rotate=45.00, anchor=south] {$$ \mid {\scriptstyle w_{0} w_{0}}$} ++(45.00:10ex);</span>
<span class="go">\node[state] (v3) at (-2.000000, 3.000000) {$\mathbf{1}$};</span>
<span class="go">\node[state] (v4) at (2.000000, 3.000000) {$\mathbf{2}$};</span>
<span class="go">\path[-&gt;] (v1) edge[loop left] node[rotate=90, anchor=south] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0}}$} ();</span>
<span class="go">\path[-&gt;] (v1.-21.57) edge node[rotate=-26.57, anchor=south] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0} w_{0}}$} (v0.148.43);</span>
<span class="go">\path[-&gt;] (v3) edge[loop above] node {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0}}$} ();</span>
<span class="go">\path[-&gt;] (v3.-51.31) edge node[rotate=-56.31, anchor=south] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0} w_{-1}}$} (v0.118.69);</span>
<span class="go">\path[-&gt;] (v4) edge[loop right] node[rotate=90, anchor=north] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0}}$} ();</span>
<span class="go">\path[-&gt;] (v4.-118.69) edge node[rotate=56.31, anchor=north] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0} w_{-2}}$} (v0.51.31);</span>
<span class="go">\path[-&gt;] (v2) edge[loop below] node {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0}}$} ();</span>
<span class="go">\path[-&gt;] (v2.-148.43) edge node[rotate=26.57, anchor=north] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0} w_{-3}}$} (v0.21.57);</span>
<span class="go">\path[-&gt;] (v0.158.43) edge node[rotate=333.43, anchor=north] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0} w_{0}}$} (v1.328.43);</span>
<span class="go">\path[-&gt;] (v0.128.69) edge node[rotate=303.69, anchor=north] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0} w_{1}}$} (v3.298.69);</span>
<span class="go">\path[-&gt;] (v0.61.31) edge node[rotate=56.31, anchor=south] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0} w_{2}}$} (v4.231.31);</span>
<span class="go">\path[-&gt;] (v0.31.57) edge node[rotate=26.57, anchor=south] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0} w_{3}}$} (v2.201.57);</span>
<span class="go">\path[-&gt;] (v0) edge[loop below] node {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0}}$} ();</span>
<span class="go">\end{tikzpicture}</span>
<span class="gp">sage: </span><span class="n">view</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="c"># not tested</span>
</pre></div>
</div>
<p>To actually see this, use the live documentation in the Sage notebook
and execute the cells.</p>
<p>By changing some of the options, we get the following output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span>
<span class="go">....:     format_transition_label=T.default_format_transition_label,</span>
<span class="go">....:     accepting_style=&#39;accepting by arrow&#39;,</span>
<span class="go">....:     accepting_show_empty=True</span>
<span class="go">....:     )</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">\begin{tikzpicture}[auto, initial text=, &gt;=latex, accepting text=, accepting/.style=accepting by arrow, accepting distance=10ex]</span>
<span class="go">\node[state, initial, initial where=above] (v0) at (0.000000, 0.000000) {$\mathcal{I}$};</span>
<span class="go">\node[state] (v1) at (-6.000000, 3.000000) {$\mathbf{0}$};</span>
<span class="go">\path[-&gt;] (v1.180.00) edge node[rotate=360.00, anchor=south] {$$ \mid \varepsilon$} ++(180.00:10ex);</span>
<span class="go">\node[state] (v2) at (6.000000, 3.000000) {$\mathbf{3}$};</span>
<span class="go">\path[-&gt;] (v2.45.00) edge node[rotate=45.00, anchor=south] {$$ \mid w_{0} w_{0}$} ++(45.00:10ex);</span>
<span class="go">\node[state] (v3) at (-2.000000, 3.000000) {$\mathbf{1}$};</span>
<span class="go">\node[state] (v4) at (2.000000, 3.000000) {$\mathbf{2}$};</span>
<span class="go">\path[-&gt;] (v1) edge[loop left] node[rotate=90, anchor=south] {$w_{0}\mid w_{0}$} ();</span>
<span class="go">\path[-&gt;] (v1.-21.57) edge node[rotate=-26.57, anchor=south] {$w_{0}\mid w_{0} w_{0}$} (v0.148.43);</span>
<span class="go">\path[-&gt;] (v3) edge[loop above] node {$w_{0}\mid w_{0}$} ();</span>
<span class="go">\path[-&gt;] (v3.-51.31) edge node[rotate=-56.31, anchor=south] {$w_{0}\mid w_{0} w_{-1}$} (v0.118.69);</span>
<span class="go">\path[-&gt;] (v4) edge[loop right] node[rotate=90, anchor=north] {$w_{0}\mid w_{0}$} ();</span>
<span class="go">\path[-&gt;] (v4.-118.69) edge node[rotate=56.31, anchor=north] {$w_{0}\mid w_{0} w_{-2}$} (v0.51.31);</span>
<span class="go">\path[-&gt;] (v2) edge[loop below] node {$w_{0}\mid w_{0}$} ();</span>
<span class="go">\path[-&gt;] (v2.-148.43) edge node[rotate=26.57, anchor=north] {$w_{0}\mid w_{0} w_{-3}$} (v0.21.57);</span>
<span class="go">\path[-&gt;] (v0.158.43) edge node[rotate=333.43, anchor=north] {$w_{0}\mid w_{0} w_{0}$} (v1.328.43);</span>
<span class="go">\path[-&gt;] (v0.128.69) edge node[rotate=303.69, anchor=north] {$w_{0}\mid w_{0} w_{1}$} (v3.298.69);</span>
<span class="go">\path[-&gt;] (v0.61.31) edge node[rotate=56.31, anchor=south] {$w_{0}\mid w_{0} w_{2}$} (v4.231.31);</span>
<span class="go">\path[-&gt;] (v0.31.57) edge node[rotate=26.57, anchor=south] {$w_{0}\mid w_{0} w_{3}$} (v2.201.57);</span>
<span class="go">\path[-&gt;] (v0) edge[loop below] node {$w_{0}\mid w_{0}$} ();</span>
<span class="go">\end{tikzpicture}</span>
<span class="gp">sage: </span><span class="n">view</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="c"># not tested</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">format_state_label</span><span class="o">=</span><span class="s">&#39;Nothing&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">format_state_label must be callable.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">format_letter</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">format_letter must be callable.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">format_transition_label</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">format_transition_label must be callable.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">loop_where</span><span class="o">=</span><span class="mi">37</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">loop_where must be a callable or a</span>
<span class="go">dictionary.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">loop_where</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">&#39;top&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">loop_where for 4 must be in [&#39;below&#39;,</span>
<span class="go">&#39;right&#39;, &#39;above&#39;, &#39;left&#39;].</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">initial_where</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">initial_where must be a callable or a</span>
<span class="go">dictionary.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">initial_where</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">&#39;top&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">initial_where for 4 must be in [&#39;below&#39;,</span>
<span class="go">&#39;right&#39;, &#39;above&#39;, &#39;left&#39;].</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">accepting_style</span><span class="o">=</span><span class="s">&#39;fancy&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">accepting_style must be in [&#39;accepting by</span>
<span class="go">double&#39;, &#39;accepting by arrow&#39;].</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">accepting_where</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">accepting_where must be a callable or a</span>
<span class="go">dictionary.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">accepting_where</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">&#39;top&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">accepting_where for 0 must be in [&#39;below&#39;,</span>
<span class="go">&#39;right&#39;, &#39;above&#39;, &#39;left&#39;].</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">accepting_where</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;above&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s">&#39;top&#39;</span><span class="p">})</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">accepting_where for 3 must be a real number or</span>
<span class="go">be in [&#39;below&#39;, &#39;right&#39;, &#39;above&#39;, &#39;left&#39;].</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.markov_chain_simplification">
<tt class="descname">markov_chain_simplification</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.markov_chain_simplification" title="Permalink to this definition">¶</a></dt>
<dd><p>Consider <tt class="docutils literal"><span class="pre">self</span></tt> as Markov chain with probabilities as input labels
and simplify it.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>Simplified version of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLE:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_add_input</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="go">....:                 [2, 2, 1/4, 1], [2, -2, 1/4, 1], [-2, -2, 1/4, 1],</span>
<span class="go">....:                 [-2, 2, 1/4, 1], [2, 3, 1/2, 2], [-2, 3, 1/2, 2]],</span>
<span class="go">....:                initial_states=[1],</span>
<span class="go">....:                final_states=[3],</span>
<span class="go">....:                on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">T1</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">markov_chain_simplification</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">T1</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from ((1,),) to ((2, -2),): 1|0,</span>
<span class="go"> Transition from ((2, -2),) to ((2, -2),): 1/2|1,</span>
<span class="go"> Transition from ((2, -2),) to ((3,),): 1/2|2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.merged_transitions">
<tt class="descname">merged_transitions</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.merged_transitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges transitions which have the same <tt class="docutils literal"><span class="pre">from_state</span></tt>,
<tt class="docutils literal"><span class="pre">to_state</span></tt> and <tt class="docutils literal"><span class="pre">word_out</span></tt> while adding their <tt class="docutils literal"><span class="pre">word_in</span></tt>.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A finite state machine with merged transitions. If no mergers occur,
return <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLE:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_add_input</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                 [2, 2, 1/4, 1], [2, -2, 1/4, 1], [-2, -2, 1/4, 1],</span>
<span class="go">....:                 [-2, 2, 1/4, 1], [2, 3, 1/2, 1], [-2, 3, 1/2, 1]],</span>
<span class="go">....:                on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">T1</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">merged_transitions</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T1</span> <span class="ow">is</span> <span class="n">T</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">T1</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from -2 to -2: 1/4|1,</span>
<span class="go"> Transition from -2 to 2: 1/4|1,</span>
<span class="go"> Transition from -2 to 3: 1/2|1,</span>
<span class="go"> Transition from 1 to 2: 1/4|1,</span>
<span class="go"> Transition from 1 to -2: 3/4|1,</span>
<span class="go"> Transition from 2 to -2: 1/4|1,</span>
<span class="go"> Transition from 2 to 2: 1/4|1,</span>
<span class="go"> Transition from 2 to 3: 1/2|1]</span>
</pre></div>
</div>
<p>Applying the function again does not change the result:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T2</span> <span class="o">=</span> <span class="n">T1</span><span class="o">.</span><span class="n">merged_transitions</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T2</span> <span class="ow">is</span> <span class="n">T1</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.moments_waiting_time">
<tt class="descname">moments_waiting_time</tt><big>(</big><em>test=&lt;type 'bool'&gt;</em>, <em>is_zero=None</em>, <em>expectation_only=False</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.moments_waiting_time" title="Permalink to this definition">¶</a></dt>
<dd><p>If this finite state machine acts as a Markov chain, return
the expectation and variance of the number of steps until
first writing <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">test</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">bool</span></tt>) a callable deciding whether
an output label is to be considered <tt class="docutils literal"><span class="pre">True</span></tt>. By default, the
standard conversion to boolean is used.</li>
<li><tt class="docutils literal"><span class="pre">is_zero</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a callable deciding
whether an expression for a probability is zero. By default,
checking for zero is simply done by
<a class="reference external" href="../../../structure/sage/structure/element.html#sage.structure.element.Element.is_zero" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-meth docutils literal"><span class="pre">is_zero()</span></tt></a>.  This
parameter can be used to provide a more sophisticated check
for zero, e.g. in the case of symbolic probabilities, see
the examples below. This parameter is passed on to
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_Markov_chain" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_Markov_chain"><tt class="xref py py-meth docutils literal"><span class="pre">is_Markov_chain()</span></tt></a>. This parameter only affects the
input of the Markov chain.</li>
<li><tt class="docutils literal"><span class="pre">expectation_only</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) if set, the
variance is not computed (in order to save time). By default,
the variance is computed.</li>
</ul>
<p>OUTPUT:</p>
<p>A dictionary (if <tt class="docutils literal"><span class="pre">expectation_only=False</span></tt>) consisting of</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">expectation</span></tt>,</li>
<li><tt class="docutils literal"><span class="pre">variance</span></tt>.</li>
</ul>
<p>Otherwise, just the expectation is returned (no dictionary for
<tt class="docutils literal"><span class="pre">expectation_only=True</span></tt>).</p>
<p>Expectation and variance of the number of steps until first
writing <tt class="docutils literal"><span class="pre">True</span></tt> (as determined by the parameter <tt class="docutils literal"><span class="pre">test</span></tt>).</p>
<p>ALGORITHM:</p>
<p>Relies on a (classical and easy) probabilistic argument,
cf. <a class="reference internal" href="#fgt1992" id="id17">[FGT1992]</a>, Eqns. (6) and (7).</p>
<p>For the variance, see <a class="reference internal" href="#fhp2015" id="id18">[FHP2015]</a>, Section 2.</p>
<p>EXAMPLES:</p>
<ol class="arabic">
<li><p class="first">The simplest example is to wait for the first <span class="math">\(1\)</span> in a
<span class="math">\(0\)</span>-<span class="math">\(1\)</span>-string where both digits appear with probability
<span class="math">\(1/2\)</span>. In fact, the waiting time equals <span class="math">\(k\)</span> if and only if
the string starts with <span class="math">\(0^{k-1}1\)</span>. This event occurs with
probability <span class="math">\(2^{-k}\)</span>. Therefore, the expected waiting time
and the variance are <span class="math">\(\sum_{k\ge 1} k2^{-k}=2\)</span> and
<span class="math">\(\sum_{k\ge 1} (k-2)^2 2^{-k}=2\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s">&#39;k&#39;</span><span class="p">)</span>
<span class="go">k</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="p">),</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">infinity</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">((</span><span class="n">k</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="p">),</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">infinity</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>We now compute the same expectation and variance by using a
Markov chain:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="p">(</span>
<span class="go">....:     duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span>
<span class="go">....:     [(0, 0, 1/2, 0), (0, 0, 1/2, 1)],</span>
<span class="go">....:     on_duplicate_transition=\</span>
<span class="go">....:         duplicate_transition_add_input,</span>
<span class="go">....:     initial_states=[0],</span>
<span class="go">....:     final_states=[0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">moments_waiting_time</span><span class="p">()</span>
<span class="go">{&#39;expectation&#39;: 2, &#39;variance&#39;: 2}</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">moments_waiting_time</span><span class="p">(</span><span class="n">expectation_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>In the following, we replace the output <tt class="docutils literal"><span class="pre">0</span></tt> by <tt class="docutils literal"><span class="pre">-1</span></tt> and
demonstrate the use of the parameter <tt class="docutils literal"><span class="pre">test</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">delete_transition</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">Transition from 0 to 0: 1/2|-1</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">moments_waiting_time</span><span class="p">(</span><span class="n">test</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
<span class="go">{&#39;expectation&#39;: 2, &#39;variance&#39;: 2}</span>
</pre></div>
</div>
</li>
<li><p class="first">Make sure that the transducer is actually a Markov
chain. Although this is checked by the code, unexpected
behaviour may still occur if the transducer looks like a
Markov chain. In the following example, we &#8216;forget&#8217; to
assign probabilities, but due to a coincidence, all
&#8216;probabilities&#8217; add up to one. Nevertheless, <span class="math">\(0\)</span> is never
written, so the expectation is <span class="math">\(1\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                on_duplicate_transition=\</span>
<span class="go">....:                    duplicate_transition_add_input,</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">moments_waiting_time</span><span class="p">()</span>
<span class="go">{&#39;expectation&#39;: 1, &#39;variance&#39;: 0}</span>
</pre></div>
</div>
</li>
<li><p class="first">If <tt class="docutils literal"><span class="pre">True</span></tt> is never written, the moments are
<tt class="docutils literal"><span class="pre">+Infinity</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                on_duplicate_transition=\</span>
<span class="go">....:                    duplicate_transition_add_input,</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">moments_waiting_time</span><span class="p">()</span>
<span class="go">{&#39;expectation&#39;: +Infinity, &#39;variance&#39;: +Infinity}</span>
</pre></div>
</div>
</li>
<li><p class="first">Let <span class="math">\(h\)</span> and <span class="math">\(r\)</span> be positive integers. We consider random
strings of letters <span class="math">\(1\)</span>, <span class="math">\(\ldots\)</span>, <span class="math">\(r\)</span> where the letter <span class="math">\(j\)</span>
occurs with probability <span class="math">\(p_j\)</span>. Let <span class="math">\(B\)</span> be the random
variable giving the first position of a block of <span class="math">\(h\)</span>
consecutive identical letters. Then</p>
<div class="math">
\[\begin{split}\begin{aligned}
\mathbb{E}(B)&amp;=\frac1{\displaystyle\sum_{i=1}^r
\frac1{p_i^{-1}+\cdots+p_i^{-h}}},\\
\mathbb{V}(B)&amp;=\frac{\displaystyle\sum_{i=1}^r\biggl(
\frac{p_i +p_i^h}{1-p_i^h}
- 2h\frac{ p_i^h(1-p_i)}{(1-p_i^h)^2}\biggr)}
{\displaystyle\biggl(\sum_{i=1}^r
\frac1{p_i^{-1}+\cdots+p_i^{-h}}\biggr)^2}
\end{aligned}\end{split}\]</div>
<p>cf. <a class="reference internal" href="#s1986" id="id19">[S1986]</a>, p. 62, or <a class="reference internal" href="#fhp2015" id="id20">[FHP2015]</a>, Theorem 1. We now
verify this with a transducer approach.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="go">....:     R = PolynomialRing(</span>
<span class="go">....:             QQ,</span>
<span class="go">....:             names=[&#39;p_%d&#39; % j for j in range(r)])</span>
<span class="go">....:     p = R.gens()</span>
<span class="go">....:     def is_zero(polynomial):</span>
<span class="go">....:         return polynomial in (sum(p) - 1) * R</span>
<span class="go">....:     theory_expectation = 1/(sum(1/sum(p[j]^(-i)</span>
<span class="go">....:                     for i in range(1, h+1))</span>
<span class="go">....:                     for j in range(r)))</span>
<span class="go">....:     theory_variance = sum(</span>
<span class="go">....:         (p[i] + p[i]^h)/(1 - p[i]^h)</span>
<span class="go">....:         - 2*h*p[i]^h * (1 - p[i])/(1 - p[i]^h)^2</span>
<span class="go">....:         for i in range(r)</span>
<span class="go">....:         ) * theory_expectation^2</span>
<span class="go">....:     alphabet = range(r)</span>
<span class="go">....:     counters = [</span>
<span class="go">....:         transducers.CountSubblockOccurrences([j]*h,</span>
<span class="go">....:                     alphabet)</span>
<span class="go">....:         for j in alphabet]</span>
<span class="go">....:     all_counter = counters[0].cartesian_product(</span>
<span class="go">....:         counters[1:])</span>
<span class="go">....:     adder = transducers.add(input_alphabet=[0, 1],</span>
<span class="go">....:         number_of_operands=r)</span>
<span class="go">....:     probabilities = Transducer(</span>
<span class="go">....:        [(0, 0, p[j], j) for j in alphabet],</span>
<span class="go">....:        initial_states=[0],</span>
<span class="go">....:        final_states=[0],</span>
<span class="go">....:        on_duplicate_transition=\</span>
<span class="go">....:            duplicate_transition_add_input)</span>
<span class="go">....:     chain = adder(all_counter(probabilities))</span>
<span class="go">....:     result = chain.moments_waiting_time(</span>
<span class="go">....:        is_zero=is_zero)</span>
<span class="go">....:     return is_zero((result[&#39;expectation&#39;] -</span>
<span class="go">....:                theory_expectation).numerator()) \</span>
<span class="go">....:            and \</span>
<span class="go">....:            is_zero((result[&#39;variance&#39;] -</span>
<span class="go">....:                 theory_variance).numerator())</span>
<span class="gp">sage: </span><span class="n">test</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p class="first">Consider the alphabet <span class="math">\(\{0, \ldots, r-1\}\)</span>, some <span class="math">\(1\le j\le
r\)</span> and some <span class="math">\(h\ge 1\)</span>.  For some probabilities <span class="math">\(p_0\)</span>,
<span class="math">\(\ldots\)</span>, <span class="math">\(p_{r-1}\)</span>, we consider infinite words where the
letters occur independently with the given probabilities.
The random variable <span class="math">\(B_j\)</span> is the first position <span class="math">\(n\)</span> such
that there exist <span class="math">\(j\)</span> of the <span class="math">\(r\)</span> letters having an <span class="math">\(h\)</span>-run.
The expectation of <span class="math">\(B_j\)</span> is given in <a class="reference internal" href="#fhp2015" id="id21">[FHP2015]</a>, Theorem 2.
Here, we verify this result by using transducers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="go">....:     R = PolynomialRing(</span>
<span class="go">....:             QQ,</span>
<span class="go">....:             names=[&#39;p_%d&#39; % i for i in range(r)])</span>
<span class="go">....:     p = R.gens()</span>
<span class="go">....:     def is_zero(polynomial):</span>
<span class="go">....:         return polynomial in (sum(p) - 1) * R</span>
<span class="go">....:     alphabet = range(r)</span>
<span class="go">....:     counters = [</span>
<span class="go">....:         transducers.Wait([0, 1])(</span>
<span class="go">....:             transducers.CountSubblockOccurrences(</span>
<span class="go">....:                 [i]*h,</span>
<span class="go">....:                 alphabet))</span>
<span class="go">....:         for i in alphabet]</span>
<span class="go">....:     all_counter = counters[0].cartesian_product(</span>
<span class="go">....:         counters[1:])</span>
<span class="go">....:     adder = transducers.add(input_alphabet=[0, 1],</span>
<span class="go">....:         number_of_operands=r)</span>
<span class="go">....:     threshold = transducers.map(</span>
<span class="go">....:         f=lambda x: x &gt;= j,</span>
<span class="go">....:         input_alphabet=srange(r+1))</span>
<span class="go">....:     probabilities = Transducer(</span>
<span class="go">....:         [(0, 0, p[i], i) for i in alphabet],</span>
<span class="go">....:         initial_states=[0],</span>
<span class="go">....:         final_states=[0],</span>
<span class="go">....:         on_duplicate_transition=\</span>
<span class="go">....:             duplicate_transition_add_input)</span>
<span class="go">....:     chain = threshold(adder(all_counter(</span>
<span class="go">....:         probabilities)))</span>
<span class="go">....:     result = chain.moments_waiting_time(</span>
<span class="go">....:         is_zero=is_zero,</span>
<span class="go">....:         expectation_only=True)</span>
<span class="go">....:</span>
<span class="go">....:     R_v = PolynomialRing(</span>
<span class="go">....:             QQ,</span>
<span class="go">....:             names=[&#39;p_%d&#39; % i for i in range(r)])</span>
<span class="go">....:     v = R_v.gens()</span>
<span class="go">....:     S = 1/(1 - sum(v[i]/(1+v[i])</span>
<span class="go">....:                    for i in range(r)))</span>
<span class="go">....:     alpha = [(p[i] - p[i]^h)/(1 - p[i])</span>
<span class="go">....:              for i in range(r)]</span>
<span class="go">....:     gamma = [p[i]/(1 - p[i]) for i in range(r)]</span>
<span class="go">....:     alphabet_set = set(alphabet)</span>
<span class="go">....:     expectation = 0</span>
<span class="go">....:     for q in range(j):</span>
<span class="go">....:         for M in Subsets(alphabet_set, q):</span>
<span class="go">....:             summand = S</span>
<span class="go">....:             for i in M:</span>
<span class="go">....:                 summand = summand.subs(</span>
<span class="go">....:                     {v[i]: gamma[i]}) -\</span>
<span class="go">....:                     summand.subs({v[i]: alpha[i]})</span>
<span class="go">....:             for i in alphabet_set - set(M):</span>
<span class="go">....:                 summand = summand.subs(</span>
<span class="go">....:                     {v[i]: alpha[i]})</span>
<span class="go">....:             expectation += summand</span>
<span class="go">....:     return is_zero((result - expectation).\</span>
<span class="go">....:             numerator())</span>
<span class="gp">sage: </span><span class="n">test</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
</ol>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="fgt1992" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[FGT1992]</a></td><td>Philippe Flajolet, Danièle Gardy, Loÿs Thimonier,
<em>Birthday paradox, coupon collectors, caching algorithms and
self-organizing search</em>, Discrete Appl. Math. 39 (1992),
207&#8211;229, <a class="reference external" href="https://dx.doi.org/10.1016/0166-218X(92)90177-C">doi:10.1016/0166-218X(92)90177-C</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="fhp2015" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[FHP2015]</td><td><em>(<a class="fn-backref" href="#id18">1</a>, <a class="fn-backref" href="#id20">2</a>, <a class="fn-backref" href="#id21">3</a>)</em> Uta Freiberg, Clemens Heuberger, Helmut Prodinger,
<em>Application of Smirnov Words to Waiting Time Distributions
of Runs</em>, <a class="reference external" href="http://arxiv.org/abs/1503.08096">Arxiv 1503.08096</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="s1986" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[S1986]</a></td><td>Gábor J. Székely, <em>Paradoxes in Probability Theory
and Mathematical Statistics</em>, D. Reidel Publishing Company.</td></tr>
</tbody>
</table>
<p>TESTS:</p>
<p>Only Markov chains are acceptable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">Identity</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">moments_waiting_time</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Only Markov chains can compute</span>
<span class="go">moments_waiting_time.</span>
</pre></div>
</div>
<p>There must be a unique initial state:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                on_duplicate_transition=\</span>
<span class="go">....:                    duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">moments_waiting_time</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Unique initial state is required.</span>
</pre></div>
</div>
<p>Using <span class="math">\(0\)</span> as initial state in this example, a <span class="math">\(1\)</span> is written in
the first step with probability <span class="math">\(1\)</span>, so the waiting time is
always <span class="math">\(1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">moments_waiting_time</span><span class="p">()</span>
<span class="go">{&#39;expectation&#39;: 1, &#39;variance&#39;: 0}</span>
</pre></div>
</div>
<p>Using both <span class="math">\(0\)</span> and <span class="math">\(1\)</span> as initial states again yields an error
message:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">moments_waiting_time</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Unique initial state is required.</span>
</pre></div>
</div>
<p>Detection of infinite waiting time for symbolic probabilities:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                on_duplicate_transition=\</span>
<span class="go">....:                    duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">moments_waiting_time</span><span class="p">(</span>
<span class="go">....:     is_zero=lambda e: e in (p + q - 1)*R)</span>
<span class="go">{&#39;expectation&#39;: +Infinity, &#39;variance&#39;: +Infinity}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition">
<tt class="descname">on_duplicate_transition</tt><big>(</big><em>old_transition</em>, <em>new_transition</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Which function to call when a duplicate transition is inserted.</p>
<p>It can be set by the parameter <tt class="docutils literal"><span class="pre">on_duplicate_transition</span></tt> when
initializing a finite state machine, see
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>, <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_Markov_chain" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_Markov_chain"><tt class="xref py py-meth docutils literal"><span class="pre">is_Markov_chain()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.markov_chain_simplification" title="sage.combinat.finite_state_machine.FiniteStateMachine.markov_chain_simplification"><tt class="xref py py-meth docutils literal"><span class="pre">markov_chain_simplification()</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.output_alphabet">
<tt class="descname">output_alphabet</tt><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.output_alphabet" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of letters representing the output alphabet of the finite
state machine.</p>
<p>It can be set by the parameter <tt class="docutils literal"><span class="pre">output_alphabet</span></tt> when initializing
a finite state machine, see <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>.</p>
<p>It can also be set by the method <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.input_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.input_alphabet"><tt class="xref py py-attr docutils literal"><span class="pre">input_alphabet</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.output_projection">
<tt class="descname">output_projection</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.output_projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a automaton where the input of each transition of self
is deleted and the new input is the original output.</p>
<p>INPUT:</p>
<p>Nothing</p>
<p>OUTPUT:</p>
<p>An automaton.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                         (&#39;B&#39;, &#39;B&#39;, 1, 0)])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">output_projection</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;B&#39;: 1|-,</span>
<span class="go"> Transition from &#39;A&#39; to &#39;A&#39;: 1|-,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;B&#39;: 0|-]</span>
</pre></div>
</div>
<p>Final output words are also considered correctly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;B&#39;, 1, 0), (&#39;A&#39;, (&#39;final&#39;, 0), 0, 0)],</span>
<span class="go">....:                final_states=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">output_projection</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;, &#39;B&#39;, (&#39;final&#39;, 0), (&#39;final&#39;, 1)]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;B&#39;: 1|-,</span>
<span class="go"> Transition from &#39;A&#39; to &#39;A&#39;: 1|-,</span>
<span class="go"> Transition from &#39;A&#39; to (&#39;final&#39;, 0): 0|-,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;B&#39;: 0|-,</span>
<span class="go"> Transition from &#39;B&#39; to (&#39;final&#39;, 1): 2|-]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;, (&#39;final&#39;, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.plot">
<tt class="descname">plot</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a graph of the finite state machine with labeled
vertices and labeled edges.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A plot of the graph of the finite state machine.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 3 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.predecessors">
<tt class="descname">predecessors</tt><big>(</big><em>state</em>, <em>valid_input=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists all predecessors of a state.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">state</span></tt> &#8211; the state from which the predecessors should be
listed.</li>
<li><tt class="docutils literal"><span class="pre">valid_input</span></tt> &#8211; If <tt class="docutils literal"><span class="pre">valid_input</span></tt> is a list, then we
only consider transitions whose input labels are contained
in <tt class="docutils literal"><span class="pre">valid_input</span></tt>. <tt class="docutils literal"><span class="pre">state</span></tt> has to be a <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><tt class="xref py py-class docutils literal"><span class="pre">FSMState</span></tt></a>
(not a label of a state). If input labels of length larger
than <span class="math">\(1\)</span> are used, then <tt class="docutils literal"><span class="pre">valid_input</span></tt> has to be a list of
lists.</li>
</ul>
<p>OUTPUT:</p>
<p>A list of states.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;I&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;I&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">),</span>
<span class="go">....:                 (&#39;I&#39;, &#39;C&#39;, &#39;c&#39;, &#39;a&#39;), (&#39;A&#39;, &#39;F&#39;, &#39;b&#39;, &#39;a&#39;),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;F&#39;, [&#39;c&#39;, &#39;b&#39;], &#39;b&#39;), (&#39;C&#39;, &#39;F&#39;, &#39;a&#39;, &#39;c&#39;)],</span>
<span class="go">....:                initial_states=[&#39;I&#39;], final_states=[&#39;F&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">))</span>
<span class="go">[&#39;A&#39;, &#39;I&#39;]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;F&#39;</span><span class="p">),</span> <span class="n">valid_input</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="go">[&#39;F&#39;, &#39;C&#39;, &#39;A&#39;, &#39;I&#39;]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;F&#39;</span><span class="p">),</span> <span class="n">valid_input</span><span class="o">=</span><span class="p">[[</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">],</span> <span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="go">[&#39;F&#39;, &#39;C&#39;, &#39;B&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.prepone_output">
<tt class="descname">prepone_output</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.prepone_output" title="Permalink to this definition">¶</a></dt>
<dd><p>For all paths, shift the output of the path from one
transition to the earliest possible preceeding transition of
the path.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>Apply the following to each state <span class="math">\(s\)</span> (except initial states) of the
finite state machine as often as possible:</p>
<p>If the letter <span class="math">\(a\)</span> is a prefix of the output label of all transitions from
<span class="math">\(s\)</span> (including the final output of <span class="math">\(s\)</span>), then remove it from all these
labels and append it to all output labels of all transitions leading
to <span class="math">\(s\)</span>.</p>
<p>We assume that the states have no output labels, but final outputs are
allowed.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;B&#39;, 0, 0),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;C&#39;, 1, 0)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;],</span>
<span class="go">....:                final_states=[&#39;C&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">prepone_output</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;B&#39;: 1|1,0,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;B&#39;: 0|0,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;C&#39;: 1|-]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;C&#39;, 1, [1, 1]),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;C&#39;, 0, 1)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;],</span>
<span class="go">....:                final_states=[&#39;C&#39;])</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">prepone_output</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;B&#39;: 0|1,1,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;C&#39;: 1|1,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;C&#39;: 0|-]</span>
</pre></div>
</div>
<p>If initial states are not labeled as such, unexpected results may be
obtained:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">prepone_output</span><span class="p">()</span>
<span class="go">verbose 0 (...: finite_state_machine.py, prepone_output)</span>
<span class="go">All transitions leaving state 0 have an output label with</span>
<span class="go">prefix 0.  However, there is no inbound transition and it</span>
<span class="go">is not an initial state. This routine (possibly called by</span>
<span class="go">simplification) therefore erased this prefix from all</span>
<span class="go">outbound transitions.</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|-]</span>
</pre></div>
</div>
<p>Also the final output of final states can be changed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;C&#39;, 1, [1, 1]),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;C&#39;, 0, 1)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;],</span>
<span class="go">....:                final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">prepone_output</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;B&#39;: 0|1,1,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;C&#39;: 1|1,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;C&#39;: 0|-]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;C&#39;, 1, [1, 1]),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;C&#39;, 0, 1)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;],</span>
<span class="go">....:                final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">prepone_output</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;B&#39;: 0|1,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;C&#39;: 1|1,1,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;C&#39;: 0|1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[0]</span>
</pre></div>
</div>
<p>Output labels do not have to be hashable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]),</span>
<span class="go">....:                 (1, 0, 0, [vector([0, 0]), 0]),</span>
<span class="go">....:                 (1, 1, 1, [vector([0, 0]), 1]),</span>
<span class="go">....:                 (0, 0, 1, 0)],</span>
<span class="go">....:                 determine_alphabets=False,</span>
<span class="go">....:                 initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">prepone_output</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from 0 to 1: 0|(0, 0),</span>
<span class="go"> Transition from 0 to 0: 1|0,</span>
<span class="go"> Transition from 1 to 0: 0|0,</span>
<span class="go"> Transition from 1 to 1: 1|1,(0, 0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.process">
<tt class="descname">process</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the finite state machine accepts the input, the state
where the computation stops and which output is generated.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">input_tape</span></tt> &#8211; the input tape can be a list or an
iterable with entries from the input alphabet. If we are
working with a multi-tape machine (see parameter
<tt class="docutils literal"><span class="pre">use_multitape_input</span></tt> and notes below), then the tape is a
list or tuple of tracks, each of which can be a list or an
iterable with entries from the input alphabet.</li>
<li><tt class="docutils literal"><span class="pre">initial_state</span></tt> or <tt class="docutils literal"><span class="pre">initial_states</span></tt> &#8211; the initial
state(s) in which the machine starts. Either specify a
single one with <tt class="docutils literal"><span class="pre">initial_state</span></tt> or a list of them with
<tt class="docutils literal"><span class="pre">initial_states</span></tt>. If both are given, <tt class="docutils literal"><span class="pre">initial_state</span></tt>
will be appended to <tt class="docutils literal"><span class="pre">initial_states</span></tt>. If neither is
specified, the initial states of the finite state machine
are taken.</li>
<li><tt class="docutils literal"><span class="pre">list_of_outputs</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a boolean or
<tt class="docutils literal"><span class="pre">None</span></tt>. If <tt class="docutils literal"><span class="pre">True</span></tt>, then the outputs are given in list form
(even if we have no or only one single output). If
<tt class="docutils literal"><span class="pre">False</span></tt>, then the result is never a list (an exception is
raised if the result cannot be returned). If
<tt class="docutils literal"><span class="pre">list_of_outputs=None</span></tt>, the method determines automatically
what to do (e.g. if a non-deterministic machine returns more
than one path, then the output is returned in list form).</li>
<li><tt class="docutils literal"><span class="pre">only_accepted</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a boolean. If set,
then the first argument in the output is guaranteed to be
<tt class="docutils literal"><span class="pre">True</span></tt> (if the output is a list, then the first argument
of each element will be <tt class="docutils literal"><span class="pre">True</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">always_include_output</span></tt> &#8211; if set (not by default), always
include the output. This is inconsequential for a
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>, but can be used in derived
classes where the output is suppressed by default,
cf. <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">format_output</span></tt> &#8211; a function that translates the written
output (which is in form of a list) to something more
readable. By default (<tt class="docutils literal"><span class="pre">None</span></tt>) identity is used here.</li>
<li><tt class="docutils literal"><span class="pre">check_epsilon_transitions</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) a
boolean. If <tt class="docutils literal"><span class="pre">False</span></tt>, then epsilon transitions are not
taken into consideration during process.</li>
<li><tt class="docutils literal"><span class="pre">write_final_word_out</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) a boolean
specifying whether the final output words should be written
or not.</li>
<li><tt class="docutils literal"><span class="pre">use_multitape_input</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a
boolean. If <tt class="docutils literal"><span class="pre">True</span></tt>, then the multi-tape mode of the
process iterator is activated. See also the notes below for
multi-tape machines.</li>
<li><tt class="docutils literal"><span class="pre">process_all_prefixes_of_input</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a
boolean. If <tt class="docutils literal"><span class="pre">True</span></tt>, then each prefix of the input word is
processed (instead of processing the whole input word at
once). Consequently, there is an output generated for each
of these prefixes.</li>
<li><tt class="docutils literal"><span class="pre">process_iterator_class</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a class
inherited from <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a>. If <tt class="docutils literal"><span class="pre">None</span></tt>,
then <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a> is taken. An instance of this
class is created and is used during the processing.</li>
<li><tt class="docutils literal"><span class="pre">automatic_output_type</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a boolean.
If set and the input has a parent, then the
output will have the same parent. If the input does not have
a parent, then the output will be of the same type as the
input.</li>
</ul>
<p>OUTPUT:</p>
<p>A triple (or a list of triples,
cf. parameter <tt class="docutils literal"><span class="pre">list_of_outputs</span></tt>), where</p>
<ul class="simple">
<li>the first entry is <tt class="docutils literal"><span class="pre">True</span></tt> if the input string is accepted,</li>
<li>the second gives the reached state after processing the
input tape (This is a state with label <tt class="docutils literal"><span class="pre">None</span></tt> if the input
could not be processed, i.e., if at one point no
transition to go on could be found.), and</li>
<li>the third gives a list of the output labels written during
processing (in the case the finite state machine runs as
transducer).</li>
</ul>
<p>Note that in the case the finite state machine is not
deterministic, all possible paths are taken into account.</p>
<p>This function uses an iterator which, in its simplest form, goes
from one state to another in each step. To decide which way to
go, it uses the input words of the outgoing transitions and
compares them to the input tape. More precisely, in each step,
the iterator takes an outgoing transition of the current state,
whose input label equals the input letter of the tape. The
output label of the transition, if present, is written on the
output tape.</p>
<p>If the choice of the outgoing transition is not unique (i.e.,
we have a non-deterministic finite state machine), all
possibilites are followed. This is done by splitting the
process into several branches, one for each of the possible
outgoing transitions.</p>
<p>The process (iteration) stops if all branches are finished,
i.e., for no branch, there is any transition whose input word
coincides with the processed input tape. This can simply
happen when the entire tape was read.</p>
<p>Also see <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a> for a version of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">process()</span></tt></a> with shortened output.</p>
<p>Internally this function creates and works with an instance of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a>. This iterator can also be obtained
with <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><tt class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></tt></a>.</p>
<p>If working with multi-tape finite state machines, all input
words of transitions are words of <span class="math">\(k\)</span>-tuples of letters.
Moreover, the input tape has to consist of <span class="math">\(k\)</span> tracks, i.e.,
be a list or tuple of <span class="math">\(k\)</span> iterators, one for each track.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Working with multi-tape finite state machines is still
experimental and can lead to wrong outputs.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">binary_inverter</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">({</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:                                      initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">binary_inverter</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(True, &#39;A&#39;, [1, 0, 1, 1, 0, 0])</span>
</pre></div>
</div>
<p>Alternatively, we can invoke this function by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">binary_inverter</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(True, &#39;A&#39;, [1, 0, 1, 1, 0, 0])</span>
</pre></div>
</div>
<p>Below we construct a finite state machine which tests if an input
is a non-adjacent form, i.e., no two neighboring letters are
both nonzero (see also the example on
<a class="reference internal" href="#finite-state-machine-recognizing-nafs-example"><em>non-adjacent forms</em></a>
in the documentation of the module
<a class="reference internal" href=""><em>Finite State Machines, Automata, Transducers</em></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span>
<span class="go">....:     {&#39;_&#39;: [(&#39;_&#39;, 0), (1, 1)], 1: [(&#39;_&#39;, 0)]},</span>
<span class="go">....:     initial_states=[&#39;_&#39;], final_states=[&#39;_&#39;, 1])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">NAF</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">w</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                           [0, 1, 1, 1, 0], [1, 0, 0, 1, 1]]]</span>
<span class="go">[True, True, False, True, False, False]</span>
</pre></div>
</div>
<p>Working only with the first component (i.e., returning whether
accepted or not) usually corresponds to using the more
specialized class <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton" title="sage.combinat.finite_state_machine.Automaton"><tt class="xref py py-class docutils literal"><span class="pre">Automaton</span></tt></a>.</p>
<p>Non-deterministic finite state machines can be handeled as well.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:     initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[(False, 1, [0]), (False, 2, [0])]</span>
</pre></div>
</div>
<p>Here is another non-deterministic finite state machine. Note
that we use <tt class="docutils literal"><span class="pre">format_output</span></tt> (see
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a>) to convert the written outputs
(all characters) to strings.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                 (0, 1, 1, &#39;c&#39;), (1, 0, [], &#39;d&#39;),</span>
<span class="go">....:                 (1, 1, 1, &#39;e&#39;)],</span>
<span class="go">....:                initial_states=[0], final_states=[0, 1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
<span class="go">(False, None, None)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
<span class="go">[(True, 0, &#39;ad&#39;), (True, 1, &#39;a&#39;)]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
<span class="go">[(True, 0, &#39;cd&#39;), (True, 1, &#39;c&#39;)]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
<span class="go">[(True, 0, &#39;cdcd&#39;), (True, 0, &#39;ced&#39;),</span>
<span class="go"> (True, 1, &#39;cdc&#39;), (True, 1, &#39;ce&#39;)]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
<span class="go">[(True, 0, &#39;adcd&#39;), (True, 0, &#39;aed&#39;),</span>
<span class="go"> (True, 1, &#39;adc&#39;), (True, 1, &#39;ae&#39;), (False, 2, &#39;b&#39;)]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">o</span><span class="p">),</span>
<span class="go">....:           only_accepted=True)</span>
<span class="go">[(True, 0, &#39;adcd&#39;), (True, 0, &#39;aed&#39;),</span>
<span class="go"> (True, 1, &#39;adc&#39;), (True, 1, &#39;ae&#39;)]</span>
</pre></div>
</div>
<p>A simple example of a multi-tape finite state machine is the
following: It writes the length of the first tape many letters
<tt class="docutils literal"><span class="pre">a</span></tt> and then the length of the second tape many letters
<tt class="docutils literal"><span class="pre">b</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="s">&#39;a&#39;</span><span class="p">),</span>
<span class="go">....:                         (0, 1, [], []),</span>
<span class="go">....:                         (1, 1, (None, 1), &#39;b&#39;)],</span>
<span class="go">....:                        initial_states=[0],</span>
<span class="go">....:                        final_states=[1])</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">process</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">use_multitape_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(True, 1, [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><tt class="xref py py-meth docutils literal"><span class="pre">Transducer.process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><tt class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a>.</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                 (0, 1, 1, 2), (1, 0, [], 1), (1, 1, 1, 3)],</span>
<span class="go">....:     initial_states=[0], final_states=[0, 1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">(False, None, None)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[(True, 0, [0, 1]), (True, 1, [0])]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[(True, 0, [2, 1]), (True, 1, [2])]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[(True, 0, [2, 1, 2, 1]), (True, 0, [2, 3, 1]),</span>
<span class="go"> (True, 1, [2, 1, 2]), (True, 1, [2, 3])]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                        initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No accepting output was found but according to the</span>
<span class="go">given options, an accepting output should be returned. Change</span>
<span class="go">only_accepted and/or list_of_outputs options.</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">(False, 0, [0])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">(False, 0, [0])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[(False, 0, [0])]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No accepting output was found but according to the</span>
<span class="go">given options, an accepting output should be returned. Change</span>
<span class="go">only_accepted and/or list_of_outputs options.</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">(False, None, None)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">(False, None, None)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">)],</span>
<span class="go">....:                        initial_states=[0],</span>
<span class="go">....:                        final_states=[1])</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0],</span>
<span class="go">....:               final_states=[1])</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">(True, 1, [&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">(True, 1)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">(True, 1, [&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(False, 2, [&#39;b&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(False, 2)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(False, 2, [&#39;b&#39;])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">(False, None, None)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">(False, None)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">(False, None, None)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.product_FiniteStateMachine">
<tt class="descname">product_FiniteStateMachine</tt><big>(</big><em>other</em>, <em>function</em>, <em>new_input_alphabet=None</em>, <em>only_accessible_components=True</em>, <em>final_function=None</em>, <em>new_class=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.product_FiniteStateMachine" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new finite state machine whose states are
<span class="math">\(d\)</span>-tuples of states of the original finite state machines.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; a finite state machine (for <span class="math">\(d=2\)</span>) or a list
(or iterable) of <span class="math">\(d-1\)</span> finite state machines.</li>
<li><tt class="docutils literal"><span class="pre">function</span></tt> has to accept <span class="math">\(d\)</span> transitions from <span class="math">\(A_j\)</span> to <span class="math">\(B_j\)</span>
for <span class="math">\(j\in\{1, \ldots, d\}\)</span> and returns a pair <tt class="docutils literal"><span class="pre">(word_in,</span> <span class="pre">word_out)</span></tt>
which is the label of the transition <span class="math">\(A=(A_1, \ldots, A_d)\)</span> to <span class="math">\(B=(B_1,
\ldots, B_d)\)</span>. If there is no transition from <span class="math">\(A\)</span> to <span class="math">\(B\)</span>,
then <tt class="docutils literal"><span class="pre">function</span></tt> should raise a <tt class="docutils literal"><span class="pre">LookupError</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">new_input_alphabet</span></tt> (optional) &#8211; the new input alphabet
as a list.</li>
<li><tt class="docutils literal"><span class="pre">only_accessible_components</span></tt> &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt> (default), then
the result is piped through <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components"><tt class="xref py py-meth docutils literal"><span class="pre">accessible_components()</span></tt></a>. If no
<tt class="docutils literal"><span class="pre">new_input_alphabet</span></tt> is given, it is determined by
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">final_function</span></tt> &#8211; A function mapping <span class="math">\(d\)</span> final states of
the original finite state machines to the final output of
the corresponding state in the new finite state machine. By
default, the final output is the empty word if both final
outputs of the constituent states are empty; otherwise, a
<tt class="docutils literal"><span class="pre">ValueError</span></tt> is raised.</li>
<li><tt class="docutils literal"><span class="pre">new_class</span></tt> &#8211; Class of the new finite state machine. By
default (<tt class="docutils literal"><span class="pre">None</span></tt>), the class of <tt class="docutils literal"><span class="pre">self</span></tt> is used.</li>
</ul>
<p>OUTPUT:</p>
<p>A finite state machine whose states are <span class="math">\(d\)</span>-tuples of states of the
original finite state machines. A state is initial or
final if all constituent states are initial or final,
respectively.</p>
<p>The labels of the transitions are defined by <tt class="docutils literal"><span class="pre">function</span></tt>.</p>
<p>The final output of a final state is determined by calling
<tt class="docutils literal"><span class="pre">final_function</span></tt> on the constituent states.</p>
<p>The color of a new state is the tuple of colors of the
constituent states of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt>. However,
if all constituent states have color <tt class="docutils literal"><span class="pre">None</span></tt>, then
the state has color <tt class="docutils literal"><span class="pre">None</span></tt>, too.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
<span class="go">....:               initial_states=[&#39;A&#39;], final_states=[&#39;B&#39;],</span>
<span class="go">....:               determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">final_states</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">addition</span><span class="p">(</span><span class="n">transition1</span><span class="p">,</span> <span class="n">transition2</span><span class="p">):</span>
<span class="go">....:     return (transition1.word_in[0] + transition2.word_in[0],</span>
<span class="go">....:             None)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">addition</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">only_accessible_components</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;A&#39;, 1) to (&#39;B&#39;, 1): 2|-,</span>
<span class="go"> Transition from (&#39;A&#39;, 1) to (&#39;A&#39;, 1): 1|-,</span>
<span class="go"> Transition from (&#39;B&#39;, 1) to (&#39;A&#39;, 1): 3|-]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">color</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">H</span><span class="o">.</span><span class="n">iter_states</span><span class="p">()]</span>
<span class="go">[None, None]</span>
<span class="gp">sage: </span><span class="n">H1</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">addition</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">only_accessible_components</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H1</span><span class="o">.</span><span class="n">states</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">F</span><span class="o">.</span><span class="n">states</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">H1</span><span class="o">.</span><span class="n">states</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">G</span><span class="o">.</span><span class="n">states</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0] )</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0] )</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span>
<span class="go">....:         G, lambda t1,t2: (t1.word_in[0]*t2.word_in[0], None))</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[(0, 0), (1, 0)]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0] )</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0] )</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
<span class="go">....:                                  lambda t1,t2: (t1.word_in[0]*t2.word_in[0], None),</span>
<span class="go">....:                                  only_accessible_components=False)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[(0, 0), (1, 0), (0, 1), (1, 1)]</span>
</pre></div>
</div>
<p>Also final output words are considered according to the function
<tt class="docutils literal"><span class="pre">final_function</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">final_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">minus</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">):</span>
<span class="go">....:     return (t1.word_in[0] - t2.word_in[0],</span>
<span class="go">....:                t1.word_out[0] - t2.word_out[0])</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">minus</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">A final function must be given.</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">plus</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
<span class="go">....:     return s1.final_word_out[0] + s2.final_word_out[0]</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">minus</span><span class="p">,</span>
<span class="go">....:                                  final_function=plus)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[(1, 0)]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">final_states</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[2]</span>
</pre></div>
</div>
<p>Products of more than two finite state machines are also possible:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">plus</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span><span class="p">):</span>
<span class="go">....:     if s1.word_in == s2.word_in == s3.word_in:</span>
<span class="go">....:          return (s1.word_in,</span>
<span class="go">....:                  sum(s.word_out[0] for s in (s1, s2, s3)))</span>
<span class="go">....:     else:</span>
<span class="go">....:         raise LookupError</span>
<span class="gp">sage: </span><span class="n">T0</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T1</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T2</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">T0</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">([</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">],</span> <span class="n">plus</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from ((), (), ()) to ((0,), (), ()): 0|0,</span>
<span class="go"> Transition from ((), (), ()) to ((), (1,), ()): 1|0,</span>
<span class="go"> Transition from ((), (), ()) to ((), (), (2,)): 2|0,</span>
<span class="go"> Transition from ((0,), (), ()) to ((0,), (), ()): 0|1,</span>
<span class="go"> Transition from ((0,), (), ()) to ((), (1,), ()): 1|0,</span>
<span class="go"> Transition from ((0,), (), ()) to ((), (), (2,)): 2|0,</span>
<span class="go"> Transition from ((), (1,), ()) to ((0,), (), ()): 0|0,</span>
<span class="go"> Transition from ((), (1,), ()) to ((), (1,), ()): 1|1,</span>
<span class="go"> Transition from ((), (1,), ()) to ((), (), (2,)): 2|0,</span>
<span class="go"> Transition from ((), (), (2,)) to ((0,), (), ()): 0|0,</span>
<span class="go"> Transition from ((), (), (2,)) to ((), (1,), ()): 1|0,</span>
<span class="go"> Transition from ((), (), (2,)) to ((), (), (2,)): 2|1]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">[0, 1, 0, 1, 0, 1, 0, 0, 0, 1]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">other</span></tt> can also be an iterable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">==</span> <span class="n">T0</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="nb">iter</span><span class="p">([</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">]),</span> <span class="n">plus</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Check that colors are correctly dealt with. In particular, the
new colors have to be hashable such that
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.determinisation" title="sage.combinat.finite_state_machine.Automaton.determinisation"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.determinisation()</span></tt></a> does not fail:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="n">A</span><span class="p">,</span>
<span class="go">....:                                  lambda t1, t2: (0, None))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">states</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">color</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span>
<span class="go">Automaton with 1 state</span>
</pre></div>
</div>
<p>Check handling of the parameter <tt class="docutils literal"><span class="pre">other</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">plus</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">other must be a finite state machine or a list</span>
<span class="go">of finite state machines.</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">([</span><span class="bp">None</span><span class="p">],</span> <span class="n">plus</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">other must be a finite state machine or a list</span>
<span class="go">of finite state machines.</span>
</pre></div>
</div>
<p>Test whether <tt class="docutils literal"><span class="pre">new_class</span></tt> works:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
<span class="go">&lt;class &#39;sage.combinat.finite_state_machine.Transducer&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span>
<span class="go">....:      new_class=Automaton))</span>
<span class="go">&lt;class &#39;sage.combinat.finite_state_machine.Automaton&#39;&gt;</span>
</pre></div>
</div>
<p>Check that isolated vertices are kept (<a class="reference external" href="http://trac.sagemath.org/16762">trac ticket #16762</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[(0, &#39;A&#39;)]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span>
<span class="go">....:     G, None, only_accessible_components=False).states()</span>
<span class="go">[(0, &#39;A&#39;), (1, &#39;A&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.projection">
<tt class="descname">projection</tt><big>(</big><em>what='input'</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an Automaton which transition labels are the projection
of the transition labels of the input.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">what</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">input</span></tt>) either <tt class="docutils literal"><span class="pre">input</span></tt> or <tt class="docutils literal"><span class="pre">output</span></tt>.</li>
</ul>
<p>OUTPUT:</p>
<p>An automaton.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                         (&#39;B&#39;, &#39;B&#39;, 1, 0)])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">projection</span><span class="p">(</span><span class="n">what</span><span class="o">=</span><span class="s">&#39;output&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;B&#39;: 1|-,</span>
<span class="go"> Transition from &#39;A&#39; to &#39;A&#39;: 1|-,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;B&#39;: 0|-]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.quotient">
<tt class="descname">quotient</tt><big>(</big><em>classes</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.quotient" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the quotient with respect to the equivalence
classes.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">classes</span></tt> is a list of equivalence classes of states.</li>
</ul>
<p>OUTPUT:</p>
<p>A finite state machine.</p>
<p>The labels of the new states are tuples of states of the
<tt class="docutils literal"><span class="pre">self</span></tt>, corresponding to <tt class="docutils literal"><span class="pre">classes</span></tt>.</p>
<p>Assume that <span class="math">\(c\)</span> is a class, and <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are states in
<span class="math">\(c\)</span>. Then there is a bijection <span class="math">\(\varphi\)</span> between the
transitions from <span class="math">\(a\)</span> and the transitions from <span class="math">\(b\)</span> with the
following properties: if <span class="math">\(\varphi(t_a)=t_b\)</span>, then</p>
<ul class="simple">
<li><span class="math">\(t_a.\mathit{word}_\mathit{in}=t_b.\mathit{word}_\mathit{in}\)</span>,</li>
<li><span class="math">\(t_a.\mathit{word}_\mathit{out}=t_b.\mathit{word}_\mathit{out}\)</span>, and</li>
<li><span class="math">\(t_a\)</span> and <span class="math">\(t_b\)</span> lead to some equivalent states <span class="math">\(a'\)</span> and <span class="math">\(b'\)</span>.</li>
</ul>
<p>Non-initial states may be merged with initial states, the
resulting state is an initial state.</p>
<p>All states in a class must have the same <tt class="docutils literal"><span class="pre">is_final</span></tt>,
<tt class="docutils literal"><span class="pre">final_word_out</span></tt> and <tt class="docutils literal"><span class="pre">word_out</span></tt> values.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">fsm</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (&quot;B&quot;, &quot;C&quot;, 0, 0), (&quot;B&quot;, &quot;C&quot;, 1, 1),</span>
<span class="go">....:                           (&quot;C&quot;, &quot;D&quot;, 0, 1), (&quot;C&quot;, &quot;D&quot;, 1, 0),</span>
<span class="go">....:                           (&quot;D&quot;, &quot;A&quot;, 0, 0), (&quot;D&quot;, &quot;A&quot;, 1, 1)])</span>
<span class="gp">sage: </span><span class="n">fsmq</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">quotient</span><span class="p">([[</span><span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">),</span> <span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">)],</span>
<span class="go">....:                      [fsm.state(&quot;B&quot;), fsm.state(&quot;D&quot;)]])</span>
<span class="gp">sage: </span><span class="n">fsmq</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;A&#39;, &#39;C&#39;)</span>
<span class="go">              to (&#39;B&#39;, &#39;D&#39;): 0|1,</span>
<span class="go"> Transition from (&#39;A&#39;, &#39;C&#39;)</span>
<span class="go">              to (&#39;B&#39;, &#39;D&#39;): 1|0,</span>
<span class="go"> Transition from (&#39;B&#39;, &#39;D&#39;)</span>
<span class="go">              to (&#39;A&#39;, &#39;C&#39;): 0|0,</span>
<span class="go"> Transition from (&#39;B&#39;, &#39;D&#39;)</span>
<span class="go">              to (&#39;A&#39;, &#39;C&#39;): 1|1]</span>
<span class="gp">sage: </span><span class="n">fsmq</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|1,</span>
<span class="go"> Transition from 0 to 1: 1|0,</span>
<span class="go"> Transition from 1 to 0: 0|0,</span>
<span class="go"> Transition from 1 to 0: 1|1]</span>
<span class="gp">sage: </span><span class="n">fsmq1</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">quotient</span><span class="p">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">equivalence_classes</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">fsmq1</span> <span class="o">==</span> <span class="n">fsmq</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">quotient</span><span class="p">([[</span><span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">),</span> <span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">),</span> <span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">),</span> <span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&quot;D&quot;</span><span class="p">)]])</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AssertionError</span>: <span class="n">Transitions of state &#39;A&#39; and &#39;B&#39; are incompatible.</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">fsm</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (&quot;B&quot;, &quot;C&quot;, 0, 0), (&quot;B&quot;, &quot;C&quot;, 1, 1),</span>
<span class="go">....:                           (&quot;C&quot;, &quot;D&quot;, 0, 1), (&quot;C&quot;, &quot;D&quot;, 1, 0),</span>
<span class="go">....:                           (&quot;D&quot;, &quot;A&quot;, 0, 0), (&quot;D&quot;, &quot;A&quot;, 1, 1)],</span>
<span class="go">....:                           final_states=[&quot;A&quot;, &quot;C&quot;])</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">fsmq</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">quotient</span><span class="p">([[</span><span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">),</span> <span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">)],</span>
<span class="go">....:                      [fsm.state(&quot;B&quot;), fsm.state(&quot;D&quot;)]])</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AssertionError</span>: <span class="n">Class [&#39;A&#39;, &#39;C&#39;] mixes</span>
<span class="go">final states with different final output words.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.relabeled">
<tt class="descname">relabeled</tt><big>(</big><em>memo=None</em>, <em>labels=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.relabeled" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deep copy of the finite state machine, but the
states are relabeled.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">memo</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a dictionary storing already
processed elements.</li>
<li><tt class="docutils literal"><span class="pre">labels</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a dictionary or callable
mapping old labels to new labels. If <tt class="docutils literal"><span class="pre">None</span></tt>, then the new
labels are integers starting with 0.</li>
</ul>
<p>OUTPUT:</p>
<p>A new finite state machine.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FSM1</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">FSM1</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span>
<span class="gp">sage: </span><span class="n">FSM2</span> <span class="o">=</span> <span class="n">FSM1</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM2</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">sage: </span><span class="n">FSM3</span> <span class="o">=</span> <span class="n">FSM1</span><span class="o">.</span><span class="n">relabeled</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">:</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="s">&#39;c&#39;</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">FSM3</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">sage: </span><span class="n">FSM4</span> <span class="o">=</span> <span class="n">FSM2</span><span class="o">.</span><span class="n">relabeled</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">FSM4</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[0, 2, 4]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FSM2</span><span class="o">.</span><span class="n">relabeled</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">labels must be None, a callable or a dictionary.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.remove_epsilon_transitions">
<tt class="descname">remove_epsilon_transitions</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.remove_epsilon_transitions" title="Permalink to this definition">¶</a></dt>
<dd><p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">()</span><span class="o">.</span><span class="n">remove_epsilon_transitions</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.set_coordinates">
<tt class="descname">set_coordinates</tt><big>(</big><em>coordinates</em>, <em>default=True</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.set_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Set coordinates of the states for the LaTeX representation by
a dictionary or a function mapping labels to coordinates.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">coordinates</span></tt> &#8211; a dictionary or a function mapping labels
of states to pairs interpreted as coordinates.</li>
<li><tt class="docutils literal"><span class="pre">default</span></tt> &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt>, then states not given by
<tt class="docutils literal"><span class="pre">coordinates</span></tt> get a default position on a circle of
radius 3.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">set_coordinates</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coordinates</span>
<span class="go">(0, 0)</span>
</pre></div>
</div>
<p>We can also use a function to determine the coordinates:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">set_coordinates</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coordinates</span>
<span class="go">(2, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.split_transitions">
<tt class="descname">split_transitions</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.split_transitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new transducer, where all transitions in self with input
labels consisting of more than one letter
are replaced by a path of the corresponding length.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A new transducer.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;], final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">split_transitions</span><span class="p">()</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[(&#39;A&#39;, ()), (&#39;B&#39;, ()),</span>
<span class="go"> (&#39;A&#39;, (1,)), (&#39;A&#39;, (1, 2))]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.state">
<tt class="descname">state</tt><big>(</big><em>state</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the state of the finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">state</span></tt> &#8211; If <tt class="docutils literal"><span class="pre">state</span></tt> is not an instance of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><tt class="xref py py-class docutils literal"><span class="pre">FSMState</span></tt></a>, then it is assumed that it is the label
of a state.</li>
</ul>
<p>OUTPUT:</p>
<p>Returns the state of the finite state machine corresponding to
<tt class="docutils literal"><span class="pre">state</span></tt>.</p>
<p>If no state is found, then a <tt class="docutils literal"><span class="pre">LookupError</span></tt> is thrown.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="n">A</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">A</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">A</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;xyz&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">LookupError</span>: <span class="n">No state with label xyz found.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.states">
<tt class="descname">states</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the states of the finite state machine.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>The states of the finite state machine as list.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.transition">
<tt class="descname">transition</tt><big>(</big><em>transition</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the transition of the finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">transition</span></tt> &#8211; If <tt class="docutils literal"><span class="pre">transition</span></tt> is not an instance of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><tt class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></tt></a>, then it is assumed that it is a
tuple <tt class="docutils literal"><span class="pre">(from_state,</span> <span class="pre">to_state,</span> <span class="pre">word_in,</span> <span class="pre">word_out)</span></tt>.</li>
</ul>
<p>OUTPUT:</p>
<p>Returns the transition of the finite state machine
corresponding to <tt class="docutils literal"><span class="pre">transition</span></tt>.</p>
<p>If no transition is found, then a <tt class="docutils literal"><span class="pre">LookupError</span></tt> is thrown.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([</span><span class="n">t</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transition</span><span class="p">((</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|-</span>
<span class="gp">sage: </span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">transition</span><span class="p">((</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.transitions">
<tt class="descname">transitions</tt><big>(</big><em>from_state=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.transitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all transitions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">from_state</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) If <tt class="docutils literal"><span class="pre">from_state</span></tt> is
given, then a list of transitions starting there is given.</li>
</ul>
<p>OUTPUT:</p>
<p>A list of all transitions.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;1&#39; to &#39;2&#39;: 1|-,</span>
<span class="go"> Transition from &#39;2&#39; to &#39;2&#39;: 0|-]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.transposition">
<tt class="descname">transposition</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.transposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new finite state machine, where all transitions of the
input finite state machine are reversed.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A new finite state machine.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">aut</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                 initial_states=[&#39;A&#39;], final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">aut</span><span class="o">.</span><span class="n">transposition</span><span class="p">()</span><span class="o">.</span><span class="n">transitions</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span>
<span class="go">[Transition from &#39;B&#39; to &#39;A&#39;: 0|-]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">aut</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                 initial_states=[&#39;1&#39;], final_states=[&#39;1&#39;, &#39;2&#39;])</span>
<span class="gp">sage: </span><span class="n">aut</span><span class="o">.</span><span class="n">transposition</span><span class="p">()</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>If a final state of <tt class="docutils literal"><span class="pre">self</span></tt> has a non-empty final output word,
transposition is not implemented:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;2&#39;, &#39;2&#39;, 0, 2)],</span>
<span class="go">....:                 initial_states=[&#39;1&#39;],</span>
<span class="go">....:                 final_states=[&#39;1&#39;, &#39;2&#39;])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">transposition</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">Transposition for transducers with</span>
<span class="go">final output words is not implemented.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out">
<tt class="descname">with_final_word_out</tt><big>(</big><em>letters</em>, <em>allow_non_final=True</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a new finite state machine with final output words
for all states by implicitly reading trailing letters until a
final state is reached.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">letters</span></tt> &#8211; either an element of the input alphabet or a
list of such elements. This is repeated cyclically when
needed.</li>
<li><tt class="docutils literal"><span class="pre">allow_non_final</span></tt> &#8211; a boolean (default: <tt class="docutils literal"><span class="pre">True</span></tt>) which
indicates whether we allow that some states may be non-final
in the resulting finite state machine. I.e., if <tt class="docutils literal"><span class="pre">False</span></tt> then
each state has to have a path to a final state with input
label matching <tt class="docutils literal"><span class="pre">letters</span></tt>.</li>
</ul>
<p>OUTPUT:</p>
<p>A finite state machine.</p>
<p>The inplace version of this function is
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out"><tt class="xref py py-meth docutils literal"><span class="pre">construct_final_word_out()</span></tt></a>.</p>
<p>Suppose for the moment a single element <tt class="docutils literal"><span class="pre">letter</span></tt> as input
for <tt class="docutils literal"><span class="pre">letters</span></tt>. This is equivalent to <tt class="docutils literal"><span class="pre">letters</span> <span class="pre">=</span> <span class="pre">[letter]</span></tt>.
We will discuss the general case below.</p>
<p>Let <tt class="docutils literal"><span class="pre">word_in</span></tt> be a word over the input alphabet and assume
that the original finite state machine transforms <tt class="docutils literal"><span class="pre">word_in</span></tt> to
<tt class="docutils literal"><span class="pre">word_out</span></tt> reaching a possibly non-final state <tt class="docutils literal"><span class="pre">s</span></tt>. Let
further <span class="math">\(k\)</span> be the minimum number of letters <tt class="docutils literal"><span class="pre">letter</span></tt> such
that there is a path from <tt class="docutils literal"><span class="pre">s</span></tt> to some final state <tt class="docutils literal"><span class="pre">f</span></tt> whose
input label consists of <span class="math">\(k\)</span> copies of <tt class="docutils literal"><span class="pre">letter</span></tt> and whose
output label is <tt class="docutils literal"><span class="pre">path_word_out</span></tt>. Then the state <tt class="docutils literal"><span class="pre">s</span></tt> of the
resulting finite state machine is a final state with final
output <tt class="docutils literal"><span class="pre">path_word_out</span> <span class="pre">+</span> <span class="pre">f.final_word_out</span></tt>. Therefore, the new
finite state machine transforms <tt class="docutils literal"><span class="pre">word_in</span></tt> to <tt class="docutils literal"><span class="pre">word_out</span> <span class="pre">+</span>
<span class="pre">path_word_out</span> <span class="pre">+</span> <span class="pre">f.final_word_out</span></tt>.</p>
<p>This is e.g. useful for finite state machines operating on digit
expansions: there, it is sometimes required to read a sufficient
number of trailing zeros (at the most significant positions) in
order to reach a final state and to flush all carries. In this
case, this method constructs an essentially equivalent finite
state machine in the sense that it not longer requires adding
sufficiently many trailing zeros. However, it is the
responsibility of the user to make sure that if adding trailing
zeros to the input anyway, the output is equivalent.</p>
<p>If <tt class="docutils literal"><span class="pre">letters</span></tt> consists of more than one letter, then it is
assumed that (not necessarily complete) cycles of <tt class="docutils literal"><span class="pre">letters</span></tt>
are appended as trailing input.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#finite-state-machine-gray-code-example"><em>example on Gray code</em></a></p>
</div>
<p>EXAMPLES:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">A simple transducer transforming <span class="math">\(00\)</span> blocks to <span class="math">\(01\)</span>
blocks:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">(False, 1, [0, 1, 0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">(True, 0, [0, 1, 0, 1])</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">iter_final_states</span><span class="p">():</span>
<span class="go">....:     print f, f.final_word_out</span>
<span class="go">0 []</span>
<span class="go">1 [1]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">(True, 1, [0, 1, 0, 1])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">(True, 0, [0, 1, 0, 1])</span>
</pre></div>
</div>
</li>
<li><p class="first">A more realistic example: Addition of <span class="math">\(1\)</span> in binary. We
construct a transition function transforming the input
to its binary expansion:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">binary_transition</span><span class="p">(</span><span class="n">carry</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
<span class="go">....:     value = carry + input</span>
<span class="go">....:     if value.mod(2) == 0:</span>
<span class="go">....:         return (value/2, 0)</span>
<span class="go">....:     else:</span>
<span class="go">....:         return ((value-1)/2, 1)</span>
</pre></div>
</div>
<p>Now, we only have to start with a carry of <span class="math">\(1\)</span> to
get the required transducer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span><span class="n">binary_transition</span><span class="p">,</span>
<span class="go">....:                input_alphabet=[0, 1],</span>
<span class="go">....:                initial_states=[1],</span>
<span class="go">....:                final_states=[0])</span>
</pre></div>
</div>
<p>We test this for the binary expansion of <span class="math">\(7\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(False, 1, [0, 0, 0])</span>
</pre></div>
</div>
<p>The final carry <span class="math">\(1\)</span> has not be flushed yet, we have to add a
trailing zero:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">(True, 0, [0, 0, 0, 1])</span>
</pre></div>
</div>
<p>We check that with this trailing zero, the transducer
performs as advertised:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">ZZ</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">bits</span><span class="p">()</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">....:     for k in srange(16))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>However, most of the time, we produce superfluous trailing
zeros:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span><span class="p">(</span><span class="mf">11.</span><span class="n">bits</span><span class="p">()</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[0, 0, 1, 1, 0]</span>
</pre></div>
</div>
<p>We now use this method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">iter_final_states</span><span class="p">():</span>
<span class="go">....:     print f, f.final_word_out</span>
<span class="go">1 [1]</span>
<span class="go">0 []</span>
</pre></div>
</div>
<p>The same tests as above, but we do not have to pad with
trailing zeros anymore:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(True, 1, [0, 0, 0, 1])</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">ZZ</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">bits</span><span class="p">()),</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">....:     for k in srange(16))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>No more trailing zero in the output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span><span class="p">(</span><span class="mf">11.</span><span class="n">bits</span><span class="p">())</span>
<span class="go">[0, 0, 1, 1]</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">bits</span><span class="p">())[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">....:     for k in srange(16))</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p class="first">Here is an example, where we allow trailing repeated <span class="math">\(10\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span>
<span class="go">....:                 (1, 2, 1, &#39;b&#39;),</span>
<span class="go">....:                 (2, 0, 0, &#39;c&#39;)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0])</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">iter_final_states</span><span class="p">():</span>
<span class="go">....:     print f, &#39;&#39;.join(f.final_word_out)</span>
<span class="go">0</span>
<span class="go">1 bc</span>
</pre></div>
</div>
<p>Trying this with trailing repeated <span class="math">\(01\)</span> does not produce
a <tt class="docutils literal"><span class="pre">final_word_out</span></tt> for state <tt class="docutils literal"><span class="pre">1</span></tt>, but for state <tt class="docutils literal"><span class="pre">2</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">iter_final_states</span><span class="p">():</span>
<span class="go">....:     print f, &#39;&#39;.join(f.final_word_out)</span>
<span class="go">0</span>
<span class="go">2 c</span>
</pre></div>
</div>
</li>
<li><p class="first">Here another example with a more-letter trailing input:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span>
<span class="go">....:                 (1, 2, 0, &#39;b&#39;), (1, 2, 1, &#39;b&#39;),</span>
<span class="go">....:                 (2, 3, 0, &#39;c&#39;), (2, 0, 1, &#39;e&#39;),</span>
<span class="go">....:                 (3, 1, 0, &#39;d&#39;), (3, 1, 1, &#39;d&#39;)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0],</span>
<span class="go">....:                with_final_word_out=[0, 0, 1, 1])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">iter_final_states</span><span class="p">():</span>
<span class="go">....:     print f, &#39;&#39;.join(f.final_word_out)</span>
<span class="go">0</span>
<span class="go">1 bcdbcdbe</span>
<span class="go">2 cdbe</span>
<span class="go">3 dbe</span>
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
<p>TESTS:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Reading copies of <tt class="docutils literal"><span class="pre">letter</span></tt> may result in a cycle. In
this simple example, we have no final state at all:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The finite state machine contains</span>
<span class="go">a cycle starting at state 0 with input label 0</span>
<span class="go">and no final state.</span>
</pre></div>
</div>
</li>
<li><p class="first">A unique transition with input word <tt class="docutils literal"><span class="pre">letter</span></tt> is
required:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No unique transition leaving state 0</span>
<span class="go">with input label 0.</span>
</pre></div>
</div>
<p>It is not a problem if there is no transition starting
at state <tt class="docutils literal"><span class="pre">1</span></tt> with input word <tt class="docutils literal"><span class="pre">letter</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">iter_final_states</span><span class="p">():</span>
<span class="go">....:     print f, f.final_word_out</span>
</pre></div>
</div>
<p>Anyhow, you can override this by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_non_final</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No unique transition leaving state 1</span>
<span class="go">with input label 0.</span>
</pre></div>
</div>
</li>
<li><p class="first">All transitions must have input labels of length <span class="math">\(1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">All transitions must have input</span>
<span class="go">labels of length 1. Consider calling split_transitions().</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">All transitions must have input</span>
<span class="go">labels of length 1. Consider calling split_transitions().</span>
</pre></div>
</div>
</li>
<li><p class="first">An empty list as input is not allowed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">([])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">letters is not allowed to be an empty list.</span>
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.finite_state_machine.Transducer">
<em class="property">class </em><tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">Transducer</tt><big>(</big><em>data=None</em>, <em>initial_states=None</em>, <em>final_states=None</em>, <em>input_alphabet=None</em>, <em>output_alphabet=None</em>, <em>determine_alphabets=None</em>, <em>with_final_word_out=None</em>, <em>store_states_dict=True</em>, <em>on_duplicate_transition=None</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.Transducer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.finite_state_machine.FiniteStateMachine</span></tt></a></p>
<p>This creates a transducer, which is a finite state machine, whose
transitions have input and output labels.</p>
<p>An transducer has additional features like creating a simplified
transducer.</p>
<p>See class <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a> for more information.</p>
<p>EXAMPLES:</p>
<p>We can create a transducer performing the addition of 1 (for
numbers given in binary and read from right to left) in the
following way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="s">&#39;N&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;N&#39;, &#39;N&#39;, 0, 0), (&#39;N&#39;, &#39;N&#39;, 1, 1)],</span>
<span class="go">....:                initial_states=[&#39;C&#39;], final_states=[&#39;N&#39;])</span>
<span class="gp">sage: </span><span class="n">T</span>
<span class="go">Transducer with 2 states</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[0, 0, 1]</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="mf">15.</span><span class="n">digits</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">16</span>
</pre></div>
</div>
<p>Note that we have padded the binary input sequence by a <span class="math">\(0\)</span> so
that the transducer can reach its final state.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Transducer</span><span class="p">()</span>
<span class="go">Empty transducer</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.finite_state_machine.Transducer.cartesian_product">
<tt class="descname">cartesian_product</tt><big>(</big><em>other</em>, <em>only_accessible_components=True</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.Transducer.cartesian_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new transducer which can simultaneously process an
input with the machines <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt> where the
output labels are <span class="math">\(d\)</span>-tuples of the original output labels.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> - a finite state machine (if <span class="math">\(d=2\)</span>) or a list (or
other iterable) of <span class="math">\(d-1\)</span> finite state machines</li>
<li><tt class="docutils literal"><span class="pre">only_accessible_components</span></tt> &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt> (default), then
the result is piped through <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components"><tt class="xref py py-meth docutils literal"><span class="pre">accessible_components()</span></tt></a>. If no
<tt class="docutils literal"><span class="pre">new_input_alphabet</span></tt> is given, it is determined by
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>A transducer which can simultaneously process an input with <tt class="docutils literal"><span class="pre">self</span></tt>
and the machine(s) in <tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>The set of states of the new transducer is the cartesian product of
the set of states of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>Let <span class="math">\((A_j, B_j, a_j, b_j)\)</span> for <span class="math">\(j\in\{1, \ldots, d\}\)</span> be
transitions in the machines <tt class="docutils literal"><span class="pre">self</span></tt> and in <tt class="docutils literal"><span class="pre">other</span></tt>. Then
there is a transition <span class="math">\(((A_1, \ldots, A_d), (B_1, \ldots,
B_d), a, (b_1, \ldots, b_d))\)</span> in the new transducer if <span class="math">\(a_1 =
\cdots = a_d =: a\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">transducer1</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (&#39;A&#39;, &#39;A&#39;, 1, 1)],</span>
<span class="go">....:                          initial_states=[&#39;A&#39;],</span>
<span class="go">....:                          final_states=[&#39;A&#39;],</span>
<span class="go">....:                          determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">transducer2</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">]),</span>
<span class="go">....:                           (0, 0, 1, &#39;b&#39;),</span>
<span class="go">....:                           (1, 1, 0, &#39;a&#39;)],</span>
<span class="go">....:                          initial_states=[0],</span>
<span class="go">....:                          final_states=[1],</span>
<span class="go">....:                          determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">transducer1</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">transducer2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span>
<span class="go">Transducer with 2 states</span>
<span class="gp">sage: </span><span class="n">result</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;A&#39;, 0) to (&#39;A&#39;, 1): 0|(0, &#39;b&#39;),(None, &#39;c&#39;),</span>
<span class="go"> Transition from (&#39;A&#39;, 0) to (&#39;A&#39;, 0): 1|(1, &#39;b&#39;),</span>
<span class="go"> Transition from (&#39;A&#39;, 1) to (&#39;A&#39;, 1): 0|(0, &#39;a&#39;)]</span>
<span class="gp">sage: </span><span class="n">result</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[(1, &#39;b&#39;), (0, &#39;b&#39;), (None, &#39;c&#39;),  (0, &#39;a&#39;)]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">transducer1</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">transducer2</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="go">([1, 0, 0], [&#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;])</span>
</pre></div>
</div>
<p>Also final output words are correctly processed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">transducer1</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">transducer1</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">transducer2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span><span class="o">.</span><span class="n">final_states</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[(2, None)]</span>
</pre></div>
</div>
<p>The following transducer counts the number of 11 blocks minus
the number of 10 blocks over the alphabet <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">1]</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">count_11</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">(</span>
<span class="go">....:     [1, 1],</span>
<span class="go">....:     input_alphabet=[0, 1])</span>
<span class="gp">sage: </span><span class="n">count_10</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">(</span>
<span class="go">....:     [1, 0],</span>
<span class="go">....:     input_alphabet=[0, 1])</span>
<span class="gp">sage: </span><span class="n">count_11x10</span> <span class="o">=</span> <span class="n">count_11</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">count_10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">difference</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])(</span><span class="n">count_11x10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from 0 to 1: 0|-1,</span>
<span class="go"> Transition from 0 to 0: 1|1,</span>
<span class="go"> Transition from 1 to 1: 0|0,</span>
<span class="go"> Transition from 1 to 0: 1|0]</span>
<span class="gp">sage: </span><span class="nb">input</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="o">==</span> <span class="n">output</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If <tt class="docutils literal"><span class="pre">other</span></tt> is an automaton, then <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.cartesian_product" title="sage.combinat.finite_state_machine.Transducer.cartesian_product"><tt class="xref py py-meth docutils literal"><span class="pre">cartesian_product()</span></tt></a> returns
<tt class="docutils literal"><span class="pre">self</span></tt> where the input is restricted to the input accepted by
<tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>For example, if the transducer transforms the standard
binary expansion into the non-adjacent form and the automaton
recognizes the binary expansion without adjacent ones, then the
cartesian product of these two is a transducer which does not change
the input (except for changing <tt class="docutils literal"><span class="pre">a</span></tt> to <tt class="docutils literal"><span class="pre">(a,</span> <span class="pre">None)</span></tt> and ignoring a
leading <span class="math">\(0\)</span>).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
<span class="go">....:                   (0, 2, 1, None),</span>
<span class="go">....:                   (1, 1, 0, 0),</span>
<span class="go">....:                   (1, 2, 1, 0),</span>
<span class="go">....:                   (2, 1, 0, 1),</span>
<span class="go">....:                   (2, 3, 1, -1),</span>
<span class="go">....:                   (3, 2, 0, 0),</span>
<span class="go">....:                   (3, 3, 1, 0)],</span>
<span class="go">....:                  initial_states=[0],</span>
<span class="go">....:                  final_states=[1],</span>
<span class="go">....:                  determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">aut11</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                   initial_states=[0],</span>
<span class="go">....:                   final_states=[0, 1],</span>
<span class="go">....:                   determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">res</span> <span class="o">=</span> <span class="n">NAF</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">aut11</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">res</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[(1, None), (0, None), (0, None), (1, None), (0, None), (1, None)]</span>
</pre></div>
</div>
<p>This is obvious because if the standard binary expansion does not have
adjacent ones, then it is the same as the non-adjacent form.</p>
<p>Be aware that <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.cartesian_product" title="sage.combinat.finite_state_machine.Transducer.cartesian_product"><tt class="xref py py-meth docutils literal"><span class="pre">cartesian_product()</span></tt></a> is not commutative.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">aut11</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">NAF</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Only an automaton can be intersected with an automaton.</span>
</pre></div>
</div>
<p>The cartesian product of more than two finite state machines can also
be computed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T0</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T1</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T2</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">T0</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">([</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from ((), (), ()) to ((0,), (), ()): 0|(0, 0, 0),</span>
<span class="go"> Transition from ((), (), ()) to ((), (1,), ()): 1|(0, 0, 0),</span>
<span class="go"> Transition from ((), (), ()) to ((), (), (2,)): 2|(0, 0, 0),</span>
<span class="go"> Transition from ((0,), (), ()) to ((0,), (), ()): 0|(1, 0, 0),</span>
<span class="go"> Transition from ((0,), (), ()) to ((), (1,), ()): 1|(0, 0, 0),</span>
<span class="go"> Transition from ((0,), (), ()) to ((), (), (2,)): 2|(0, 0, 0),</span>
<span class="go"> Transition from ((), (1,), ()) to ((0,), (), ()): 0|(0, 0, 0),</span>
<span class="go"> Transition from ((), (1,), ()) to ((), (1,), ()): 1|(0, 1, 0),</span>
<span class="go"> Transition from ((), (1,), ()) to ((), (), (2,)): 2|(0, 0, 0),</span>
<span class="go"> Transition from ((), (), (2,)) to ((0,), (), ()): 0|(0, 0, 0),</span>
<span class="go"> Transition from ((), (), (2,)) to ((), (1,), ()): 1|(0, 0, 0),</span>
<span class="go"> Transition from ((), (), (2,)) to ((), (), (2,)): 2|(0, 0, 1)]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">[(0, 0, 0),</span>
<span class="go"> (1, 0, 0),</span>
<span class="go"> (0, 0, 0),</span>
<span class="go"> (0, 1, 0),</span>
<span class="go"> (0, 0, 0),</span>
<span class="go"> (0, 0, 1),</span>
<span class="go"> (0, 0, 0),</span>
<span class="go"> (0, 0, 0),</span>
<span class="go"> (0, 0, 0),</span>
<span class="go"> (0, 0, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Transducer.intersection">
<tt class="descname">intersection</tt><big>(</big><em>other</em>, <em>only_accessible_components=True</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.Transducer.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new transducer which accepts an input if it is accepted by
both given finite state machines producing the same output.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; a transducer</li>
<li><tt class="docutils literal"><span class="pre">only_accessible_components</span></tt> &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt> (default), then
the result is piped through <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components"><tt class="xref py py-meth docutils literal"><span class="pre">accessible_components()</span></tt></a>. If no
<tt class="docutils literal"><span class="pre">new_input_alphabet</span></tt> is given, it is determined by
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><tt class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></tt></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>A new transducer which computes the intersection
(see below) of the languages of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>The set of states of the transducer is the cartesian product of the
set of states of both given transducer. There is a transition <span class="math">\(((A,
B), (C, D), a, b)\)</span> in the new transducer if there are
transitions <span class="math">\((A, C, a, b)\)</span> and <span class="math">\((B, D, a, b)\)</span> in the old transducers.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">transducer1</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (&#39;2&#39;, &#39;2&#39;, 1, 0),</span>
<span class="go">....:                           (&#39;2&#39;, &#39;2&#39;, 0, 1)],</span>
<span class="go">....:                          initial_states=[&#39;1&#39;],</span>
<span class="go">....:                          final_states=[&#39;2&#39;])</span>
<span class="gp">sage: </span><span class="n">transducer2</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (&#39;A&#39;, &#39;B&#39;, 0, 0),</span>
<span class="go">....:                           (&#39;B&#39;, &#39;B&#39;, 0, 1),</span>
<span class="go">....:                           (&#39;B&#39;, &#39;A&#39;, 1, 1)],</span>
<span class="go">....:                          initial_states=[&#39;A&#39;],</span>
<span class="go">....:                          final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">res</span> <span class="o">=</span> <span class="n">transducer1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">transducer2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">res</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;1&#39;, &#39;A&#39;) to (&#39;2&#39;, &#39;A&#39;): 1|0,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;A&#39;) to (&#39;2&#39;, &#39;A&#39;): 1|0]</span>
</pre></div>
</div>
<p>In general, transducers are not closed under intersection. But
for transducer which do not have epsilon-transitions, the
intersection is well defined (cf. <a class="reference internal" href="#bawo2012" id="id22">[BaWo2012]</a>). However, in
the next example the intersection of the two transducers is
not well defined. The intersection of the languages consists
of <span class="math">\((a^n, b^n c^n)\)</span>. This set is not recognizable by a
<em>finite</em> transducer.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                  (0, 1, None, &#39;c&#39;),</span>
<span class="go">....:                  (1, 1, None, &#39;c&#39;)],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[0, 1])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                  (&#39;A&#39;, &#39;B&#39;, &#39;a&#39;, &#39;c&#39;),</span>
<span class="go">....:                  (&#39;B&#39;, &#39;B&#39;, &#39;a&#39;, &#39;c&#39;)],</span>
<span class="go">....:                 initial_states=[&#39;A&#39;],</span>
<span class="go">....:                 final_states=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">t2</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">An epsilon-transition (with empty input or output)</span>
<span class="go">was found.</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">transducer1</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                          initial_states=[&#39;1&#39;],</span>
<span class="go">....:                          final_states=[&#39;2&#39;])</span>
<span class="gp">sage: </span><span class="n">transducer2</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                          initial_states=[&#39;A&#39;],</span>
<span class="go">....:                          final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">res</span> <span class="o">=</span> <span class="n">transducer1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">transducer2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">res</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[(&#39;2&#39;, &#39;B&#39;)]</span>
<span class="gp">sage: </span><span class="n">transducer1</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">transducer2</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">res</span> <span class="o">=</span> <span class="n">transducer1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">transducer2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">res</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="bawo2012" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id22">[BaWo2012]</a></td><td>Javier Baliosian and Dina Wonsever, <em>Finite State
Transducers</em>, chapter in <em>Handbook of Finite State Based Models and
Applications</em>, edited by Jiacun Wang, Chapman and Hall/CRC, 2012.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Transducer.process">
<tt class="descname">process</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.Transducer.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the transducer accepts the input, the state
where the computation stops and which output is generated.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">input_tape</span></tt> &#8211; the input tape can be a list or an
iterable with entries from the input alphabet. If we are
working with a multi-tape machine (see parameter
<tt class="docutils literal"><span class="pre">use_multitape_input</span></tt> and notes below), then the tape is a
list or tuple of tracks, each of which can be a list or an
iterable with entries from the input alphabet.</li>
<li><tt class="docutils literal"><span class="pre">initial_state</span></tt> or <tt class="docutils literal"><span class="pre">initial_states</span></tt> &#8211; the initial
state(s) in which the machine starts. Either specify a
single one with <tt class="docutils literal"><span class="pre">initial_state</span></tt> or a list of them with
<tt class="docutils literal"><span class="pre">initial_states</span></tt>. If both are given, <tt class="docutils literal"><span class="pre">initial_state</span></tt>
will be appended to <tt class="docutils literal"><span class="pre">initial_states</span></tt>. If neither is
specified, the initial states of the finite state machine
are taken.</li>
<li><tt class="docutils literal"><span class="pre">list_of_outputs</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a boolean or
<tt class="docutils literal"><span class="pre">None</span></tt>. If <tt class="docutils literal"><span class="pre">True</span></tt>, then the outputs are given in list form
(even if we have no or only one single output). If
<tt class="docutils literal"><span class="pre">False</span></tt>, then the result is never a list (an exception is
raised if the result cannot be returned). If
<tt class="docutils literal"><span class="pre">list_of_outputs=None</span></tt> the method determines automatically
what to do (e.g. if a non-deterministic machine returns more
than one path, then the output is returned in list form).</li>
<li><tt class="docutils literal"><span class="pre">only_accepted</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a boolean. If set,
then the first argument in the output is guaranteed to be
<tt class="docutils literal"><span class="pre">True</span></tt> (if the output is a list, then the first argument
of each element will be <tt class="docutils literal"><span class="pre">True</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">full_output</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) a boolean. If set,
then the full output is given, otherwise only the generated
output (the third entry below only). If the input is not
accepted, a <tt class="docutils literal"><span class="pre">ValueError</span></tt> is raised.</li>
<li><tt class="docutils literal"><span class="pre">always_include_output</span></tt> &#8211; if set (not by default), always
include the output. This is inconsequential for a
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer" title="sage.combinat.finite_state_machine.Transducer"><tt class="xref py py-class docutils literal"><span class="pre">Transducer</span></tt></a>, but can be used in other classes
derived from <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a> where the output is
suppressed by default, cf. <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">format_output</span></tt> &#8211; a function that translates the written
output (which is in form of a list) to something more
readable. By default (<tt class="docutils literal"><span class="pre">None</span></tt>) identity is used here.</li>
<li><tt class="docutils literal"><span class="pre">check_epsilon_transitions</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) a
boolean. If <tt class="docutils literal"><span class="pre">False</span></tt>, then epsilon transitions are not
taken into consideration during process.</li>
<li><tt class="docutils literal"><span class="pre">write_final_word_out</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) a boolean
specifying whether the final output words should be written
or not.</li>
<li><tt class="docutils literal"><span class="pre">use_multitape_input</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a
boolean. If <tt class="docutils literal"><span class="pre">True</span></tt>, then the multi-tape mode of the
process iterator is activated. See also the notes below for
multi-tape machines.</li>
<li><tt class="docutils literal"><span class="pre">process_all_prefixes_of_input</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a
boolean. If <tt class="docutils literal"><span class="pre">True</span></tt>, then each prefix of the input word is
processed (instead of processing the whole input word at
once). Consequently, there is an output generated for each
of these prefixes.</li>
<li><tt class="docutils literal"><span class="pre">process_iterator_class</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a class
inherited from <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a>. If <tt class="docutils literal"><span class="pre">None</span></tt>,
then <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a> is taken. An instance of this
class is created and is used during the processing.</li>
<li><tt class="docutils literal"><span class="pre">automatic_output_type</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a boolean
If set and the input has a parent, then the
output will have the same parent. If the input does not have
a parent, then the output will be of the same type as the
input.</li>
</ul>
<p>OUTPUT:</p>
<p>The full output is a triple (or a list of triples,
cf. parameter <tt class="docutils literal"><span class="pre">list_of_outputs</span></tt>), where</p>
<ul class="simple">
<li>the first entry is <tt class="docutils literal"><span class="pre">True</span></tt> if the input string is accepted,</li>
<li>the second gives the reached state after processing the
input tape (This is a state with label <tt class="docutils literal"><span class="pre">None</span></tt> if the input
could not be processed, i.e., if at one point no
transition to go on could be found.), and</li>
<li>the third gives a list of the output labels written during
processing.</li>
</ul>
<p>If <tt class="docutils literal"><span class="pre">full_output</span></tt> is <tt class="docutils literal"><span class="pre">False</span></tt>, then only the third entry
is returned.</p>
<p>Note that in the case the transducer is not
deterministic, all possible paths are taken into account.</p>
<p>This function uses an iterator which, in its simplest form, goes
from one state to another in each step. To decide which way to
go, it uses the input words of the outgoing transitions and
compares them to the input tape. More precisely, in each step,
the iterator takes an outgoing transition of the current state,
whose input label equals the input letter of the tape. The
output label of the transition, if present, is written on the
output tape.</p>
<p>If the choice of the outgoing transition is not unique (i.e.,
we have a non-deterministic finite state machine), all
possibilites are followed. This is done by splitting the
process into several branches, one for each of the possible
outgoing transitions.</p>
<p>The process (iteration) stops if all branches are finished,
i.e., for no branch, there is any transition whose input word
coincides with the processed input tape. This can simply
happen when the entire tape was read.</p>
<p>Also see <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a> for a version of
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><tt class="xref py py-meth docutils literal"><span class="pre">process()</span></tt></a> with shortened output.</p>
<p>Internally this function creates and works with an instance of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a>. This iterator can also be obtained
with <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><tt class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></tt></a>.</p>
<p>If working with multi-tape finite state machines, all input
words of transitions are words of <span class="math">\(k\)</span>-tuples of letters.
Moreover, the input tape has to consist of <span class="math">\(k\)</span> tracks, i.e.,
be a list or tuple of <span class="math">\(k\)</span> iterators, one for each track.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Working with multi-tape finite state machines is still
experimental and can lead to wrong outputs.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">binary_inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:                              initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">binary_inverter</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(True, &#39;A&#39;, [1, 0, 1, 1, 0, 0])</span>
</pre></div>
</div>
<p>If we are only interested in the output, we can also use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">binary_inverter</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[1, 0, 1, 1, 0, 0]</span>
</pre></div>
</div>
<p>This can also be used with words as input:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">Words</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span> <span class="n">W</span>
<span class="go">Words over {0, 1}</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">W</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span> <span class="n">w</span>
<span class="go">word: 010011</span>
<span class="gp">sage: </span><span class="n">binary_inverter</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go">word: 101100</span>
</pre></div>
</div>
<p>In this case it is automatically determined that the output is
a word. The call above is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">binary_inverter</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">w</span><span class="p">,</span>
<span class="go">....:                         full_output=False,</span>
<span class="go">....:                         list_of_outputs=False,</span>
<span class="go">....:                         automatic_output_type=True)</span>
<span class="go">word: 101100</span>
</pre></div>
</div>
<p>The following transducer transforms <span class="math">\(0^n 1\)</span> to <span class="math">\(1^n 2\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>We can see the different possibilites of the output by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="p">[</span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                         [0], [0, 0], [2, 0], [0, 1, 2]]]</span>
<span class="go">[(True, 1, [2]), (True, 1, [1, 2]),</span>
<span class="go"> (True, 1, [1, 1, 2]), (False, None, None),</span>
<span class="go"> (False, 0, [1]), (False, 0, [1, 1]),</span>
<span class="go"> (False, None, None), (False, None, None)]</span>
</pre></div>
</div>
<p>If we just want a condensed output, we use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="p">[</span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">....:      for w in [[1], [0, 1], [0, 0, 1]]]</span>
<span class="go">[[2], [1, 2], [1, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">full_output</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">full_output</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
</pre></div>
</div>
<p>It is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="p">[</span><span class="n">T</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]]</span>
<span class="go">[[2], [1, 2], [1, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
</pre></div>
</div>
<p>A cycle with empty input and empty output is correctly processed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0], final_states=[1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([])</span>
<span class="go">[(False, 0, []), (True, 1, [])]</span>
<span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[(False, 0, [&#39;r&#39;]), (True, 1, [&#39;r&#39;])]</span>
</pre></div>
</div>
<p>If there is a cycle with empty input but non-empty output, the
possible outputs would be an infinite set:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s">&#39;z&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0], final_states=[1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RuntimeError</span>: <span class="n">State 0 is in an epsilon cycle (no input),</span>
<span class="go">but output is written.</span>
</pre></div>
</div>
<p>But if this cycle with empty input and non-empty output is not
reached, the correct output is produced:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([])</span>
<span class="go">(False, -1, [])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RuntimeError</span>: <span class="n">State 0 is in an epsilon cycle (no input),</span>
<span class="go">but output is written.</span>
</pre></div>
</div>
<p>If we set <tt class="docutils literal"><span class="pre">check_epsilon_transitions=False</span></tt>, then no
transitions with empty input are considered
anymore. Thus cycles with empty input are no problem anymore:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">check_epsilon_transitions</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">(False, 0, [&#39;r&#39;])</span>
</pre></div>
</div>
<p>A simple example of a multi-tape transducer is the
following: It writes the length of the first tape many letters <tt class="docutils literal"><span class="pre">a</span></tt>
and then the length of the second tape many letters <tt class="docutils literal"><span class="pre">b</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="s">&#39;a&#39;</span><span class="p">),</span>
<span class="go">....:                 (0, 1, [], []),</span>
<span class="go">....:                 (1, 1, (None, 1), &#39;b&#39;)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">process</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">use_multitape_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(True, 1, [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><tt class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><tt class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a>.</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0, 1], final_states=[1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[(False, 0, [&#39;a&#39;, &#39;b&#39;]), (True, 1, [&#39;b&#39;, &#39;a&#39;])]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">(False, 0, [&#39;a&#39;, &#39;b&#39;])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="s">&#39;c&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">(True, 1, [&#39;b&#39;, &#39;a&#39;, &#39;c&#39;])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">write_final_word_out</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">(True, 1, [&#39;b&#39;, &#39;a&#39;])</span>
</pre></div>
</div>
<p>The parameter <tt class="docutils literal"><span class="pre">input_tape</span></tt> is required:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">No input tape given.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Transducer.simplification">
<tt class="descname">simplification</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.Transducer.simplification" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a simplified transducer.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A new transducer.</p>
<p>This function simplifies a transducer by Moore&#8217;s algorithm,
first moving common output labels of transitions leaving a
state to output labels of transitions entering the state
(cf. <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.prepone_output" title="sage.combinat.finite_state_machine.FiniteStateMachine.prepone_output"><tt class="xref py py-meth docutils literal"><span class="pre">prepone_output()</span></tt></a>).</p>
<p>The resulting transducer implements the same function as the
original transducer.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">fsm</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (&quot;B&quot;, &quot;C&quot;, 0, 0), (&quot;B&quot;, &quot;C&quot;, 1, 1),</span>
<span class="go">....:                           (&quot;C&quot;, &quot;D&quot;, 0, 1), (&quot;C&quot;, &quot;D&quot;, 1, 0),</span>
<span class="go">....:                           (&quot;D&quot;, &quot;A&quot;, 0, 0), (&quot;D&quot;, &quot;A&quot;, 1, 1)])</span>
<span class="gp">sage: </span><span class="n">fsms</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">fsms</span>
<span class="go">Transducer with 2 states</span>
<span class="gp">sage: </span><span class="n">fsms</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;A&#39;, &#39;C&#39;)</span>
<span class="go">              to (&#39;B&#39;, &#39;D&#39;): 0|1,</span>
<span class="go"> Transition from (&#39;A&#39;, &#39;C&#39;)</span>
<span class="go">              to (&#39;B&#39;, &#39;D&#39;): 1|0,</span>
<span class="go"> Transition from (&#39;B&#39;, &#39;D&#39;)</span>
<span class="go">              to (&#39;A&#39;, &#39;C&#39;): 0|0,</span>
<span class="go"> Transition from (&#39;B&#39;, &#39;D&#39;)</span>
<span class="go">              to (&#39;A&#39;, &#39;C&#39;): 1|1]</span>
<span class="gp">sage: </span><span class="n">fsms</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|1,</span>
<span class="go"> Transition from 0 to 1: 1|0,</span>
<span class="go"> Transition from 1 to 0: 0|0,</span>
<span class="go"> Transition from 1 to 0: 1|1]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">fsm</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                   (&quot;A&quot;, &quot;B&quot;, 1, 1),</span>
<span class="go">....:                   (&quot;A&quot;, &quot;C&quot;, 1, -1),</span>
<span class="go">....:                   (&quot;B&quot;, &quot;A&quot;, 2, 0),</span>
<span class="go">....:                   (&quot;C&quot;, &quot;A&quot;, 2, 0)])</span>
<span class="gp">sage: </span><span class="n">fsm_simplified</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">fsm_simplified</span>
<span class="go">Transducer with 2 states</span>
<span class="gp">sage: </span><span class="n">fsm_simplified</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;A&#39;,) to (&#39;A&#39;,): 0|0,</span>
<span class="go"> Transition from (&#39;A&#39;,) to (&#39;B&#39;, &#39;C&#39;): 1|1,0,</span>
<span class="go"> Transition from (&#39;A&#39;,) to (&#39;B&#39;, &#39;C&#39;): 1|-1,0,</span>
<span class="go"> Transition from (&#39;B&#39;, &#39;C&#39;) to (&#39;A&#39;,): 2|-]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_add_input</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                 (&#39;A&#39;, &#39;B&#39;, 1/4, 1),</span>
<span class="go">....:                 (&#39;A&#39;, &#39;C&#39;, 1/4, 1),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;A&#39;, 1, 0),</span>
<span class="go">....:                 (&#39;C&#39;, &#39;A&#39;, 1, 0)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;],</span>
<span class="go">....:                on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from (&#39;A&#39;,) to (&#39;A&#39;,): 1/2|0,</span>
<span class="go"> Transition from (&#39;A&#39;,) to (&#39;B&#39;, &#39;C&#39;): 1/2|1,</span>
<span class="go"> Transition from (&#39;B&#39;, &#39;C&#39;) to (&#39;A&#39;,): 1|0]</span>
</pre></div>
</div>
<p>Illustrating the use of colors in order to avoid identification of states:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
<span class="go">....:                  [1,0,0,0], [1,1,1,1]],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[0,1])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from (0, 1) to (0, 1): 0|0,</span>
<span class="go"> Transition from (0, 1) to (0, 1): 1|1]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from (0,) to (0,): 0|0,</span>
<span class="go"> Transition from (0,) to (1,): 1|1,</span>
<span class="go"> Transition from (1,) to (0,): 0|0,</span>
<span class="go"> Transition from (1,) to (1,): 1|1]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.duplicate_transition_add_input">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">duplicate_transition_add_input</tt><big>(</big><em>old_transition</em>, <em>new_transition</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.duplicate_transition_add_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternative function for handling duplicate transitions in finite
state machines. This implementation adds the input label of the
new transition to the input label of the old transition.  This is
intended for the case where a Markov chain is modelled by a finite
state machine using the input labels as transition probabilities.</p>
<p>See the documentation of the <tt class="docutils literal"><span class="pre">on_duplicate_transition</span></tt> parameter
of <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">old_transition</span></tt> &#8211; A transition in a finite state machine.</li>
<li><tt class="docutils literal"><span class="pre">new_transition</span></tt> &#8211; A transition, identical to <tt class="docutils literal"><span class="pre">old_transition</span></tt>,
which is to be inserted into the finite state machine.</li>
</ul>
<p>OUTPUT:</p>
<p>A transition whose input weight is the sum of the input
weights of <tt class="docutils literal"><span class="pre">old_transition</span></tt> and <tt class="docutils literal"><span class="pre">new_transition</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_add_input</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">duplicate_transition_add_input</span><span class="p">(</span><span class="n">FSMTransition</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
<span class="go">....:                                FSMTransition(&#39;a&#39;, &#39;a&#39;, 1/2))</span>
<span class="go">Transition from &#39;a&#39; to &#39;a&#39;: 1|-</span>
</pre></div>
</div>
<p>Input labels must be lists of length 1:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">duplicate_transition_add_input</span><span class="p">(</span><span class="n">FSMTransition</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
<span class="go">....:                                FSMTransition(&#39;a&#39;, &#39;a&#39;, [1, 1]))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Trying to use duplicate_transition_add_input on</span>
<span class="go">&quot;Transition from &#39;a&#39; to &#39;a&#39;: 1,1|-&quot; and</span>
<span class="go">&quot;Transition from &#39;a&#39; to &#39;a&#39;: 1,1|-&quot;,</span>
<span class="go">but input words are assumed to be lists of length 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.duplicate_transition_ignore">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">duplicate_transition_ignore</tt><big>(</big><em>old_transition</em>, <em>new_transition</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.duplicate_transition_ignore" title="Permalink to this definition">¶</a></dt>
<dd><p>Default function for handling duplicate transitions in finite
state machines. This implementation ignores the occurrence.</p>
<p>See the documentation of the <tt class="docutils literal"><span class="pre">on_duplicate_transition</span></tt> parameter
of <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">old_transition</span></tt> &#8211; A transition in a finite state machine.</li>
<li><tt class="docutils literal"><span class="pre">new_transition</span></tt> &#8211; A transition, identical to <tt class="docutils literal"><span class="pre">old_transition</span></tt>,
which is to be inserted into the finite state machine.</li>
</ul>
<p>OUTPUT:</p>
<p>The same transition, unchanged.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_ignore</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">duplicate_transition_ignore</span><span class="p">(</span><span class="n">FSMTransition</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                             FSMTransition(0, 0, 1))</span>
<span class="go">Transition from 0 to 0: 1|-</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.duplicate_transition_raise_error">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">duplicate_transition_raise_error</tt><big>(</big><em>old_transition</em>, <em>new_transition</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.duplicate_transition_raise_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternative function for handling duplicate transitions in finite
state machines. This implementation raises a <tt class="docutils literal"><span class="pre">ValueError</span></tt>.</p>
<p>See the documentation of the <tt class="docutils literal"><span class="pre">on_duplicate_transition</span></tt> parameter
of <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">old_transition</span></tt> &#8211; A transition in a finite state machine.</li>
<li><tt class="docutils literal"><span class="pre">new_transition</span></tt> &#8211; A transition, identical to <tt class="docutils literal"><span class="pre">old_transition</span></tt>,
which is to be inserted into the finite state machine.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing. A <tt class="docutils literal"><span class="pre">ValueError</span></tt> is raised.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_raise_error</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">duplicate_transition_raise_error</span><span class="p">(</span><span class="n">FSMTransition</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                                  FSMTransition(0, 0, 1))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Attempting to re-insert transition Transition from 0 to 0: 1|-</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.equal">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">equal</tt><big>(</big><em>iterator</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether all elements of <tt class="docutils literal"><span class="pre">iterator</span></tt> are equal.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">iterator</span></tt> &#8211; an iterator of the elements to check</li>
</ul>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<p>This implements <a class="reference external" href="http://stackoverflow.com/a/3844832/1052778">http://stackoverflow.com/a/3844832/1052778</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">equal</span>
<span class="gp">sage: </span><span class="n">equal</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">equal</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">equal</span><span class="p">([])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">equal</span><span class="p">(</span><span class="nb">iter</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can test other properties of the elements than the elements
themselves. In the following example, we check whether all tuples
have the same lengths:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">equal</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">equal</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.full_group_by">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">full_group_by</tt><big>(</big><em>l</em>, <em>key=&lt;function &lt;lambda&gt; at 0x7f6c2b01f758&gt;</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.full_group_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Group iterable <tt class="docutils literal"><span class="pre">l</span></tt> by values of <tt class="docutils literal"><span class="pre">key</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li>iterable <tt class="docutils literal"><span class="pre">l</span></tt></li>
<li>key function <tt class="docutils literal"><span class="pre">key</span></tt></li>
</ul>
<p>OUTPUT:</p>
<p>A list of pairs <tt class="docutils literal"><span class="pre">(k,</span> <span class="pre">elements)</span></tt> such that <tt class="docutils literal"><span class="pre">key(e)=k</span></tt> for all
<tt class="docutils literal"><span class="pre">e</span></tt> in <tt class="docutils literal"><span class="pre">elements</span></tt>.</p>
<p>This is similar to <tt class="docutils literal"><span class="pre">itertools.groupby</span></tt> except that lists are
returned instead of iterables and no prior sorting is required.</p>
<p>We do not require</p>
<ul class="simple">
<li>that the keys are sortable (in contrast to the
approach via <tt class="docutils literal"><span class="pre">sorted</span></tt> and <tt class="docutils literal"><span class="pre">itertools.groupby</span></tt>) and</li>
<li>that the keys are hashable (in contrast to the
implementation proposed in <a class="reference external" href="http://stackoverflow.com/a/15250161">http://stackoverflow.com/a/15250161</a>).</li>
</ul>
<p>However, it is required</p>
<ul class="simple">
<li>that distinct keys have distinct <tt class="docutils literal"><span class="pre">str</span></tt>-representations.</li>
</ul>
<p>The implementation is inspired by
<a class="reference external" href="http://stackoverflow.com/a/15250161">http://stackoverflow.com/a/15250161</a>, but non-hashable keys are
allowed.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">full_group_by</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="n">full_group_by</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[(2/x, [0, 2]), (1/x, [1])]</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">groupby</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">elements</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="go">....:                            key=lambda i:t[i]),</span>
<span class="go">....:                            key=lambda i:t[i]):</span>
<span class="go">....:     print k, list(elements)</span>
<span class="go">2/x [0]</span>
<span class="go">1/x [1]</span>
<span class="go">2/x [2]</span>
</pre></div>
</div>
<p>Note that the behavior is different from <tt class="docutils literal"><span class="pre">itertools.groupby</span></tt>
because neither <span class="math">\(1/x&lt;2/x\)</span> nor <span class="math">\(2/x&lt;1/x\)</span> does hold.</p>
<p>Here, the result <tt class="docutils literal"><span class="pre">r</span></tt> has been sorted in order to guarantee a
consistent order for the doctest suite.</p>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.is_Automaton">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">is_Automaton</tt><big>(</big><em>FSM</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.is_Automaton" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether or not <tt class="docutils literal"><span class="pre">FSM</span></tt> inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton" title="sage.combinat.finite_state_machine.Automaton"><tt class="xref py py-class docutils literal"><span class="pre">Automaton</span></tt></a>.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">is_FiniteStateMachine</span><span class="p">,</span> <span class="n">is_Automaton</span>
<span class="gp">sage: </span><span class="n">is_Automaton</span><span class="p">(</span><span class="n">FiniteStateMachine</span><span class="p">())</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_Automaton</span><span class="p">(</span><span class="n">Automaton</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_FiniteStateMachine</span><span class="p">(</span><span class="n">Automaton</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.is_FSMProcessIterator">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">is_FSMProcessIterator</tt><big>(</big><em>PI</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.is_FSMProcessIterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether or not <tt class="docutils literal"><span class="pre">PI</span></tt> inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><tt class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></tt></a>.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">is_FSMProcessIterator</span><span class="p">,</span> <span class="n">FSMProcessIterator</span>
<span class="gp">sage: </span><span class="n">is_FSMProcessIterator</span><span class="p">(</span><span class="n">FSMProcessIterator</span><span class="p">(</span><span class="n">FiniteStateMachine</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">[]))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.is_FSMState">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">is_FSMState</tt><big>(</big><em>S</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.is_FSMState" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether or not <tt class="docutils literal"><span class="pre">S</span></tt> inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><tt class="xref py py-class docutils literal"><span class="pre">FSMState</span></tt></a>.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">is_FSMState</span><span class="p">,</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">is_FSMState</span><span class="p">(</span><span class="n">FSMState</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.is_FSMTransition">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">is_FSMTransition</tt><big>(</big><em>T</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.is_FSMTransition" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether or not <tt class="docutils literal"><span class="pre">T</span></tt> inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><tt class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></tt></a>.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">is_FSMTransition</span><span class="p">,</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">is_FSMTransition</span><span class="p">(</span><span class="n">FSMTransition</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.is_FiniteStateMachine">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">is_FiniteStateMachine</tt><big>(</big><em>FSM</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.is_FiniteStateMachine" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether or not <tt class="docutils literal"><span class="pre">FSM</span></tt> inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><tt class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></tt></a>.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">is_FiniteStateMachine</span>
<span class="gp">sage: </span><span class="n">is_FiniteStateMachine</span><span class="p">(</span><span class="n">FiniteStateMachine</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_FiniteStateMachine</span><span class="p">(</span><span class="n">Automaton</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_FiniteStateMachine</span><span class="p">(</span><span class="n">Transducer</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.is_Transducer">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">is_Transducer</tt><big>(</big><em>FSM</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.is_Transducer" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether or not <tt class="docutils literal"><span class="pre">FSM</span></tt> inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer" title="sage.combinat.finite_state_machine.Transducer"><tt class="xref py py-class docutils literal"><span class="pre">Transducer</span></tt></a>.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">is_FiniteStateMachine</span><span class="p">,</span> <span class="n">is_Transducer</span>
<span class="gp">sage: </span><span class="n">is_Transducer</span><span class="p">(</span><span class="n">FiniteStateMachine</span><span class="p">())</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_Transducer</span><span class="p">(</span><span class="n">Transducer</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_FiniteStateMachine</span><span class="p">(</span><span class="n">Transducer</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.setup_latex_preamble">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">setup_latex_preamble</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.setup_latex_preamble" title="Permalink to this definition">¶</a></dt>
<dd><p>This function adds the package <tt class="docutils literal"><span class="pre">tikz</span></tt> with support for automata
to the preamble of Latex so that the finite state machines can be
drawn nicely.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>See the section on <a class="reference internal" href="#finite-state-machine-latex-output"><em>LaTeX output</em></a>
in the introductory examples of this module.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">setup_latex_preamble</span>
<span class="gp">sage: </span><span class="n">setup_latex_preamble</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="s">&quot;\usepackage{tikz}&quot;</span> <span class="ow">in</span> <span class="n">latex</span><span class="o">.</span><span class="n">extra_preamble</span><span class="p">())</span> <span class="o">==</span> <span class="n">latex</span><span class="o">.</span><span class="n">has_file</span><span class="p">(</span><span class="s">&quot;tikz.sty&quot;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.startswith">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">startswith</tt><big>(</big><em>list</em>, <em>prefix</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.startswith" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether list starts with the given prefix.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">list</span></tt> &#8211; list</li>
<li><tt class="docutils literal"><span class="pre">prefix</span></tt> &#8211; list representing the prefix</li>
</ul>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<p>Similar to <a class="reference external" href="https://docs.python.org/library/stdtypes.html#str.startswith" title="(in Python v2.7)"><tt class="xref py py-meth docutils literal"><span class="pre">str.startswith()</span></tt></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">startswith</span>
<span class="gp">sage: </span><span class="n">startswith</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">startswith</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">startswith</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.tupleofwords_to_wordoftuples">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">tupleofwords_to_wordoftuples</tt><big>(</big><em>tupleofwords</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.tupleofwords_to_wordoftuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Transposes a tuple of words over the alphabet to a word of tuples.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">tupleofwords</span></tt> &#8211; a tuple of a list of letters.</li>
</ul>
<p>OUTPUT:</p>
<p>A list of tuples.</p>
<p>Missing letters in the words are padded with the letter <tt class="docutils literal"><span class="pre">None</span></tt>
(from the empty word).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="p">(</span>
<span class="go">....:     tupleofwords_to_wordoftuples)</span>
<span class="gp">sage: </span><span class="n">tupleofwords_to_wordoftuples</span><span class="p">(</span>
<span class="go">....:     ([1, 2], [3, 4, 5, 6], [7]))</span>
<span class="go">[(1, 3, 7), (2, 4, None), (None, 5, None), (None, 6, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.wordoftuples_to_tupleofwords">
<tt class="descclassname">sage.combinat.finite_state_machine.</tt><tt class="descname">wordoftuples_to_tupleofwords</tt><big>(</big><em>wordoftuples</em><big>)</big><a class="headerlink" href="#sage.combinat.finite_state_machine.wordoftuples_to_tupleofwords" title="Permalink to this definition">¶</a></dt>
<dd><p>Transposes a word of tuples to a tuple of words over the alphabet.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">wordoftuples</span></tt> &#8211; a list of tuples of letters.</li>
</ul>
<p>OUTPUT:</p>
<p>A tuple of lists.</p>
<p>Letters <tt class="docutils literal"><span class="pre">None</span></tt> (empty word) are removed from each word in the output.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="p">(</span>
<span class="go">....:     wordoftuples_to_tupleofwords)</span>
<span class="gp">sage: </span><span class="n">wordoftuples_to_tupleofwords</span><span class="p">(</span>
<span class="go">....:     [(1, 2), (1, None), (1, None), (1, 2), (None, 2)])</span>
<span class="go">([1, 1, 1, 1], [2, 2, 2])</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Finite State Machines, Automata, Transducers</a><ul>
<li><a class="reference internal" href="#contents">Contents</a><ul>
<li><a class="reference internal" href="#finitestatemachine-and-derived-classes-transducer-and-automaton"><tt class="docutils literal"><span class="pre">FiniteStateMachine</span></tt> and derived classes <tt class="docutils literal"><span class="pre">Transducer</span></tt> and <tt class="docutils literal"><span class="pre">Automaton</span></tt></a><ul>
<li><a class="reference internal" href="#accessing-parts-of-a-finite-state-machine">Accessing parts of a finite state machine</a></li>
<li><a class="reference internal" href="#modified-copies">(Modified) Copies</a></li>
<li><a class="reference internal" href="#manipulation">Manipulation</a></li>
<li><a class="reference internal" href="#properties">Properties</a></li>
<li><a class="reference internal" href="#operations">Operations</a></li>
<li><a class="reference internal" href="#simplification">Simplification</a></li>
<li><a class="reference internal" href="#conversion">Conversion</a><ul>
<li><a class="reference internal" href="#latex-output">LaTeX output</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#fsmstate"><tt class="docutils literal"><span class="pre">FSMState</span></tt></a></li>
<li><a class="reference internal" href="#fsmtransition"><tt class="docutils literal"><span class="pre">FSMTransition</span></tt></a></li>
<li><a class="reference internal" href="#fsmprocessiterator"><tt class="docutils literal"><span class="pre">FSMProcessIterator</span></tt></a></li>
<li><a class="reference internal" href="#helper-functions">Helper Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#a-simple-finite-state-machine">A simple finite state machine</a></li>
<li><a class="reference internal" href="#a-simple-automaton-recognizing-nafs">A simple Automaton (recognizing NAFs)</a><ul>
<li><a class="reference internal" href="#recognizing-nafs-via-automata-operations">Recognizing NAFs via Automata Operations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#finite-state-machine-latex-output">LaTeX output</a></li>
<li><a class="reference internal" href="#a-simple-transducer-binary-inverter">A simple transducer (binary inverter)</a></li>
<li><a class="reference internal" href="#transducers-and-in-finite-words">Transducers and (in)finite Words</a></li>
<li><a class="reference internal" href="#a-transducer-which-performs-division-by-in-binary">A transducer which performs division by <span class="math">\(3\)</span> in binary</a></li>
<li><a class="reference internal" href="#gray-code">Gray Code</a></li>
<li><a class="reference internal" href="#using-the-hook-functions">Using the hook-functions</a></li>
<li><a class="reference internal" href="#detecting-sequences-with-same-number-of-and">Detecting sequences with same number of <span class="math">\(0\)</span> and <span class="math">\(1\)</span></a></li>
</ul>
</li>
<li><a class="reference internal" href="#methods">Methods</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="finite_class.html"
                                  title="previous chapter">Finite combinatorial classes</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="finite_state_machine_generators.html"
                                  title="next chapter">Common Automata and Transducers (Finite State Machines Generators)</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/combinat/finite_state_machine.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="finite_state_machine_generators.html" title="Common Automata and Transducers (Finite State Machines Generators)"
             >next</a> |</li>
        <li class="right" >
          <a href="finite_class.html" title="Finite combinatorial classes"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Combinatorics</a> &raquo;</li>

          <li><a href="../../module_list.html" >Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2015, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>