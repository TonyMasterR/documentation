<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Binary Trees &mdash; Sage Reference Manual v6.6: Combinatorics</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '6.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v6.6: Combinatorics" href="../../index.html" />
    <link rel="up" title="Comprehensive Module list" href="../../module_list.html" />
    <link rel="next" title="Cartesian Products" href="cartesian_product.html" />
    <link rel="prev" title="Binary Recurrence Sequences." href="binary_recurrence_sequences.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="cartesian_product.html" title="Cartesian Products"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="binary_recurrence_sequences.html" title="Binary Recurrence Sequences."
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Combinatorics</a> &raquo;</li>

          <li><a href="../../module_list.html" accesskey="U">Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="binary-trees">
<span id="sage-combinat-binary-tree"></span><h1>Binary Trees<a class="headerlink" href="#binary-trees" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.binary_tree"></span><p>This module deals with binary trees as mathematical (in particular immutable)
objects.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you need the data-structure for example to represent sets or hash
tables with AVL trees, you should have a look at <tt class="xref py py-mod docutils literal"><span class="pre">sage.misc.sagex_ds</span></tt>.</p>
</div>
<p>AUTHORS:</p>
<ul class="simple">
<li>Florent Hivert (2010-2011): initial implementation.</li>
</ul>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="lodayronco" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[LodayRonco]</td><td>Jean-Louis Loday and Maria O. Ronco.
<em>Hopf algebra of the planar binary trees</em>,
Advances in Mathematics, volume 139, issue 2,
10 November 1998, pp. 293-309.
<a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S0001870898917595">http://www.sciencedirect.com/science/article/pii/S0001870898917595</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="hnt05" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[HNT05]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id5">2</a>, <a class="fn-backref" href="#id6">3</a>, <a class="fn-backref" href="#id9">4</a>, <a class="fn-backref" href="#id15">5</a>, <a class="fn-backref" href="#id16">6</a>, <a class="fn-backref" href="#id17">7</a>)</em> Florent Hivert, Jean-Christophe Novelli, and Jean-Yves Thibon.
<em>The algebra of binary search trees</em>,
<a class="reference external" href="http://arxiv.org/abs/math/0401089v2">Arxiv math/0401089v2</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="cp12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[CP12]</td><td><em>(<a class="fn-backref" href="#id8">1</a>, <a class="fn-backref" href="#id11">2</a>)</em> Gregory Chatel, Viviane Pons.
<em>Counting smaller trees in the Tamari order</em>,
<a class="reference external" href="http://arxiv.org/abs/1212.0751v1">Arxiv 1212.0751v1</a>.</td></tr>
</tbody>
</table>
<dl class="class">
<dt id="sage.combinat.binary_tree.BinaryTree">
<em class="property">class </em><tt class="descclassname">sage.combinat.binary_tree.</tt><tt class="descname">BinaryTree</tt><big>(</big><em>parent</em>, <em>children=None</em>, <em>check=True</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="abstract_tree.html#sage.combinat.abstract_tree.AbstractClonableTree" title="sage.combinat.abstract_tree.AbstractClonableTree"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.abstract_tree.AbstractClonableTree</span></tt></a>, <a class="reference external" href="../../../structure/sage/structure/list_clone.html#sage.structure.list_clone.ClonableArray" title="(in Sage Reference Manual: Basic Structures v6.6)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.list_clone.ClonableArray</span></tt></a></p>
<p>Binary trees.</p>
<p>Binary trees here mean ordered (a.k.a. plane) finite binary
trees, where &#8220;ordered&#8221; means that the children of each node are
ordered.</p>
<p>Binary trees contain nodes and leaves, where each node has two
children while each leaf has no children. The number of leaves
of a binary tree always equals the number of nodes plus <span class="math">\(1\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">children</span></tt> &#8211; <tt class="docutils literal"><span class="pre">None</span></tt> (default) or a list, tuple or iterable of
length <span class="math">\(2\)</span> of binary trees or convertible objects. This corresponds
to the standard recursive definition of a binary tree as either a
leaf or a pair of binary trees. Syntactic sugar allows leaving out
all but the outermost calls of the <tt class="docutils literal"><span class="pre">BinaryTree()</span></tt> constructor, so
that, e. g., <tt class="docutils literal"><span class="pre">BinaryTree([BinaryTree(None),BinaryTree(None)])</span></tt> can
be shortened to <tt class="docutils literal"><span class="pre">BinaryTree([None,None])</span></tt>. It is also allowed to
abbreviate <tt class="docutils literal"><span class="pre">[None,</span> <span class="pre">None]</span></tt> by <tt class="docutils literal"><span class="pre">[]</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">check</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) whether check for binary should be
performed or not.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span>
<span class="go">[., .]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">])</span>
<span class="go">[., .]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="p">[]])</span>
<span class="go">[., [., .]]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span> <span class="bp">None</span><span class="p">])</span>
<span class="go">[[., .], .]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">(</span><span class="s">&quot;[[], .]&quot;</span><span class="p">)</span>
<span class="go">[[., .], .]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">])])</span>
<span class="go">[., [., .]]</span>

<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span> <span class="bp">None</span><span class="p">,</span> <span class="p">[]])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">this is not a binary tree</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,</span> <span class="p">[[],[[],</span> <span class="bp">None</span><span class="p">]]],[[],[]]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],[]],[]])</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">t1</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t1c</span><span class="p">:</span>
<span class="go">....:     t1c[1,1,1] = t2</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">==</span> <span class="n">t1c</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.as_ordered_tree">
<tt class="descname">as_ordered_tree</tt><big>(</big><em>with_leaves=True</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.as_ordered_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the same tree seen as an ordered tree. By default, leaves
are transformed into actual nodes, but this can be avoided by
setting the optional variable <tt class="docutils literal"><span class="pre">with_leaves</span></tt> to <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([]);</span> <span class="n">bt</span>
<span class="go">[., .]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">as_ordered_tree</span><span class="p">()</span>
<span class="go">[[], []]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">as_ordered_tree</span><span class="p">(</span><span class="n">with_leaves</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">();</span> <span class="n">bt</span>
<span class="go">1[., .]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">as_ordered_tree</span><span class="p">()</span>
<span class="go">1[None[], None[]]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">as_ordered_tree</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">1[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.canonical_labelling">
<tt class="descname">canonical_labelling</tt><big>(</big><em>shift=1</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.canonical_labelling" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a labelled version of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The canonical labelling of a binary tree is a certain labelling of the
nodes (not the leaves) of the tree.
The actual canonical labelling is currently unspecified. However, it
is guaranteed to have labels in <span class="math">\(1...n\)</span> where <span class="math">\(n\)</span> is the number of
nodes of the tree. Moreover, two (unlabelled) trees compare as equal if
and only if their canonical labelled trees compare as equal.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="go">1[., .]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="go">5[2[1[., .], 4[3[., .], .]], 7[6[., .], 8[., .]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.canopee">
<tt class="descname">canopee</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.canopee" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the canopee of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The <em>canopee</em> of a non-empty binary tree <span class="math">\(T\)</span> with <span class="math">\(n\)</span> internal nodes is
the list <span class="math">\(l\)</span> of <span class="math">\(0\)</span> and <span class="math">\(1\)</span> of length <span class="math">\(n-1\)</span> obtained by going along the
leaves of <span class="math">\(T\)</span> from left to right except the two extremal ones, writing
<span class="math">\(0\)</span> if the leaf is a right leaf and <span class="math">\(1\)</span> if the leaf is a left leaf.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">canopee</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="p">[]])</span><span class="o">.</span><span class="n">canopee</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span> <span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">canopee</span><span class="p">()</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[]])</span><span class="o">.</span><span class="n">canopee</span><span class="p">()</span>
<span class="go">[0, 1]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span><span class="o">.</span><span class="n">canopee</span><span class="p">()</span>
<span class="go">[0, 1, 0, 0, 1, 0, 1]</span>
</pre></div>
</div>
<p>The number of pairs <span class="math">\((t_1, t_2)\)</span> of binary trees of size <span class="math">\(n\)</span> such that
the canopee of <span class="math">\(t_1\)</span> is the complementary of the canopee of <span class="math">\(t_2\)</span> is
also the number of Baxter permutations (see <a class="reference internal" href="#dg94" id="id1">[DG94]</a>, see
also <a class="reference external" href="http://oeis.org/A001181">OEIS sequence A001181</a>). We check this in small cases:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="p">[</span><span class="nb">len</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">....:       if map(lambda x:1-x, u.canopee()) == v.canopee()])</span>
<span class="go">....:    for n in range(1, 5)]</span>
<span class="go">[1, 2, 6, 22]</span>
</pre></div>
</div>
<p>Here is a less trivial implementation of this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.finite_set_map_cy</span> <span class="kn">import</span> <span class="n">fibers</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.misc.all</span> <span class="kn">import</span> <span class="n">attrcall</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">baxter</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="go">....:     f = fibers(lambda t: tuple(t.canopee()),</span>
<span class="go">....:                   BinaryTrees(n))</span>
<span class="go">....:     return sum(len(f[i])*len(f[tuple(1-x for x in i)])</span>
<span class="go">....:                for i in f)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">baxter</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)]</span>
<span class="go">[1, 2, 6, 22, 92, 422]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">canopee</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">canopee is only defined for non empty binary trees</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="dg94" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[DG94]</a></td><td>S. Dulucq and O. Guibert. Mots de piles, tableaux
standards et permutations de Baxter, proceedings of
Formal Power Series and Algebraic Combinatorics, 1994.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.check">
<tt class="descname">check</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that <tt class="docutils literal"><span class="pre">self</span></tt> is a binary tree.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[]])</span>     <span class="c"># indirect doctest</span>
<span class="go">[[., .], [., .]]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[],</span> <span class="p">[]])</span> <span class="c"># indirect doctest</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">this is not a binary tree</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[]])</span>         <span class="c"># indirect doctest</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">this is not a binary tree</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.graph">
<tt class="descname">graph</tt><big>(</big><em>with_leaves=True</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert <tt class="docutils literal"><span class="pre">self</span></tt> to a digraph. By default, this graph contains
both nodes and leaves, hence is never empty. To obtain a graph
which contains only the nodes, the <tt class="docutils literal"><span class="pre">with_leaves</span></tt> optional
keyword variable has to be set to <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">with_leaves</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) a Boolean, determining
whether the resulting graph will be formed from the leaves
and the nodes of <tt class="docutils literal"><span class="pre">self</span></tt> (if <tt class="docutils literal"><span class="pre">True</span></tt>), or only from the
nodes of <tt class="docutils literal"><span class="pre">self</span></tt> (if <tt class="docutils literal"><span class="pre">False</span></tt>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],</span> <span class="bp">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Digraph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Digraph on 2 vertices</span>

<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Digraph on 9 vertices</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 4, None), (1, 2, None), (1, 3, None), (4, 5, None), (4, 8, None), (5, 6, None), (5, 7, None)]</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Digraph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 2, None), (2, 3, None)]</span>

<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Digraph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Digraph on 0 vertices</span>

<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Digraph on 3 vertices</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Digraph on 1 vertex</span>

<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[[],</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Digraph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 2, None), (2, 3, None), (2, 4, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.in_order_traversal">
<tt class="descname">in_order_traversal</tt><big>(</big><em>node_action=None</em>, <em>leaf_action=None</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.in_order_traversal" title="Permalink to this definition">¶</a></dt>
<dd><p>Explore the binary tree <tt class="docutils literal"><span class="pre">self</span></tt> using the depth-first infix-order
traversal algorithm, executing the <tt class="docutils literal"><span class="pre">node_action</span></tt> function
whenever traversing a node and executing the <tt class="docutils literal"><span class="pre">leaf_action</span></tt>
function whenever traversing a leaf.</p>
<p>In more detail, what this method does to a tree <span class="math">\(T\)</span> is the
following:</p>
<div class="highlight-python"><div class="highlight"><pre>if the root of `T` is a node:
    apply in_order_traversal to the left subtree of `T`
        (with the same node_action and leaf_action);
    apply node_action to the root of `T`;
    apply in_order_traversal to the right subtree of `T`
        (with the same node_action and leaf_action);
else:
    apply leaf_action to the root of `T`.
</pre></div>
</div>
<p>For example on the following binary tree <span class="math">\(T\)</span>, where we denote
leaves by <span class="math">\(a, b, c, \ldots\)</span> and nodes by <span class="math">\(1, 2, 3, \ldots\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>|     ____3____          |
|    /         \         |
|   1          __7__     |
|  / \        /     \    |
| a   2      _5_     8   |
|    / \    /   \   / \  |
|   b   c  4     6 h   i |
|         / \   / \      |
|        d   e f   g     |
</pre></div>
</div>
<p>this method first applies <tt class="docutils literal"><span class="pre">leaf_action</span></tt> to <span class="math">\(a\)</span>, then applies
<tt class="docutils literal"><span class="pre">node_action</span></tt> to <span class="math">\(1\)</span>, then <tt class="docutils literal"><span class="pre">leaf_action</span></tt> to <span class="math">\(b\)</span>, then
<tt class="docutils literal"><span class="pre">node_action</span></tt> to <span class="math">\(2\)</span>, etc., with the vertices being traversed
in the order <span class="math">\(a,1,b,2,c,3,d,4,e,5,f,6,g,7,h,8,i\)</span>.</p>
<p>See <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.in_order_traversal_iter" title="sage.combinat.binary_tree.BinaryTree.in_order_traversal_iter"><tt class="xref py py-meth docutils literal"><span class="pre">in_order_traversal_iter()</span></tt></a> for a version of this
algorithm which only iterates through the vertices rather than
applying any function to them.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">node_action</span></tt> &#8211; (optional) a function which takes a node in input
and does something during the exploration</li>
<li><tt class="docutils literal"><span class="pre">leaf_action</span></tt> &#8211; (optional) a function which takes a leaf in input
and does something during the exploration</li>
</ul>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">nb_leaf</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">l_action</span><span class="p">(</span><span class="n">_</span><span class="p">):</span>
<span class="go">....:    global nb_leaf</span>
<span class="go">....:    nb_leaf += 1</span>
<span class="gp">sage: </span><span class="n">nb_node</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">n_action</span><span class="p">(</span><span class="n">_</span><span class="p">):</span>
<span class="go">....:    global nb_node</span>
<span class="go">....:    nb_node += 1</span>

<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">in_order_traversal</span><span class="p">(</span><span class="n">n_action</span><span class="p">,</span> <span class="n">l_action</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">nb_leaf</span><span class="p">,</span> <span class="n">nb_node</span>
<span class="go">(1, 0)</span>

<span class="gp">sage: </span><span class="n">nb_leaf</span><span class="p">,</span> <span class="n">nb_node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[[],[]]]);</span> <span class="n">b</span>
<span class="go">[[., .], [[., .], [., .]]]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">in_order_traversal</span><span class="p">(</span><span class="n">n_action</span><span class="p">,</span> <span class="n">l_action</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">nb_leaf</span><span class="p">,</span> <span class="n">nb_node</span>
<span class="go">(6, 5)</span>
<span class="gp">sage: </span><span class="n">nb_leaf</span><span class="p">,</span> <span class="n">nb_node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">in_order_traversal</span><span class="p">(</span><span class="n">n_action</span><span class="p">,</span> <span class="n">l_action</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">nb_leaf</span><span class="p">,</span> <span class="n">nb_node</span>
<span class="go">(6, 5)</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">in_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="p">))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[1, 2, 3, 4, 5]</span>

<span class="gp">sage: </span><span class="n">leaf</span> <span class="o">=</span> <span class="s">&#39;a&#39;</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">l_action</span><span class="p">(</span><span class="n">_</span><span class="p">):</span>
<span class="go">....:    global leaf, l</span>
<span class="go">....:    l.append(leaf)</span>
<span class="go">....:    leaf = chr( ord(leaf)+1 )</span>
<span class="gp">sage: </span><span class="n">n_action</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],[[[],[]],[]]])</span><span class="o">.</span>\
<span class="go">....:     canonical_labelling()</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">in_order_traversal</span><span class="p">(</span><span class="n">n_action</span><span class="p">,</span> <span class="n">l_action</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[&#39;a&#39;, 1, &#39;b&#39;, 2, &#39;c&#39;, 3, &#39;d&#39;, 4, &#39;e&#39;, 5, &#39;f&#39;, 6, &#39;g&#39;, 7, &#39;h&#39;, 8,</span>
<span class="go"> &#39;i&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.in_order_traversal_iter">
<tt class="descname">in_order_traversal_iter</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.in_order_traversal_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>The depth-first infix-order traversal iterator for the binary
tree <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This method iters each vertex (node and leaf alike) of the given
binary tree following the depth-first infix order traversal
algorithm.</p>
<p>The <em>depth-first infix order traversal algorithm</em> iterates
through a binary tree as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>iterate through the left subtree (by the depth-first infix
    order traversal algorithm);
yield the root;
iterate through the right subtree (by the depth-first infix
    order traversal algorithm).
</pre></div>
</div>
<p>For example on the following binary tree <span class="math">\(T\)</span>, where we denote
leaves by <span class="math">\(a, b, c, \ldots\)</span> and nodes by <span class="math">\(1, 2, 3, \ldots\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>|     ____3____          |
|    /         \         |
|   1          __7__     |
|  / \        /     \    |
| a   2      _5_     8   |
|    / \    /   \   / \  |
|   b   c  4     6 h   i |
|         / \   / \      |
|        d   e f   g     |
</pre></div>
</div>
<p>the depth-first infix-order traversal algorithm iterates through
the vertices of <span class="math">\(T\)</span> in the following order:
<span class="math">\(a,1,b,2,c,3,d,4,e,5,f,6,g,7,h,8,i\)</span>.</p>
<p>See <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.in_order_traversal" title="sage.combinat.binary_tree.BinaryTree.in_order_traversal"><tt class="xref py py-meth docutils literal"><span class="pre">in_order_traversal()</span></tt></a> for a version of this algorithm
which not only iterates through, but actually does something at
the vertices of tree.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[[],[]]]);</span> <span class="n">ascii_art</span><span class="p">([</span><span class="n">b</span><span class="p">])</span>
<span class="go">[   _o_     ]</span>
<span class="go">[  /   \    ]</span>
<span class="go">[ o     o   ]</span>
<span class="go">[      / \  ]</span>
<span class="go">[     o   o ]</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">in_order_traversal_iter</span><span class="p">()))</span>
<span class="go">[                                       ]</span>
<span class="go">[ , o, ,   _o_        o      o      o   ]</span>
<span class="go">[         /   \             / \         ]</span>
<span class="go">[        o     o           o   o        ]</span>
<span class="go">[             / \                       ]</span>
<span class="go">[            o   o, ,  , ,      , ,  ,  ]</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span>
<span class="go">....:     b.canonical_labelling().in_order_traversal_iter()))</span>
<span class="go">[                           ]</span>
<span class="go">[ 1,   _2_      3    4    5 ]</span>
<span class="go">[     /   \         / \     ]</span>
<span class="go">[    1     4       3   5    ]</span>
<span class="go">[         / \               ]</span>
<span class="go">[        3   5,  ,      ,   ]</span>

<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">BinaryTree</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">in_order_traversal_iter</span><span class="p">())</span>
<span class="go">[.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.is_complete">
<tt class="descname">is_complete</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.is_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">self</span></tt> is complete, else return <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<p>In a nutshell, a complete binary tree is a perfect binary tree
except possibly in the last level, with all nodes in the last
level &#8220;flush to the left&#8221;.</p>
<p>In more detail:
A complete binary tree (also called binary heap) is a binary tree in
which every level, except possibly the last one (the deepest), is
completely filled. At depth <span class="math">\(n\)</span>, all nodes must be as far left as
possible.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>|         ___o___   |
|        /       \  |
|     __o__       o |
|    /     \        |
|   o       o       |
|  / \     / \      |
| o   o   o   o     |
</pre></div>
</div>
<p>is not complete but the following ones are:</p>
<div class="highlight-python"><div class="highlight"><pre>|     __o__          _o_            ___o___     |
|    /     \        /   \          /       \    |
|   o       o      o     o      __o__       o   |
|  / \     / \    / \          /     \     / \  |
| o   o   o   o, o   o    ,   o       o   o   o |
|                            / \     /          |
|                           o   o   o           |
</pre></div>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lst</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">bt</span><span class="p">:</span> <span class="n">bt</span><span class="o">.</span><span class="n">is_complete</span><span class="p">(),</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span> <span class="n">ascii_art</span><span class="p">(</span><span class="n">lst</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="c"># long time</span>
<span class="go">[  ]</span>
<span class="go">[ o ]</span>
<span class="go">[   o ]</span>
<span class="go">[  /  ]</span>
<span class="go">[ o   ]</span>
<span class="go">[   o   ]</span>
<span class="go">[  / \  ]</span>
<span class="go">[ o   o ]</span>
<span class="go">[     o   ]</span>
<span class="go">[    / \  ]</span>
<span class="go">[   o   o ]</span>
<span class="go">[  /      ]</span>
<span class="go">[ o       ]</span>
<span class="go">[     _o_   ]</span>
<span class="go">[    /   \  ]</span>
<span class="go">[   o     o ]</span>
<span class="go">[  / \      ]</span>
<span class="go">[ o   o     ]</span>
<span class="go">[     __o__   ]</span>
<span class="go">[    /     \  ]</span>
<span class="go">[   o       o ]</span>
<span class="go">[  / \     /  ]</span>
<span class="go">[ o   o   o   ]</span>
<span class="go">[     __o__     ]</span>
<span class="go">[    /     \    ]</span>
<span class="go">[   o       o   ]</span>
<span class="go">[  / \     / \  ]</span>
<span class="go">[ o   o   o   o ]</span>
<span class="go">[       __o__     ]</span>
<span class="go">[      /     \    ]</span>
<span class="go">[     o       o   ]</span>
<span class="go">[    / \     / \  ]</span>
<span class="go">[   o   o   o   o ]</span>
<span class="go">[  /              ]</span>
<span class="go">[ o               ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.is_empty">
<tt class="descname">is_empty</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <tt class="docutils literal"><span class="pre">self</span></tt> is empty.</p>
<p>The notion of emptiness employed here is the one which defines
a binary tree to be empty if its root is a leaf. There is
precisely one empty binary tree.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span> <span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.is_full">
<tt class="descname">is_full</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.is_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">self</span></tt> is full, else return <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<p>A full binary tree is a tree in which every node either has two
child nodes or has two child leaves.</p>
<p>This is also known as <em>proper binary tree</em> or <em>2-tree</em> or <em>strictly
binary tree</em>.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>|       __o__   |
|      /     \  |
|     o       o |
|    / \        |
|   o   o       |
|  /     \      |
| o       o     |
</pre></div>
</div>
<p>is not full but the next one is:</p>
<div class="highlight-python"><div class="highlight"><pre>|         ___o___   |
|        /       \  |
|     __o__       o |
|    /     \        |
|   o       o       |
|  / \     / \      |
| o   o   o   o     |
</pre></div>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[[[],</span><span class="bp">None</span><span class="p">],[</span><span class="bp">None</span><span class="p">,[]]],</span> <span class="p">[]])</span><span class="o">.</span><span class="n">is_full</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[[[],[]],[[],[]]],</span> <span class="p">[]])</span><span class="o">.</span><span class="n">is_full</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">bt</span><span class="p">:</span> <span class="n">bt</span><span class="o">.</span><span class="n">is_full</span><span class="p">(),</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="go">[   _o_          _o_   ]</span>
<span class="go">[  /   \        /   \  ]</span>
<span class="go">[ o     o      o     o ]</span>
<span class="go">[      / \    / \      ]</span>
<span class="go">[     o   o, o   o     ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.is_perfect">
<tt class="descname">is_perfect</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.is_perfect" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">self</span></tt> is perfect, else return <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<p>A perfect binary tree is a full tree in which all leaves are at the
same depth.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>|         ___o___   |
|        /       \  |
|     __o__       o |
|    /     \        |
|   o       o       |
|  / \     / \      |
| o   o   o   o     |
</pre></div>
</div>
<p>is not perfect but the next one is:</p>
<div class="highlight-python"><div class="highlight"><pre>|     __o__     |
|    /     \    |
|   o       o   |
|  / \     / \  |
| o   o   o   o |
</pre></div>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lst</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">bt</span><span class="p">:</span> <span class="n">bt</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">(),</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span> <span class="n">ascii_art</span><span class="p">(</span><span class="n">lst</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="c"># long time</span>
<span class="go">[  ]</span>
<span class="go">[ o ]</span>
<span class="go">[  ]</span>
<span class="go">[   o   ]</span>
<span class="go">[  / \  ]</span>
<span class="go">[ o   o ]</span>
<span class="go">[  ]</span>
<span class="go">[  ]</span>
<span class="go">[  ]</span>
<span class="go">[     __o__     ]</span>
<span class="go">[    /     \    ]</span>
<span class="go">[   o       o   ]</span>
<span class="go">[  / \     / \  ]</span>
<span class="go">[ o   o   o   o ]</span>
<span class="go">[  ]</span>
<span class="go">[  ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.left_border_symmetry">
<tt class="descname">left_border_symmetry</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.left_border_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tree where a symmetry has been applied recursively on
all left borders. If a tree is made of three trees <span class="math">\([T_1, T_2,
T_3]\)</span> on its left border, it becomes <span class="math">\([T_3', T_2', T_1']\)</span> where
same symmetry has been applied to <span class="math">\(T_1, T_2, T_3\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">left_border_symmetry</span><span class="p">()</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">left_border_symmetry</span><span class="p">()</span>
<span class="go">[., .]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],</span><span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">left_border_symmetry</span><span class="p">()</span>
<span class="go">[[., .], [., .]]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[</span><span class="bp">None</span><span class="p">,[]]],</span><span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">left_border_symmetry</span><span class="p">()</span>
<span class="go">[[., .], [., [., .]]]</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[</span><span class="bp">None</span><span class="p">,[]]],</span><span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bt</span>
<span class="go">4[1[., 2[., 3[., .]]], .]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">left_border_symmetry</span><span class="p">()</span>
<span class="go">1[4[., .], 2[., 3[., .]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.left_right_symmetry">
<tt class="descname">left_right_symmetry</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.left_right_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the left-right symmetrized tree of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">left_right_symmetry</span><span class="p">()</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">left_right_symmetry</span><span class="p">()</span>
<span class="go">[., .]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span><span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">left_right_symmetry</span><span class="p">()</span>
<span class="go">[., [., .]]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,</span> <span class="p">[]],</span><span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">left_right_symmetry</span><span class="p">()</span>
<span class="go">[., [[., .], .]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.left_rotate">
<tt class="descname">left_rotate</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.left_rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of left rotation applied to the binary
tree <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Left rotation on binary trees is defined as follows:
Let <span class="math">\(T\)</span> be a binary tree such that the right child of the
root of <span class="math">\(T\)</span> is a node. Let <span class="math">\(A\)</span> be the left
child of the root of <span class="math">\(T\)</span>, and let <span class="math">\(B\)</span> and <span class="math">\(C\)</span> be the
left and right children of the right child of the root
of <span class="math">\(T\)</span>. (Keep in mind that nodes of trees are identified
with the subtrees consisting of their descendants.)
Then, the left rotation of <span class="math">\(T\)</span> is the binary tree in
which the right child of the root is <span class="math">\(C\)</span>, whereas
the left child of the root is a node whose left and right
children are <span class="math">\(A\)</span> and <span class="math">\(B\)</span>. In pictures:</p>
<div class="highlight-python"><div class="highlight"><pre>|   *                        *   |
|  / \                      / \  |
| A   *  -left-rotate-&gt;    *   C |
|    / \                  / \    |
|   B   C                A   B   |
</pre></div>
</div>
<p>where asterisks signify a single node each (but <span class="math">\(A\)</span>, <span class="math">\(B\)</span>
and <span class="math">\(C\)</span> might be empty).</p>
<p>For example,</p>
<div class="highlight-python"><div class="highlight"><pre>|   _o_                        o |
|  /   \                      /  |
| o     o  -left-rotate-&gt;    o   |
|      /                    / \  |
|     o                    o   o |
&lt;BLANKLINE&gt;
|       __o__                            o |
|      /     \                          /  |
|     o       o  -left-rotate-&gt;        o   |
|    / \                              /    |
|   o   o                            o     |
|  /     \                          / \    |
| o       o                        o   o   |
|                                 /     \  |
|                                o       o |
</pre></div>
</div>
<p>Left rotation is the inverse operation to right rotation
(<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.right_rotate" title="sage.combinat.binary_tree.BinaryTree.right_rotate"><tt class="xref py py-meth docutils literal"><span class="pre">right_rotate()</span></tt></a>).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.right_rotate" title="sage.combinat.binary_tree.BinaryTree.right_rotate"><tt class="xref py py-meth docutils literal"><span class="pre">right_rotate()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[[],</span><span class="bp">None</span><span class="p">]]);</span> <span class="n">ascii_art</span><span class="p">([</span><span class="n">b</span><span class="p">])</span>
<span class="go">[   _o_   ]</span>
<span class="go">[  /   \  ]</span>
<span class="go">[ o     o ]</span>
<span class="go">[      /  ]</span>
<span class="go">[     o   ]</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">left_rotate</span><span class="p">()])</span>
<span class="go">[     o ]</span>
<span class="go">[    /  ]</span>
<span class="go">[   o   ]</span>
<span class="go">[  / \  ]</span>
<span class="go">[ o   o ]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">left_rotate</span><span class="p">()</span><span class="o">.</span><span class="n">right_rotate</span><span class="p">()</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.make_leaf">
<tt class="descname">make_leaf</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.make_leaf" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <tt class="docutils literal"><span class="pre">self</span></tt> so that it becomes a leaf (i. e., an empty tree).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">self</span></tt> must be in a mutable state.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.make_node" title="sage.combinat.binary_tree.BinaryTree.make_node"><tt class="xref py py-meth docutils literal"><span class="pre">make_node</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">make_leaf</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">object is immutable; please change a copy instead.</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">t</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t1</span><span class="p">:</span>
<span class="go">....:     t1.make_leaf()</span>
<span class="gp">sage: </span><span class="n">t</span><span class="p">,</span> <span class="n">t1</span>
<span class="go">([., .], .)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.make_node">
<tt class="descname">make_node</tt><big>(</big><em>child_list=[None, None]</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.make_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <tt class="docutils literal"><span class="pre">self</span></tt> so that it becomes a node with children <tt class="docutils literal"><span class="pre">child_list</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">child_list</span></tt> &#8211; a pair of binary trees (or objects convertible to)</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">self</span></tt> must be in a mutable state.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.make_leaf" title="sage.combinat.binary_tree.BinaryTree.make_leaf"><tt class="xref py py-meth docutils literal"><span class="pre">make_leaf</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">make_node</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">object is immutable; please change a copy instead.</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">t</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t1</span><span class="p">:</span>
<span class="go">....:     t1.make_node([None, None])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="p">,</span> <span class="n">t1</span>
<span class="go">(., [., .])</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">t</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
<span class="go">....:     t.make_node([BinaryTree(), BinaryTree(), BinaryTree([])])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">the list must have length 2</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">t1</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t2</span><span class="p">:</span>
<span class="go">....:     t2.make_node([t1, t1])</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">t2</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t3</span><span class="p">:</span>
<span class="go">....:     t3.make_node([t1, t2])</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span>
<span class="go">([., .], [[., .], [., .]], [[., .], [[., .], [., .]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.over">
<tt class="descname">over</tt><big>(</big><em>bt</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.over" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">self</span></tt> over <tt class="docutils literal"><span class="pre">bt</span></tt>, where &#8220;over&#8221; is the <tt class="docutils literal"><span class="pre">over</span></tt>
(<span class="math">\(/\)</span>) operation.</p>
<p>If <span class="math">\(T\)</span> and <span class="math">\(T'\)</span> are two binary trees, then <span class="math">\(T\)</span> over <span class="math">\(T'\)</span>
(written <span class="math">\(T / T'\)</span>) is defined as the tree obtained by grafting
<span class="math">\(T'\)</span> on the rightmost leaf of <span class="math">\(T\)</span>. More precisely, <span class="math">\(T / T'\)</span> is
defined by identifying the root of the <span class="math">\(T'\)</span> with the rightmost
leaf of <span class="math">\(T\)</span>. See section 4.5 of <a class="reference internal" href="#hnt05" id="id2">[HNT05]</a>.</p>
<p>If <span class="math">\(T\)</span> is empty, then <span class="math">\(T / T' = T'\)</span>.</p>
<p>The definition of this &#8220;over&#8221; operation goes back to
Loday-Ronco <a class="reference internal" href="permutation.html#lodron0102066" id="id3">[LodRon0102066]</a> (Definition 2.2), but it is
denoted by <span class="math">\(\backslash\)</span> and called the &#8220;under&#8221; operation there.
In fact, trees in sage have their root at the top, contrary to
the trees in <a class="reference internal" href="permutation.html#lodron0102066" id="id4">[LodRon0102066]</a> which are growing upwards. For
this reason, the names of the over and under operations are
swapped, in order to keep a graphical meaning.
(Our notation follows that of section 4.5 of <a class="reference internal" href="#hnt05" id="id5">[HNT05]</a>.)</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.under" title="sage.combinat.binary_tree.BinaryTree.under"><tt class="xref py py-meth docutils literal"><span class="pre">under()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<p>Showing only the nodes of a binary tree, here is an
example for the over operation:</p>
<div class="highlight-python"><div class="highlight"><pre>|   o       __o__       _o_         |
|  / \  /  /     \  =  /   \        |
| o   o   o       o   o     o       |
|          \     /           \      |
|           o   o           __o__   |
|                          /     \  |
|                         o       o |
|                          \     /  |
|                           o   o   |
</pre></div>
</div>
<p>A Sage example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[[],[]]])</span>
<span class="gp">sage: </span><span class="n">b2</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,</span> <span class="p">[]],[]])</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">((</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b1</span><span class="o">/</span><span class="n">b2</span><span class="p">))</span>
<span class="go">(   _o_        _o_      _o_           )</span>
<span class="go">(  /   \      /   \    /   \          )</span>
<span class="go">( o     o    o     o  o     o_        )</span>
<span class="go">(      / \    \            /  \       )</span>
<span class="go">(     o   o,   o    ,     o    o      )</span>
<span class="go">(                               \     )</span>
<span class="go">(                               _o_   )</span>
<span class="go">(                              /   \  )</span>
<span class="go">(                             o     o )</span>
<span class="go">(                              \      )</span>
<span class="go">(                               o     )</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[]]);</span> <span class="n">ascii_art</span><span class="p">([</span><span class="n">b1</span><span class="p">])</span>
<span class="go">[   o   ]</span>
<span class="go">[  / \  ]</span>
<span class="go">[ o   o ]</span>
<span class="gp">sage: </span><span class="n">b2</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],[[],</span><span class="bp">None</span><span class="p">]]);</span> <span class="n">ascii_art</span><span class="p">([</span><span class="n">b2</span><span class="p">])</span>
<span class="go">[   __o__   ]</span>
<span class="go">[  /     \  ]</span>
<span class="go">[ o       o ]</span>
<span class="go">[  \     /  ]</span>
<span class="go">[   o   o   ]</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">([</span><span class="n">b1</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">b2</span><span class="p">)])</span>
<span class="go">[   _o_         ]</span>
<span class="go">[  /   \        ]</span>
<span class="go">[ o     o       ]</span>
<span class="go">[        \      ]</span>
<span class="go">[       __o__   ]</span>
<span class="go">[      /     \  ]</span>
<span class="go">[     o       o ]</span>
<span class="go">[      \     /  ]</span>
<span class="go">[       o   o   ]</span>
</pre></div>
</div>
<p>The same in the labelled case:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b1</span> <span class="o">=</span> <span class="n">b1</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b2</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">([</span><span class="n">b1</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">b2</span><span class="p">)])</span>
<span class="go">[   _2_         ]</span>
<span class="go">[  /   \        ]</span>
<span class="go">[ 1     3       ]</span>
<span class="go">[        \      ]</span>
<span class="go">[       __3__   ]</span>
<span class="go">[      /     \  ]</span>
<span class="go">[     1       5 ]</span>
<span class="go">[      \     /  ]</span>
<span class="go">[       2   4   ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.q_hook_length_fraction">
<tt class="descname">q_hook_length_fraction</tt><big>(</big><em>q=None</em>, <em>q_factor=False</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.q_hook_length_fraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the <tt class="docutils literal"><span class="pre">q</span></tt>-hook length fraction of the binary tree <tt class="docutils literal"><span class="pre">self</span></tt>,
with an additional &#8220;q-factor&#8221; if desired.</p>
<p>If <span class="math">\(T\)</span> is a (plane) binary tree and <span class="math">\(q\)</span> is a polynomial
indeterminate over some ring, then the <span class="math">\(q\)</span>-hook length fraction
<span class="math">\(h_{q} (T)\)</span> of <span class="math">\(T\)</span> is defined by</p>
<div class="math">
\[h_{q} (T)
= \frac{[\lvert T \rvert]_q!}{\prod_{t \in T}
[\lvert T_t \rvert]_q},\]</div>
<p>where the product ranges over all nodes <span class="math">\(t\)</span> of <span class="math">\(T\)</span>, where <span class="math">\(T_t\)</span>
denotes the subtree of <span class="math">\(T\)</span> consisting of <span class="math">\(t\)</span> and its all
descendants, and where for every tree <span class="math">\(S\)</span>, we denote by
<span class="math">\(\lvert S \rvert\)</span> the number of nodes of <span class="math">\(S\)</span>. While this
definition only shows that <span class="math">\(h_{q} (T)\)</span> is a rational function
in <span class="math">\(T\)</span>, it is in fact easy to show that <span class="math">\(h_{q} (T)\)</span> is
actually a polynomial in <span class="math">\(T\)</span>, and thus makes sense when any
element of a commutative ring is substituted for <span class="math">\(q\)</span>.
This can also be explicitly seen from the following recursive
formula for <span class="math">\(h_{q} (T)\)</span>:</p>
<div class="math">
\[h_{q} (T)
= \binom{ \lvert T \rvert - 1 }{ \lvert T_1 \rvert }_q
h_{q} (T_1) h_{q} (T_2),\]</div>
<p>where <span class="math">\(T\)</span> is any nonempty binary tree, and <span class="math">\(T_1\)</span> and <span class="math">\(T_2\)</span> are
the two child trees of the root of <span class="math">\(T\)</span>, and where
<span class="math">\(\binom{a}{b}_q\)</span> denotes a <span class="math">\(q\)</span>-binomial coefficient.</p>
<p>A variation of the <span class="math">\(q\)</span>-hook length fraction is the following
&#8220;<span class="math">\(q\)</span>-hook length fraction with <span class="math">\(q\)</span>-factor&#8221;:</p>
<div class="math">
\[f_{q} (T)
= h_{q} (T) \cdot
\prod_{t \in T} q^{\lvert T_{\mathrm{right}(t)} \rvert},\]</div>
<p>where for every node <span class="math">\(t\)</span>, we denote by <span class="math">\(\mathrm{right}(t)\)</span> the
right child of <span class="math">\(t\)</span>.
This <span class="math">\(f_{q} (T)\)</span> differs from <span class="math">\(h_{q} (T)\)</span> only in a
multiplicative factor, which is a power of <span class="math">\(q\)</span>.</p>
<p>When <span class="math">\(q = 1\)</span>, both <span class="math">\(f_{q} (T)\)</span> and <span class="math">\(h_{q} (T)\)</span> equal the number
of permutations whose binary search tree (see <a class="reference internal" href="#hnt05" id="id6">[HNT05]</a> for the
definition) is <span class="math">\(T\)</span> (after dropping the labels). For example,
there are <span class="math">\(20\)</span> permutations which give a binary tree of the
following shape:</p>
<div class="highlight-python"><div class="highlight"><pre>|     __o__   |
|    /     \  |
|   o       o |
|  / \     /  |
| o   o   o   |
</pre></div>
</div>
<p>by the binary search insertion algorithm, in accordance with
the fact that this tree satisfies <span class="math">\(f_{1} (T) = 20\)</span>.</p>
<p>When <span class="math">\(q\)</span> is considered as a polynomial indeterminate,
<span class="math">\(f_{q} (T)\)</span> is the generating function for all permutations
whose binary search tree is <span class="math">\(T\)</span> (after dropping the labels)
with respect to the number of inversions (i. e., the Coxeter
length) of the permutations.</p>
<p>Objects similar to <span class="math">\(h_{q} (T)\)</span> also make sense for general
ordered forests (rather than just binary trees), see e. g.
<a class="reference internal" href="#bw88" id="id7">[BW88]</a>, Theorem 9.1.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">q</span></tt> &#8211; a ring element which is to be substituted as <span class="math">\(q\)</span>
into the <span class="math">\(q\)</span>-hook length fraction (by default, this is
set to be the indeterminate <span class="math">\(q\)</span> in the polynomial ring
<span class="math">\(\ZZ[q]\)</span>)</li>
<li><tt class="docutils literal"><span class="pre">q_factor</span></tt> &#8211; a Boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>) which
determines whether to compute <span class="math">\(h_{q} (T)\)</span> or to
compute <span class="math">\(f_{q} (T)\)</span> (namely, <span class="math">\(h_{q} (T)\)</span> is obtained when
<tt class="docutils literal"><span class="pre">q_factor</span> <span class="pre">==</span> <span class="pre">False</span></tt>, and <span class="math">\(f_{q} (T)\)</span> is obtained when
<tt class="docutils literal"><span class="pre">q_factor</span> <span class="pre">==</span> <span class="pre">True</span></tt>)</li>
</ul>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="bw88" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[BW88]</a></td><td>Anders Bjoerner, Michelle L. Wachs,
<em>Generalized quotients in Coxeter groups</em>.
Transactions of the American Mathematical Society,
vol. 308, no. 1, July 1988.
<a class="reference external" href="http://www.ams.org/journals/tran/1988-308-01/S0002-9947-1988-0946427-X/S0002-9947-1988-0946427-X.pdf">http://www.ams.org/journals/tran/1988-308-01/S0002-9947-1988-0946427-X/S0002-9947-1988-0946427-X.pdf</a></td></tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<p>Let us start with a simple example. Actually, let us start
with the easiest possible example &#8211; the binary tree with
only one vertex (which is a leaf):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">(</span><span class="n">q_factor</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Nothing different for a tree with one node and two leaves:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([]);</span> <span class="n">b</span>
<span class="go">[., .]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">(</span><span class="n">q_factor</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Let us get to a more interesting tree:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],[]],[[],</span><span class="bp">None</span><span class="p">]]);</span> <span class="n">b</span>
<span class="go">[[[., .], [., .]], [[., .], .]]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">()(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">20</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">()</span>
<span class="go">q^7 + 2*q^6 + 3*q^5 + 4*q^4 + 4*q^3 + 3*q^2 + 2*q + 1</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">(</span><span class="n">q_factor</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">q^10 + 2*q^9 + 3*q^8 + 4*q^7 + 4*q^6 + 3*q^5 + 2*q^4 + q^3</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">465</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">q_factor</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">3720</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="s">&#39;q&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">q^14 + 2*q^12 + 3*q^10 + 4*q^8 + 4*q^6 + 3*q^4 + 2*q^2 + 1</span>
</pre></div>
</div>
<p>Let us check the fact that <span class="math">\(f_{q} (T)\)</span> is the generating function
for all permutations whose binary search tree is <span class="math">\(T\)</span> (after
dropping the labels) with respect to the number of inversions of
the permutations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">q_hook_length_fraction_2</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
<span class="go">....:     P = PolynomialRing(ZZ, &#39;q&#39;)</span>
<span class="go">....:     q = P.gen()</span>
<span class="go">....:     res = P.zero()</span>
<span class="go">....:     for w in T.sylvester_class():</span>
<span class="go">....:         res += q ** Permutation(w).length()</span>
<span class="go">....:     return res</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_genfun</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return all( q_hook_length_fraction_2(T)</span>
<span class="go">....:                 == T.q_hook_length_fraction(q_factor=True)</span>
<span class="go">....:                 for T in BinaryTrees(i) )</span>
<span class="gp">sage: </span><span class="n">test_genfun</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.right_rotate">
<tt class="descname">right_rotate</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.right_rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of right rotation applied to the binary
tree <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Right rotation on binary trees is defined as follows:
Let <span class="math">\(T\)</span> be a binary tree such that the left child of the
root of <span class="math">\(T\)</span> is a node. Let <span class="math">\(C\)</span> be the right
child of the root of <span class="math">\(T\)</span>, and let <span class="math">\(A\)</span> and <span class="math">\(B\)</span> be the
left and right children of the left child of the root
of <span class="math">\(T\)</span>. (Keep in mind that nodes of trees are identified
with the subtrees consisting of their descendants.)
Then, the right rotation of <span class="math">\(T\)</span> is the binary tree in
which the left child of the root is <span class="math">\(A\)</span>, whereas
the right child of the root is a node whose left and right
children are <span class="math">\(B\)</span> and <span class="math">\(C\)</span>. In pictures:</p>
<div class="highlight-python"><div class="highlight"><pre>|     *                      *     |
|    / \                    / \    |
|   *   C -right-rotate-&gt;  A   *   |
|  / \                        / \  |
| A   B                      B   C |
</pre></div>
</div>
<p>where asterisks signify a single node each (but <span class="math">\(A\)</span>, <span class="math">\(B\)</span>
and <span class="math">\(C\)</span> might be empty).</p>
<p>For example,</p>
<div class="highlight-python"><div class="highlight"><pre>|     o                     _o_   |
|    /                     /   \  |
|   o    -right-rotate-&gt;  o     o |
|  / \                         /  |
| o   o                       o   |
&lt;BLANKLINE&gt;
|       __o__                         _o__      |
|      /     \                       /    \     |
|     o       o  -right-rotate-&gt;    o     _o_   |
|    / \                           /     /   \  |
|   o   o                         o     o     o |
|  /     \                               \      |
| o       o                               o     |
</pre></div>
</div>
<p>Right rotation is the inverse operation to left rotation
(<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.left_rotate" title="sage.combinat.binary_tree.BinaryTree.left_rotate"><tt class="xref py py-meth docutils literal"><span class="pre">left_rotate()</span></tt></a>).</p>
<p>The right rotation operation introduced here is the one defined
in Definition 2.1 of <a class="reference internal" href="#cp12" id="id8">[CP12]</a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.left_rotate" title="sage.combinat.binary_tree.BinaryTree.left_rotate"><tt class="xref py py-meth docutils literal"><span class="pre">left_rotate()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],[]],</span> <span class="bp">None</span><span class="p">]);</span> <span class="n">ascii_art</span><span class="p">([</span><span class="n">b</span><span class="p">])</span>
<span class="go">[     o ]</span>
<span class="go">[    /  ]</span>
<span class="go">[   o   ]</span>
<span class="go">[  / \  ]</span>
<span class="go">[ o   o ]</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">right_rotate</span><span class="p">()])</span>
<span class="go">[   _o_   ]</span>
<span class="go">[  /   \  ]</span>
<span class="go">[ o     o ]</span>
<span class="go">[      /  ]</span>
<span class="go">[     o   ]</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[[],</span><span class="bp">None</span><span class="p">],[</span><span class="bp">None</span><span class="p">,[]]],</span> <span class="p">[]]);</span> <span class="n">ascii_art</span><span class="p">([</span><span class="n">b</span><span class="p">])</span>
<span class="go">[       __o__   ]</span>
<span class="go">[      /     \  ]</span>
<span class="go">[     o       o ]</span>
<span class="go">[    / \        ]</span>
<span class="go">[   o   o       ]</span>
<span class="go">[  /     \      ]</span>
<span class="go">[ o       o     ]</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">right_rotate</span><span class="p">()])</span>
<span class="go">[     _o__      ]</span>
<span class="go">[    /    \     ]</span>
<span class="go">[   o     _o_   ]</span>
<span class="go">[  /     /   \  ]</span>
<span class="go">[ o     o     o ]</span>
<span class="go">[        \      ]</span>
<span class="go">[         o     ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.show">
<tt class="descname">show</tt><big>(</big><em>with_leaves=False</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the binary tree <tt class="docutils literal"><span class="pre">show</span></tt>, with or without leaves depending
on the Boolean keyword variable <tt class="docutils literal"><span class="pre">with_leaves</span></tt>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Left and right children might get interchanged in
the actual picture. Moreover, for a labelled binary
tree, the labels shown in the picture are not (in
general) the ones given by the labelling!</p>
<p class="last">Use <tt class="xref py py-meth docutils literal"><span class="pre">_latex_()</span></tt>, <tt class="docutils literal"><span class="pre">view</span></tt>,
<tt class="xref py py-meth docutils literal"><span class="pre">_ascii_art_()</span></tt> or <tt class="docutils literal"><span class="pre">pretty_print</span></tt> for more
faithful representations of the data of the tree.</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.sylvester_class">
<tt class="descname">sylvester_class</tt><big>(</big><em>left_to_right=False</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.sylvester_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the sylvester class corresponding to the binary tree
<tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The sylvester class of a tree <span class="math">\(T\)</span> is the set of permutations
<span class="math">\(\sigma\)</span> whose right-to-left binary search tree (a notion defined
in <a class="reference internal" href="#hnt05" id="id9">[HNT05]</a>, Definition 7) is <span class="math">\(T\)</span> after forgetting the labels.
This is an equivalence class of the sylvester congruence (the
congruence on words which holds two words <span class="math">\(uacvbw\)</span> and <span class="math">\(ucavbw\)</span>
congruent whenever <span class="math">\(a\)</span>, <span class="math">\(b\)</span>, <span class="math">\(c\)</span> are letters satisfying
<span class="math">\(a \leq b &lt; c\)</span>, and extends by transitivity) on the symmetric
group.</p>
<p>For example the following tree&#8217;s sylvester class consists of the
permutations <span class="math">\((1,3,2)\)</span> and <span class="math">\((3,1,2)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>[   o   ]
[  / \  ]
[ o   o ]
</pre></div>
</div>
<p>(only the nodes are drawn here).</p>
<p>The right-to-left binary search tree of a word is constructed by
an RSK-like insertion algorithm which proceeds as follows: Start
with an empty labelled binary tree, and read the word from right
to left. Each time a letter is read from the word, insert this
letter in the existing tree using binary search tree insertion
(<a class="reference internal" href="#sage.combinat.binary_tree.LabelledBinaryTree.binary_search_insert" title="sage.combinat.binary_tree.LabelledBinaryTree.binary_search_insert"><tt class="xref py py-meth docutils literal"><span class="pre">binary_search_insert()</span></tt></a>).
This is what the
<a class="reference internal" href="permutation.html#sage.combinat.permutation.Permutation.binary_search_tree" title="sage.combinat.permutation.Permutation.binary_search_tree"><tt class="xref py py-meth docutils literal"><span class="pre">binary_search_tree()</span></tt></a>
method computes if it is given the keyword
<tt class="docutils literal"><span class="pre">left_to_right=False</span></tt>.</p>
<p>Here are two more descriptions of the sylvester class of a binary
search tree:</p>
<ul class="simple">
<li>The sylvester class of a binary search tree <span class="math">\(T\)</span> is the set of
all linear extensions of the poset corresponding to <span class="math">\(T\)</span> (that
is, of the poset whose Hasse diagram is <span class="math">\(T\)</span>, with the root on
top), provided that the nodes of <span class="math">\(T\)</span> are labelled with
<span class="math">\(1, 2, \ldots, n\)</span> in a binary-search-tree way (i.e., every left
descendant of a node has a label smaller than that of the node,
and every right descendant of a node has a label higher than
that of the node).</li>
<li>The sylvester class of a binary search tree <span class="math">\(T\)</span> (with vertex
labels <span class="math">\(1, 2, \ldots, n\)</span>) is the interval <span class="math">\([u, v]\)</span> in the right
permutohedron order
(<a class="reference internal" href="permutation.html#sage.combinat.permutation.Permutation.permutohedron_lequal" title="sage.combinat.permutation.Permutation.permutohedron_lequal"><tt class="xref py py-meth docutils literal"><span class="pre">permutohedron_lequal()</span></tt></a>),
where <span class="math">\(u\)</span> is the 312-avoiding permutation corresponding to <span class="math">\(T\)</span>
(<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.to_312_avoiding_permutation" title="sage.combinat.binary_tree.BinaryTree.to_312_avoiding_permutation"><tt class="xref py py-meth docutils literal"><span class="pre">to_312_avoiding_permutation()</span></tt></a>), and where <span class="math">\(v\)</span> is the
132-avoiding permutation corresponding to <span class="math">\(T\)</span>
(<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.to_132_avoiding_permutation" title="sage.combinat.binary_tree.BinaryTree.to_132_avoiding_permutation"><tt class="xref py py-meth docutils literal"><span class="pre">to_132_avoiding_permutation()</span></tt></a>).</li>
</ul>
<p>If the optional keyword variable <tt class="docutils literal"><span class="pre">left_to_right</span></tt> is set to
<tt class="docutils literal"><span class="pre">True</span></tt>, then the <em>left</em> sylvester class of <tt class="docutils literal"><span class="pre">self</span></tt> is
returned instead. This is the set of permutations <span class="math">\(\sigma\)</span> whose
left-to-right binary search tree (that is, the result of the
<a class="reference internal" href="permutation.html#sage.combinat.permutation.Permutation.binary_search_tree" title="sage.combinat.permutation.Permutation.binary_search_tree"><tt class="xref py py-meth docutils literal"><span class="pre">binary_search_tree()</span></tt></a>
with <tt class="docutils literal"><span class="pre">left_to_right</span></tt> set to <tt class="docutils literal"><span class="pre">True</span></tt>) is <tt class="docutils literal"><span class="pre">self</span></tt>. It is an
equivalence class of the left sylvester congruence.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This method yields the elements of the sylvester class as
raw lists, not as permutations!</p>
</div>
<p>EXAMPLES:</p>
<p>Verifying the claim that the right-to-left binary search trees of
the permutations in the sylvester class of a tree <span class="math">\(t\)</span> all equal
<span class="math">\(t\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_bst_of_sc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">left_to_right</span><span class="p">):</span>
<span class="go">....:     for t in BinaryTrees(n):</span>
<span class="go">....:         for p in t.sylvester_class(left_to_right=left_to_right):</span>
<span class="go">....:             p_per = Permutation(p)</span>
<span class="go">....:             tree = p_per.binary_search_tree(left_to_right=left_to_right)</span>
<span class="go">....:             if not BinaryTree(tree) == t:</span>
<span class="go">....:                 return False</span>
<span class="go">....:     return True</span>
<span class="gp">sage: </span><span class="n">test_bst_of_sc</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_bst_of_sc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>   <span class="c"># long time</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_bst_of_sc</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>   <span class="c"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The same with the left-to-right version of binary search:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">test_bst_of_sc</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_bst_of_sc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>   <span class="c"># long time</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_bst_of_sc</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>   <span class="c"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Checking that the sylvester class is the set of linear extensions
of the poset of the tree:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span><span class="n">sylvester_class</span><span class="p">())</span>
<span class="go">....:      == sorted(list(v) for v in t.canonical_labelling().to_poset().linear_extensions())</span>
<span class="go">....:      for t in BinaryTrees(4) )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">BinaryTree</span><span class="p">([[],[]])</span><span class="o">.</span><span class="n">sylvester_class</span><span class="p">())</span>
<span class="go">[[1, 3, 2], [3, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span><span class="bp">None</span><span class="p">],[[],[]]])</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bt</span><span class="o">.</span><span class="n">sylvester_class</span><span class="p">());</span> <span class="n">l</span>
<span class="go">[[1, 2, 4, 6, 5, 3],</span>
<span class="go"> [1, 4, 2, 6, 5, 3],</span>
<span class="go"> [1, 4, 6, 2, 5, 3],</span>
<span class="go"> [1, 4, 6, 5, 2, 3],</span>
<span class="go"> [4, 1, 2, 6, 5, 3],</span>
<span class="go"> [4, 1, 6, 2, 5, 3],</span>
<span class="go"> [4, 1, 6, 5, 2, 3],</span>
<span class="go"> [4, 6, 1, 2, 5, 3],</span>
<span class="go"> [4, 6, 1, 5, 2, 3],</span>
<span class="go"> [4, 6, 5, 1, 2, 3],</span>
<span class="go"> [1, 2, 6, 4, 5, 3],</span>
<span class="go"> [1, 6, 2, 4, 5, 3],</span>
<span class="go"> [1, 6, 4, 2, 5, 3],</span>
<span class="go"> [1, 6, 4, 5, 2, 3],</span>
<span class="go"> [6, 1, 2, 4, 5, 3],</span>
<span class="go"> [6, 1, 4, 2, 5, 3],</span>
<span class="go"> [6, 1, 4, 5, 2, 3],</span>
<span class="go"> [6, 4, 1, 2, 5, 3],</span>
<span class="go"> [6, 4, 1, 5, 2, 3],</span>
<span class="go"> [6, 4, 5, 1, 2, 3]]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="n">Integer</span><span class="p">(</span><span class="n">bt</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">()(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Border cases:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">sylvester_class</span><span class="p">())</span>
<span class="go">[[]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">sylvester_class</span><span class="p">())</span>
<span class="go">[[1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.tamari_greater">
<tt class="descname">tamari_greater</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_greater" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of all trees greater or equal to <tt class="docutils literal"><span class="pre">self</span></tt> in the Tamari
order.</p>
<p>This is the order filter of the Tamari order generated by <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>See <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_lequal()</span></tt></a> for the definition of the Tamari poset.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_smaller" title="sage.combinat.binary_tree.BinaryTree.tamari_smaller"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_smaller()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<p>For example, the tree:</p>
<div class="highlight-python"><div class="highlight"><pre>|     __o__   |
|    /     \  |
|   o       o |
|  / \     /  |
| o   o   o   |
</pre></div>
</div>
<p>has these trees greater or equal to it:</p>
<div class="highlight-python"><div class="highlight"><pre>|o          , o        , o        , o        ,  o       ,   o      ,|
| \            \          \          \           \           \      |
|  o            o          o           o         _o_        __o__   |
|   \            \          \           \       /   \      /     \  |
|    o            o          o          _o_    o     o    o       o |
|     \            \        / \        /   \    \     \    \     /  |
|      o            o      o   o      o     o    o     o    o   o   |
|       \            \          \          /                        |
|        o            o          o        o                         |
|         \          /                                              |
|          o        o                                               |
&lt;BLANKLINE&gt;
|   o        ,   o      ,   _o_      ,   _o__     ,   __o__    ,   ___o___  ,|
|  / \          / \        /   \        /    \       /     \      /       \  |
| o   o        o   o      o     o      o     _o_    o       o    o         o |
|      \            \          / \          /   \    \       \    \       /  |
|       o            o        o   o        o     o    o       o    o     o   |
|        \            \            \            /      \            \        |
|         o            o            o          o        o            o       |
|          \          /                                                      |
|           o        o                                                       |
&lt;BLANKLINE&gt;
|     _o_    ,     __o__  |
|    /   \        /     \ |
|   o     o      o       o|
|  / \     \    / \     / |
| o   o     o  o   o   o  |
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">BinaryTree</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="n">B</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="n">B</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="n">B</span><span class="p">([])])])]);</span><span class="n">b</span>
<span class="go">[., [., [., [., .]]]]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_greater</span><span class="p">()</span>
<span class="go">[[., [., [., [., .]]]]]</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">([</span><span class="n">B</span><span class="p">([</span><span class="n">B</span><span class="p">([</span><span class="n">B</span><span class="p">([]),</span> <span class="bp">None</span><span class="p">]),</span> <span class="bp">None</span><span class="p">]),</span> <span class="bp">None</span><span class="p">]);</span><span class="n">b</span>
<span class="go">[[[[., .], .], .], .]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_greater</span><span class="p">()</span>
<span class="go">[[., [., [., [., .]]]], [., [., [[., .], .]]],</span>
<span class="go">[., [[., .], [., .]]], [., [[., [., .]], .]],</span>
<span class="go">[., [[[., .], .], .]], [[., .], [., [., .]]],</span>
<span class="go">[[., .], [[., .], .]], [[., [., .]], [., .]],</span>
<span class="go">[[., [., [., .]]], .], [[., [[., .], .]], .],</span>
<span class="go">[[[., .], .], [., .]], [[[., .], [., .]], .],</span>
<span class="go">[[[., [., .]], .], .], [[[[., .], .], .], .]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.tamari_interval">
<tt class="descname">tamari_interval</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Tamari interval between <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt> as a
<a class="reference internal" href="interval_posets.html#sage.combinat.interval_posets.TamariIntervalPoset" title="sage.combinat.interval_posets.TamariIntervalPoset"><tt class="xref py py-class docutils literal"><span class="pre">TamariIntervalPoset</span></tt></a>.</p>
<p>A &#8220;Tamari interval&#8221; is an interval in the Tamari poset.
See <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_lequal()</span></tt></a> for the definition of the Tamari poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; a binary tree greater or equal to <tt class="docutils literal"><span class="pre">self</span></tt>
in the Tamari order</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]],</span> <span class="bp">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">ip</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">tamari_interval</span><span class="p">(</span><span class="n">BinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="p">[[</span><span class="bp">None</span><span class="p">,</span> <span class="p">[]],</span> <span class="bp">None</span><span class="p">]]));</span> <span class="n">ip</span>
<span class="go">The tamari interval of size 4 induced by relations [(2, 4), (3, 4), (3, 1), (2, 1)]</span>
<span class="gp">sage: </span><span class="n">ip</span><span class="o">.</span><span class="n">lower_binary_tree</span><span class="p">()</span>
<span class="go">[[., [[., .], .]], .]</span>
<span class="gp">sage: </span><span class="n">ip</span><span class="o">.</span><span class="n">upper_binary_tree</span><span class="p">()</span>
<span class="go">[., [[., [., .]], .]]</span>
<span class="gp">sage: </span><span class="n">ip</span><span class="o">.</span><span class="n">interval_cardinality</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">ip</span><span class="o">.</span><span class="n">number_of_tamari_inversions</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">ip</span><span class="o">.</span><span class="n">binary_trees</span><span class="p">())</span>
<span class="go">[[., [[., [., .]], .]],</span>
<span class="go"> [[., [., [., .]]], .],</span>
<span class="go"> [., [[[., .], .], .]],</span>
<span class="go"> [[., [[., .], .]], .]]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">tamari_interval</span><span class="p">(</span><span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],[]]))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">The two binary trees are not comparable on the Tamari lattice.</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Setting <tt class="docutils literal"><span class="pre">other</span></tt> equal to <tt class="docutils literal"><span class="pre">bt</span></tt> gives an interval consisting of
just one element:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">ip</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">tamari_interval</span><span class="p">(</span><span class="n">bt</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ip</span>
<span class="go">The tamari interval of size 4 induced by relations [(1, 4), (2, 3), (3, 4), (3, 1), (2, 1)]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">ip</span><span class="o">.</span><span class="n">binary_trees</span><span class="p">())</span>
<span class="go">[[[., [[., .], .]], .]]</span>
</pre></div>
</div>
<p>Empty trees work well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ip</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">tamari_interval</span><span class="p">(</span><span class="n">bt</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ip</span>
<span class="go">The tamari interval of size 0 induced by relations []</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">ip</span><span class="o">.</span><span class="n">binary_trees</span><span class="p">())</span>
<span class="go">[.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.tamari_join">
<tt class="descname">tamari_join</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_join" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the join of the binary trees <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt>
(of equal size) in the <span class="math">\(n\)</span>-th Tamari poset (where <span class="math">\(n\)</span> is
the size of these trees).</p>
<p>The <span class="math">\(n\)</span>-th Tamari poset (defined in <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_lequal()</span></tt></a>)
is known to be a lattice, and the map from the <span class="math">\(n\)</span>-th
symmetric group <span class="math">\(S_n\)</span> to the <span class="math">\(n\)</span>-th Tamari poset defined
by sending every permutation <span class="math">\(p \in S_n\)</span> to the binary
search tree of <span class="math">\(p\)</span> (more precisely, to
<tt class="docutils literal"><span class="pre">p.binary_search_tree_shape()</span></tt>) is a lattice
homomorphism. (See Theorem 6.2 in <a class="reference internal" href="#read04" id="id10">[Read04]</a>.)</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_lequal()</span></tt></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_meet" title="sage.combinat.binary_tree.BinaryTree.tamari_meet"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_meet()</span></tt></a>.</p>
</div>
<p>AUTHORS:</p>
<p>Viviane Pons and Darij Grinberg, 18 June 2014.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,</span> <span class="p">[]],</span> <span class="bp">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="bp">None</span><span class="p">],</span> <span class="bp">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">e</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="p">[[[],</span> <span class="bp">None</span><span class="p">],</span> <span class="bp">None</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">b2</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="bp">None</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">b1</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">b2</span><span class="p">)</span>
<span class="go">[., [[., .], [., .]]]</span>
<span class="gp">sage: </span><span class="n">b3</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">b1</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">b3</span><span class="p">)</span>
<span class="go">[., [., [[., .], .]]]</span>
<span class="gp">sage: </span><span class="n">b2</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">b3</span><span class="p">)</span>
<span class="go">[[., .], [., [., .]]]</span>
</pre></div>
</div>
<p>The universal property of the meet operation is
satisfied:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_uni_join</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
<span class="go">....:     j = p.tamari_join(q)</span>
<span class="go">....:     if not p.tamari_lequal(j):</span>
<span class="go">....:         return False</span>
<span class="go">....:     if not q.tamari_lequal(j):</span>
<span class="go">....:         return False</span>
<span class="go">....:     for r in p.tamari_greater():</span>
<span class="go">....:         if q.tamari_lequal(r) and not j.tamari_lequal(r):</span>
<span class="go">....:             return False</span>
<span class="go">....:     return True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">test_uni_join</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">();</span> <span class="n">q</span> <span class="o">=</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">();</span> <span class="n">test_uni_join</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Border cases:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([])</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">[., .]</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="read04" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Read04]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id12">2</a>)</em> Nathan Reading.
<em>Cambrian Lattices</em>.
<a class="reference external" href="http://arxiv.org/abs/math/0402086v2">Arxiv math/0402086v2</a>.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.tamari_lequal">
<tt class="descname">tamari_lequal</tt><big>(</big><em>t2</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">self</span></tt> is less or equal to another binary
tree <tt class="docutils literal"><span class="pre">t2</span></tt> (of the same size as <tt class="docutils literal"><span class="pre">self</span></tt>) in the Tamari order.</p>
<p>The Tamari order on binary trees of size <span class="math">\(n\)</span> is the partial order
on the set of all binary trees of size <span class="math">\(n\)</span> generated by the
following requirement:  If a binary tree <span class="math">\(T'\)</span> is obtained by
right rotation (see <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.right_rotate" title="sage.combinat.binary_tree.BinaryTree.right_rotate"><tt class="xref py py-meth docutils literal"><span class="pre">right_rotate()</span></tt></a>) from a binary tree <span class="math">\(T\)</span>,
then <span class="math">\(T &lt; T'\)</span>.
This not only is a well-defined partial order, but actually is
a lattice structure on the set of binary trees of size <span class="math">\(n\)</span>, and
is a quotient of the weak order on the <span class="math">\(n\)</span>-th symmetric group
(also known as the right permutohedron order, see
<a class="reference internal" href="permutation.html#sage.combinat.permutation.Permutation.permutohedron_lequal" title="sage.combinat.permutation.Permutation.permutohedron_lequal"><tt class="xref py py-meth docutils literal"><span class="pre">permutohedron_lequal()</span></tt></a>).
See <a class="reference internal" href="#cp12" id="id11">[CP12]</a>. The set of binary trees of size <span class="math">\(n\)</span> equipped with
the Tamari order is called the <span class="math">\(n\)</span>-th Tamari poset.</p>
<p>The Tamari order can equivalently be defined as follows:</p>
<p>If <span class="math">\(T\)</span> and <span class="math">\(S\)</span> are two binary trees of size <span class="math">\(n\)</span>, then the
following four statements are equivalent:</p>
<ul class="simple">
<li>We have <span class="math">\(T \leq S\)</span> in the Tamari order.</li>
<li>There exist elements <span class="math">\(t\)</span> and <span class="math">\(s\)</span> of the Sylvester classes
(<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.sylvester_class" title="sage.combinat.binary_tree.BinaryTree.sylvester_class"><tt class="xref py py-meth docutils literal"><span class="pre">sylvester_class()</span></tt></a>) of <span class="math">\(T\)</span> and <span class="math">\(S\)</span>, respectively,
such that <span class="math">\(t \leq s\)</span> in the weak order on the symmetric
group.</li>
<li>The 132-avoiding permutation corresponding to <span class="math">\(T\)</span> (see
<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.to_132_avoiding_permutation" title="sage.combinat.binary_tree.BinaryTree.to_132_avoiding_permutation"><tt class="xref py py-meth docutils literal"><span class="pre">to_132_avoiding_permutation()</span></tt></a>) is <span class="math">\(\leq\)</span> to the
132-avoiding permutation corresponding to <span class="math">\(S\)</span> in the weak
order on the symmetric group.</li>
<li>The 312-avoiding permutation corresponding to <span class="math">\(T\)</span> (see
<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.to_312_avoiding_permutation" title="sage.combinat.binary_tree.BinaryTree.to_312_avoiding_permutation"><tt class="xref py py-meth docutils literal"><span class="pre">to_312_avoiding_permutation()</span></tt></a>) is <span class="math">\(\leq\)</span> to the
312-avoiding permutation corresponding to <span class="math">\(S\)</span> in the weak
order on the symmetric group.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_smaller" title="sage.combinat.binary_tree.BinaryTree.tamari_smaller"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_smaller()</span></tt></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_greater" title="sage.combinat.binary_tree.BinaryTree.tamari_greater"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_greater()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_pred" title="sage.combinat.binary_tree.BinaryTree.tamari_pred"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_pred()</span></tt></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_succ" title="sage.combinat.binary_tree.BinaryTree.tamari_succ"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_succ()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_interval" title="sage.combinat.binary_tree.BinaryTree.tamari_interval"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_interval()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<p>This tree:</p>
<div class="highlight-python"><div class="highlight"><pre>|       o    |
|      / \   |
|     o   o  |
|    /       |
|   o        |
|  / \       |
| o   o      |
</pre></div>
</div>
<p>is Tamari-<span class="math">\(\leq\)</span> to the following tree:</p>
<div class="highlight-python"><div class="highlight"><pre>|     _o_     |
|    /   \    |
|   o     o   |
|  / \     \  |
| o   o     o |
</pre></div>
</div>
<p>Checking this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[[],</span> <span class="p">[]],</span> <span class="bp">None</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],[]],[</span><span class="bp">None</span><span class="p">,[]]])</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_lequal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
<span class="go">....:     for S in T.tamari_smaller():</span>
<span class="go">....:         if S != T and T.tamari_lequal(S):</span>
<span class="go">....:             print &quot;FAILURE&quot;</span>
<span class="go">....:         if not S.tamari_lequal(T):</span>
<span class="go">....:             print &quot;FAILURE&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.tamari_meet">
<tt class="descname">tamari_meet</tt><big>(</big><em>other</em>, <em>side='right'</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_meet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the meet of the binary trees <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt>
(of equal size) in the <span class="math">\(n\)</span>-th Tamari poset (where <span class="math">\(n\)</span> is
the size of these trees).</p>
<p>The <span class="math">\(n\)</span>-th Tamari poset (defined in <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_lequal()</span></tt></a>)
is known to be a lattice, and the map from the <span class="math">\(n\)</span>-th
symmetric group <span class="math">\(S_n\)</span> to the <span class="math">\(n\)</span>-th Tamari poset defined
by sending every permutation <span class="math">\(p \in S_n\)</span> to the binary
search tree of <span class="math">\(p\)</span> (more precisely, to
<tt class="docutils literal"><span class="pre">p.binary_search_tree_shape()</span></tt>) is a lattice
homomorphism. (See Theorem 6.2 in <a class="reference internal" href="#read04" id="id12">[Read04]</a>.)</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_lequal()</span></tt></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_join" title="sage.combinat.binary_tree.BinaryTree.tamari_join"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_join()</span></tt></a>.</p>
</div>
<p>AUTHORS:</p>
<p>Viviane Pons and Darij Grinberg, 18 June 2014.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,</span> <span class="p">[]],</span> <span class="bp">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="bp">None</span><span class="p">],</span> <span class="bp">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">c</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">c</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">d</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">d</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">d</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">e</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="p">[[[],</span> <span class="bp">None</span><span class="p">],</span> <span class="bp">None</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">b2</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="bp">None</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">b1</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">b2</span><span class="p">)</span>
<span class="go">[[[[., .], .], .], .]</span>
<span class="gp">sage: </span><span class="n">b3</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">b1</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">b3</span><span class="p">)</span>
<span class="go">[[[[., .], .], .], .]</span>
<span class="gp">sage: </span><span class="n">b2</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">b3</span><span class="p">)</span>
<span class="go">[[[[., .], .], .], .]</span>
</pre></div>
</div>
<p>The universal property of the meet operation is
satisfied:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_uni_meet</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
<span class="go">....:     m = p.tamari_meet(q)</span>
<span class="go">....:     if not m.tamari_lequal(p):</span>
<span class="go">....:         return False</span>
<span class="go">....:     if not m.tamari_lequal(q):</span>
<span class="go">....:         return False</span>
<span class="go">....:     for r in p.tamari_smaller():</span>
<span class="go">....:         if r.tamari_lequal(q) and not r.tamari_lequal(m):</span>
<span class="go">....:             return False</span>
<span class="go">....:     return True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">test_uni_meet</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">();</span> <span class="n">q</span> <span class="o">=</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">();</span> <span class="n">test_uni_meet</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Border cases:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([])</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">[., .]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.tamari_pred">
<tt class="descname">tamari_pred</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_pred" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the list of predecessors of <tt class="docutils literal"><span class="pre">self</span></tt> in the Tamari poset.</p>
<p>This list is computed by performing all left rotates possible on
its nodes.</p>
<p>See <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_lequal()</span></tt></a> for the definition of the Tamari poset.</p>
<p>EXAMPLES:</p>
<p>For this tree:</p>
<div class="highlight-python"><div class="highlight"><pre>|     __o__   |
|    /     \  |
|   o       o |
|  / \     /  |
| o   o   o   |
</pre></div>
</div>
<p>the list is:</p>
<div class="highlight-python"><div class="highlight"><pre>|        o ,       _o_   |
|       /         /   \  |
|     _o_        o     o |
|    /   \      /     /  |
|   o     o    o     o   |
|  / \        /          |
| o   o      o           |
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">BinaryTree</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">([</span><span class="n">B</span><span class="p">([</span><span class="n">B</span><span class="p">([</span><span class="n">B</span><span class="p">([]),</span> <span class="bp">None</span><span class="p">]),</span> <span class="bp">None</span><span class="p">]),</span> <span class="bp">None</span><span class="p">]);</span><span class="n">b</span>
<span class="go">[[[[., .], .], .], .]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_pred</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="n">B</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="n">B</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="n">B</span><span class="p">([])])])]);</span><span class="n">b</span>
<span class="go">[., [., [., [., .]]]]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_pred</span><span class="p">()</span>
<span class="go">[[[., .], [., [., .]]], [., [[., .], [., .]]], [., [., [[., .], .]]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.tamari_smaller">
<tt class="descname">tamari_smaller</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_smaller" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of all trees smaller or equal to <tt class="docutils literal"><span class="pre">self</span></tt> in the Tamari
order.</p>
<p>This is the order ideal of the Tamari order generated by <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>See <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_lequal()</span></tt></a> for the definition of the Tamari poset.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_greater" title="sage.combinat.binary_tree.BinaryTree.tamari_greater"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_greater()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<p>The tree:</p>
<div class="highlight-python"><div class="highlight"><pre>|     __o__   |
|    /     \  |
|   o       o |
|  / \     /  |
| o   o   o   |
</pre></div>
</div>
<p>has these trees smaller or equal to it:</p>
<div class="highlight-python"><div class="highlight"><pre>|    __o__  ,       _o_  ,        o ,         o,         o,           o |
|   /     \        /   \         /           /          /            /  |
|  o       o      o     o      _o_          o          o            o   |
| / \     /      /     /      /   \        / \        /            /    |
|o   o   o      o     o      o     o      o   o      o            o     |
|              /            / \          /          /            /      |
|             o            o   o        o          o            o       |
|                                      /          / \          /        |
|                                     o          o   o        o         |
|                                                            /          |
|                                                           o           |
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">BinaryTree</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="n">B</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="n">B</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="n">B</span><span class="p">([])])])]);</span><span class="n">b</span>
<span class="go">[., [., [., [., .]]]]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_smaller</span><span class="p">()</span>
<span class="go">[[., [., [., [., .]]]], [., [., [[., .], .]]],</span>
<span class="go">[., [[., .], [., .]]], [., [[., [., .]], .]],</span>
<span class="go">[., [[[., .], .], .]], [[., .], [., [., .]]],</span>
<span class="go">[[., .], [[., .], .]], [[., [., .]], [., .]],</span>
<span class="go">[[., [., [., .]]], .], [[., [[., .], .]], .],</span>
<span class="go">[[[., .], .], [., .]], [[[., .], [., .]], .],</span>
<span class="go">[[[., [., .]], .], .], [[[[., .], .], .], .]]</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">([</span><span class="n">B</span><span class="p">([</span><span class="n">B</span><span class="p">([</span><span class="n">B</span><span class="p">([]),</span> <span class="bp">None</span><span class="p">]),</span> <span class="bp">None</span><span class="p">]),</span> <span class="bp">None</span><span class="p">]);</span><span class="n">b</span>
<span class="go">[[[[., .], .], .], .]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_smaller</span><span class="p">()</span>
<span class="go">[[[[[., .], .], .], .]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.tamari_succ">
<tt class="descname">tamari_succ</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_succ" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the list of successors of <tt class="docutils literal"><span class="pre">self</span></tt> in the Tamari poset.</p>
<p>This is the list of all trees obtained by a right rotate of
one of its nodes.</p>
<p>See <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><tt class="xref py py-meth docutils literal"><span class="pre">tamari_lequal()</span></tt></a> for the definition of the Tamari poset.</p>
<p>EXAMPLES:</p>
<p>The list of successors of:</p>
<div class="highlight-python"><div class="highlight"><pre>|     __o__   |
|    /     \  |
|   o       o |
|  / \     /  |
| o   o   o   |
</pre></div>
</div>
<p>is:</p>
<div class="highlight-python"><div class="highlight"><pre>|   _o__     ,   ___o___  ,     _o_     |
|  /    \       /       \      /   \    |
| o     _o_    o         o    o     o   |
|      /   \    \       /    / \     \  |
|     o     o    o     o    o   o     o |
|          /      \                     |
|         o        o                    |
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">BinaryTree</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">([</span><span class="n">B</span><span class="p">([</span><span class="n">B</span><span class="p">([</span><span class="n">B</span><span class="p">([]),</span> <span class="bp">None</span><span class="p">]),</span> <span class="bp">None</span><span class="p">]),</span> <span class="bp">None</span><span class="p">]);</span><span class="n">b</span>
<span class="go">[[[[., .], .], .], .]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_succ</span><span class="p">()</span>
<span class="go">[[[[., .], .], [., .]], [[[., .], [., .]], .], [[[., [., .]], .], .]]</span>

<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">([])</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_succ</span><span class="p">()</span>
<span class="go">[]</span>

<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_succ</span><span class="p">()</span>
<span class="go">[[., [., [., .]]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.to_132_avoiding_permutation">
<tt class="descname">to_132_avoiding_permutation</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_132_avoiding_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 132-avoiding permutation corresponding to the binary tree.</p>
<p>The linear extensions of a binary tree form an interval of the weak
order called the sylvester class of the tree. This permutation is
the maximal element of this sylvester class.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_132_avoiding_permutation</span><span class="p">()</span>
<span class="go">[3, 1, 2]</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_132_avoiding_permutation</span><span class="p">()</span>
<span class="go">[8, 6, 7, 3, 4, 1, 2, 5]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">==</span> <span class="n">bt</span><span class="o">.</span><span class="n">to_132_avoiding_permutation</span><span class="p">()</span><span class="o">.</span><span class="n">binary_search_tree_shape</span><span class="p">(</span><span class="n">left_to_right</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">==</span> <span class="n">bt</span><span class="o">.</span><span class="n">to_132_avoiding_permutation</span><span class="p">()</span><span class="o">.</span><span class="n">binary_search_tree_shape</span><span class="p">(</span><span class="n">left_to_right</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.to_312_avoiding_permutation">
<tt class="descname">to_312_avoiding_permutation</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_312_avoiding_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 312-avoiding permutation corresponding to the binary tree.</p>
<p>The linear extensions of a binary tree form an interval of the weak
order called the sylvester class of the tree. This permutation is
the minimal element of this sylvester class.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_312_avoiding_permutation</span><span class="p">()</span>
<span class="go">[1, 3, 2]</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_312_avoiding_permutation</span><span class="p">()</span>
<span class="go">[1, 3, 4, 2, 6, 8, 7, 5]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">==</span> <span class="n">bt</span><span class="o">.</span><span class="n">to_312_avoiding_permutation</span><span class="p">()</span><span class="o">.</span><span class="n">binary_search_tree_shape</span><span class="p">(</span><span class="n">left_to_right</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">==</span> <span class="n">bt</span><span class="o">.</span><span class="n">to_312_avoiding_permutation</span><span class="p">()</span><span class="o">.</span><span class="n">binary_search_tree_shape</span><span class="p">(</span><span class="n">left_to_right</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.to_dyck_word">
<tt class="descname">to_dyck_word</tt><big>(</big><em>usemap='1L0R'</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_dyck_word" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Dyck word associated with <tt class="docutils literal"><span class="pre">self</span></tt> using the given map.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">usemap</span></tt> &#8211; a string, either <tt class="docutils literal"><span class="pre">1L0R</span></tt>, <tt class="docutils literal"><span class="pre">1R0L</span></tt>, <tt class="docutils literal"><span class="pre">L1R0</span></tt>, <tt class="docutils literal"><span class="pre">R1L0</span></tt></li>
</ul>
<p>The bijection is defined recursively as follows:</p>
<ul class="simple">
<li>a leaf is associated to the empty Dyck Word</li>
<li>a tree with children <span class="math">\(l,r\)</span> is associated with the Dyck word
described by <tt class="docutils literal"><span class="pre">usemap</span></tt> where <span class="math">\(L\)</span> and <span class="math">\(R\)</span> are respectively the
Dyck words associated with the trees <span class="math">\(l\)</span> and <span class="math">\(r\)</span>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">()</span>
<span class="go">[1, 0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">()</span>
<span class="go">[1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],</span><span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">()</span>
<span class="go">[1, 1, 0, 1, 0, 0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],</span><span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">(</span><span class="s">&quot;1R0L&quot;</span><span class="p">)</span>
<span class="go">[1, 0, 1, 1, 0, 0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],</span><span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">(</span><span class="s">&quot;L1R0&quot;</span><span class="p">)</span>
<span class="go">[1, 1, 0, 0, 1, 0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],</span><span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">(</span><span class="s">&quot;R1L0&quot;</span><span class="p">)</span>
<span class="go">[1, 1, 0, 1, 0, 0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],</span><span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">(</span><span class="s">&quot;R10L&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">R10L is not a correct map</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">==</span> <span class="n">bt</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">()</span><span class="o">.</span><span class="n">to_binary_tree</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">==</span> <span class="n">bt</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">(</span><span class="s">&quot;1R0L&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_binary_tree</span><span class="p">(</span><span class="s">&quot;1R0L&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">==</span> <span class="n">bt</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">(</span><span class="s">&quot;L1R0&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_binary_tree</span><span class="p">(</span><span class="s">&quot;L1R0&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">==</span> <span class="n">bt</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">(</span><span class="s">&quot;R1L0&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_binary_tree</span><span class="p">(</span><span class="s">&quot;R1L0&quot;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.to_dyck_word_tamari">
<tt class="descname">to_dyck_word_tamari</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_dyck_word_tamari" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Dyck word associated with <tt class="docutils literal"><span class="pre">self</span></tt> in consistency with
the Tamari order on Dyck words and binary trees.</p>
<p>The bijection is defined recursively as follows:</p>
<ul class="simple">
<li>a leaf is associated with an empty Dyck word;</li>
<li>a tree with children <span class="math">\(l,r\)</span> is associated with the Dyck word
<span class="math">\(T(l) 1 T(r) 0\)</span>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">to_dyck_word_tamari</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">to_dyck_word_tamari</span><span class="p">()</span>
<span class="go">[1, 0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],</span><span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">to_dyck_word_tamari</span><span class="p">()</span>
<span class="go">[1, 1, 0, 0, 1, 0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span><span class="o">.</span><span class="n">to_dyck_word_tamari</span><span class="p">()</span>
<span class="go">[1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.to_ordered_tree_left_branch">
<tt class="descname">to_ordered_tree_left_branch</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_ordered_tree_left_branch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ordered tree of size <span class="math">\(n+1\)</span> by the following recursive rule:</p>
<ul class="simple">
<li>if <span class="math">\(x\)</span> is the left child of <span class="math">\(y\)</span>, <span class="math">\(x\)</span> becomes the left brother
of <span class="math">\(y\)</span></li>
<li>if <span class="math">\(x\)</span> is the right child of <span class="math">\(y\)</span>, <span class="math">\(x\)</span> becomes the last child
of <span class="math">\(y\)</span></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_ordered_tree_left_branch</span><span class="p">()</span>
<span class="go">[[], [[]]]</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_ordered_tree_left_branch</span><span class="p">()</span>
<span class="go">[[], [[], []], [[], [[]]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.to_ordered_tree_right_branch">
<tt class="descname">to_ordered_tree_right_branch</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_ordered_tree_right_branch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ordered tree of size <span class="math">\(n+1\)</span> by the following recursive rule:</p>
<ul class="simple">
<li>if <span class="math">\(x\)</span> is the right child of <span class="math">\(y\)</span>, <span class="math">\(x\)</span> becomes the right brother
of <span class="math">\(y\)</span></li>
<li>if <span class="math">\(x\)</span> is the left child of <span class="math">\(y\)</span>, <span class="math">\(x\)</span> becomes the first child
of <span class="math">\(y\)</span></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_ordered_tree_right_branch</span><span class="p">()</span>
<span class="go">[[[]], []]</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="bp">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_ordered_tree_right_branch</span><span class="p">()</span>
<span class="go">[[[[]], [[]]], [[]], []]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.to_poset">
<tt class="descname">to_poset</tt><big>(</big><em>with_leaves=False</em>, <em>root_to_leaf=False</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_poset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the poset obtained by interpreting the tree as a Hasse
diagram.</p>
<p>The default orientation is from leaves to root but you can
pass <tt class="docutils literal"><span class="pre">root_to_leaf=True</span></tt> to obtain the inverse orientation.</p>
<p>Leaves are ignored by default, but one can set <tt class="docutils literal"><span class="pre">with_leaves</span></tt> to
<tt class="docutils literal"><span class="pre">True</span></tt> to obtain the poset of the complete tree.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">with_leaves</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a Boolean, determining
whether the resulting poset will be formed from the leaves
and the nodes of <tt class="docutils literal"><span class="pre">self</span></tt> (if <tt class="docutils literal"><span class="pre">True</span></tt>), or only from the
nodes of <tt class="docutils literal"><span class="pre">self</span></tt> (if <tt class="docutils literal"><span class="pre">False</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">root_to_leaf</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a Boolean,
determining whether the poset orientation should be from root
to leaves (if <tt class="docutils literal"><span class="pre">True</span></tt>) or from leaves to root (if <tt class="docutils literal"><span class="pre">False</span></tt>).</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_poset</span><span class="p">()</span>
<span class="go">Finite poset containing 1 elements</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_poset</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_poset</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [0, 2]]</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_poset</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">root_to_leaf</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 2]]</span>
</pre></div>
</div>
<p>If the tree is labelled, we use its labelling to label the poset.
Otherwise, we use the poset canonical labelling:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[</span><span class="bp">None</span><span class="p">,[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bt</span>
<span class="go">2[1[., .], 3[., 4[., .]]]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_poset</span><span class="p">()</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[4, 3], [3, 2], [1, 2]]</span>
</pre></div>
</div>
<p>Let us check that the empty binary tree is correctly handled:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_poset</span><span class="p">()</span>
<span class="go">Finite poset containing 0 elements</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_poset</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Finite poset containing 1 elements</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.to_undirected_graph">
<tt class="descname">to_undirected_graph</tt><big>(</big><em>with_leaves=False</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_undirected_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the undirected graph obtained from the tree nodes and edges.</p>
<p>Leaves are ignored by default, but one can set <tt class="docutils literal"><span class="pre">with_leaves</span></tt> to
<tt class="docutils literal"><span class="pre">True</span></tt> to obtain the graph of the complete tree.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">with_leaves</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) a Boolean, determining
whether the resulting graph will be formed from the leaves
and the nodes of <tt class="docutils literal"><span class="pre">self</span></tt> (if <tt class="docutils literal"><span class="pre">True</span></tt>), or only from the
nodes of <tt class="docutils literal"><span class="pre">self</span></tt> (if <tt class="docutils literal"><span class="pre">False</span></tt>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">()</span>
<span class="go">Graph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Graph on 3 vertices</span>

<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">()</span>
<span class="go">Graph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Graph on 1 vertex</span>
</pre></div>
</div>
<p>If the tree is labelled, we use its labelling to label the graph.
Otherwise, we use the graph canonical labelling which means that
two different trees can have the same graph.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[</span><span class="bp">None</span><span class="p">,[]]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="go">2[1[., .], 3[., 4[., .]]]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(1, 2, None), (2, 3, None), (3, 4, None)]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 3, None), (1, 2, None), (2, 3, None)]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">()</span> <span class="o">==</span> <span class="n">bt</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],[]])</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">()</span> <span class="o">==</span> <span class="n">BinaryTree</span><span class="p">([[[],</span><span class="bp">None</span><span class="p">],</span><span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTree.under">
<tt class="descname">under</tt><big>(</big><em>bt</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.under" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">self</span></tt> under <tt class="docutils literal"><span class="pre">bt</span></tt>, where &#8220;under&#8221; is the <tt class="docutils literal"><span class="pre">under</span></tt>
(<span class="math">\(\backslash\)</span>) operation.</p>
<p>If <span class="math">\(T\)</span> and <span class="math">\(T'\)</span> are two binary trees, then <span class="math">\(T\)</span> under <span class="math">\(T'\)</span>
(written <span class="math">\(T \backslash T'\)</span>) is defined as the tree obtained
by grafting <span class="math">\(T\)</span> on the leftmost leaf of <span class="math">\(T'\)</span>. More precisely,
<span class="math">\(T \backslash T'\)</span> is defined by identifying the root of <span class="math">\(T\)</span>
with the leftmost leaf of <span class="math">\(T'\)</span>.</p>
<p>If <span class="math">\(T'\)</span> is empty, then <span class="math">\(T \backslash T' = T\)</span>.</p>
<p>The definition of this &#8220;under&#8221; operation goes back to
Loday-Ronco <a class="reference internal" href="permutation.html#lodron0102066" id="id13">[LodRon0102066]</a> (Definition 2.2), but it is
denoted by <span class="math">\(/\)</span> and called the &#8220;over&#8221; operation there. In fact,
trees in sage have their root at the top, contrary to the trees
in <a class="reference internal" href="permutation.html#lodron0102066" id="id14">[LodRon0102066]</a> which are growing upwards. For this reason,
the names of the over and under operations are swapped, in
order to keep a graphical meaning.
(Our notation follows that of section 4.5 of <a class="reference internal" href="#hnt05" id="id15">[HNT05]</a>.)</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.over" title="sage.combinat.binary_tree.BinaryTree.over"><tt class="xref py py-meth docutils literal"><span class="pre">over()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<p>Showing only the nodes of a binary tree, here is an
example for the under operation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">b2</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,[]])</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">((</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b1</span> \ <span class="n">b2</span><span class="p">))</span>
<span class="go">(   o    o        _o_   )</span>
<span class="go">(  / \    \      /   \  )</span>
<span class="go">( o   o,   o,   o     o )</span>
<span class="go">(              / \      )</span>
<span class="go">(             o   o     )</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[[</span><span class="bp">None</span><span class="p">,[]],</span><span class="bp">None</span><span class="p">]]);</span> <span class="n">ascii_art</span><span class="p">([</span><span class="n">b1</span><span class="p">])</span>
<span class="go">[   _o_   ]</span>
<span class="go">[  /   \  ]</span>
<span class="go">[ o     o ]</span>
<span class="go">[      /  ]</span>
<span class="go">[     o   ]</span>
<span class="go">[      \  ]</span>
<span class="go">[       o ]</span>
<span class="gp">sage: </span><span class="n">b2</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[</span><span class="bp">None</span><span class="p">,[]]]);</span> <span class="n">ascii_art</span><span class="p">([</span><span class="n">b2</span><span class="p">])</span>
<span class="go">[   o     ]</span>
<span class="go">[  / \    ]</span>
<span class="go">[ o   o   ]</span>
<span class="go">[      \  ]</span>
<span class="go">[       o ]</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">([</span><span class="n">b1</span><span class="o">.</span><span class="n">under</span><span class="p">(</span><span class="n">b2</span><span class="p">)])</span>
<span class="go">[        o_     ]</span>
<span class="go">[       /  \    ]</span>
<span class="go">[      o    o   ]</span>
<span class="go">[     /      \  ]</span>
<span class="go">[   _o_       o ]</span>
<span class="go">[  /   \        ]</span>
<span class="go">[ o     o       ]</span>
<span class="go">[      /        ]</span>
<span class="go">[     o         ]</span>
<span class="go">[      \        ]</span>
<span class="go">[       o       ]</span>
</pre></div>
</div>
<p>The same in the labelled case:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b1</span> <span class="o">=</span> <span class="n">b1</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b2</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">([</span><span class="n">b1</span><span class="o">.</span><span class="n">under</span><span class="p">(</span><span class="n">b2</span><span class="p">)])</span>
<span class="go">[        2_     ]</span>
<span class="go">[       /  \    ]</span>
<span class="go">[      1    3   ]</span>
<span class="go">[     /      \  ]</span>
<span class="go">[   _2_       4 ]</span>
<span class="go">[  /   \        ]</span>
<span class="go">[ 1     5       ]</span>
<span class="go">[      /        ]</span>
<span class="go">[     3         ]</span>
<span class="go">[      \        ]</span>
<span class="go">[       4       ]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.binary_tree.BinaryTrees">
<em class="property">class </em><tt class="descclassname">sage.combinat.binary_tree.</tt><tt class="descname">BinaryTrees</tt><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Basic Structures v6.6)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></tt></a>, <a class="reference external" href="../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Basic Structures v6.6)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.parent.Parent</span></tt></a></p>
<p>Factory for binary trees.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">size</span></tt> &#8211; (optional) an integer</li>
</ul>
<p>OUPUT:</p>
<ul class="simple">
<li>the set of all binary trees (of the given <tt class="docutils literal"><span class="pre">size</span></tt> if specified)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">()</span>
<span class="go">Binary trees</span>

<span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Binary trees of size 2</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this is a factory class whose constructor returns instances of
subclasses.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the fact that BinaryTrees is a class instead of a simple callable
is an implementation detail. It could be changed in the future
and one should not rely on it.</p>
</div>
<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTrees.leaf">
<tt class="descname">leaf</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees.leaf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a leaf tree with <tt class="docutils literal"><span class="pre">self</span></tt> as parent.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">()</span><span class="o">.</span><span class="n">leaf</span><span class="p">()</span>
<span class="go">.</span>
</pre></div>
</div>
<p>TEST:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="p">(</span><span class="n">BinaryTrees</span><span class="p">()</span><span class="o">.</span><span class="n">leaf</span><span class="p">()</span> <span class="ow">is</span>
<span class="go">....:  sage.combinat.binary_tree.BinaryTrees_all().leaf())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.binary_tree.BinaryTrees_all">
<em class="property">class </em><tt class="descclassname">sage.combinat.binary_tree.</tt><tt class="descname">BinaryTrees_all</tt><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/sets/disjoint_union_enumerated_sets.html#sage.sets.disjoint_union_enumerated_sets.DisjointUnionEnumeratedSets" title="(in Sage Reference Manual: Basic Structures v6.6)"><tt class="xref py py-class docutils literal"><span class="pre">sage.sets.disjoint_union_enumerated_sets.DisjointUnionEnumeratedSets</span></tt></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTrees" title="sage.combinat.binary_tree.BinaryTrees"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.binary_tree.BinaryTrees</span></tt></a></p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.binary_tree</span> <span class="kn">import</span> <span class="n">BinaryTrees_all</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">BinaryTrees_all</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">+Infinity</span>

<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
<span class="go">(., [., .], [., [., .]], [[., .], .], [., [., [., .]]])</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Binary trees</span>
<span class="gp">sage: </span><span class="n">B</span><span class="p">([])</span>
<span class="go">[., .]</span>

<span class="gp">sage: </span><span class="n">B</span> <span class="ow">is</span> <span class="n">BinaryTrees_all</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span> <span class="c"># long time</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="sage.combinat.binary_tree.BinaryTrees_all.Element">
<tt class="descname">Element</tt><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees_all.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree" title="sage.combinat.binary_tree.BinaryTree"><tt class="xref py py-class docutils literal"><span class="pre">BinaryTree</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTrees_all.labelled_trees">
<tt class="descname">labelled_trees</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees_all.labelled_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of labelled trees associated to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">()</span><span class="o">.</span><span class="n">labelled_trees</span><span class="p">()</span>
<span class="go">Labelled binary trees</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTrees_all.unlabelled_trees">
<tt class="descname">unlabelled_trees</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees_all.unlabelled_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of unlabelled trees associated to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">()</span><span class="o">.</span><span class="n">unlabelled_trees</span><span class="p">()</span>
<span class="go">Binary trees</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.binary_tree.BinaryTrees_size">
<em class="property">class </em><tt class="descclassname">sage.combinat.binary_tree.</tt><tt class="descname">BinaryTrees_size</tt><big>(</big><em>size</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTrees" title="sage.combinat.binary_tree.BinaryTrees"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.binary_tree.BinaryTrees</span></tt></a></p>
<p>The enumerated sets of binary trees of given size</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.binary_tree</span> <span class="kn">import</span> <span class="n">BinaryTrees_size</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span> <span class="n">TestSuite</span><span class="p">(</span><span class="n">BinaryTrees_size</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTrees_size.cardinality">
<tt class="descname">cardinality</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees_size.cardinality" title="Permalink to this definition">¶</a></dt>
<dd><p>The cardinality of <tt class="docutils literal"><span class="pre">self</span></tt></p>
<p>This is a Catalan number.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">42</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTrees_size.element_class">
<tt class="descname">element_class</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees_size.element_class" title="Permalink to this definition">¶</a></dt>
<dd><p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">element_class</span>
<span class="go">&lt;class &#39;sage.combinat.binary_tree.BinaryTrees_all_with_category.element_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">__class__</span> <span class="o">==</span> <span class="n">BinaryTrees</span><span class="p">()</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">__class__</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.BinaryTrees_size.random_element">
<tt class="descname">random_element</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees_size.random_element" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random <tt class="docutils literal"><span class="pre">BinaryTree</span></tt> with uniform probability.</p>
<p>This method generates a random <tt class="docutils literal"><span class="pre">DyckWord</span></tt> and then uses a
bijection between Dyck words and binary trees.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span> <span class="c"># random</span>
<span class="go">[., [., [., [., [., .]]]]]</span>
<span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="go">[., .]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span><span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.binary_tree.LabelledBinaryTree">
<em class="property">class </em><tt class="descclassname">sage.combinat.binary_tree.</tt><tt class="descname">LabelledBinaryTree</tt><big>(</big><em>parent</em>, <em>children</em>, <em>label=None</em>, <em>check=True</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="abstract_tree.html#sage.combinat.abstract_tree.AbstractLabelledClonableTree" title="sage.combinat.abstract_tree.AbstractLabelledClonableTree"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.abstract_tree.AbstractLabelledClonableTree</span></tt></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree" title="sage.combinat.binary_tree.BinaryTree"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.binary_tree.BinaryTree</span></tt></a></p>
<p>Labelled binary trees.</p>
<p>A labelled binary tree is a binary tree (see <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree" title="sage.combinat.binary_tree.BinaryTree"><tt class="xref py py-class docutils literal"><span class="pre">BinaryTree</span></tt></a> for
the meaning of this) with a label assigned to each node.
The labels need not be integers, nor are they required to be distinct.
<tt class="docutils literal"><span class="pre">None</span></tt> can be used as a label.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">While it is possible to assign values to leaves (not just nodes)
using this class, these labels are disregarded by various
methods such as
<a class="reference internal" href="abstract_tree.html#sage.combinat.abstract_tree.AbstractLabelledTree.labels" title="sage.combinat.abstract_tree.AbstractLabelledTree.labels"><tt class="xref py py-meth docutils literal"><span class="pre">labels()</span></tt></a>,
<tt class="xref py py-meth docutils literal"><span class="pre">map_labels()</span></tt>,
and (ironically)
<a class="reference internal" href="abstract_tree.html#sage.combinat.abstract_tree.AbstractLabelledTree.leaf_labels" title="sage.combinat.abstract_tree.AbstractLabelledTree.leaf_labels"><tt class="xref py py-meth docutils literal"><span class="pre">leaf_labels()</span></tt></a>.</p>
</div>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">children</span></tt> &#8211; <tt class="docutils literal"><span class="pre">None</span></tt> (default) or a list, tuple or iterable of
length <span class="math">\(2\)</span> of labelled binary trees or convertible objects. This
corresponds to the standard recursive definition of a labelled
binary tree as being either a leaf, or a pair of:</p>
<ul class="simple">
<li>a pair of labelled binary trees,</li>
<li>and a label.</li>
</ul>
<p>(The label is specified in the keyword variable <tt class="docutils literal"><span class="pre">label</span></tt>; see
below.)</p>
<p>Syntactic sugar allows leaving out all but the outermost calls
of the <tt class="docutils literal"><span class="pre">LabelledBinaryTree()</span></tt> constructor, so that, e. g.,
<tt class="docutils literal"><span class="pre">LabelledBinaryTree([LabelledBinaryTree(None),LabelledBinaryTree(None)])</span></tt>
can be shortened to <tt class="docutils literal"><span class="pre">LabelledBinaryTree([None,None])</span></tt>. However,
using this shorthand, it is impossible to label any vertex of
the tree other than the root (because there is no way to pass a
<tt class="docutils literal"><span class="pre">label</span></tt> variable without calling <tt class="docutils literal"><span class="pre">LabelledBinaryTree</span></tt>
explicitly).</p>
<p>It is also allowed to abbreviate <tt class="docutils literal"><span class="pre">[None,</span> <span class="pre">None]</span></tt> by <tt class="docutils literal"><span class="pre">[]</span></tt> if
one does not want to label the leaves (which one should not do
anyway!).</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">label</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) the label to be put on the root
of this tree.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">check</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) whether checks should be
performed or not.</p>
</li>
</ul>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">It is currently not possible to use <tt class="docutils literal"><span class="pre">LabelledBinaryTree()</span></tt>
as a shorthand for <tt class="docutils literal"><span class="pre">LabelledBinaryTree(None)</span></tt> (in analogy to
similar syntax in the <tt class="docutils literal"><span class="pre">BinaryTree</span></tt> class).</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&quot;ae&quot;</span><span class="p">)</span>    <span class="c"># not well supported</span>
<span class="go">&#39;ae&#39;</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([])</span>
<span class="go">None[., .]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([],</span> <span class="n">label</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>    <span class="c"># not well supported</span>
<span class="go">3[., .]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">])</span>
<span class="go">None[., .]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">5[., .]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="p">[]])</span>
<span class="go">None[., None[., .]]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="p">[]],</span> <span class="n">label</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">4[., None[., .]]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([[],</span> <span class="bp">None</span><span class="p">])</span>
<span class="go">None[None[., .], .]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">(</span><span class="s">&quot;[[], .]&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">False[None[., .], .]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="n">LabelledBinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="mi">4</span><span class="p">)],</span> <span class="n">label</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3[., 4[., .]]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">])],</span> <span class="n">label</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3[., None[., .]]</span>

<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([[],</span> <span class="bp">None</span><span class="p">,</span> <span class="p">[]])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">this is not a binary tree</span>

<span class="gp">sage: </span><span class="n">LBT</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">LBT</span><span class="p">([[</span><span class="n">LBT</span><span class="p">([],</span> <span class="n">label</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="bp">None</span><span class="p">],</span> <span class="bp">None</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="mi">4</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">4[None[2[., .], .], .]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,</span> <span class="p">[[],[[],</span> <span class="bp">None</span><span class="p">]]],[[],[]]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span><span class="p">([[[],[]],[]])</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">t1</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t1c</span><span class="p">:</span>
<span class="go">....:     t1c[1,1,1] = t2</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">==</span> <span class="n">t1c</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We check for <a class="reference external" href="http://trac.sagemath.org/16314">trac ticket #16314</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">LBT</span><span class="p">([</span> <span class="n">LBT</span><span class="p">([</span><span class="n">LBT</span><span class="p">([],</span> <span class="n">label</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
<span class="go">....:                 LBT([], label=5)], label=6),</span>
<span class="go">....:            None], label=4); t1</span>
<span class="go">4[6[2[., .], 5[., .]], .]</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">LabelledBinaryTree</span><span class="p">):</span>
<span class="go">....:     pass</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="n">t1</span><span class="p">);</span> <span class="n">t2</span>
<span class="go">4[6[2[., .], 5[., .]], .]</span>
<span class="gp">sage: </span><span class="n">t2</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">t2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">t2</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="n">t2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">__class__</span>
<span class="go">(&lt;class &#39;__main__.Foo&#39;&gt;, &lt;class &#39;__main__.Foo&#39;&gt;)</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.binary_tree.LabelledBinaryTree.binary_search_insert">
<tt class="descname">binary_search_insert</tt><big>(</big><em>letter</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTree.binary_search_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of inserting a letter <tt class="docutils literal"><span class="pre">letter</span></tt> into the
right strict binary search tree <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">letter</span></tt> &#8211; any object comparable with the labels of <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>OUTPUT:</p>
<p>The right strict binary search tree <tt class="docutils literal"><span class="pre">self</span></tt> with <tt class="docutils literal"><span class="pre">letter</span></tt>
inserted into it according to the binary search insertion
algorithm.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">self</span></tt> is supposed to be a binary search tree.
This is not being checked!</p>
</div>
<p>A right strict binary search tree is defined to be a labelled
binary tree such that for each node <span class="math">\(n\)</span> with label <span class="math">\(x\)</span>,
every descendant of the left child of <span class="math">\(n\)</span> has a label <span class="math">\(\leq x\)</span>,
and every descendant of the right child of <span class="math">\(n\)</span> has a label
<span class="math">\(&gt; x\)</span>. (Here, only nodes count as descendants, and every node
counts as its own descendant too.) Leaves are assumed to have
no labels.</p>
<p>Given a right strict binary search tree <span class="math">\(t\)</span> and a letter <span class="math">\(i\)</span>,
the result of inserting <span class="math">\(i\)</span> into <span class="math">\(t\)</span> (denoted <span class="math">\(Ins(i, t)\)</span> in
the following) is defined recursively as follows:</p>
<ul class="simple">
<li>If <span class="math">\(t\)</span> is empty, then <span class="math">\(Ins(i, t)\)</span> is the tree with one node
only, and this node is labelled with <span class="math">\(i\)</span>.</li>
<li>Otherwise, let <span class="math">\(j\)</span> be the label of the root of <span class="math">\(t\)</span>. If
<span class="math">\(i &gt; j\)</span>, then <span class="math">\(Ins(i, t)\)</span> is obtained by replacing the
right child of <span class="math">\(t\)</span> by <span class="math">\(Ins(i, r)\)</span> in <span class="math">\(t\)</span>, where <span class="math">\(r\)</span> denotes
the right child of <span class="math">\(t\)</span>. If <span class="math">\(i \leq j\)</span>, then <span class="math">\(Ins(i, t)\)</span> is
obtained by replacing the left child of <span class="math">\(t\)</span> by <span class="math">\(Ins(i, l)\)</span>
in <span class="math">\(t\)</span>, where <span class="math">\(l\)</span> denotes the left child of <span class="math">\(t\)</span>.</li>
</ul>
<p>See, for example, <a class="reference internal" href="#hnt05" id="id16">[HNT05]</a> for properties of this algorithm.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If <span class="math">\(t\)</span> is nonempty, then inserting <span class="math">\(i\)</span> into <span class="math">\(t\)</span> does not
change the root label of <span class="math">\(t\)</span>. Hence, as opposed to
algorithms like Robinson-Schensted-Knuth, binary
search tree insertion involves no bumping.</p>
</div>
<p>EXAMPLES:</p>
<p>The example from Fig. 2 of <a class="reference internal" href="#hnt05" id="id17">[HNT05]</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LBT</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">LBT</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[., .]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[., d[., .]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[., d[., e[., .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[a[., .], d[., e[., .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[a[., b[., .]], d[., e[., .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[a[., b[., .]], d[d[., .], e[., .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[a[a[., .], b[., .]], d[d[., .], e[., .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[a[a[., .], b[., .]], d[d[c[., .], .], e[., .]]]</span>
</pre></div>
</div>
<p>Other examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LBT</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span>
<span class="gp">sage: </span><span class="n">LBT</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3[., .]</span>
<span class="gp">sage: </span><span class="n">LBT</span><span class="p">([],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1[., 3[., .]]</span>
<span class="gp">sage: </span><span class="n">LBT</span><span class="p">([],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3[1[., .], .]</span>
<span class="gp">sage: </span><span class="n">res</span> <span class="o">=</span> <span class="n">LBT</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]:</span>
<span class="go">....:     res = res.binary_search_insert(i)</span>
<span class="gp">sage: </span><span class="n">res</span>
<span class="go">3[1[., 2[., .]], 5[4[., .], 6[., .]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.LabelledBinaryTree.heap_insert">
<tt class="descname">heap_insert</tt><big>(</big><em>l</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTree.heap_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of inserting a letter <tt class="docutils literal"><span class="pre">l</span></tt> into the binary
heap (tree) <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>A binary heap is a labelled complete binary tree such that for
each node, the label at the node is greater or equal to the
label of each of its child nodes. (More precisely, this is
called a max-heap.)</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>|     _7_   |
|    /   \  |
|   5     6 |
|  / \      |
| 3   4     |
</pre></div>
</div>
<p>is a binary heap.</p>
<p>See <a class="reference external" href="http://en.wikipedia.org/wiki/Binary_heap#Insert">Wikipedia article Binary_heap#Insert</a> for a description of how to
insert a letter into a binary heap. The result is another binary
heap.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">letter</span></tt> &#8211; any object comparable with the labels of <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">self</span></tt> is assumed to be a binary heap (tree). No check is
performed.</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">heap_insert</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">ascii_art</span><span class="p">([</span><span class="n">h</span><span class="p">])</span>
<span class="go">[ 3 ]</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">heap_insert</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">ascii_art</span><span class="p">([</span><span class="n">h</span><span class="p">])</span>
<span class="go">[   4 ]</span>
<span class="go">[  /  ]</span>
<span class="go">[ 3   ]</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">heap_insert</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span> <span class="n">ascii_art</span><span class="p">([</span><span class="n">h</span><span class="p">])</span>
<span class="go">[   6   ]</span>
<span class="go">[  / \  ]</span>
<span class="go">[ 3   4 ]</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">heap_insert</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">ascii_art</span><span class="p">([</span><span class="n">h</span><span class="p">])</span>
<span class="go">[     6   ]</span>
<span class="go">[    / \  ]</span>
<span class="go">[   3   4 ]</span>
<span class="go">[  /      ]</span>
<span class="go">[ 2       ]</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">([</span><span class="n">h</span><span class="o">.</span><span class="n">heap_insert</span><span class="p">(</span><span class="mi">5</span><span class="p">)])</span>
<span class="go">[     _6_   ]</span>
<span class="go">[    /   \  ]</span>
<span class="go">[   5     4 ]</span>
<span class="go">[  / \      ]</span>
<span class="go">[ 2   3     ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.LabelledBinaryTree.left_rotate">
<tt class="descname">left_rotate</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTree.left_rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of left rotation applied to the labelled
binary tree <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Left rotation on labelled binary trees is defined as
follows: Let <span class="math">\(T\)</span> be a labelled binary tree such that the
right child of the root of <span class="math">\(T\)</span> is a node. Let
<span class="math">\(A\)</span> be the left child of the root of <span class="math">\(T\)</span>, and let <span class="math">\(B\)</span>
and <span class="math">\(C\)</span> be the left and right children of the right child
of the root of <span class="math">\(T\)</span>. (Keep in mind that nodes of trees are
identified with the subtrees consisting of their
descendants.) Furthermore, let <span class="math">\(x\)</span> be the label at the
root of <span class="math">\(T\)</span>, and <span class="math">\(y\)</span> be the label at the right child of the
root of <span class="math">\(T\)</span>.
Then, the left rotation of <span class="math">\(T\)</span> is the labelled binary tree
in which the root is labelled <span class="math">\(y\)</span>, the right child of the
root is <span class="math">\(C\)</span>, whereas the left child of the root is a node
labelled <span class="math">\(x\)</span> whose left and right children are <span class="math">\(A\)</span> and <span class="math">\(B\)</span>.
In pictures:</p>
<div class="highlight-python"><div class="highlight"><pre>|     y                    x     |
|    / \                  / \    |
|   x   C &lt;-left-rotate- A   y   |
|  / \                      / \  |
| A   B                    B   C |
</pre></div>
</div>
<p>Left rotation is the inverse operation to right rotation
(<a class="reference internal" href="#sage.combinat.binary_tree.LabelledBinaryTree.right_rotate" title="sage.combinat.binary_tree.LabelledBinaryTree.right_rotate"><tt class="xref py py-meth docutils literal"><span class="pre">right_rotate()</span></tt></a>).</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LB</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">LB</span><span class="p">([</span><span class="n">LB</span><span class="p">([</span><span class="n">LB</span><span class="p">([],</span><span class="s">&quot;A&quot;</span><span class="p">),</span> <span class="n">LB</span><span class="p">([],</span><span class="s">&quot;B&quot;</span><span class="p">)],</span><span class="s">&quot;x&quot;</span><span class="p">),</span><span class="n">LB</span><span class="p">([],</span><span class="s">&quot;C&quot;</span><span class="p">)],</span> <span class="s">&quot;y&quot;</span><span class="p">);</span> <span class="n">b</span>
<span class="go">y[x[A[., .], B[., .]], C[., .]]</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">right_rotate</span><span class="p">()</span><span class="o">.</span><span class="n">left_rotate</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.LabelledBinaryTree.right_rotate">
<tt class="descname">right_rotate</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTree.right_rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of right rotation applied to the labelled
binary tree <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Right rotation on labelled binary trees is defined as
follows: Let <span class="math">\(T\)</span> be a labelled binary tree such that the
left child of the root of <span class="math">\(T\)</span> is a node. Let
<span class="math">\(C\)</span> be the right child of the root of <span class="math">\(T\)</span>, and let <span class="math">\(A\)</span>
and <span class="math">\(B\)</span> be the left and right children of the left child
of the root of <span class="math">\(T\)</span>. (Keep in mind that nodes of trees are
identified with the subtrees consisting of their
descendants.) Furthermore, let <span class="math">\(y\)</span> be the label at the
root of <span class="math">\(T\)</span>, and <span class="math">\(x\)</span> be the label at the left child of the
root of <span class="math">\(T\)</span>.
Then, the right rotation of <span class="math">\(T\)</span> is the labelled binary
tree in which the root is labelled <span class="math">\(x\)</span>, the left child of
the root is <span class="math">\(A\)</span>, whereas the right child of the root is a
node labelled <span class="math">\(y\)</span> whose left and right children are <span class="math">\(B\)</span>
and <span class="math">\(C\)</span>. In pictures:</p>
<div class="highlight-python"><div class="highlight"><pre>|     y                      x     |
|    / \                    / \    |
|   x   C -right-rotate-&gt;  A   y   |
|  / \                        / \  |
| A   B                      B   C |
</pre></div>
</div>
<p>Right rotation is the inverse operation to left rotation
(<a class="reference internal" href="#sage.combinat.binary_tree.LabelledBinaryTree.left_rotate" title="sage.combinat.binary_tree.LabelledBinaryTree.left_rotate"><tt class="xref py py-meth docutils literal"><span class="pre">left_rotate()</span></tt></a>).</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LB</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">LB</span><span class="p">([</span><span class="n">LB</span><span class="p">([</span><span class="n">LB</span><span class="p">([],</span><span class="s">&quot;A&quot;</span><span class="p">),</span> <span class="n">LB</span><span class="p">([],</span><span class="s">&quot;B&quot;</span><span class="p">)],</span><span class="s">&quot;x&quot;</span><span class="p">),</span><span class="n">LB</span><span class="p">([],</span><span class="s">&quot;C&quot;</span><span class="p">)],</span> <span class="s">&quot;y&quot;</span><span class="p">);</span> <span class="n">b</span>
<span class="go">y[x[A[., .], B[., .]], C[., .]]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">right_rotate</span><span class="p">()</span>
<span class="go">x[A[., .], y[B[., .], C[., .]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.LabelledBinaryTree.semistandard_insert">
<tt class="descname">semistandard_insert</tt><big>(</big><em>letter</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTree.semistandard_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of inserting a letter <tt class="docutils literal"><span class="pre">letter</span></tt> into the
semistandard tree <tt class="docutils literal"><span class="pre">self</span></tt> using the bumping algorithm.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">letter</span></tt> &#8211; any object comparable with the labels of <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>OUTPUT:</p>
<p>The semistandard tree <tt class="docutils literal"><span class="pre">self</span></tt> with <tt class="docutils literal"><span class="pre">letter</span></tt> inserted into it
according to the bumping algorithm.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">self</span></tt> is supposed to be a semistandard tree.
This is not being checked!</p>
</div>
<p>A semistandard tree is defined to be a labelled binary tree
such that for each node <span class="math">\(n\)</span> with label <span class="math">\(x\)</span>, every descendant of
the left child of <span class="math">\(n\)</span> has a label <span class="math">\(&gt; x\)</span>, and every descendant
of the right child of <span class="math">\(n\)</span> has a label <span class="math">\(\geq x\)</span>. (Here, only
nodes count as descendants, and every node counts as its own
descendant too.) Leaves are assumed to have no labels.</p>
<p>Given a semistandard tree <span class="math">\(t\)</span> and a letter <span class="math">\(i\)</span>, the result of
inserting <span class="math">\(i\)</span> into <span class="math">\(t\)</span> (denoted <span class="math">\(Ins(i, t)\)</span> in the following)
is defined recursively as follows:</p>
<ul class="simple">
<li>If <span class="math">\(t\)</span> is empty, then <span class="math">\(Ins(i, t)\)</span> is the tree with one node
only, and this node is labelled with <span class="math">\(i\)</span>.</li>
<li>Otherwise, let <span class="math">\(j\)</span> be the label of the root of <span class="math">\(t\)</span>. If
<span class="math">\(i \geq j\)</span>, then <span class="math">\(Ins(i, t)\)</span> is obtained by replacing the
right child of <span class="math">\(t\)</span> by <span class="math">\(Ins(i, r)\)</span> in <span class="math">\(t\)</span>, where <span class="math">\(r\)</span> denotes
the right child of <span class="math">\(t\)</span>. If <span class="math">\(i &lt; j\)</span>, then <span class="math">\(Ins(i, t)\)</span> is
obtained by replacing the label at the root of <span class="math">\(t\)</span> by <span class="math">\(i\)</span>,
and replacing the left child of <span class="math">\(t\)</span> by <span class="math">\(Ins(j, l)\)</span>
in <span class="math">\(t\)</span>, where <span class="math">\(l\)</span> denotes the left child of <span class="math">\(t\)</span>.</li>
</ul>
<p>This algorithm is similar to the Robinson-Schensted-Knuth
insertion algorithm for semistandard Young tableaux.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li>Darij Grinberg (10 Nov 2013).</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LBT</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">LBT</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[., .]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[., d[., .]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[., d[., e[., .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">a[b[., .], d[., e[., .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">a[b[., .], b[d[., .], e[., .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">a[b[., .], b[d[., .], d[e[., .], .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">a[b[., .], a[b[d[., .], .], d[e[., .], .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">a[b[., .], a[b[d[., .], .], c[d[e[., .], .], .]]]</span>
</pre></div>
</div>
<p>Other examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LBT</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span>
<span class="gp">sage: </span><span class="n">LBT</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3[., .]</span>
<span class="gp">sage: </span><span class="n">LBT</span><span class="p">([],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1[., 3[., .]]</span>
<span class="gp">sage: </span><span class="n">LBT</span><span class="p">([],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1[3[., .], .]</span>
<span class="gp">sage: </span><span class="n">res</span> <span class="o">=</span> <span class="n">LBT</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]:</span>
<span class="go">....:     res = res.semistandard_insert(i)</span>
<span class="gp">sage: </span><span class="n">res</span>
<span class="go">1[3[., .], 2[5[., .], 4[., 6[., .]]]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.binary_tree.LabelledBinaryTrees">
<em class="property">class </em><tt class="descclassname">sage.combinat.binary_tree.</tt><tt class="descname">LabelledBinaryTrees</tt><big>(</big><em>category=None</em><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ordered_tree.html#sage.combinat.ordered_tree.LabelledOrderedTrees" title="sage.combinat.ordered_tree.LabelledOrderedTrees"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.ordered_tree.LabelledOrderedTrees</span></tt></a></p>
<p>This is a parent stub to serve as a factory class for trees with various
labels constraints.</p>
<dl class="attribute">
<dt id="sage.combinat.binary_tree.LabelledBinaryTrees.Element">
<tt class="descname">Element</tt><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTrees.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.binary_tree.LabelledBinaryTree" title="sage.combinat.binary_tree.LabelledBinaryTree"><tt class="xref py py-class docutils literal"><span class="pre">LabelledBinaryTree</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.LabelledBinaryTrees.labelled_trees">
<tt class="descname">labelled_trees</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTrees.labelled_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of labelled trees associated to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LabelledBinaryTrees</span><span class="p">()</span><span class="o">.</span><span class="n">labelled_trees</span><span class="p">()</span>
<span class="go">Labelled binary trees</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.binary_tree.LabelledBinaryTrees.unlabelled_trees">
<tt class="descname">unlabelled_trees</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTrees.unlabelled_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of unlabelled trees associated to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LabelledBinaryTrees</span><span class="p">()</span><span class="o">.</span><span class="n">unlabelled_trees</span><span class="p">()</span>
<span class="go">Binary trees</span>
</pre></div>
</div>
<p>This is used to compute the shape:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">LabelledBinaryTrees</span><span class="p">()</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">();</span> <span class="n">t</span>
<span class="go">[[[., .], [., .]], [[., .], [., .]]]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Binary trees</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">LabelledBinaryTrees</span><span class="p">()</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="go">4[2[1[., .], 3[., .]], 6[5[., .], 7[., .]]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="binary_recurrence_sequences.html"
                                  title="previous chapter">Binary Recurrence Sequences.</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="cartesian_product.html"
                                  title="next chapter">Cartesian Products</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/combinat/binary_tree.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="cartesian_product.html" title="Cartesian Products"
             >next</a> |</li>
        <li class="right" >
          <a href="binary_recurrence_sequences.html" title="Binary Recurrence Sequences."
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Combinatorics</a> &raquo;</li>

          <li><a href="../../module_list.html" >Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2015, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>