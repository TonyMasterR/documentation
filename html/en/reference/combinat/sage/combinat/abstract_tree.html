<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Abstract Recursive Trees &mdash; Sage Reference Manual v7.0: Combinatorics</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v7.0: Combinatorics" href="../../index.html" />
    <link rel="up" title="Comprehensive Module list" href="../../module_list.html" />
    <link rel="next" title="Affine Permutations" href="affine_permutation.html" />
    <link rel="prev" title="Combinatorics" href="__init__.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="affine_permutation.html" title="Affine Permutations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="__init__.html" title="Combinatorics"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Combinatorics</a> &raquo;</li>

          <li><a href="../../module_list.html" accesskey="U">Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="abstract-recursive-trees">
<span id="sage-combinat-abstract-tree"></span><h1>Abstract Recursive Trees<a class="headerlink" href="#abstract-recursive-trees" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.abstract_tree"></span><p>The purpose of this class is to help implement trees with a specific structure
on the children of each node. For instance, one could want to define a tree in
which each node sees its children as linearly (see the <a class="reference internal" href="ordered_tree.html#module-sage.combinat.ordered_tree" title="sage.combinat.ordered_tree"><tt class="xref py py-mod docutils literal"><span class="pre">Ordered</span> <span class="pre">Trees</span></tt></a> module) or cyclically ordered.</p>
<p><strong>Tree structures</strong></p>
<p>Conceptually, one can define a tree structure from any object that can contain
others. Indeed, a list can contain lists which contain lists which contain
lists, and thus define a tree ... The same can be done with sets, or any kind
of iterable objects.</p>
<p>While any iterable is sufficient to encode trees, it can prove useful to have
other methods available like isomorphism tests (see next section), conversions
to DiGraphs objects (see <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractLabelledTree.as_digraph" title="sage.combinat.abstract_tree.AbstractLabelledTree.as_digraph"><tt class="xref py py-meth docutils literal"><span class="pre">as_digraph()</span></tt></a>) or
computation of the number of automorphisms constrained by the structure on
children. Providing such methods is the whole purpose of the
<a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree" title="sage.combinat.abstract_tree.AbstractTree"><tt class="xref py py-class docutils literal"><span class="pre">AbstractTree</span></tt></a> class.</p>
<p>As a result, the <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree" title="sage.combinat.abstract_tree.AbstractTree"><tt class="xref py py-class docutils literal"><span class="pre">AbstractTree</span></tt></a> class is not meant to be
instantiated, but extended. It is expected that classes extending this one may
also inherit from classes representing iterables, for instance
<tt class="xref py py-class docutils literal"><span class="pre">ClonableArray</span></tt> or <a class="reference external" href="../../../structure/sage/structure/list_clone.html#sage.structure.list_clone.ClonableList" title="(in Sage Reference Manual: Basic Structures v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">ClonableList</span></tt></a></p>
<p><strong>Constrained Trees</strong></p>
<p>The tree built from a specific container will reflect the properties of the
container. Indeed, if <tt class="docutils literal"><span class="pre">A</span></tt> is an iterable class whose elements are linearly
ordered, a class <tt class="docutils literal"><span class="pre">B</span></tt> extending both of <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree" title="sage.combinat.abstract_tree.AbstractTree"><tt class="xref py py-class docutils literal"><span class="pre">AbstractTree</span></tt></a> and <tt class="docutils literal"><span class="pre">A</span></tt> will
be such that the children of a node will be linearly ordered. If <tt class="docutils literal"><span class="pre">A</span></tt> behaves
like a set (i.e. if there is no order on the elements it contains), then two
trees will be considered as equal if one can be obtained from the other
through permutations between the children of a same node (see next section).</p>
<p><strong>Paths and ID</strong></p>
<p>It is expected that each element of a set of children should be identified by
its index in the container. This way, any node of the tree can be identified
by a word describing a path from the root node.</p>
<p><strong>Canonical labellings</strong></p>
<p>Equality between instances of classes extending both <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree" title="sage.combinat.abstract_tree.AbstractTree"><tt class="xref py py-class docutils literal"><span class="pre">AbstractTree</span></tt></a>
and <tt class="docutils literal"><span class="pre">A</span></tt> is entirely defined by the equality defined on the elements of
<tt class="docutils literal"><span class="pre">A</span></tt>. A canonical labelling of such a tree, however, should be such that
two trees <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> satisfying <tt class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></tt> have the same canonical
labellings. On the other hand, the canonical labellings of trees <tt class="docutils literal"><span class="pre">a</span></tt> and
<tt class="docutils literal"><span class="pre">b</span></tt> satisfying <tt class="docutils literal"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></tt> are expected to be different.</p>
<p>For this reason, the values returned by the <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree.canonical_labelling" title="sage.combinat.abstract_tree.AbstractTree.canonical_labelling"><tt class="xref py py-meth docutils literal"><span class="pre">canonical_labelling</span></tt></a> method heavily
depend on the data structure used for a node&#8217;s children and <strong>should be</strong>
<strong>overridden</strong> by most of the classes extending <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree" title="sage.combinat.abstract_tree.AbstractTree"><tt class="xref py py-class docutils literal"><span class="pre">AbstractTree</span></tt></a> if it is
incoherent with the data structure.</p>
<p><strong>Authors</strong></p>
<ul class="simple">
<li>Florent Hivert (2010-2011): initial revision</li>
<li>Frédéric Chapoton (2011): contributed some methods</li>
</ul>
<dl class="class">
<dt id="sage.combinat.abstract_tree.AbstractClonableTree">
<em class="property">class </em><tt class="descclassname">sage.combinat.abstract_tree.</tt><tt class="descname">AbstractClonableTree</tt><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractClonableTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree" title="sage.combinat.abstract_tree.AbstractTree"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.abstract_tree.AbstractTree</span></tt></a></p>
<p>Abstract Clonable Tree.</p>
<p>An abstract class for trees with clone protocol (see
<a class="reference external" href="../../../structure/sage/structure/list_clone.html#module-sage.structure.list_clone" title="(in Sage Reference Manual: Basic Structures v7.0)"><tt class="xref py py-mod docutils literal"><span class="pre">list_clone</span></tt></a>). It is expected that classes extending
this one may also inherit from classes like <tt class="xref py py-class docutils literal"><span class="pre">ClonableArray</span></tt> or
<a class="reference external" href="../../../structure/sage/structure/list_clone.html#sage.structure.list_clone.ClonableList" title="(in Sage Reference Manual: Basic Structures v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">ClonableList</span></tt></a> depending whether one
wants to build trees where adding a child is allowed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Due to the limitation of Cython inheritance, one cannot inherit
here from <a class="reference external" href="../../../structure/sage/structure/list_clone.html#sage.structure.list_clone.ClonableElement" title="(in Sage Reference Manual: Basic Structures v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">ClonableElement</span></tt></a>, because
it would prevent us from later inheriting from
<a class="reference external" href="../../../structure/sage/structure/list_clone.html#sage.structure.list_clone.ClonableArray" title="(in Sage Reference Manual: Basic Structures v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">ClonableArray</span></tt></a> or
<a class="reference external" href="../../../structure/sage/structure/list_clone.html#sage.structure.list_clone.ClonableList" title="(in Sage Reference Manual: Basic Structures v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">ClonableList</span></tt></a>.</p>
</div>
<p class="rubric">How should this class be extended ?</p>
<p>A class extending <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractClonableTree" title="sage.combinat.abstract_tree.AbstractClonableTree"><tt class="xref py py-class docutils literal"><span class="pre">AbstractClonableTree</span></tt></a> should satisfy the
following assumptions:</p>
<ul class="simple">
<li>An instantiable class extending <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractClonableTree" title="sage.combinat.abstract_tree.AbstractClonableTree"><tt class="xref py py-class docutils literal"><span class="pre">AbstractClonableTree</span></tt></a> should also extend
the <a class="reference external" href="../../../structure/sage/structure/list_clone.html#sage.structure.list_clone.ClonableElement" title="(in Sage Reference Manual: Basic Structures v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">ClonableElement</span></tt></a>
class or one of its subclasses generally, at least <a class="reference external" href="../../../structure/sage/structure/list_clone.html#sage.structure.list_clone.ClonableArray" title="(in Sage Reference Manual: Basic Structures v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">ClonableArray</span></tt></a>.</li>
<li>To respect the Clone protocol, the <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractClonableTree.check" title="sage.combinat.abstract_tree.AbstractClonableTree.check"><tt class="xref py py-meth docutils literal"><span class="pre">AbstractClonableTree.check()</span></tt></a>
method should be overridden by the new class.</li>
</ul>
<p>See also the assumptions in <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree" title="sage.combinat.abstract_tree.AbstractTree"><tt class="xref py py-class docutils literal"><span class="pre">AbstractTree</span></tt></a>.</p>
<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractClonableTree.check">
<tt class="descname">check</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractClonableTree.check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that <tt class="docutils literal"><span class="pre">self</span></tt> is a correct tree.</p>
<p>This method does nothing. It is implemented here because many
extensions of <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractClonableTree" title="sage.combinat.abstract_tree.AbstractClonableTree"><tt class="xref py py-class docutils literal"><span class="pre">AbstractClonableTree</span></tt></a> also extend
<a class="reference external" href="../../../structure/sage/structure/list_clone.html#sage.structure.list_clone.ClonableElement" title="(in Sage Reference Manual: Basic Structures v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.list_clone.ClonableElement</span></tt></a>, which requires it.</p>
<p>It should be overridden in subclasses in order to check that the
characterizing property of the respective kind of tree holds (eg: two
children for binary trees).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">OrderedTree</span><span class="p">([[],[[]]])</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],[[],[]]])</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.abstract_tree.AbstractLabelledClonableTree">
<em class="property">class </em><tt class="descclassname">sage.combinat.abstract_tree.</tt><tt class="descname">AbstractLabelledClonableTree</tt><big>(</big><em>parent</em>, <em>children</em>, <em>label=None</em>, <em>check=True</em><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractLabelledClonableTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractLabelledTree" title="sage.combinat.abstract_tree.AbstractLabelledTree"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.abstract_tree.AbstractLabelledTree</span></tt></a>, <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractClonableTree" title="sage.combinat.abstract_tree.AbstractClonableTree"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.abstract_tree.AbstractClonableTree</span></tt></a></p>
<p>Abstract Labelled Clonable Tree</p>
<p>This class takes care of modification for the label by the clone protocol.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Due to the limitation of Cython inheritance, one cannot inherit
here from <tt class="xref py py-class docutils literal"><span class="pre">ClonableArray</span></tt>, because it would prevent us to
inherit later from <a class="reference external" href="../../../structure/sage/structure/list_clone.html#sage.structure.list_clone.ClonableList" title="(in Sage Reference Manual: Basic Structures v7.0)"><tt class="xref py py-class docutils literal"><span class="pre">ClonableList</span></tt></a>.</p>
</div>
<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractLabelledClonableTree.map_labels">
<tt class="descname">map_labels</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractLabelledClonableTree.map_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the function <span class="math">\(f\)</span> to the labels of <tt class="docutils literal"><span class="pre">self</span></tt></p>
<p>This method returns a copy of <tt class="docutils literal"><span class="pre">self</span></tt> on which the function <span class="math">\(f\)</span> has
been applied on all labels (a label <span class="math">\(x\)</span> is replaced by <span class="math">\(f(x)\)</span>).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LT</span> <span class="o">=</span> <span class="n">LabelledOrderedTree</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">LT</span><span class="p">([</span><span class="n">LT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">LT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="mi">7</span><span class="p">)],</span><span class="n">label</span><span class="o">=</span><span class="mi">3</span><span class="p">);</span> <span class="n">t</span>
<span class="go">3[1[], 7[]]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">map_labels</span><span class="p">(</span><span class="k">lambda</span> <span class="n">z</span><span class="p">:</span><span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="go">4[2[], 8[]]</span>

<span class="gp">sage: </span><span class="n">LBT</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">LBT</span><span class="p">([</span><span class="n">LBT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">LBT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="mi">4</span><span class="p">)],</span><span class="n">label</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span> <span class="n">bt</span>
<span class="go">2[1[., .], 4[., .]]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">map_labels</span><span class="p">(</span><span class="k">lambda</span> <span class="n">z</span><span class="p">:</span><span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3[2[., .], 5[., .]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractLabelledClonableTree.set_label">
<tt class="descname">set_label</tt><big>(</big><em>path</em>, <em>label</em><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractLabelledClonableTree.set_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the label of subtree indexed by <tt class="docutils literal"><span class="pre">path</span></tt> to <tt class="docutils literal"><span class="pre">label</span></tt></p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">path</span></tt> &#8211; <tt class="docutils literal"><span class="pre">None</span></tt> (default) or a path (list or tuple of children</dt>
<dd><p class="first last">index in the tree)</p>
</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">label</span></tt> &#8211; any sage object</p>
</li>
</ul>
<p>OUTPUT: Nothing, <tt class="docutils literal"><span class="pre">self</span></tt> is modified in place</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">self</span></tt> must be in a mutable state. See
<a class="reference external" href="../../../structure/sage/structure/list_clone.html#module-sage.structure.list_clone" title="(in Sage Reference Manual: Basic Structures v7.0)"><tt class="xref py py-mod docutils literal"><span class="pre">sage.structure.list_clone</span></tt></a> for more details about
mutability.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">LabelledOrderedTree</span><span class="p">([[],[[],[]]])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">set_label</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">object is immutable; please change a copy instead.</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">t</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
<span class="go">....:     t.set_label((0,), 4)</span>
<span class="gp">sage: </span><span class="n">t</span>
<span class="go">None[4[], None[None[], None[]]]</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">t</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
<span class="go">....:     t.set_label((1,0), label = 42)</span>
<span class="gp">sage: </span><span class="n">t</span>
<span class="go">None[4[], None[42[], None[]]]</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p>Do we want to implement the following syntactic sugar:</p>
<div class="last highlight-python"><div class="highlight"><pre>with t.clone() as tt:
    tt.labels[1,2] = 3 ?
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractLabelledClonableTree.set_root_label">
<tt class="descname">set_root_label</tt><big>(</big><em>label</em><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractLabelledClonableTree.set_root_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the label of the root of <tt class="docutils literal"><span class="pre">self</span></tt></p>
<p>INPUT: <tt class="docutils literal"><span class="pre">label</span></tt> &#8211; any Sage object</p>
<p>OUTPUT: <tt class="docutils literal"><span class="pre">None</span></tt>, <tt class="docutils literal"><span class="pre">self</span></tt> is modified in place</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">self</span></tt> must be in a mutable state. See
<a class="reference external" href="../../../structure/sage/structure/list_clone.html#module-sage.structure.list_clone" title="(in Sage Reference Manual: Basic Structures v7.0)"><tt class="xref py py-mod docutils literal"><span class="pre">sage.structure.list_clone</span></tt></a> for more details about
mutability.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">LabelledOrderedTree</span><span class="p">([[],[[],[]]])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">set_root_label</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">object is immutable; please change a copy instead.</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">t</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
<span class="go">....:     t.set_root_label(3)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">t</span>
<span class="go">3[None[], None[None[], None[]]]</span>
</pre></div>
</div>
<p>This also works for binary trees:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">set_root_label</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">object is immutable; please change a copy instead.</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">bt</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">bt</span><span class="p">:</span>
<span class="go">....:     bt.set_root_label(3)</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">bt</span>
<span class="go">3[None[., .], None[., .]]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">with</span> <span class="n">t</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
<span class="go">....:     t[0] = LabelledOrderedTree(t[0], label = 4)</span>
<span class="gp">sage: </span><span class="n">t</span>
<span class="go">3[4[], None[None[], None[]]]</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">t</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
<span class="go">....:     t[1,0] = LabelledOrderedTree(t[1,0], label = 42)</span>
<span class="gp">sage: </span><span class="n">t</span>
<span class="go">3[4[], None[42[], None[]]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.abstract_tree.AbstractLabelledTree">
<em class="property">class </em><tt class="descclassname">sage.combinat.abstract_tree.</tt><tt class="descname">AbstractLabelledTree</tt><big>(</big><em>parent</em>, <em>children</em>, <em>label=None</em>, <em>check=True</em><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractLabelledTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree" title="sage.combinat.abstract_tree.AbstractTree"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.abstract_tree.AbstractTree</span></tt></a></p>
<p>Abstract Labelled Tree.</p>
<p>Typically a class for labelled trees is contructed by inheriting from
a class for unlabelled trees and <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractLabelledTree" title="sage.combinat.abstract_tree.AbstractLabelledTree"><tt class="xref py py-class docutils literal"><span class="pre">AbstractLabelledTree</span></tt></a>.</p>
<p class="rubric">How should this class be extended ?</p>
<p>A class extending <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractLabelledTree" title="sage.combinat.abstract_tree.AbstractLabelledTree"><tt class="xref py py-class docutils literal"><span class="pre">AbstractLabelledTree</span></tt></a> should respect the
following assumptions:</p>
<ul class="simple">
<li>For a labelled tree <tt class="docutils literal"><span class="pre">T</span></tt> the call <tt class="docutils literal"><span class="pre">T.parent().unlabelled_trees()</span></tt>
should return a parent for unlabelled trees of the same kind: for
example,<ul>
<li>if <tt class="docutils literal"><span class="pre">T</span></tt> is a binary labelled tree, <tt class="docutils literal"><span class="pre">T.parent()</span></tt> is
<tt class="docutils literal"><span class="pre">LabelledBinaryTrees()</span></tt> and <tt class="docutils literal"><span class="pre">T.parent().unlabelled_trees()</span></tt> is
<tt class="docutils literal"><span class="pre">BinaryTrees()</span></tt></li>
<li>if <tt class="docutils literal"><span class="pre">T</span></tt> is an ordered labelled tree, <tt class="docutils literal"><span class="pre">T.parent()</span></tt> is
<tt class="docutils literal"><span class="pre">LabelledOrderedTrees()</span></tt> and <tt class="docutils literal"><span class="pre">T.parent().unlabelled_trees()</span></tt> is
<tt class="docutils literal"><span class="pre">OrderedTrees()</span></tt></li>
</ul>
</li>
<li>In the same vein, the class of <tt class="docutils literal"><span class="pre">T</span></tt> should contain an attribute
<tt class="docutils literal"><span class="pre">_UnLabelled</span></tt> which should be the class for the corresponding
unlabelled trees.</li>
</ul>
<p>See also the assumptions in <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree" title="sage.combinat.abstract_tree.AbstractTree"><tt class="xref py py-class docutils literal"><span class="pre">AbstractTree</span></tt></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree" title="sage.combinat.abstract_tree.AbstractTree"><tt class="xref py py-class docutils literal"><span class="pre">AbstractTree</span></tt></a></p>
</div>
<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractLabelledTree.as_digraph">
<tt class="descname">as_digraph</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractLabelledTree.as_digraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a directed graph version of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">At this time, the output makes sense only if <tt class="docutils literal"><span class="pre">self</span></tt> is a
labelled binary tree with no repeated labels and no <tt class="docutils literal"><span class="pre">None</span></tt>
labels.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LT</span> <span class="o">=</span> <span class="n">LabelledOrderedTrees</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">LT</span><span class="p">([</span><span class="n">LT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="mi">6</span><span class="p">),</span><span class="n">LT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span><span class="n">label</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">as_digraph</span><span class="p">()</span>
<span class="go">Digraph on 3 vertices</span>

<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">],[[],</span><span class="bp">None</span><span class="p">]]);</span>
<span class="gp">sage: </span><span class="n">lt</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">lt</span><span class="o">.</span><span class="n">as_digraph</span><span class="p">()</span>
<span class="go">Digraph on 4 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractLabelledTree.label">
<tt class="descname">label</tt><big>(</big><em>path=None</em><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractLabelledTree.label" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the label of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">path</span></tt> &#8211; None (default) or a path (list or tuple of children index</dt>
<dd><p class="first last">in the tree)</p>
</dd>
</dl>
</li>
</ul>
<p>OUTPUT: the label of the subtree indexed by <tt class="docutils literal"><span class="pre">path</span></tt></p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">LabelledOrderedTree</span><span class="p">([[],[]],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">LabelledOrderedTree</span><span class="p">([</span><span class="n">LabelledOrderedTree</span><span class="p">([],</span> <span class="mi">5</span><span class="p">),[]],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">label</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractLabelledTree.labels">
<tt class="descname">labels</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractLabelledTree.labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of labels of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LT</span> <span class="o">=</span> <span class="n">LabelledOrderedTree</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">LT</span><span class="p">([</span><span class="n">LT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;b&#39;</span><span class="p">),</span><span class="n">LT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)],</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>

<span class="gp">sage: </span><span class="n">LBT</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span>
<span class="gp">sage: </span><span class="n">LBT</span><span class="p">([</span><span class="n">LBT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">LBT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="mi">4</span><span class="p">)],</span><span class="n">label</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">labels</span><span class="p">()</span>
<span class="go">[2, 1, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractLabelledTree.leaf_labels">
<tt class="descname">leaf_labels</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractLabelledTree.leaf_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of labels of the leaves of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>In case of a labelled binary tree, these &#8220;leaves&#8221; are not actually
the leaves of the binary trees, but the nodes whose both children
are leaves!</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LT</span> <span class="o">=</span> <span class="n">LabelledOrderedTree</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">LT</span><span class="p">([</span><span class="n">LT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;b&#39;</span><span class="p">),</span><span class="n">LT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)],</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">leaf_labels</span><span class="p">()</span>
<span class="go">[&#39;b&#39;, &#39;c&#39;]</span>

<span class="gp">sage: </span><span class="n">LBT</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">LBT</span><span class="p">([</span><span class="n">LBT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;b&#39;</span><span class="p">),</span><span class="n">LBT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)],</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">leaf_labels</span><span class="p">()</span>
<span class="go">[&#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">sage: </span><span class="n">LBT</span><span class="p">([],</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">leaf_labels</span><span class="p">()</span>
<span class="go">[&#39;1&#39;]</span>
<span class="gp">sage: </span><span class="n">LBT</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">leaf_labels</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractLabelledTree.shape">
<tt class="descname">shape</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractLabelledTree.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unlabelled tree associated to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">LabelledOrderedTree</span><span class="p">([[],[[]]],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">();</span> <span class="n">t</span>
<span class="go">[[], [[]]]</span>

<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([[],[[],[]]],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>
<span class="go">[[., .], [[., .], [., .]]]</span>

<span class="gp">sage: </span><span class="n">LRT</span> <span class="o">=</span> <span class="n">LabelledRootedTree</span>
<span class="gp">sage: </span><span class="n">tb</span> <span class="o">=</span> <span class="n">LRT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">LRT</span><span class="p">([</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>
<span class="go">[[], []]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Ordered trees</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.combinat.ordered_tree.OrderedTrees_all_with_category.element_class&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.abstract_tree.AbstractTree">
<em class="property">class </em><tt class="descclassname">sage.combinat.abstract_tree.</tt><tt class="descname">AbstractTree</tt><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Abstract Tree.</p>
<p>There is no data structure defined here, as this class is meant to be
extended, not instantiated.</p>
<p class="rubric">How should this class be extended?</p>
<p>A class extending <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree" title="sage.combinat.abstract_tree.AbstractTree"><tt class="xref py py-class docutils literal"><span class="pre">AbstractTree</span></tt></a> should respect several
assumptions:</p>
<ul class="simple">
<li>For a tree <tt class="docutils literal"><span class="pre">T</span></tt>, the call <tt class="docutils literal"><span class="pre">iter(T)</span></tt> should return an iterator on the
children of the root <tt class="docutils literal"><span class="pre">T</span></tt>.</li>
<li>The <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree.canonical_labelling" title="sage.combinat.abstract_tree.AbstractTree.canonical_labelling"><tt class="xref py py-meth docutils literal"><span class="pre">canonical_labelling</span></tt></a> method
should return the same value for trees that are considered equal (see the
&#8220;canonical labellings&#8221; section in the documentation of the
<a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree" title="sage.combinat.abstract_tree.AbstractTree"><tt class="xref py py-class docutils literal"><span class="pre">AbstractTree</span></tt></a> class).</li>
<li>For a tree <tt class="docutils literal"><span class="pre">T</span></tt> the call <tt class="docutils literal"><span class="pre">T.parent().labelled_trees()</span></tt> should return
a parent for labelled trees of the same kind: for example,<ul>
<li>if <tt class="docutils literal"><span class="pre">T</span></tt> is a binary tree, <tt class="docutils literal"><span class="pre">T.parent()</span></tt> is <tt class="docutils literal"><span class="pre">BinaryTrees()</span></tt> and
<tt class="docutils literal"><span class="pre">T.parent().labelled_trees()</span></tt> is <tt class="docutils literal"><span class="pre">LabelledBinaryTrees()</span></tt></li>
<li>if <tt class="docutils literal"><span class="pre">T</span></tt> is an ordered tree, <tt class="docutils literal"><span class="pre">T.parent()</span></tt> is <tt class="docutils literal"><span class="pre">OrderedTrees()</span></tt> and
<tt class="docutils literal"><span class="pre">T.parent().labelled_trees()</span></tt> is <tt class="docutils literal"><span class="pre">LabelledOrderedTrees()</span></tt></li>
</ul>
</li>
</ul>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">OrderedTree</span><span class="p">())</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">BinaryTree</span><span class="p">())</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractTree.breadth_first_order_traversal">
<tt class="descname">breadth_first_order_traversal</tt><big>(</big><em>action=None</em><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractTree.breadth_first_order_traversal" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the breadth-first post-order traversal algorithm
and subject every node encountered to some procedure
<tt class="docutils literal"><span class="pre">action</span></tt>. The algorithm is:</p>
<div class="highlight-python"><div class="highlight"><pre>queue &lt;- [ root ];
while the queue is not empty:
    node &lt;- pop( queue );
    manipulate the node;
    prepend to the queue the list of all subtrees of
        the node (from the rightmost to the leftmost).
</pre></div>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">action</span></tt> &#8211; (optional) a function which takes a node as
input, and does something during the exploration</li>
</ul>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">None</span></tt>. (This is <em>not</em> an iterator.)</p>
<p>EXAMPLES:</p>
<p>For example, on the following binary tree <span class="math">\(b\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>|   ___3____      |
|  /        \     |
| 1         _7_   |
|  \       /   \  |
|   2     5     8 |
|        / \      |
|       4   6     |
</pre></div>
</div>
<p>the breadth-first order traversal algorithm explores <span class="math">\(b\)</span> in the
following order of nodes: <span class="math">\(3,1,7,2,5,8,4,6\)</span>.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],[[[],[]],[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">breadth_first_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[3, 1, 7, 2, 5, 8, 4, 6]</span>

<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">OrderedTree</span><span class="p">([[[[],[]]],[[]],[[],[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span>
<span class="go">1[2[3[4[], 5[]]], 6[7[]], 8[9[], 10[]]]</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">breadth_first_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[1, 2, 6, 8, 3, 7, 9, 10, 4, 5]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span>\
<span class="go">....:     breadth_first_order_traversal(</span>
<span class="go">....:         lambda node: l.append(node.label()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">OrderedTree</span><span class="p">([])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span>\
<span class="go">....:     breadth_first_order_traversal(</span>
<span class="go">....:         lambda node: l.append(node.label()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractTree.canonical_labelling">
<tt class="descname">canonical_labelling</tt><big>(</big><em>shift=1</em><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractTree.canonical_labelling" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a labelled version of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The actual canonical labelling is currently unspecified. However, it
is guaranteed to have labels in <span class="math">\(1...n\)</span> where <span class="math">\(n\)</span> is the number of
nodes of the tree. Moreover, two (unlabelled) trees compare as equal if
and only if their canonical labelled trees compare as equal.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">OrderedTree</span><span class="p">([[],</span> <span class="p">[[],</span> <span class="p">[[],</span> <span class="p">[]],</span> <span class="p">[[],</span> <span class="p">[]]],</span> <span class="p">[[],</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="go">1[2[], 3[4[], 5[6[], 7[]], 8[9[], 10[]]], 11[12[], 13[]]]</span>

<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="go">1[., .]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],[[],[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="go">2[1[., .], 4[3[., .], 5[., .]]]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="go">.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractTree.depth">
<tt class="descname">depth</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractTree.depth" title="Permalink to this definition">¶</a></dt>
<dd><p>The depth of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">OrderedTree</span><span class="p">()</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">OrderedTree</span><span class="p">([])</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">OrderedTree</span><span class="p">([[],[]])</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">OrderedTree</span><span class="p">([[],[[]]])</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">OrderedTree</span><span class="p">([[],</span> <span class="p">[[],</span> <span class="p">[[],</span> <span class="p">[]],</span> <span class="p">[[],</span> <span class="p">[]]],</span> <span class="p">[[],</span> <span class="p">[]]])</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span>
<span class="go">4</span>

<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],[[],[]]])</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractTree.iterative_post_order_traversal">
<tt class="descname">iterative_post_order_traversal</tt><big>(</big><em>action=None</em><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractTree.iterative_post_order_traversal" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the depth-first post-order traversal algorithm (iterative
implementation) and subject every node encountered
to some procedure <tt class="docutils literal"><span class="pre">action</span></tt>. The algorithm is:</p>
<div class="highlight-python"><div class="highlight"><pre>explore each subtree (by the algorithm) from the
    leftmost one to the rightmost one;
then manipulate the root with function `action` (in the
    case of a binary tree, only if the root is not a leaf).
</pre></div>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">action</span></tt> &#8211; (optional) a function which takes a node as
input, and does something during the exploration</li>
</ul>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">None</span></tt>. (This is <em>not</em> an iterator.)</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree.post_order_traversal_iter" title="sage.combinat.abstract_tree.AbstractTree.post_order_traversal_iter"><tt class="xref py py-meth docutils literal"><span class="pre">post_order_traversal_iter()</span></tt></a></li>
</ul>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],[[[],[]],[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span>
<span class="go">3[1[., 2[., .]], 7[5[4[., .], 6[., .]], 8[., .]]]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">iterative_post_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[2, 1, 4, 6, 5, 8, 7, 3]</span>

<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">OrderedTree</span><span class="p">([[[[],[]]],[[]],[[],[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span>
<span class="go">1[2[3[4[], 5[]]], 6[7[]], 8[9[], 10[]]]</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">iterative_post_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[4, 5, 3, 2, 7, 6, 9, 10, 8, 1]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span>\
<span class="go">....:     iterative_post_order_traversal(</span>
<span class="go">....:         lambda node: l.append(node.label()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">OrderedTree</span><span class="p">([])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span>\
<span class="go">....:     iterative_post_order_traversal(</span>
<span class="go">....:         lambda node: l.append(node.label()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[1]</span>
</pre></div>
</div>
<p>The following test checks that things do not go wrong if some among
the descendants of the tree are equal or even identical:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">u</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span>
<span class="go">7</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">iterative_post_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractTree.iterative_pre_order_traversal">
<tt class="descname">iterative_pre_order_traversal</tt><big>(</big><em>action=None</em><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractTree.iterative_pre_order_traversal" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the depth-first pre-order traversal algorithm (iterative
implementation) and subject every node encountered
to some procedure <tt class="docutils literal"><span class="pre">action</span></tt>. The algorithm is:</p>
<div class="highlight-python"><div class="highlight"><pre>manipulate the root with function `action` (in the case
    of a binary tree, only if the root is not a leaf);
then explore each subtree (by the algorithm) from the
    leftmost one to the rightmost one.
</pre></div>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">action</span></tt> &#8211; (optional) a function which takes a node as
input, and does something during the exploration</li>
</ul>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">None</span></tt>. (This is <em>not</em> an iterator.)</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree.pre_order_traversal_iter" title="sage.combinat.abstract_tree.AbstractTree.pre_order_traversal_iter"><tt class="xref py py-meth docutils literal"><span class="pre">pre_order_traversal_iter()</span></tt></a></li>
<li><a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree.pre_order_traversal" title="sage.combinat.abstract_tree.AbstractTree.pre_order_traversal"><tt class="xref py py-meth docutils literal"><span class="pre">pre_order_traversal()</span></tt></a></li>
</ul>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],[[[],[]],[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span>
<span class="go">3[1[., 2[., .]], 7[5[4[., .], 6[., .]], 8[., .]]]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">iterative_pre_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[3, 1, 2, 7, 5, 4, 6, 8]</span>

<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">OrderedTree</span><span class="p">([[[[],[]]],[[]],[[],[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span>
<span class="go">1[2[3[4[], 5[]]], 6[7[]], 8[9[], 10[]]]</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">iterative_pre_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>

<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span>\
<span class="go">....:     pre_order_traversal(lambda node: l.append(node.label()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">OrderedTree</span><span class="p">([])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span>\
<span class="go">....:     iterative_pre_order_traversal(lambda node: l.append(node.label()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[1]</span>
</pre></div>
</div>
<p>The following test checks that things do not go wrong if some among
the descendants of the tree are equal or even identical:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">u</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span>
<span class="go">7</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">iterative_pre_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractTree.node_number">
<tt class="descname">node_number</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractTree.node_number" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of nodes of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">OrderedTree</span><span class="p">()</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">OrderedTree</span><span class="p">([])</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">OrderedTree</span><span class="p">([[],[]])</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">OrderedTree</span><span class="p">([[],[[]]])</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">OrderedTree</span><span class="p">([[],</span> <span class="p">[[],</span> <span class="p">[[],</span> <span class="p">[]],</span> <span class="p">[[],</span> <span class="p">[]]],</span> <span class="p">[[],</span> <span class="p">[]]])</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span>
<span class="go">13</span>
</pre></div>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span> <span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,</span> <span class="p">[[],</span> <span class="p">[]]],</span> <span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractTree.paths">
<tt class="descname">paths</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractTree.paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a generator for all paths to nodes of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<p>This method returns a list of sequences of integers. Each of these
sequences represents a path from the root node to some node. For
instance, <span class="math">\((1, 3, 2, 5, 0, 3)\)</span> represents the node obtained by
choosing the 1st child of the root node (in the ordering returned
by <tt class="docutils literal"><span class="pre">iter</span></tt>), then the 3rd child of its child, then the 2nd child
of the latter, etc. (where the labelling of the children is
zero-based).</p>
<p>The root element is represented by the empty tuple <tt class="docutils literal"><span class="pre">()</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">OrderedTree</span><span class="p">([])</span><span class="o">.</span><span class="n">paths</span><span class="p">())</span>
<span class="go">[()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">OrderedTree</span><span class="p">([[],[[]]])</span><span class="o">.</span><span class="n">paths</span><span class="p">())</span>
<span class="go">[(), (0,), (1,), (1, 0)]</span>

<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">BinaryTree</span><span class="p">([[],[[],[]]])</span><span class="o">.</span><span class="n">paths</span><span class="p">())</span>
<span class="go">[(), (0,), (1,), (1, 0), (1, 1)]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">OrderedTree</span><span class="p">([[],</span> <span class="p">[[],</span> <span class="p">[[],</span> <span class="p">[]],</span> <span class="p">[[],</span> <span class="p">[]]],</span> <span class="p">[[],</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">paths</span><span class="p">()))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">paths</span><span class="p">())</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[[],[]]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">bt</span><span class="o">.</span><span class="n">paths</span><span class="p">()))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractTree.post_order_traversal">
<tt class="descname">post_order_traversal</tt><big>(</big><em>action=None</em><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractTree.post_order_traversal" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the depth-first post-order traversal algorithm (recursive
implementation) and subject every node encountered
to some procedure <tt class="docutils literal"><span class="pre">action</span></tt>. The algorithm is:</p>
<div class="highlight-python"><div class="highlight"><pre>explore each subtree (by the algorithm) from the
    leftmost one to the rightmost one;
then manipulate the root with function `action` (in the
    case of a binary tree, only if the root is not a leaf).
</pre></div>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">action</span></tt> &#8211; (optional) a function which takes a node as
input, and does something during the exploration</li>
</ul>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">None</span></tt>. (This is <em>not</em> an iterator.)</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree.post_order_traversal_iter" title="sage.combinat.abstract_tree.AbstractTree.post_order_traversal_iter"><tt class="xref py py-meth docutils literal"><span class="pre">post_order_traversal_iter()</span></tt></a></li>
<li><a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree.iterative_post_order_traversal" title="sage.combinat.abstract_tree.AbstractTree.iterative_post_order_traversal"><tt class="xref py py-meth docutils literal"><span class="pre">iterative_post_order_traversal()</span></tt></a></li>
</ul>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],[[[],[]],[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span>
<span class="go">3[1[., 2[., .]], 7[5[4[., .], 6[., .]], 8[., .]]]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">post_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[2, 1, 4, 6, 5, 8, 7, 3]</span>

<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">OrderedTree</span><span class="p">([[[[],[]]],[[]],[[],[]]])</span><span class="o">.</span>\
<span class="go">....:     canonical_labelling(); t</span>
<span class="go">1[2[3[4[], 5[]]], 6[7[]], 8[9[], 10[]]]</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">post_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[4, 5, 3, 2, 7, 6, 9, 10, 8, 1]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span>\
<span class="go">....:     post_order_traversal(lambda node: l.append(node.label()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">OrderedTree</span><span class="p">([])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span>\
<span class="go">....:     post_order_traversal(lambda node: l.append(node.label()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[1]</span>
</pre></div>
</div>
<p>The following test checks that things do not go wrong if some among
the descendants of the tree are equal or even identical:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">u</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span>
<span class="go">7</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">post_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractTree.post_order_traversal_iter">
<tt class="descname">post_order_traversal_iter</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractTree.post_order_traversal_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>The depth-first post-order traversal iterator.</p>
<p>This method iters each node following the depth-first post-order
traversal algorithm (recursive implementation). The algorithm
is:</p>
<div class="highlight-python"><div class="highlight"><pre>explore each subtree (by the algorithm) from the
    leftmost one to the rightmost one;
then yield the root (in the case of binary trees, only if
    it is not a leaf).
</pre></div>
</div>
<p>EXAMPLES:</p>
<p>For example on the following binary tree <span class="math">\(b\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>|   ___3____      |
|  /        \     |
| 1         _7_   |
|  \       /   \  |
|   2     5     8 |
|        / \      |
|       4   6     |
</pre></div>
</div>
<p>(only the nodes are shown), the depth-first post-order traversal
algorithm explores <span class="math">\(b\)</span> in the following order of nodes:
<span class="math">\(2,1,4,6,5,8,7,3\)</span>.</p>
<p>For another example, consider the labelled tree:</p>
<div class="highlight-python"><div class="highlight"><pre>|     __1____ |
|    /  /   / |
|   2  6   8_ |
|   |  |  / / |
|   3_ 7 9 10 |
|  / /        |
| 4 5         |
</pre></div>
</div>
<p>The algorithm explores this tree in the following order:
<span class="math">\(4,5,3,2,7,6,9,10,8,1\)</span>.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],[[[],[]],[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">([</span><span class="n">b</span><span class="p">])</span>
<span class="go">[   ___3____      ]</span>
<span class="go">[  /        \     ]</span>
<span class="go">[ 1         _7_   ]</span>
<span class="go">[  \       /   \  ]</span>
<span class="go">[   2     5     8 ]</span>
<span class="go">[        / \      ]</span>
<span class="go">[       4   6     ]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">post_order_traversal_iter</span><span class="p">()]</span>
<span class="go">[2, 1, 4, 6, 5, 8, 7, 3]</span>

<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">OrderedTree</span><span class="p">([[[[],[]]],[[]],[[],[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">([</span><span class="n">t</span><span class="p">])</span>
<span class="go">[     __1____   ]</span>
<span class="go">[    /  /   /   ]</span>
<span class="go">[   2  6   8_   ]</span>
<span class="go">[   |  |  / /   ]</span>
<span class="go">[   3_ 7 9 10   ]</span>
<span class="go">[  / /          ]</span>
<span class="go">[ 4 5           ]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">post_order_traversal_iter</span><span class="p">()]</span>
<span class="go">[4, 5, 3, 2, 7, 6, 9, 10, 8, 1]</span>

<span class="gp">sage: </span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span>\
<span class="go">....:     post_order_traversal_iter()]</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">OrderedTree</span><span class="p">([])</span><span class="o">.</span>\
<span class="go">....:     canonical_labelling().post_order_traversal_iter()]</span>
<span class="go">[1]</span>
</pre></div>
</div>
<p>The following test checks that things do not go wrong if some among
the descendants of the tree are equal or even identical:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">u</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span>
<span class="go">7</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">post_order_traversal_iter</span><span class="p">()]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractTree.pre_order_traversal">
<tt class="descname">pre_order_traversal</tt><big>(</big><em>action=None</em><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractTree.pre_order_traversal" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the depth-first pre-order traversal algorithm (recursive
implementation) and subject every node encountered
to some procedure <tt class="docutils literal"><span class="pre">action</span></tt>. The algorithm is:</p>
<div class="highlight-python"><div class="highlight"><pre>manipulate the root with function `action` (in the case
    of a binary tree, only if the root is not a leaf);
then explore each subtree (by the algorithm) from the
    leftmost one to the rightmost one.
</pre></div>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">action</span></tt> &#8211; (optional) a function which takes a node as
input, and does something during the exploration</li>
</ul>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">None</span></tt>. (This is <em>not</em> an iterator.)</p>
<p>EXAMPLES:</p>
<p>For example, on the following binary tree <span class="math">\(b\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>|   ___3____      |
|  /        \     |
| 1         _7_   |
|  \       /   \  |
|   2     5     8 |
|        / \      |
|       4   6     |
</pre></div>
</div>
<p>the depth-first pre-order traversal algorithm explores <span class="math">\(b\)</span> in the
following order of nodes: <span class="math">\(3,1,2,7,5,4,6,8\)</span>.</p>
<p>Another example:</p>
<div class="highlight-python"><div class="highlight"><pre>|     __1____ |
|    /  /   / |
|   2  6   8_ |
|   |  |  / / |
|   3_ 7 9 10 |
|  / /        |
| 4 5         |
</pre></div>
</div>
<p>The algorithm explores this tree in the following order:
<span class="math">\(1,2,3,4,5,6,7,8,9,10\)</span>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree.pre_order_traversal_iter" title="sage.combinat.abstract_tree.AbstractTree.pre_order_traversal_iter"><tt class="xref py py-meth docutils literal"><span class="pre">pre_order_traversal_iter()</span></tt></a></li>
<li><a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree.iterative_pre_order_traversal" title="sage.combinat.abstract_tree.AbstractTree.iterative_pre_order_traversal"><tt class="xref py py-meth docutils literal"><span class="pre">iterative_pre_order_traversal()</span></tt></a></li>
</ul>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],[[[],[]],[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span>
<span class="go">3[1[., 2[., .]], 7[5[4[., .], 6[., .]], 8[., .]]]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">pre_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[3, 1, 2, 7, 5, 4, 6, 8]</span>
<span class="gp">sage: </span><span class="n">li</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">iterative_pre_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">li</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()))</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">==</span> <span class="n">li</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">OrderedTree</span><span class="p">([[[[],[]]],[[]],[[],[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span>
<span class="go">1[2[3[4[], 5[]]], 6[7[]], 8[9[], 10[]]]</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">pre_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="gp">sage: </span><span class="n">li</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">iterative_pre_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">li</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()))</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">==</span> <span class="n">li</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span>\
<span class="go">....:     pre_order_traversal(lambda node: l.append(node.label()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">OrderedTree</span><span class="p">([])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span>\
<span class="go">....:     pre_order_traversal(lambda node: l.append(node.label()))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">[1]</span>
</pre></div>
</div>
<p>The following test checks that things do not go wrong if some among
the descendants of the tree are equal or even identical:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">u</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span>
<span class="go">7</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">pre_order_traversal</span><span class="p">(</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractTree.pre_order_traversal_iter">
<tt class="descname">pre_order_traversal_iter</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractTree.pre_order_traversal_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>The depth-first pre-order traversal iterator.</p>
<p>This method iters each node following the depth-first pre-order
traversal algorithm (recursive implementation). The algorithm
is:</p>
<div class="highlight-python"><div class="highlight"><pre>yield the root (in the case of binary trees, if it is not
    a leaf);
then explore each subtree (by the algorithm) from the
    leftmost one to the rightmost one.
</pre></div>
</div>
<p>EXAMPLES:</p>
<p>For example, on the following binary tree <span class="math">\(b\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>|   ___3____      |
|  /        \     |
| 1         _7_   |
|  \       /   \  |
|   2     5     8 |
|        / \      |
|       4   6     |
</pre></div>
</div>
<p>(only the nodes shown), the depth-first pre-order traversal
algorithm explores <span class="math">\(b\)</span> in the following order of nodes:
<span class="math">\(3,1,2,7,5,4,6,8\)</span>.</p>
<p>Another example:</p>
<div class="highlight-python"><div class="highlight"><pre>|     __1____ |
|    /  /   / |
|   2  6   8_ |
|   |  |  / / |
|   3_ 7 9 10 |
|  / /        |
| 4 5         |
</pre></div>
</div>
<p>The algorithm explores this labelled tree in the following
order: <span class="math">\(1,2,3,4,5,6,7,8,9,10\)</span>.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="bp">None</span><span class="p">,[]],[[[],[]],[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">([</span><span class="n">b</span><span class="p">])</span>
<span class="go">[   ___3____      ]</span>
<span class="go">[  /        \     ]</span>
<span class="go">[ 1         _7_   ]</span>
<span class="go">[  \       /   \  ]</span>
<span class="go">[   2     5     8 ]</span>
<span class="go">[        / \      ]</span>
<span class="go">[       4   6     ]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">pre_order_traversal_iter</span><span class="p">()]</span>
<span class="go">[3, 1, 2, 7, 5, 4, 6, 8]</span>

<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">OrderedTree</span><span class="p">([[[[],[]]],[[]],[[],[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">([</span><span class="n">t</span><span class="p">])</span>
<span class="go">[     __1____   ]</span>
<span class="go">[    /  /   /   ]</span>
<span class="go">[   2  6   8_   ]</span>
<span class="go">[   |  |  / /   ]</span>
<span class="go">[   3_ 7 9 10   ]</span>
<span class="go">[  / /          ]</span>
<span class="go">[ 4 5           ]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">pre_order_traversal_iter</span><span class="p">()]</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>

<span class="gp">sage: </span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">pre_order_traversal_iter</span><span class="p">()]</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>The following test checks that things do not go wrong if some among
the descendants of the tree are equal or even identical:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">u</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span>
<span class="go">7</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">pre_order_traversal_iter</span><span class="p">()]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractTree.subtrees">
<tt class="descname">subtrees</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractTree.subtrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a generator for all nonempty subtrees of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The number of nonempty subtrees of a tree is its number of
nodes. (The word &#8220;nonempty&#8221; makes a difference only in the
case of binary trees. For ordered trees, for example, all
trees are nonempty.)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">OrderedTree</span><span class="p">([])</span><span class="o">.</span><span class="n">subtrees</span><span class="p">())</span>
<span class="go">[[]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">OrderedTree</span><span class="p">([[],[[]]])</span><span class="o">.</span><span class="n">subtrees</span><span class="p">())</span>
<span class="go">[[[], [[]]], [], [[]], []]</span>

<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">OrderedTree</span><span class="p">([[],[[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span><span class="n">subtrees</span><span class="p">())</span>
<span class="go">[1[2[], 3[4[]]], 2[], 3[4[]], 4[]]</span>

<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">BinaryTree</span><span class="p">([[],[[],[]]])</span><span class="o">.</span><span class="n">subtrees</span><span class="p">())</span>
<span class="go">[[[., .], [[., .], [., .]]], [., .], [[., .], [., .]], [., .], [., .]]</span>

<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span><span class="n">subtrees</span><span class="p">())</span>
<span class="go">[2[1[., .], 3[., .]], 1[., .], 3[., .]]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">OrderedTree</span><span class="p">([[],</span> <span class="p">[[],</span> <span class="p">[[],</span> <span class="p">[]],</span> <span class="p">[[],</span> <span class="p">[]]],</span> <span class="p">[[],</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">subtrees</span><span class="p">()))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">subtrees</span><span class="p">())</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[[],[]]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">bt</span><span class="o">.</span><span class="n">subtrees</span><span class="p">()))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractTree.to_hexacode">
<tt class="descname">to_hexacode</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractTree.to_hexacode" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a tree into an hexadecimal string.</p>
<p>The definition of the hexacode is recursive. The first letter is
the valence of the root as an hexadecimal (up to 15), followed by
the concatenation of the hexacodes of the subtrees.</p>
<p>This method only works for trees where every vertex has
valency at most 15.</p>
<p>See <a class="reference internal" href="#sage.combinat.abstract_tree.from_hexacode" title="sage.combinat.abstract_tree.from_hexacode"><tt class="xref py py-func docutils literal"><span class="pre">from_hexacode()</span></tt></a> for the reverse transformation.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.abstract_tree</span> <span class="kn">import</span> <span class="n">from_hexacode</span>
<span class="gp">sage: </span><span class="n">LT</span> <span class="o">=</span> <span class="n">LabelledOrderedTrees</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">from_hexacode</span><span class="p">(</span><span class="s">&#39;2010&#39;</span><span class="p">,</span> <span class="n">LT</span><span class="p">)</span><span class="o">.</span><span class="n">to_hexacode</span><span class="p">()</span>
<span class="go">&#39;2010&#39;</span>
<span class="gp">sage: </span><span class="n">LT</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">to_hexacode</span><span class="p">()</span>
<span class="go">&#39;3020010&#39;</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">from_hexacode</span><span class="p">(</span><span class="s">&#39;a0000000000000000&#39;</span><span class="p">,</span> <span class="n">LT</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">to_hexacode</span><span class="p">()</span>
<span class="go">&#39;a0000000000&#39;</span>

<span class="gp">sage: </span><span class="n">OrderedTrees</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">to_hexacode</span><span class="p">()</span>
<span class="go">&#39;500000&#39;</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">one</span> <span class="o">=</span> <span class="n">LT</span><span class="p">([],</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;@&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">LT</span><span class="p">([</span><span class="n">one</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">)],</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;@&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_hexacode</span><span class="p">()</span>
<span class="go">&#39;f000000000000000&#39;</span>
<span class="gp">sage: </span><span class="n">LT</span><span class="p">([</span><span class="n">one</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">)],</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;@&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_hexacode</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">the width of the tree is too large</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.abstract_tree.AbstractTree.tree_factorial">
<tt class="descname">tree_factorial</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.AbstractTree.tree_factorial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tree-factorial of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Definition:</p>
<p>The tree-factorial <span class="math">\(T!\)</span> of a tree <span class="math">\(T\)</span> is the product <span class="math">\(\prod_{v\in
T}\#\mbox{children}(v)\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LT</span> <span class="o">=</span> <span class="n">LabelledOrderedTrees</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">LT</span><span class="p">([</span><span class="n">LT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="mi">6</span><span class="p">),</span><span class="n">LT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span><span class="n">label</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">tree_factorial</span><span class="p">()</span>
<span class="go">3</span>

<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],[[],[]]])</span><span class="o">.</span><span class="n">tree_factorial</span><span class="p">()</span>
<span class="go">15</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">tree_factorial</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.combinat.abstract_tree.from_hexacode">
<tt class="descclassname">sage.combinat.abstract_tree.</tt><tt class="descname">from_hexacode</tt><big>(</big><em>ch</em>, <em>parent=None</em>, <em>label='&#64;'</em><big>)</big><a class="headerlink" href="#sage.combinat.abstract_tree.from_hexacode" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an hexadecimal string into a tree.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ch</span></tt> &#8211; an hexadecimal string</li>
<li><tt class="docutils literal"><span class="pre">parent</span></tt> &#8211; kind of trees to be produced. If <tt class="docutils literal"><span class="pre">None</span></tt>, this will
be <tt class="docutils literal"><span class="pre">LabelledOrderedTrees</span></tt></li>
<li><tt class="docutils literal"><span class="pre">label</span></tt> &#8211; a label (default: <tt class="docutils literal"><span class="pre">'&#64;'</span></tt>) to be used for every vertex
of the tree</li>
</ul>
<p>See <a class="reference internal" href="#sage.combinat.abstract_tree.AbstractTree.to_hexacode" title="sage.combinat.abstract_tree.AbstractTree.to_hexacode"><tt class="xref py py-meth docutils literal"><span class="pre">AbstractTree.to_hexacode()</span></tt></a> for the description of the encoding</p>
<p>See <tt class="xref py py-func docutils literal"><span class="pre">_from_hexacode_aux()</span></tt> for the actual code</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.abstract_tree</span> <span class="kn">import</span> <span class="n">from_hexacode</span>
<span class="gp">sage: </span><span class="n">from_hexacode</span><span class="p">(</span><span class="s">&#39;12000&#39;</span><span class="p">,</span> <span class="n">LabelledOrderedTrees</span><span class="p">())</span>
<span class="go">@[@[@[], @[]]]</span>

<span class="gp">sage: </span><span class="n">from_hexacode</span><span class="p">(</span><span class="s">&#39;1200&#39;</span><span class="p">,</span> <span class="n">LabelledOrderedTrees</span><span class="p">())</span>
<span class="go">@[@[@[], @[]]]</span>
</pre></div>
</div>
<p>It can happen that only a prefix of the word is used:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">from_hexacode</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="o">+</span><span class="mi">14</span><span class="o">*</span><span class="s">&#39;0&#39;</span><span class="p">,</span> <span class="n">LabelledOrderedTrees</span><span class="p">())</span>
<span class="go">@[@[], @[], @[], @[], @[], @[], @[], @[], @[], @[]]</span>
</pre></div>
</div>
<p>One can choose the label:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">from_hexacode</span><span class="p">(</span><span class="s">&#39;1200&#39;</span><span class="p">,</span> <span class="n">LabelledOrderedTrees</span><span class="p">(),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;o&#39;</span><span class="p">)</span>
<span class="go">o[o[o[], o[]]]</span>
</pre></div>
</div>
<p>One can also create other kinds of trees:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">from_hexacode</span><span class="p">(</span><span class="s">&#39;1200&#39;</span><span class="p">,</span> <span class="n">OrderedTrees</span><span class="p">())</span>
<span class="go">[[[], []]]</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="__init__.html"
                                  title="previous chapter">Combinatorics</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="affine_permutation.html"
                                  title="next chapter">Affine Permutations</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/combinat/abstract_tree.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="affine_permutation.html" title="Affine Permutations"
             >next</a> |</li>
        <li class="right" >
          <a href="__init__.html" title="Combinatorics"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Combinatorics</a> &raquo;</li>

          <li><a href="../../module_list.html" >Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>