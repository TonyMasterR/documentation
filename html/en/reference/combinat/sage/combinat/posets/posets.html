<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Finite posets &mdash; Sage Reference Manual v6.9: Combinatorics</title>
    
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '6.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v6.9: Combinatorics" href="../../../index.html" />
    <link rel="up" title="Comprehensive Module list" href="../../../module_list.html" />
    <link rel="next" title="q-Analogues" href="../q_analogues.html" />
    <link rel="prev" title="A catalog of posets and lattices." href="poset_examples.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../q_analogues.html" title="q-Analogues"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="poset_examples.html" title="A catalog of posets and lattices."
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">Combinatorics</a> &raquo;</li>

          <li><a href="../../../module_list.html" accesskey="U">Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="finite-posets">
<span id="sage-combinat-posets-posets"></span><h1>Finite posets<a class="headerlink" href="#finite-posets" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.posets.posets"></span><p>This module implements finite partially ordered sets. It defines:</p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><tt class="xref py py-class docutils literal"><span class="pre">FinitePoset</span></tt></a></td>
<td>A class for finite posets</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePosets_n" title="sage.combinat.posets.posets.FinitePosets_n"><tt class="xref py py-class docutils literal"><span class="pre">FinitePosets_n</span></tt></a></td>
<td>A class for finite posets up to isomorphism (i.e. unlabeled posets)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><tt class="xref py py-meth docutils literal"><span class="pre">Poset()</span></tt></a></td>
<td>Construct a finite poset from various forms of input data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.is_poset" title="sage.combinat.posets.posets.is_poset"><tt class="xref py py-meth docutils literal"><span class="pre">is_poset()</span></tt></a></td>
<td>Tests whether a directed graph is acyclic and transitively reduced.</td>
</tr>
</tbody>
</table>
<div class="section" id="list-of-poset-methods">
<h2>List of Poset methods<a class="headerlink" href="#list-of-poset-methods" title="Permalink to this headline">¶</a></h2>
<p><strong>Comparing &amp; intervals</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="sage.combinat.posets.posets.FinitePoset.is_greater_than"><tt class="xref py py-meth docutils literal"><span class="pre">is_greater_than()</span></tt></a></td>
<td>Return <tt class="docutils literal"><span class="pre">True</span></tt> if <span class="math">\(x\)</span> is greater than but not equal to <span class="math">\(y\)</span> in the poset, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="sage.combinat.posets.posets.FinitePoset.is_gequal"><tt class="xref py py-meth docutils literal"><span class="pre">is_gequal()</span></tt></a></td>
<td>Return <tt class="docutils literal"><span class="pre">True</span></tt> if <span class="math">\(x\)</span> is greater than or equal to <span class="math">\(y\)</span> in the poset, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="sage.combinat.posets.posets.FinitePoset.is_less_than"><tt class="xref py py-meth docutils literal"><span class="pre">is_less_than()</span></tt></a></td>
<td>Return <tt class="docutils literal"><span class="pre">True</span></tt> if <span class="math">\(x\)</span> is less than but not equal to <span class="math">\(y\)</span> in the poset, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="sage.combinat.posets.posets.FinitePoset.is_lequal"><tt class="xref py py-meth docutils literal"><span class="pre">is_lequal()</span></tt></a></td>
<td>Return <tt class="docutils literal"><span class="pre">True</span></tt> if <span class="math">\(x\)</span> is less than or equal to <span class="math">\(y\)</span> in the poset, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.compare_elements" title="sage.combinat.posets.posets.FinitePoset.compare_elements"><tt class="xref py py-meth docutils literal"><span class="pre">compare_elements()</span></tt></a></td>
<td>Compares <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.closed_interval" title="sage.combinat.posets.posets.FinitePoset.closed_interval"><tt class="xref py py-meth docutils literal"><span class="pre">closed_interval()</span></tt></a></td>
<td>Return a list of the elements <span class="math">\(z\)</span> such that <span class="math">\(x \le z \le y\)</span>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.open_interval" title="sage.combinat.posets.posets.FinitePoset.open_interval"><tt class="xref py py-meth docutils literal"><span class="pre">open_interval()</span></tt></a></td>
<td>Return a list of the elements <span class="math">\(z\)</span> such that <span class="math">\(x &lt; z &lt; y\)</span>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.intervals" title="sage.combinat.posets.posets.FinitePoset.intervals"><tt class="xref py py-meth docutils literal"><span class="pre">intervals()</span></tt></a></td>
<td>Return a list of all intervals of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.intervals_iterator" title="sage.combinat.posets.posets.FinitePoset.intervals_iterator"><tt class="xref py py-meth docutils literal"><span class="pre">intervals_iterator()</span></tt></a></td>
<td>Return an iterator for all the intervals of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_filter" title="sage.combinat.posets.posets.FinitePoset.order_filter"><tt class="xref py py-meth docutils literal"><span class="pre">order_filter()</span></tt></a></td>
<td>Return the order filter generated by a list of elements.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_ideal" title="sage.combinat.posets.posets.FinitePoset.order_ideal"><tt class="xref py py-meth docutils literal"><span class="pre">order_ideal()</span></tt></a></td>
<td>Return the order ideal generated by a list of elements.</td>
</tr>
</tbody>
</table>
<p><strong>Covering</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.covers" title="sage.combinat.posets.posets.FinitePoset.covers"><tt class="xref py py-meth docutils literal"><span class="pre">covers()</span></tt></a></td>
<td>Return <tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">y</span></tt> covers <tt class="docutils literal"><span class="pre">x</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lower_covers" title="sage.combinat.posets.posets.FinitePoset.lower_covers"><tt class="xref py py-meth docutils literal"><span class="pre">lower_covers()</span></tt></a></td>
<td>Return elements covered by given element.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.upper_covers" title="sage.combinat.posets.posets.FinitePoset.upper_covers"><tt class="xref py py-meth docutils literal"><span class="pre">upper_covers()</span></tt></a></td>
<td>Return elements covering given element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cover_relations" title="sage.combinat.posets.posets.FinitePoset.cover_relations"><tt class="xref py py-meth docutils literal"><span class="pre">cover_relations()</span></tt></a></td>
<td>Return the list of cover relations.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lower_covers_iterator" title="sage.combinat.posets.posets.FinitePoset.lower_covers_iterator"><tt class="xref py py-meth docutils literal"><span class="pre">lower_covers_iterator()</span></tt></a></td>
<td>Return an iterator over elements covered by given element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.upper_covers_iterator" title="sage.combinat.posets.posets.FinitePoset.upper_covers_iterator"><tt class="xref py py-meth docutils literal"><span class="pre">upper_covers_iterator()</span></tt></a></td>
<td>Return an iterator over elements covering given element.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_iterator" title="sage.combinat.posets.posets.FinitePoset.cover_relations_iterator"><tt class="xref py py-meth docutils literal"><span class="pre">cover_relations_iterator()</span></tt></a></td>
<td>Return an iterator over cover relations of the poset.</td>
</tr>
</tbody>
</table>
<p><strong>Properties of the poset</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cardinality" title="sage.combinat.posets.posets.FinitePoset.cardinality"><tt class="xref py py-meth docutils literal"><span class="pre">cardinality()</span></tt></a></td>
<td>Return the number of elements in the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.height" title="sage.combinat.posets.posets.FinitePoset.height"><tt class="xref py py-meth docutils literal"><span class="pre">height()</span></tt></a></td>
<td>Return the number of elements in a longest chain of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.width" title="sage.combinat.posets.posets.FinitePoset.width"><tt class="xref py py-meth docutils literal"><span class="pre">width()</span></tt></a></td>
<td>Return the number of elements in a longest antichain of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="sage.combinat.posets.posets.FinitePoset.relations_number"><tt class="xref py py-meth docutils literal"><span class="pre">relations_number()</span></tt></a></td>
<td>Return the number of relations in the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.dimension" title="sage.combinat.posets.posets.FinitePoset.dimension"><tt class="xref py py-meth docutils literal"><span class="pre">dimension()</span></tt></a></td>
<td>Return the dimension of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="sage.combinat.posets.posets.FinitePoset.has_bottom"><tt class="xref py py-meth docutils literal"><span class="pre">has_bottom()</span></tt></a></td>
<td>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the poset has a unique minimal element.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="sage.combinat.posets.posets.FinitePoset.has_top"><tt class="xref py py-meth docutils literal"><span class="pre">has_top()</span></tt></a></td>
<td>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the poset has a unique maximal element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><tt class="xref py py-meth docutils literal"><span class="pre">is_bounded()</span></tt></a></td>
<td>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the poset contains a unique maximal element and a unique minimal element, and False otherwise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_chain" title="sage.combinat.posets.posets.FinitePoset.is_chain"><tt class="xref py py-meth docutils literal"><span class="pre">is_chain()</span></tt></a></td>
<td>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the poset is totally ordered, and False otherwise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_connected" title="sage.combinat.posets.posets.FinitePoset.is_connected"><tt class="xref py py-meth docutils literal"><span class="pre">is_connected()</span></tt></a></td>
<td>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the poset is connected, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_graded" title="sage.combinat.posets.posets.FinitePoset.is_graded"><tt class="xref py py-meth docutils literal"><span class="pre">is_graded()</span></tt></a></td>
<td>Return whether this poset is graded.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_ranked" title="sage.combinat.posets.posets.FinitePoset.is_ranked"><tt class="xref py py-meth docutils literal"><span class="pre">is_ranked()</span></tt></a></td>
<td>Return whether this poset is ranked.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_ranked" title="sage.combinat.posets.posets.FinitePoset.is_ranked"><tt class="xref py py-meth docutils literal"><span class="pre">is_ranked()</span></tt></a></td>
<td>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the poset is rank symmetric.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_incomparable_chain_free" title="sage.combinat.posets.posets.FinitePoset.is_incomparable_chain_free"><tt class="xref py py-meth docutils literal"><span class="pre">is_incomparable_chain_free()</span></tt></a></td>
<td>Return whether the poset is <span class="math">\((m+n)\)</span>-free.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_slender" title="sage.combinat.posets.posets.FinitePoset.is_slender"><tt class="xref py py-meth docutils literal"><span class="pre">is_slender()</span></tt></a></td>
<td>Return whether the poset <tt class="docutils literal"><span class="pre">self</span></tt> is slender or not.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_join_semilattice" title="sage.combinat.posets.posets.FinitePoset.is_join_semilattice"><tt class="xref py py-meth docutils literal"><span class="pre">is_join_semilattice()</span></tt></a></td>
<td>Return <tt class="docutils literal"><span class="pre">True</span></tt> is the poset has a join operation, and False otherwise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_meet_semilattice" title="sage.combinat.posets.posets.FinitePoset.is_meet_semilattice"><tt class="xref py py-meth docutils literal"><span class="pre">is_meet_semilattice()</span></tt></a></td>
<td>Return <tt class="docutils literal"><span class="pre">True</span></tt> if self has a meet operation, and False otherwise.</td>
</tr>
</tbody>
</table>
<p><strong>Minimal and maximal elements</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.bottom" title="sage.combinat.posets.posets.FinitePoset.bottom"><tt class="xref py py-meth docutils literal"><span class="pre">bottom()</span></tt></a></td>
<td>Return the bottom element of the poset, if it exists.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.top" title="sage.combinat.posets.posets.FinitePoset.top"><tt class="xref py py-meth docutils literal"><span class="pre">top()</span></tt></a></td>
<td>Return the top element of the poset, if it exists.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_elements" title="sage.combinat.posets.posets.FinitePoset.maximal_elements"><tt class="xref py py-meth docutils literal"><span class="pre">maximal_elements()</span></tt></a></td>
<td>Return the list of the maximal elements of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.minimal_elements" title="sage.combinat.posets.posets.FinitePoset.minimal_elements"><tt class="xref py py-meth docutils literal"><span class="pre">minimal_elements()</span></tt></a></td>
<td>Return the list of the minimal elements of the poset.</td>
</tr>
</tbody>
</table>
<p><strong>New posets from old ones</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.disjoint_union" title="sage.combinat.posets.posets.FinitePoset.disjoint_union"><tt class="xref py py-meth docutils literal"><span class="pre">disjoint_union()</span></tt></a></td>
<td>Return the disjoint union of the poset with other poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="sage.combinat.posets.posets.FinitePoset.ordinal_sum"><tt class="xref py py-meth docutils literal"><span class="pre">ordinal_sum()</span></tt></a></td>
<td>Return the ordinal sum of the poset with other poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_product" title="sage.combinat.posets.posets.FinitePoset.ordinal_product"><tt class="xref py py-meth docutils literal"><span class="pre">ordinal_product()</span></tt></a></td>
<td>Return the ordinal product of the poset with other poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.product" title="sage.combinat.posets.posets.FinitePoset.product"><tt class="xref py py-meth docutils literal"><span class="pre">product()</span></tt></a></td>
<td>Return the cartesian product of the poset with other poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.dual" title="sage.combinat.posets.posets.FinitePoset.dual"><tt class="xref py py-meth docutils literal"><span class="pre">dual()</span></tt></a></td>
<td>Return the dual poset of this poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.completion_by_cuts" title="sage.combinat.posets.posets.FinitePoset.completion_by_cuts"><tt class="xref py py-meth docutils literal"><span class="pre">completion_by_cuts()</span></tt></a></td>
<td>Return the Dedekind-MacNeille completion of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.connected_components" title="sage.combinat.posets.posets.FinitePoset.connected_components"><tt class="xref py py-meth docutils literal"><span class="pre">connected_components()</span></tt></a></td>
<td>Return the connected components of the poset as subposets.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.subposet" title="sage.combinat.posets.posets.FinitePoset.subposet"><tt class="xref py py-meth docutils literal"><span class="pre">subposet()</span></tt></a></td>
<td>Return the subposet containing elements with partial order induced by this poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.random_subposet" title="sage.combinat.posets.posets.FinitePoset.random_subposet"><tt class="xref py py-meth docutils literal"><span class="pre">random_subposet()</span></tt></a></td>
<td>Return a random subposet that contains each element with given probability.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.canonical_label" title="sage.combinat.posets.posets.FinitePoset.canonical_label"><tt class="xref py py-meth docutils literal"><span class="pre">canonical_label()</span></tt></a></td>
<td>Return copy of the poset canonically (re)labelled with elements <span class="math">\(\{0, \ldots, n-1\}\)</span>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relabel" title="sage.combinat.posets.posets.FinitePoset.relabel"><tt class="xref py py-meth docutils literal"><span class="pre">relabel()</span></tt></a></td>
<td>Return a copy of this poset with its elements relabelled.</td>
</tr>
</tbody>
</table>
<p><strong>Chains &amp; antichains</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_chain_of_poset" title="sage.combinat.posets.posets.FinitePoset.is_chain_of_poset"><tt class="xref py py-meth docutils literal"><span class="pre">is_chain_of_poset()</span></tt></a></td>
<td>Return <tt class="docutils literal"><span class="pre">True</span></tt> if given iterable is a chain of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chains" title="sage.combinat.posets.posets.FinitePoset.chains"><tt class="xref py py-meth docutils literal"><span class="pre">chains()</span></tt></a></td>
<td>Return all the chains of <tt class="docutils literal"><span class="pre">self</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="sage.combinat.posets.posets.FinitePoset.antichains"><tt class="xref py py-meth docutils literal"><span class="pre">antichains()</span></tt></a></td>
<td>Return the antichains of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="sage.combinat.posets.posets.FinitePoset.maximal_chains"><tt class="xref py py-meth docutils literal"><span class="pre">maximal_chains()</span></tt></a></td>
<td>Return all maximal chains of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_antichains" title="sage.combinat.posets.posets.FinitePoset.maximal_antichains"><tt class="xref py py-meth docutils literal"><span class="pre">maximal_antichains()</span></tt></a></td>
<td>Return all maximal antichains of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="sage.combinat.posets.posets.FinitePoset.antichains_iterator"><tt class="xref py py-meth docutils literal"><span class="pre">antichains_iterator()</span></tt></a></td>
<td>Return an iterator over the antichains of the poset.</td>
</tr>
</tbody>
</table>
<p><strong>Drawing</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.show" title="sage.combinat.posets.posets.FinitePoset.show"><tt class="xref py py-meth docutils literal"><span class="pre">show()</span></tt></a></td>
<td>Display the Hasse diagram of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.plot" title="sage.combinat.posets.posets.FinitePoset.plot"><tt class="xref py py-meth docutils literal"><span class="pre">plot()</span></tt></a></td>
<td>Return a Graphic object corresponding the Hasse diagram of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.graphviz_string" title="sage.combinat.posets.posets.FinitePoset.graphviz_string"><tt class="xref py py-meth docutils literal"><span class="pre">graphviz_string()</span></tt></a></td>
<td>Return a representation in the DOT language, ready to render in graphviz.</td>
</tr>
</tbody>
</table>
<p><strong>Comparing posets</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_isomorphic" title="sage.combinat.posets.posets.FinitePoset.is_isomorphic"><tt class="xref py py-meth docutils literal"><span class="pre">is_isomorphic()</span></tt></a></td>
<td>Return <tt class="docutils literal"><span class="pre">True</span></tt> if both posets are isomorphic.</td>
</tr>
</tbody>
</table>
<p><strong>Polynomials</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chain_polynomial" title="sage.combinat.posets.posets.FinitePoset.chain_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">chain_polynomial()</span></tt></a></td>
<td>Return the chain polynomial of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.characteristic_polynomial" title="sage.combinat.posets.posets.FinitePoset.characteristic_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">characteristic_polynomial()</span></tt></a></td>
<td>Return the characteristic polynomial of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.f_polynomial" title="sage.combinat.posets.posets.FinitePoset.f_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">f_polynomial()</span></tt></a></td>
<td>Return the f-polynomial of a bounded poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_f_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_f_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">flag_f_polynomial()</span></tt></a></td>
<td>Return the flag f-polynomial of a bounded and ranked poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_h_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_h_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">flag_h_polynomial()</span></tt></a></td>
<td>Return the flag h-polynomial of a bounded and ranked poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.h_polynomial" title="sage.combinat.posets.posets.FinitePoset.h_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">h_polynomial()</span></tt></a></td>
<td>Return the h-polynomial of a bounded poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polynomial" title="sage.combinat.posets.posets.FinitePoset.order_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">order_polynomial()</span></tt></a></td>
<td>Return the order polynomial of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.zeta_polynomial" title="sage.combinat.posets.posets.FinitePoset.zeta_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">zeta_polynomial()</span></tt></a></td>
<td>Return the zeta polynomial of the poset.</td>
</tr>
</tbody>
</table>
<p><strong>Polytopes</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chain_polytope" title="sage.combinat.posets.posets.FinitePoset.chain_polytope"><tt class="xref py py-meth docutils literal"><span class="pre">chain_polytope()</span></tt></a></td>
<td>Return the chain polytope of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polytope" title="sage.combinat.posets.posets.FinitePoset.order_polytope"><tt class="xref py py-meth docutils literal"><span class="pre">order_polytope()</span></tt></a></td>
<td>Return the order polytope of the poset.</td>
</tr>
</tbody>
</table>
<p><strong>Other &amp; not yet classified</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.comparability_graph" title="sage.combinat.posets.posets.FinitePoset.comparability_graph"><tt class="xref py py-meth docutils literal"><span class="pre">comparability_graph()</span></tt></a></td>
<td>Return the comparability graph of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_graph" title="sage.combinat.posets.posets.FinitePoset.cover_relations_graph"><tt class="xref py py-meth docutils literal"><span class="pre">cover_relations_graph()</span></tt></a></td>
<td>Return the graph of cover relations.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.coxeter_transformation" title="sage.combinat.posets.posets.FinitePoset.coxeter_transformation"><tt class="xref py py-meth docutils literal"><span class="pre">coxeter_transformation()</span></tt></a></td>
<td>Return the matrix of the Auslander-Reiten translation acting on the Grothendieck group of the derived category of modules.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cuts" title="sage.combinat.posets.posets.FinitePoset.cuts"><tt class="xref py py-meth docutils literal"><span class="pre">cuts()</span></tt></a></td>
<td>Return the cuts of the given poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.dilworth_decomposition" title="sage.combinat.posets.posets.FinitePoset.dilworth_decomposition"><tt class="xref py py-meth docutils literal"><span class="pre">dilworth_decomposition()</span></tt></a></td>
<td>Return a partition of the points into the minimal number of chains.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.evacuation" title="sage.combinat.posets.posets.FinitePoset.evacuation"><tt class="xref py py-meth docutils literal"><span class="pre">evacuation()</span></tt></a></td>
<td>Computes evacuation on the linear extension associated to the poset <tt class="docutils literal"><span class="pre">self</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.frank_network" title="sage.combinat.posets.posets.FinitePoset.frank_network"><tt class="xref py py-meth docutils literal"><span class="pre">frank_network()</span></tt></a></td>
<td>Return Frank&#8217;s network (a DiGraph along with a cost function on its edges) associated to <tt class="docutils literal"><span class="pre">self</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.greene_shape" title="sage.combinat.posets.posets.FinitePoset.greene_shape"><tt class="xref py py-meth docutils literal"><span class="pre">greene_shape()</span></tt></a></td>
<td>Computes the Greene-Kleitman partition aka Greene shape of the poset <tt class="docutils literal"><span class="pre">self</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.hasse_diagram" title="sage.combinat.posets.posets.FinitePoset.hasse_diagram"><tt class="xref py py-meth docutils literal"><span class="pre">hasse_diagram()</span></tt></a></td>
<td>Return the Hasse diagram of <tt class="docutils literal"><span class="pre">self</span></tt> as a Sage <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">DiGraph</span></tt></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet" title="sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet"><tt class="xref py py-meth docutils literal"><span class="pre">has_isomorphic_subposet()</span></tt></a></td>
<td>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the poset contains a subposet isomorphic to another poset, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.incidence_algebra" title="sage.combinat.posets.posets.FinitePoset.incidence_algebra"><tt class="xref py py-meth docutils literal"><span class="pre">incidence_algebra()</span></tt></a></td>
<td>Return the indicence algebra of <tt class="docutils literal"><span class="pre">self</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.incomparability_graph" title="sage.combinat.posets.posets.FinitePoset.incomparability_graph"><tt class="xref py py-meth docutils literal"><span class="pre">incomparability_graph()</span></tt></a></td>
<td>Return the incomparability graph of the poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_EL_labelling" title="sage.combinat.posets.posets.FinitePoset.is_EL_labelling"><tt class="xref py py-meth docutils literal"><span class="pre">is_EL_labelling()</span></tt></a></td>
<td>Return whether <tt class="docutils literal"><span class="pre">f</span></tt> is an EL labelling of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="sage.combinat.posets.posets.FinitePoset.is_linear_extension"><tt class="xref py py-meth docutils literal"><span class="pre">is_linear_extension()</span></tt></a></td>
<td>Return whether <tt class="docutils literal"><span class="pre">l</span></tt> is a linear extension of <tt class="docutils literal"><span class="pre">self</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator"><tt class="xref py py-meth docutils literal"><span class="pre">isomorphic_subposets_iterator()</span></tt></a></td>
<td>Return an iterator over the subposets isomorphic to another poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets"><tt class="xref py py-meth docutils literal"><span class="pre">isomorphic_subposets()</span></tt></a></td>
<td>Return all subposets isomorphic to another poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lequal_matrix" title="sage.combinat.posets.posets.FinitePoset.lequal_matrix"><tt class="xref py py-meth docutils literal"><span class="pre">lequal_matrix()</span></tt></a></td>
<td>Computes the matrix whose <tt class="docutils literal"><span class="pre">(i,j)</span></tt> entry is 1 if <tt class="docutils literal"><span class="pre">self.linear_extension()[i]</span> <span class="pre">&lt;</span> <span class="pre">self.linear_extension()[j]</span></tt> and 0 otherwise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.level_sets" title="sage.combinat.posets.posets.FinitePoset.level_sets"><tt class="xref py py-meth docutils literal"><span class="pre">level_sets()</span></tt></a></td>
<td>Return a list l such that l[i+1] is the set of minimal elements of the poset obtained by removing the elements in l[0], l[1], ..., l[i].</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><tt class="xref py py-meth docutils literal"><span class="pre">linear_extension()</span></tt></a></td>
<td>Return a linear extension of this poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="sage.combinat.posets.posets.FinitePoset.linear_extensions"><tt class="xref py py-meth docutils literal"><span class="pre">linear_extensions()</span></tt></a></td>
<td>Return the enumerated set of all the linear extensions of this poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.list" title="sage.combinat.posets.posets.FinitePoset.list"><tt class="xref py py-meth docutils literal"><span class="pre">list()</span></tt></a></td>
<td>List the elements of the poset. This just returns the result of <tt class="xref py py-meth docutils literal"><span class="pre">linear_extension()</span></tt>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.mobius_function_matrix" title="sage.combinat.posets.posets.FinitePoset.mobius_function_matrix"><tt class="xref py py-meth docutils literal"><span class="pre">mobius_function_matrix()</span></tt></a></td>
<td>Return a matrix whose <tt class="docutils literal"><span class="pre">(i,j)</span></tt> entry is the value of the Mobius function evaluated at <tt class="docutils literal"><span class="pre">self.linear_extension()[i]</span></tt> and <tt class="docutils literal"><span class="pre">self.linear_extension()[j]</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.mobius_function" title="sage.combinat.posets.posets.FinitePoset.mobius_function"><tt class="xref py py-meth docutils literal"><span class="pre">mobius_function()</span></tt></a></td>
<td>Return the value of the Mobius function of the poset on the elements x and y.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="sage.combinat.posets.posets.FinitePoset.order_complex"><tt class="xref py py-meth docutils literal"><span class="pre">order_complex()</span></tt></a></td>
<td>Return the order complex associated to this poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.p_partition_enumerator" title="sage.combinat.posets.posets.FinitePoset.p_partition_enumerator"><tt class="xref py py-meth docutils literal"><span class="pre">p_partition_enumerator()</span></tt></a></td>
<td>Return a <span class="math">\(P\)</span>-partition enumerator of the poset.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.promotion" title="sage.combinat.posets.posets.FinitePoset.promotion"><tt class="xref py py-meth docutils literal"><span class="pre">promotion()</span></tt></a></td>
<td>Computes the (extended) promotion on the linear extension of the poset <tt class="docutils literal"><span class="pre">self</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.random_order_ideal" title="sage.combinat.posets.posets.FinitePoset.random_order_ideal"><tt class="xref py py-meth docutils literal"><span class="pre">random_order_ideal()</span></tt></a></td>
<td>Return a random order ideal of <tt class="docutils literal"><span class="pre">self</span></tt> with uniform probability.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.rank_function" title="sage.combinat.posets.posets.FinitePoset.rank_function"><tt class="xref py py-meth docutils literal"><span class="pre">rank_function()</span></tt></a></td>
<td>Return a rank function of the poset, if it exists.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.rank" title="sage.combinat.posets.posets.FinitePoset.rank"><tt class="xref py py-meth docutils literal"><span class="pre">rank()</span></tt></a></td>
<td>Return the rank of an element, or the rank of the poset if element is None.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.unwrap" title="sage.combinat.posets.posets.FinitePoset.unwrap"><tt class="xref py py-meth docutils literal"><span class="pre">unwrap()</span></tt></a></td>
<td>Unwraps an element of this poset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_linear_extension" title="sage.combinat.posets.posets.FinitePoset.with_linear_extension"><tt class="xref py py-meth docutils literal"><span class="pre">with_linear_extension()</span></tt></a></td>
<td>Return a copy of <tt class="docutils literal"><span class="pre">self</span></tt> with a different default linear extension.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="classes-and-functions">
<h2>Classes and functions<a class="headerlink" href="#classes-and-functions" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sage.combinat.posets.posets.FinitePoset">
<em class="property">class </em><tt class="descclassname">sage.combinat.posets.posets.</tt><tt class="descname">FinitePoset</tt><big>(</big><em>hasse_diagram</em>, <em>elements</em>, <em>category</em>, <em>facade</em>, <em>key</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></tt></a>, <a class="reference external" href="../../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.parent.Parent</span></tt></a></p>
<p>A (finite) <span class="math">\(n\)</span>-element poset constructed from a directed acyclic graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">hasse_diagram</span></tt> &#8211; an instance of
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><tt class="xref py py-class docutils literal"><span class="pre">FinitePoset</span></tt></a>, or a
<a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">DiGraph</span></tt></a> that is transitively-reduced, acyclic,
loop-free, and multiedge-free.</li>
<li><tt class="docutils literal"><span class="pre">elements</span></tt> &#8211; an optional list of elements, with <tt class="docutils literal"><span class="pre">element[i]</span></tt>
corresponding to vertex <tt class="docutils literal"><span class="pre">i</span></tt>. If <tt class="docutils literal"><span class="pre">elements</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt>, then it is
set to be the vertex set of the digraph. Note that if this option is set,
then <tt class="docutils literal"><span class="pre">elements</span></tt> is considered as a specified linear extension of the poset
and the <span class="math">\(linear_extension\)</span> attribute is set.</li>
<li><tt class="docutils literal"><span class="pre">category</span></tt> &#8211; <a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets" title="(in Sage Reference Manual: Category Framework v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">FinitePosets</span></tt></a>, or a subcategory thereof.</li>
<li><tt class="docutils literal"><span class="pre">facade</span></tt> &#8211; a boolean or <tt class="docutils literal"><span class="pre">None</span></tt> (default); whether the
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><tt class="xref py py-class docutils literal"><span class="pre">FinitePoset</span></tt></a>&#8216;s elements should be
wrapped to make them aware of the Poset they belong to.<ul>
<li>If <tt class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">True</span></tt>, the
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><tt class="xref py py-class docutils literal"><span class="pre">FinitePoset</span></tt></a>&#8216;s elements are exactly
those given as input.</li>
<li>If <tt class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></tt>, the
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><tt class="xref py py-class docutils literal"><span class="pre">FinitePoset</span></tt></a>&#8216;s elements will become
<tt class="xref py py-class docutils literal"><span class="pre">PosetElement</span></tt> objects.</li>
<li>If <tt class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">None</span></tt> (default) the expected behaviour is the behaviour
of <tt class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">True</span></tt>, unless the opposite can be deduced from the
context (i.e. for instance if a
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><tt class="xref py py-class docutils literal"><span class="pre">FinitePoset</span></tt></a> is built from another
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><tt class="xref py py-class docutils literal"><span class="pre">FinitePoset</span></tt></a>, itself built with
<tt class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></tt>)</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">key</span></tt> &#8211; any hashable value (default: <tt class="docutils literal"><span class="pre">None</span></tt>).</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">uc</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.posets.posets</span> <span class="kn">import</span> <span class="n">FinitePoset</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">FinitePoset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">(</span><span class="nb">dict</span><span class="p">([[</span><span class="n">i</span><span class="p">,</span><span class="n">uc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uc</span><span class="p">))])),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 6 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[5, 4], [5, 3], [4, 1], [0, 2], [0, 3], [2, 1], [3, 1]]</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of finite posets and Category of finite enumerated sets</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">__class__</span>
<span class="go">&lt;class &#39;sage.combinat.posets.posets.FinitePoset_with_category&#39;&gt;</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">posets</span><span class="o">.</span><span class="n">posets</span><span class="o">.</span><span class="n">FinitePoset</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 6 elements</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We keep the same underlying Hasse diagram, but change the elements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">posets</span><span class="o">.</span><span class="n">posets</span><span class="o">.</span><span class="n">FinitePoset</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 6 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 5], [2, 6], [3, 4], [3, 5], [4, 6], [5, 6]]</span>
</pre></div>
</div>
<p>We test the facade argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">],</span><span class="s">&#39;b&#39;</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">],</span><span class="s">&#39;c&#39;</span><span class="p">:[</span><span class="s">&#39;d&#39;</span><span class="p">]}),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of finite posets and Category of finite enumerated sets</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">],</span><span class="s">&#39;b&#39;</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">],</span><span class="s">&#39;c&#39;</span><span class="p">:[</span><span class="s">&#39;d&#39;</span><span class="p">]}),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of finite posets</span>
<span class="go">    and Category of finite enumerated sets</span>
<span class="go">    and Category of facade sets</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">skip</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;_test_an_element&#39;</span><span class="p">])</span> <span class="c"># is_parent_of is not yet implemented</span>
</pre></div>
</div>
<p>Changing a non facade poset to a facade poset:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">PQ</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">PQ</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of finite posets</span>
<span class="go">    and Category of finite enumerated sets</span>
<span class="go">    and Category of facade sets</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">PQ</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">PQ</span> <span class="ow">is</span> <span class="n">Q</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Changing a facade poset to a non facade poset:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">QP</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">QP</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of finite posets</span>
<span class="go">    and Category of finite enumerated sets</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">QP</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="n">QP</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A class that inherits from this class needs to define
<tt class="docutils literal"><span class="pre">Element</span></tt>. This is the class of the elements that the inheriting
class contains. For example, for this class, <tt class="docutils literal"><span class="pre">FinitePoset</span></tt>,
<tt class="docutils literal"><span class="pre">Element</span></tt> is <tt class="docutils literal"><span class="pre">PosetElement</span></tt>.  It can also define <tt class="docutils literal"><span class="pre">_dual_class</span></tt> which
is the class of dual posets of this
class. E.g. <tt class="docutils literal"><span class="pre">FiniteMeetSemilattice._dual_class</span></tt> is
<tt class="docutils literal"><span class="pre">FiniteJoinSemilattice</span></tt>.</p>
</div>
<p>TESTS:</p>
<p>Equality is derived from <a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></tt></a>. We check that this
gives consistent results:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[],[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p2</span> <span class="o">==</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span>
<span class="go">(False, True)</span>
<span class="gp">sage: </span><span class="p">[[</span><span class="n">p1</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[[True, False], [False, True]]</span>
<span class="gp">sage: </span><span class="p">[[</span><span class="n">p2</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[[True, False], [False, True]]</span>
<span class="gp">sage: </span><span class="p">[[</span><span class="n">p2</span> <span class="o">==</span> <span class="n">p1</span> <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="go">[[True, False, False, False, False],</span>
<span class="go"> [False, True, False, False, False],</span>
<span class="go"> [False, False, True, False, False],</span>
<span class="go"> [False, False, False, True, False],</span>
<span class="go"> [False, False, False, False, True]]</span>

<span class="gp">sage: </span><span class="p">[[</span><span class="n">p1</span><span class="o">.</span><span class="n">__ne__</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[[False, True], [True, False]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">!=</span> <span class="n">Q</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">!=</span> <span class="n">P</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">!=</span> <span class="n">Q</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="p">[[</span><span class="n">p1</span><span class="o">.</span><span class="n">__ne__</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[[False, True], [True, False]]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="sage.combinat.posets.posets.FinitePoset.Element">
<tt class="descname">Element</tt><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">PosetElement</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.antichains">
<tt class="descname">antichains</tt><big>(</big><em>element_constructor=&lt;type 'list'&gt;</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the antichains of the poset.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">element_constructor</span></tt> &#8211; a function taking an iterable as
argument (default: list)</li>
</ul>
</div></blockquote>
<p>OUTPUT: an enumerated set</p>
<p>An <em>antichain</em> of a poset is a collection of elements of the
poset that are pairwise incomparable.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">antichains</span><span class="p">();</span> <span class="n">A</span>
<span class="go">Set of antichains of Finite lattice containing 5 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[[], [0], [1], [1, 2], [1, 3], [2], [3], [4]]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">8</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[1, 2]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">antichains</span><span class="p">())</span>
<span class="go">[[], [2], [2, 1], [2, 1, 0], [2, 0], [1], [1, 0], [0]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">antichains</span><span class="p">())</span>
<span class="go">[[], [0], [1], [2]]</span>
</pre></div>
</div>
<p>To get the antichains of a given size one can currently use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[1, 2], [1, 3]]</span>
</pre></div>
</div>
<p>Eventually the following syntax will be accepted:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="c"># todo: not implemented</span>
</pre></div>
</div>
<p>To get the antichains as, say, sets, one may use the
<tt class="docutils literal"><span class="pre">element_constructor</span></tt> option:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">antichains</span><span class="p">(</span><span class="n">element_constructor</span> <span class="o">=</span> <span class="nb">set</span><span class="p">))</span>
<span class="go">[set(), {0}, {1}, {2}]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Internally, this uses
<a class="reference internal" href="../subsets_pairwise.html#sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets" title="sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets"><tt class="xref py py-class docutils literal"><span class="pre">sage.combinat.subsets_pairwise.PairwiseCompatibleSubsets</span></tt></a>
and <a class="reference internal" href="../backtrack.html#sage.combinat.backtrack.SearchForest" title="sage.combinat.backtrack.SearchForest"><tt class="xref py py-class docutils literal"><span class="pre">SearchForest</span></tt></a>. At this point, iterating
through this set is about twice slower than using
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="sage.combinat.posets.posets.FinitePoset.antichains_iterator"><tt class="xref py py-meth docutils literal"><span class="pre">antichains_iterator()</span></tt></a> (tested on
<tt class="docutils literal"><span class="pre">posets.AntichainPoset(15)</span></tt>). The algorithm is the same
(depth first search through the tree), but
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="sage.combinat.posets.posets.FinitePoset.antichains_iterator"><tt class="xref py py-meth docutils literal"><span class="pre">antichains_iterator()</span></tt></a> manually inlines things which
apparently avoids some infrastructure overhead.</p>
<p class="last">On the other hand, this returns a full featured enumerated
set, with containment testing, etc.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_antichains" title="sage.combinat.posets.posets.FinitePoset.maximal_antichains"><tt class="xref py py-meth docutils literal"><span class="pre">maximal_antichains()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.antichains_iterator">
<tt class="descname">antichains_iterator</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.antichains_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over the antichains of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">antichains_iterator</span><span class="p">()</span>
<span class="go">&lt;generator object antichains_iterator at ...&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="sage.combinat.posets.posets.FinitePoset.antichains"><tt class="xref py py-meth docutils literal"><span class="pre">antichains()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.bottom">
<tt class="descname">bottom</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.bottom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique minimal element of the poset, if it exists.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">bottom</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">bottom</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="sage.combinat.posets.posets.FinitePoset.has_bottom"><tt class="xref py py-meth docutils literal"><span class="pre">has_bottom()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.top" title="sage.combinat.posets.posets.FinitePoset.top"><tt class="xref py py-meth docutils literal"><span class="pre">top()</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.canonical_label">
<tt class="descname">canonical_label</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.canonical_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique poset on the labels <span class="math">\(\{0, \ldots, n-1\}\)</span> (where <span class="math">\(n\)</span>
is the number of elements in the poset) that is isomorphic to this
poset and invariant in the isomorphism class.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>Canonical labeling of directed graphs:
<a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.canonical_label" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-meth docutils literal"><span class="pre">canonical_label()</span></tt></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 6], [3, 6], [4, 12], [6, 12]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">()</span> <span class="c"># random</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As a facade:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 6], [3, 6], [4, 12], [6, 12]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Canonical labeling of (semi)lattice returns (semi)lattice:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">D</span><span class="o">=</span><span class="n">DiGraph</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;c&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">=</span><span class="n">Poset</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ML</span><span class="o">=</span><span class="n">MeetSemilattice</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">ML</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="go">Finite meet-semilattice containing 3 elements</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">digraphs</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">linear_extension</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()</span> <span class="c"># random</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span> <span class="c"># random</span>
<span class="go">[[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">digraphs</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()</span> <span class="c"># random</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.cardinality">
<tt class="descname">cardinality</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cardinality" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of elements in the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.chain_polynomial">
<tt class="descname">chain_polynomial</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.chain_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chain polynomial of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The coefficient of <span class="math">\(q^k\)</span> is the number of chains of length <span class="math">\(k\)</span>
in <tt class="docutils literal"><span class="pre">self</span></tt>. The length of a chain is the number of elements.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is not what has been called the chain polynomial
in <a class="reference internal" href="#st1986" id="id1">[St1986]</a>. The latter is identical with the order
polynomial (<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polynomial" title="sage.combinat.posets.posets.FinitePoset.order_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">order_polynomial()</span></tt></a>).</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">();</span> <span class="n">t</span>
<span class="go">q^3 + 3*q^2 + 3*q + 1</span>
<span class="gp">sage: </span><span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">chains</span><span class="p">()))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">()</span>
<span class="go">6*q^4 + 18*q^3 + 19*q^2 + 8*q + 1</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">()</span>
<span class="go">5*q + 1</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">())</span>
<span class="go">Univariate Polynomial Ring in q over Integer Ring</span>

<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">chain_polynomial</span><span class="p">()</span>
<span class="go">q + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.chain_polytope">
<tt class="descname">chain_polytope</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.chain_polytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chain polytope of the poset <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The chain polytope of a finite poset <span class="math">\(P\)</span> is defined as the subset
of <span class="math">\(\RR^P\)</span> consisting of all maps <span class="math">\(x : P \to \RR\)</span> satisfying</p>
<div class="math">
\[x(p) \geq 0 \mbox{ for all } p \in P,\]</div>
<p>and</p>
<div class="math">
\[\begin{split}x(p_1) + x(p_2) + \ldots + x(p_k) \leq 1
\mbox{ for all chains } p_1 &lt; p_2 &lt; \ldots &lt; p_k
\mbox{ in } P.\end{split}\]</div>
<p>This polytope was defined and studied in <a class="reference internal" href="#st1986" id="id2">[St1986]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">chain_polytope</span><span class="p">();</span><span class="n">Q</span>
<span class="go">A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 8 vertices</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">chain_polytope</span><span class="p">();</span><span class="n">Q</span>
<span class="go">A 5-dimensional polyhedron in QQ^5 defined as the convex hull of 8 vertices</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.chains">
<tt class="descname">chains</tt><big>(</big><em>element_constructor=&lt;type 'list'&gt;</em>, <em>exclude=None</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.chains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all the chains of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">element_constructor</span></tt> &#8211; a function taking an iterable as</dt>
<dd><p class="first last">argument (default: <tt class="docutils literal"><span class="pre">list</span></tt>)</p>
</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">exclude</span></tt> &#8211; elements of the poset to be excluded
(default: <tt class="docutils literal"><span class="pre">None</span></tt>)</p>
</li>
</ul>
<p>OUTPUT:</p>
<p>The enumerated set of all chains of <tt class="docutils literal"><span class="pre">self</span></tt>, each of which
is given as an <tt class="docutils literal"><span class="pre">element_constructor</span></tt>.</p>
<p>A <em>chain</em> of a poset is a set of elements of the poset
that are pairwise comparable.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">chains</span><span class="p">();</span> <span class="n">A</span>
<span class="go">Set of chains of Finite lattice containing 5 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[[], [0], [0, 1], [0, 1, 4], [0, 2], [0, 2, 3], [0, 2, 3, 4], [0, 2, 4], [0, 3], [0, 3, 4], [0, 4], [1], [1, 4], [2], [2, 3], [2, 3, 4], [2, 4], [3], [3, 4], [4]]</span>
</pre></div>
</div>
<p>To get the chains of a given size one can currently use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[0, 1], [0, 2], [0, 3], [0, 4], [1, 4], [2, 3], [2, 4], [3, 4]]</span>
</pre></div>
</div>
<p>For bounded posets, one can exclude the bounds as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">chains</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>
<span class="go">[[], [1], [2], [3]]</span>
</pre></div>
</div>
<p>Another example of exclusion of vertices:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">chains</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">[(), (1,), (1, 2), (1, 2, 4), (1, 4), (1, 5), (2,), (2, 4), (4,), (5,)]</span>
</pre></div>
</div>
<p>Eventually the following syntax will be accepted:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="c"># todo: not implemented</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="sage.combinat.posets.posets.FinitePoset.maximal_chains"><tt class="xref py py-meth docutils literal"><span class="pre">maximal_chains()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="sage.combinat.posets.posets.FinitePoset.antichains"><tt class="xref py py-meth docutils literal"><span class="pre">antichains()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.characteristic_polynomial">
<tt class="descname">characteristic_polynomial</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.characteristic_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the characteristic polynomial of the poset.</p>
<p>The poset is expected to be graded and have a bottom
element.</p>
<p>If <span class="math">\(P\)</span> is a graded poset with rank <span class="math">\(n\)</span> and a unique minimal
element <span class="math">\(\hat{0}\)</span>, then the characteristic polynomial of
<span class="math">\(P\)</span> is defined to be</p>
<div class="math">
\[\sum_{x \in P} \mu(\hat{0}, x) q^{n-\rho(x)} \in \ZZ[q],\]</div>
<p>where <span class="math">\(\rho\)</span> is the rank function, and <span class="math">\(\mu\)</span> is the Moebius
function of <span class="math">\(P\)</span>.</p>
<p>See section 3.10 of <a class="reference internal" href="#enumcomb1" id="id3">[EnumComb1]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">()</span>
<span class="go">q^2 - 3*q + 2</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span><span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span><span class="mi">6</span><span class="p">:[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">()</span>
<span class="go">q^4 - 2*q^3 + q</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.closed_interval">
<tt class="descname">closed_interval</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.closed_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the elements <span class="math">\(z\)</span> such that <span class="math">\(x \le z \le y\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">uc</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]]</span>
<span class="gp">sage: </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uc</span><span class="p">)),</span><span class="n">uc</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">P</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">closed_interval</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.comparability_graph">
<tt class="descname">comparability_graph</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.comparability_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the comparability graph of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Comparability_graph">Wikipedia article Comparability_graph</a></p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.incomparability_graph" title="sage.combinat.posets.posets.FinitePoset.incomparability_graph"><tt class="xref py py-meth docutils literal"><span class="pre">incomparability_graph()</span></tt></a>, <a class="reference external" href="../../../../graphs/sage/graphs/comparability.html#module-sage.graphs.comparability" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-mod docutils literal"><span class="pre">sage.graphs.comparability</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">comparability_graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">comparability_graph</span><span class="p">();</span> <span class="n">g</span>
<span class="go">Comparability graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.compare_elements">
<tt class="descname">compare_elements</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.compare_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in the poset.</p>
<p>If <tt class="docutils literal"><span class="pre">x</span></tt> = <tt class="docutils literal"><span class="pre">y</span></tt>, then <tt class="docutils literal"><span class="pre">0</span></tt> is returned;
if <tt class="docutils literal"><span class="pre">x</span></tt> &lt; <tt class="docutils literal"><span class="pre">y</span></tt>, then <tt class="docutils literal"><span class="pre">-1</span></tt> is returned;
if <tt class="docutils literal"><span class="pre">x</span></tt> &gt; <tt class="docutils literal"><span class="pre">y</span></tt>, then <tt class="docutils literal"><span class="pre">1</span></tt> is returned;
and if <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> are not comparable,
then <tt class="docutils literal"><span class="pre">None</span></tt> is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">compare_elements</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.completion_by_cuts">
<tt class="descname">completion_by_cuts</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.completion_by_cuts" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the completion by cuts of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This is a lattice, also called the Dedekind-MacNeille completion.</p>
<p>See the <a class="reference external" href="https://en.wikipedia.org/wiki/Dedekind-MacNeille completion">Wikipedia article Dedekind-MacNeille completion</a>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a finite lattice</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">completion_by_cuts</span><span class="p">()</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">completion_by_cuts</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SymmetricGroupBruhatOrderPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">completion_by_cuts</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite lattice containing 7 elements</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cuts" title="sage.combinat.posets.posets.FinitePoset.cuts"><tt class="xref py py-meth docutils literal"><span class="pre">cuts()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.connected_components">
<tt class="descname">connected_components</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the connected components of the poset as subposets.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">CC</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">connected_components</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">CC</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
<span class="go">[Finite poset containing 3 elements,</span>
<span class="go"> Finite poset containing 5 elements]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">connected_components</span><span class="p">()</span> <span class="c"># Test empty poset</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.cover_relations">
<tt class="descname">cover_relations</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cover_relations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of pairs <tt class="docutils literal"><span class="pre">[x,</span> <span class="pre">y]</span></tt> of elements of the poset such
that <tt class="docutils literal"><span class="pre">y</span></tt> covers <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [0, 2], [2, 3], [3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.cover_relations_graph">
<tt class="descname">cover_relations_graph</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the graph of cover relations.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">cover_relations_graph</span><span class="p">();</span> <span class="n">G</span>
<span class="go">Graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">cover_relations_graph</span><span class="p">();</span> <span class="n">H</span>
<span class="go">Graph on 0 vertices</span>
</pre></div>
</div>
<p>Check that it is hashable and coincides with the Hasse diagram as a
graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">hash</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">Graph</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.cover_relations_iterator">
<tt class="descname">cover_relations_iterator</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the cover relations of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations_iterator</span><span class="p">())</span>
<span class="go">&lt;type &#39;generator&#39;&gt;</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">cover_relations_iterator</span><span class="p">()]</span>
<span class="go">[[1, 2], [0, 2], [2, 3], [3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.covers">
<tt class="descname">covers</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.covers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">y</span></tt> covers <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>Element <span class="math">\(y\)</span> covers <span class="math">\(x\)</span> if <span class="math">\(x &lt; y\)</span> and there is no <span class="math">\(z\)</span> such that
<span class="math">\(x &lt; z &lt; y\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.coxeter_transformation">
<tt class="descname">coxeter_transformation</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.coxeter_transformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the matrix of the Auslander-Reiten translation acting
on the Grothendieck group of the derived category of modules
on the poset <tt class="docutils literal"><span class="pre">self</span></tt>, in the basis of simple modules. This matrix is
usually called the Coxeter transformation.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">coxeter_transformation</span><span class="p">()</span>
<span class="go">[ 0  0  0  0 -1]</span>
<span class="go">[ 0  0  0  1 -1]</span>
<span class="go">[ 0  1  0  0 -1]</span>
<span class="go">[-1  1  1  0 -1]</span>
<span class="go">[-1  1  0  1 -1]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">coxeter_transformation</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">**</span><span class="mi">8</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.cuts">
<tt class="descname">cuts</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.cuts" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of cuts of the poset <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>A cut is a subset <span class="math">\(A\)</span> of <tt class="docutils literal"><span class="pre">self</span></tt> such that the set of lower
bounds of the set of upper bounds of <span class="math">\(A\)</span> is exactly <span class="math">\(A\)</span>.</p>
<p>The cuts are computed here using the maximal independent sets in the
auxiliary graph defined as <span class="math">\(P \times [0,1]\)</span> with an edge
from <span class="math">\((x, 0)\)</span> to <span class="math">\((y, 1)\)</span> if
and only if <span class="math">\(x \not\geq_P y\)</span>. See the end of section 4 in <a class="reference internal" href="#jrj94" id="id4">[JRJ94]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Pc</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">cuts</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">Pc</span><span class="p">]</span>
<span class="go">[[0], [0, 1, 2], [], [1], [2]]</span>
<span class="gp">sage: </span><span class="n">Pc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">frozenset({0})</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.completion_by_cuts" title="sage.combinat.posets.posets.FinitePoset.completion_by_cuts"><tt class="xref py py-meth docutils literal"><span class="pre">completion_by_cuts()</span></tt></a></p>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="jrj94" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[JRJ94]</a></td><td>Jourdan, Guy-Vincent; Rampon, Jean-Xavier; Jard, Claude
(1994), &#8220;Computing on-line the lattice of maximal antichains
of posets&#8221;, Order 11 (3) p. 197-210, <a class="reference external" href="https://dx.doi.org/10.1007/BF02115811">doi:10.1007/BF02115811</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.dilworth_decomposition">
<tt class="descname">dilworth_decomposition</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.dilworth_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a partition of the points into the minimal number of chains.</p>
<p>According to Dilworth&#8217;s theorem, the points of a poset can be
partitioned into <span class="math">\(\alpha\)</span> chains, where <span class="math">\(\alpha\)</span> is the cardinality of
its largest antichain. This method returns such a partition.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Dilworth's_theorem">Wikipedia article Dilworth&#8217;s_theorem</a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.width" title="sage.combinat.posets.posets.FinitePoset.width"><tt class="xref py py-meth docutils literal"><span class="pre">width()</span></tt></a> &#8211; return the width of the poset.</p>
</div>
<p>ALGORITHM:</p>
<p>We build a bipartite graph in which a vertex <span class="math">\(v\)</span> of the poset is
represented by two vertices <span class="math">\(v^-,v^+\)</span>. For any two <span class="math">\(u,v\)</span> such that
<span class="math">\(u&lt;v\)</span> in the poset we add an edge <span class="math">\(v^+u^-\)</span>.</p>
<p>A matching in this graph is equivalent to a partition of the poset
into chains: indeed, a chain <span class="math">\(v_1...v_k\)</span> gives rise to the matching
<span class="math">\(v_1^+v_2^-,v_2^+v_3^-,...\)</span>, and from a matching one can build the
union of chains.</p>
<dl class="docutils">
<dt>According to Dilworth&#8217;s theorem, the number of chains is equal to</dt>
<dd><span class="math">\(\alpha\)</span> (the posets&#8217; width).</dd>
</dl>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">width</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">dilworth_decomposition</span><span class="p">()</span>  <span class="c"># random</span>
<span class="go">[[7, 6, 4], [11, 3], [12, 8, 0], [13, 9, 1], [14, 10, 2], [15, 5]]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">IntegerCompositions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">dilworth_decomposition</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
<span class="go">....:    for i in range(len(chain)-1):</span>
<span class="go">....:        assert p.is_greater_than(chain[i],chain[i+1])</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.dimension">
<tt class="descname">dimension</tt><big>(</big><em>certificate=False</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension of the Poset.</p>
<p>The (Dushnik-Miller) dimension of a poset is the minimal
number of total orders so that the poset can be defined as
&#8220;intersection&#8221; of all of them. Mathematically said, dimension
of a poset defined on a set <span class="math">\(X\)</span> of points is the smallest
integer <span class="math">\(n\)</span> such that there exists <span class="math">\(P_1,...,P_n\)</span> linear
extensions of <span class="math">\(P\)</span> satisfying the following property:</p>
<div class="math">
\[u\leq_P v\ \text{if and only if }\ \forall i, u\leq_{P_i} v\]</div>
<p>For more information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Order_dimension">Wikipedia article Order_dimension</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">certificate</span></tt> (boolean; default:<tt class="docutils literal"><span class="pre">False</span></tt>) &#8211; whether to return an
integer (the dimension) or a certificate, i.e. a smallest set of
linear extensions.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The speed of this function greatly improves when more efficient
MILP solvers (e.g. Gurobi, CPLEX) are installed. See
<a class="reference external" href="../../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">MixedIntegerLinearProgram</span></tt></a> for more information.</p>
</div>
<p>ALGORITHM:</p>
<p>As explained <a class="reference internal" href="#ft00" id="id5">[FT00]</a>, the dimension of a poset is equal to the (weak)
chromatic number of a hypergraph. More precisely:</p>
<blockquote>
<div><p>Let <span class="math">\(inc(P)\)</span> be the set of (ordered) pairs of incomparable elements
of <span class="math">\(P\)</span>, i.e. all <span class="math">\(uv\)</span> and <span class="math">\(vu\)</span> such that <span class="math">\(u\not \leq_P v\)</span> and <span class="math">\(v\not
\leq_P u\)</span>. Any linear extension of <span class="math">\(P\)</span> is a total order on <span class="math">\(X\)</span> that
can be seen as the union of relations from <span class="math">\(P\)</span> along with some
relations from <span class="math">\(inc(P)\)</span>. Thus, the dimension of <span class="math">\(P\)</span> is the smallest
number of linear extensions of <span class="math">\(P\)</span> which <em>cover</em> all points of
<span class="math">\(inc(P)\)</span>.</p>
<p>Consequently, <span class="math">\(dim(P)\)</span> is equal to the chromatic number of the
hypergraph <span class="math">\(\mathcal H_{inc}\)</span>, where <span class="math">\(\mathcal H_{inc}\)</span> is the
hypergraph defined on <span class="math">\(inc(P)\)</span> whose sets are all <span class="math">\(S\subseteq
inc(P)\)</span> such that <span class="math">\(P\cup S\)</span> is not acyclic.</p>
</div></blockquote>
<p>We solve this problem through a <a class="reference external" href="../../../../numerical/sage/numerical/mip.html#module-sage.numerical.mip" title="(in Sage Reference Manual: Numerical Optimization v6.9)"><tt class="xref py py-mod docutils literal"><span class="pre">Mixed</span> <span class="pre">Integer</span> <span class="pre">Linear</span> <span class="pre">Program</span></tt></a>.</p>
<p>EXAMPLES:</p>
<p>We create a poset, compute a set of linear extensions and check
that we get back the poset from them:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="c"># random -- architecture-dependent</span>
<span class="go">[[0, 2, 4, 5, 1, 3, 6], [2, 5, 0, 1, 3, 4, 6], [0, 1, 2, 3, 5, 6, 4]]</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span> <span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">all</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">L</span><span class="p">))</span> <span class="p">)</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<p>According to Schnyder&#8217;s theorem, the poset (of height 2) of a graph has
dimension <span class="math">\(\leq 3\)</span> if and only if the graph is planar:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()}))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteBipartiteGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()}))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="c"># not tested - around 4s with CPLEX</span>
<span class="go">4</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Empty Poset:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">dimension</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>References:</p>
<table class="docutils citation" frame="void" id="ft00" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[FT00]</a></td><td>Stefan Felsner, William T. Trotter,
Dimension, Graph and Hypergraph Coloring,
Order,
2000, Volume 17, Issue 2, pp 167-177,
<a class="reference external" href="http://link.springer.com/article/10.1023%2FA%3A1006429830221">http://link.springer.com/article/10.1023%2FA%3A1006429830221</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.disjoint_union">
<tt class="descname">disjoint_union</tt><big>(</big><em>other</em>, <em>labels='pairs'</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.disjoint_union" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a poset isomorphic to disjoint union (also called direct
sum) of the poset with <tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>The disjoint union of <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> is a poset that contains
every element and relation from both <span class="math">\(P\)</span> and <span class="math">\(Q\)</span>, and where
every element of <span class="math">\(P\)</span> is incomparable to every element of <span class="math">\(Q\)</span>.</p>
<p>Mathematically, it is only defined when <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> have no
common element; here we force that by giving them different
names in the resulting poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt>, a poset.</li>
<li><tt class="docutils literal"><span class="pre">labels</span></tt> - (defaults to &#8216;pairs&#8217;) If set to &#8216;pairs&#8217;, each
element <tt class="docutils literal"><span class="pre">v</span></tt> in this poset will be named <tt class="docutils literal"><span class="pre">(0,v)</span></tt> and each
element <tt class="docutils literal"><span class="pre">u</span></tt> in <tt class="docutils literal"><span class="pre">other</span></tt> will be named <tt class="docutils literal"><span class="pre">(1,u)</span></tt> in the
result. If set to &#8216;integers&#8217;, the elements of the result
will be relabeled with consecutive integers.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]])</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">]])</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">P2</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[[(0, &#39;a&#39;), (0, &#39;b&#39;)], [(1, &#39;c&#39;), (1, &#39;d&#39;)]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">P2</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s">&#39;integers&#39;</span><span class="p">);</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[2, 3], [0, 1]]</span>

<span class="gp">sage: </span><span class="n">N5</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">();</span> <span class="n">N5</span>
<span class="go">Finite lattice containing 5 elements</span>
<span class="gp">sage: </span><span class="n">N5</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">N5</span><span class="p">)</span>  <span class="c"># Union of lattices is not a lattice</span>
<span class="go">Finite poset containing 10 elements</span>
</pre></div>
</div>
<p>We show how to get literally direct sum with elements untouched:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.dual">
<tt class="descname">dual</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual poset of the given poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[3, 1], [2, 1]]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">LatticePoset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]],</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 2], [1, 3], [2, 3]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[3, 2], [3, 1], [2, 0], [1, 0]]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of finite lattice posets</span>
<span class="go">    and Category of finite enumerated sets</span>
<span class="go">    and Category of facade sets</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">__class__</span>
<span class="go">&lt;class &#39;sage.combinat.posets.lattices.FiniteLatticePoset_with_category&#39;&gt;</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">MeetSemilattice</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">__class__</span>
<span class="go">&lt;class &#39;sage.combinat.posets.lattices.FiniteJoinSemilattice_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">JoinSemilattice</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">__class__</span>
<span class="go">&lt;class &#39;sage.combinat.posets.lattices.FiniteMeetSemilattice_with_category&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.evacuation">
<tt class="descname">evacuation</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.evacuation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute evacuation on the linear extension associated
to the poset <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>an isomorphic poset, with the same default linear extension</li>
</ul>
<p>Evacuation is defined on a poset <tt class="docutils literal"><span class="pre">self</span></tt> of size <span class="math">\(n\)</span> by
applying the evacuation operator
<span class="math">\((\tau_1 \cdots \tau_{n-1}) (\tau_1 \cdots \tau_{n-2}) \cdots (\tau_1)\)</span>,
to the default linear extension <span class="math">\(\pi\)</span> of <tt class="docutils literal"><span class="pre">self</span></tt>
(see <a class="reference internal" href="linear_extensions.html#sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.evacuation" title="sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.evacuation"><tt class="xref py py-meth docutils literal"><span class="pre">evacuation()</span></tt></a>),
and relabeling <tt class="docutils literal"><span class="pre">self</span></tt> accordingly. For more details see <a class="reference internal" href="#stan2009" id="id6">[Stan2009]</a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><tt class="xref py py-meth docutils literal"><span class="pre">linear_extension()</span></tt></a></li>
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_linear_extension" title="sage.combinat.posets.posets.FinitePoset.with_linear_extension"><tt class="xref py py-meth docutils literal"><span class="pre">with_linear_extension()</span></tt></a> and the <tt class="docutils literal"><span class="pre">linear_extension</span></tt> option of <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><tt class="xref py py-func docutils literal"><span class="pre">Poset()</span></tt></a></li>
<li><a class="reference internal" href="linear_extensions.html#sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.evacuation" title="sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.evacuation"><tt class="xref py py-meth docutils literal"><span class="pre">evacuation()</span></tt></a></li>
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.promotion" title="sage.combinat.posets.posets.FinitePoset.promotion"><tt class="xref py py-meth docutils literal"><span class="pre">promotion()</span></tt></a></li>
</ul>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="stan2009" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Stan2009]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id15">2</a>, <a class="fn-backref" href="#id20">3</a>)</em> Richard Stanley,
<em>Promotion and evacuation</em>,
Electron. J. Combin. 16 (2009), no. 2, Special volume in honor of
Anders Björner,
Research Paper 9, 24 pp.</td></tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">()</span>
<span class="go">Finite poset containing 2 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">()</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite poset containing 7 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 5], [3, 4], [3, 6], [4, 7], [6, 7]]</span>
</pre></div>
</div>
<p>Note that the results depend on the linear extension associated
to the poset:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 6, 4, 7]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite poset containing 7 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 5], [2, 3], [5, 6], [5, 4], [6, 7], [4, 7]]</span>
</pre></div>
</div>
<p>Here is an example of a poset where the vertices are not labelled
by <span class="math">\(\{1,2,\ldots,n\}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 3, 5, 15]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">evacuation</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Finite poset containing 4 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 3], [1, 5], [3, 15], [5, 15]]</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Anne Schilling (2012-02-18)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.f_polynomial">
<tt class="descname">f_polynomial</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.f_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math">\(f\)</span>-polynomial of a bounded poset <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This is the <span class="math">\(f\)</span>-polynomial of the order complex of the poset
minus its bounds.</p>
<p>The coefficient of <span class="math">\(q^i\)</span> is the number of chains of
<span class="math">\(i+1\)</span> elements containing both bounds of the poset.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><tt class="xref py py-meth docutils literal"><span class="pre">is_bounded()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.h_polynomial" title="sage.combinat.posets.posets.FinitePoset.h_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">h_polynomial()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="sage.combinat.posets.posets.FinitePoset.order_complex"><tt class="xref py py-meth docutils literal"><span class="pre">order_complex()</span></tt></a>,
<a class="reference external" href="../../../../homology/sage/homology/cell_complex.html#sage.homology.cell_complex.GenericCellComplex.f_vector" title="(in Sage Reference Manual: Cell complexes and their homology v6.9)"><tt class="xref py py-meth docutils literal"><span class="pre">sage.homology.cell_complex.GenericCellComplex.f_vector()</span></tt></a></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is slightly different from the <tt class="docutils literal"><span class="pre">fPolynomial</span></tt>
method in Macaulay2.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">f_polynomial</span><span class="p">()</span>
<span class="go">3*q^2 + q</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span><span class="mi">5</span><span class="p">:[</span><span class="mi">7</span><span class="p">],</span><span class="mi">6</span><span class="p">:[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">f_polynomial</span><span class="p">()</span>
<span class="go">q^4 + 4*q^3 + 5*q^2 + q</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">2</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">f_polynomial</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.flag_f_polynomial">
<tt class="descname">flag_f_polynomial</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.flag_f_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the flag <span class="math">\(f\)</span>-polynomial of a bounded and ranked poset
<tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This is the sum, over all chains containing both bounds,
of a monomial encoding the ranks of the elements of the chain.</p>
<p>More precisely, if <span class="math">\(P\)</span> is a bounded ranked poset, then the
flag <span class="math">\(f\)</span>-polynomial of <span class="math">\(P\)</span> is defined as the polynomial</p>
<div class="math">
\[\begin{split}\sum_{\substack{p_0 &lt; p_1 &lt; \ldots &lt; p_k, \\
                p_0 = \min P, \ p_k = \max P}}
x_{\rho(p_1)} x_{\rho(p_2)} \cdots x_{\rho(p_k)}
\in \ZZ[x_1, x_2, \cdots, x_n]\end{split}\]</div>
<p>where <span class="math">\(\min P\)</span> and <span class="math">\(\max P\)</span> are (respectively) the minimum and
the maximum of <span class="math">\(P\)</span>, where <span class="math">\(\rho\)</span> is the rank function of <span class="math">\(P\)</span>
(normalized to satisfy <span class="math">\(\rho(\min P) = 0\)</span>), and where
<span class="math">\(n\)</span> is the rank of <span class="math">\(\max P\)</span>. (Note that the indeterminate
<span class="math">\(x_0\)</span> doesn&#8217;t actually appear in the polynomial.)</p>
<p>For technical reasons, the polynomial is returned in the
slightly larger ring <span class="math">\(\ZZ[x_0, x_1, x_2, \cdots, x_{n+1}]\)</span> by
this method.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/h-vector">Wikipedia article h-vector</a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><tt class="xref py py-meth docutils literal"><span class="pre">is_bounded()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_h_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_h_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">flag_h_polynomial()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_f_polynomial</span><span class="p">()</span>
<span class="go">3*x1*x2 + x2</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span><span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">fl</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">flag_f_polynomial</span><span class="p">();</span> <span class="n">fl</span>
<span class="go">2*x1*x2*x3 + 2*x1*x3 + 2*x2*x3 + x3</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="s">&#39;q&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fl</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">f_polynomial</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_f_polynomial</span><span class="p">()</span>
<span class="go">3*x1*x2*x3 + 3*x1*x3 + x2*x3 + x3</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_f_polynomial</span><span class="p">()</span>
<span class="go">x1</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">2</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_f_polynomial</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.flag_h_polynomial">
<tt class="descname">flag_h_polynomial</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.flag_h_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the flag <span class="math">\(h\)</span>-polynomial of a bounded and ranked poset
<tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>If <span class="math">\(P\)</span> is a bounded ranked poset whose maximal element has
rank <span class="math">\(n\)</span> (where the minimal element is set to have rank <span class="math">\(0\)</span>),
then the flag <span class="math">\(h\)</span>-polynomial of <span class="math">\(P\)</span> is defined as the
polynomial</p>
<div class="math">
\[\prod_{k=1}^n (1-x_k) \cdot f \left(\frac{x_1}{1-x_1},
\frac{x_2}{1-x_2}, \cdots, \frac{x_n}{1-x_n}\right)
\in \ZZ[x_1, x_2, \cdots, x_n],\]</div>
<p>where <span class="math">\(f\)</span> is the flag <span class="math">\(f\)</span>-polynomial of <span class="math">\(P\)</span> (see
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_f_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_f_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">flag_f_polynomial()</span></tt></a>).</p>
<p>For technical reasons, the polynomial is returned in the
slightly larger ring <span class="math">\(\QQ[x_0, x_1, x_2, \cdots, x_{n+1}]\)</span> by
this method.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/h-vector">Wikipedia article h-vector</a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><tt class="xref py py-meth docutils literal"><span class="pre">is_bounded()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.flag_f_polynomial" title="sage.combinat.posets.posets.FinitePoset.flag_f_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">flag_f_polynomial()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">()</span>
<span class="go">2*x1*x2 + x2</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span><span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">fl</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">();</span> <span class="n">fl</span>
<span class="go">-x1*x2*x3 + x1*x3 + x2*x3 + x3</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="s">&#39;q&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fl</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">h_polynomial</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span><span class="mi">5</span><span class="p">:[</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">()</span>
<span class="go">2*x1*x3 + x3</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">()</span>
<span class="go">x3</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">()</span>
<span class="go">x1</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">2</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">flag_h_polynomial</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.frank_network">
<tt class="descname">frank_network</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.frank_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes Frank&#8217;s network of the poset <tt class="docutils literal"><span class="pre">self</span></tt>. This is defined in
Section 8 of <a class="reference internal" href="#bf1999" id="id7">[BF1999]</a>.</p>
<p>OUTPUT:</p>
<p>A pair <span class="math">\((G, e)\)</span>, where <span class="math">\(G\)</span> is Frank&#8217;s network of <span class="math">\(P\)</span> encoded as a
<a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">DiGraph</span></tt></a>, and <span class="math">\(e\)</span> is the cost function on its edges encoded
as a dictionary (indexed by these edges, which in turn are encoded
as tuples of 2 vertices).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Frank&#8217;s network of <span class="math">\(P\)</span> is a certain directed graph with <span class="math">\(2|P| + 2\)</span>
vertices, defined in Section 8 of <a class="reference internal" href="#bf1999" id="id8">[BF1999]</a>. Its set of vertices
consists of two vertices <span class="math">\((0, p)\)</span> and <span class="math">\((1, p)\)</span> for each element
<span class="math">\(p\)</span> of <span class="math">\(P\)</span>, as well as two vertices <span class="math">\((-1, 0)\)</span> and <span class="math">\((2, 0)\)</span>.
(These notations are not the ones used in <a class="reference internal" href="#bf1999" id="id9">[BF1999]</a>; see the table
below for their relation.) The edges are:</p>
<ul class="simple">
<li>for each <span class="math">\(p\)</span> in <span class="math">\(P\)</span>, an edge from <span class="math">\((-1, 0)\)</span> to <span class="math">\((0, p)\)</span>;</li>
<li>for each <span class="math">\(p\)</span> in <span class="math">\(P\)</span>, an edge from <span class="math">\((1, p)\)</span> to <span class="math">\((2, 0)\)</span>;</li>
<li>for each <span class="math">\(p\)</span> and <span class="math">\(q\)</span> in <span class="math">\(P\)</span> such that <span class="math">\(x \geq y\)</span>, an edge from
<span class="math">\((0, p)\)</span> to <span class="math">\((1, q)\)</span>.</li>
</ul>
<p>We make this digraph into a network in the sense of flow theory as
follows: The vertex <span class="math">\((-1, 0)\)</span> is considered as the source of this
network, and the vertex <span class="math">\((2, 0)\)</span> as the sink. The cost function is
defined to be <span class="math">\(1\)</span> on the edge from <span class="math">\((0, p)\)</span> to <span class="math">\((1, p)\)</span> for each
<span class="math">\(p \in P\)</span>, and to be <span class="math">\(0\)</span> on every other edge. The capacity is <span class="math">\(1\)</span>
on each edge. Here is how to translate this notations into that
used in <a class="reference internal" href="#bf1999" id="id10">[BF1999]</a>:</p>
<div class="last highlight-python"><div class="highlight"><pre>our notations                    [BF1999]
   (-1, 0)                          s
   (0, p)                          x_p
   (1, p)                          y_p
   (2, 0)                           t
    a[e]                           a(e)
</pre></div>
</div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="bf1999" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[BF1999]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id8">2</a>, <a class="fn-backref" href="#id9">3</a>, <a class="fn-backref" href="#id10">4</a>, <a class="fn-backref" href="#id11">5</a>)</em> Thomas Britz, Sergey Fomin,
<em>Finite posets and Ferrers shapes</em>,
Advances in Mathematics 158, pp. 86-127 (2001),
<a class="reference external" href="http://arxiv.org/abs/math/9912126">Arxiv math/9912126</a> (the arXiv version has less errors).</td></tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">ps</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">16</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">13</span><span class="p">],[[</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">],[</span><span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">13</span><span class="p">],[</span><span class="mi">12</span><span class="p">,</span><span class="mi">16</span><span class="p">],[</span><span class="mi">16</span><span class="p">,</span><span class="o">-</span><span class="mi">13</span><span class="p">]]]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span><span class="o">.</span><span class="n">frank_network</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[((-1, 0), (0, -13), None), ((-1, 0), (0, 12), None), ((-1, 0), (0, 14), None), ((-1, 0), (0, 16), None), ((0, -13), (1, -13), None), ((0, -13), (1, 12), None), ((0, -13), (1, 14), None), ((0, -13), (1, 16), None), ((0, 12), (1, 12), None), ((0, 14), (1, 12), None), ((0, 14), (1, 14), None), ((0, 16), (1, 12), None), ((0, 16), (1, 16), None), ((1, -13), (2, 0), None), ((1, 12), (2, 0), None), ((1, 14), (2, 0), None), ((1, 16), (2, 0), None)]</span>
<span class="gp">sage: </span><span class="n">e</span>
<span class="go">{((-1, 0), (0, -13)): 0,</span>
<span class="go"> ((-1, 0), (0, 12)): 0,</span>
<span class="go"> ((-1, 0), (0, 14)): 0,</span>
<span class="go"> ((-1, 0), (0, 16)): 0,</span>
<span class="go"> ((0, -13), (1, -13)): 1,</span>
<span class="go"> ((0, -13), (1, 12)): 0,</span>
<span class="go"> ((0, -13), (1, 14)): 0,</span>
<span class="go"> ((0, -13), (1, 16)): 0,</span>
<span class="go"> ((0, 12), (1, 12)): 1,</span>
<span class="go"> ((0, 14), (1, 12)): 0,</span>
<span class="go"> ((0, 14), (1, 14)): 1,</span>
<span class="go"> ((0, 16), (1, 12)): 0,</span>
<span class="go"> ((0, 16), (1, 16)): 1,</span>
<span class="go"> ((1, -13), (2, 0)): 0,</span>
<span class="go"> ((1, 12), (2, 0)): 0,</span>
<span class="go"> ((1, 14), (2, 0)): 0,</span>
<span class="go"> ((1, 16), (2, 0)): 0}</span>
<span class="gp">sage: </span><span class="n">qs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]]</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">qs</span><span class="p">)</span><span class="o">.</span><span class="n">frank_network</span><span class="p">()</span>
<span class="go">(Digraph on 20 vertices,</span>
<span class="go"> {((-1, 0), (0, 1)): 0,</span>
<span class="go">  ((-1, 0), (0, 2)): 0,</span>
<span class="go">  ((-1, 0), (0, 3)): 0,</span>
<span class="go">  ((-1, 0), (0, 4)): 0,</span>
<span class="go">  ((-1, 0), (0, 5)): 0,</span>
<span class="go">  ((-1, 0), (0, 6)): 0,</span>
<span class="go">  ((-1, 0), (0, 7)): 0,</span>
<span class="go">  ((-1, 0), (0, 8)): 0,</span>
<span class="go">  ((-1, 0), (0, 9)): 0,</span>
<span class="go">  ((0, 1), (1, 1)): 1,</span>
<span class="go">  ((0, 2), (1, 2)): 1,</span>
<span class="go">  ((0, 3), (1, 1)): 0,</span>
<span class="go">  ((0, 3), (1, 2)): 0,</span>
<span class="go">  ((0, 3), (1, 3)): 1,</span>
<span class="go">  ((0, 4), (1, 1)): 0,</span>
<span class="go">  ((0, 4), (1, 2)): 0,</span>
<span class="go">  ((0, 4), (1, 3)): 0,</span>
<span class="go">  ((0, 4), (1, 4)): 1,</span>
<span class="go">  ((0, 5), (1, 5)): 1,</span>
<span class="go">  ((0, 6), (1, 6)): 1,</span>
<span class="go">  ((0, 7), (1, 5)): 0,</span>
<span class="go">  ((0, 7), (1, 7)): 1,</span>
<span class="go">  ((0, 8), (1, 8)): 1,</span>
<span class="go">  ((0, 9), (1, 1)): 0,</span>
<span class="go">  ((0, 9), (1, 9)): 1,</span>
<span class="go">  ((1, 1), (2, 0)): 0,</span>
<span class="go">  ((1, 2), (2, 0)): 0,</span>
<span class="go">  ((1, 3), (2, 0)): 0,</span>
<span class="go">  ((1, 4), (2, 0)): 0,</span>
<span class="go">  ((1, 5), (2, 0)): 0,</span>
<span class="go">  ((1, 6), (2, 0)): 0,</span>
<span class="go">  ((1, 7), (2, 0)): 0,</span>
<span class="go">  ((1, 8), (2, 0)): 0,</span>
<span class="go">  ((1, 9), (2, 0)): 0})</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Darij Grinberg (2013-05-09)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.ge">
<tt class="descname">ge</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.ge" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if <span class="math">\(x\)</span> is greater than or equal to <span class="math">\(y\)</span> in the poset,
and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.graphviz_string">
<tt class="descname">graphviz_string</tt><big>(</big><em>graph_string='graph'</em>, <em>edge_string='--'</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.graphviz_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a representation in the DOT language, ready to render in
graphviz.</p>
<p>REFERENCES:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.graphviz.org/doc/info/lang.html">http://www.graphviz.org/doc/info/lang.html</a></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">],</span><span class="s">&#39;b&#39;</span><span class="p">:[</span><span class="s">&#39;d&#39;</span><span class="p">],</span><span class="s">&#39;c&#39;</span><span class="p">:[</span><span class="s">&#39;d&#39;</span><span class="p">],</span><span class="s">&#39;d&#39;</span><span class="p">:[</span><span class="s">&#39;f&#39;</span><span class="p">],</span><span class="s">&#39;e&#39;</span><span class="p">:[</span><span class="s">&#39;f&#39;</span><span class="p">],</span><span class="s">&#39;f&#39;</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="n">P</span><span class="o">.</span><span class="n">graphviz_string</span><span class="p">()</span>
<span class="go">graph {</span>
<span class="go">&quot;f&quot;;&quot;d&quot;;&quot;b&quot;;&quot;a&quot;;&quot;c&quot;;&quot;e&quot;;</span>
<span class="go">&quot;f&quot;--&quot;e&quot;;&quot;d&quot;--&quot;c&quot;;&quot;b&quot;--&quot;a&quot;;&quot;d&quot;--&quot;b&quot;;&quot;f&quot;--&quot;d&quot;;</span>
<span class="go">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.greene_shape">
<tt class="descname">greene_shape</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.greene_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Greene-Kleitman partition of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The Greene-Kleitman partition of a finite poset <span class="math">\(P\)</span> is the partition
<span class="math">\((c_1 - c_0, c_2 - c_1, c_3 - c_2, \ldots)\)</span>, where <span class="math">\(c_k\)</span> is the
maximum cardinality of a union of <span class="math">\(k\)</span> chains of <span class="math">\(P\)</span>. Equivalently,
this is the conjugate of the partition <span class="math">\((a_1 - a_0, a_2 - a_1, a_3 -
a_2, \ldots)\)</span>, where <span class="math">\(a_k\)</span> is the maximum cardinality of a union of
<span class="math">\(k\)</span> antichains of <span class="math">\(P\)</span>.</p>
<p>See many sources, e. g., <a class="reference internal" href="#bf1999" id="id11">[BF1999]</a>, for proofs of this equivalence.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">greene_shape</span><span class="p">()</span>
<span class="go">[2, 1]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">greene_shape</span><span class="p">()</span>
<span class="go">[3, 1]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">greene_shape</span><span class="p">()</span>
<span class="go">[3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">greene_shape</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Darij Grinberg (2013-05-09)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.gt">
<tt class="descname">gt</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.gt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if <span class="math">\(x\)</span> is greater than but not equal to <span class="math">\(y\)</span> in the
poset, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.h_polynomial">
<tt class="descname">h_polynomial</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.h_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math">\(h\)</span>-polynomial of a bounded poset <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This is the <span class="math">\(h\)</span>-polynomial of the order complex of the poset
minus its bounds.</p>
<p>This is related to the <span class="math">\(f\)</span>-polynomial by a simple change
of variables:</p>
<div class="math">
\[h(q) = (1-q)^{\deg f} f \left( \frac{q}{1-q} \right),\]</div>
<p>where <span class="math">\(f\)</span> and <span class="math">\(h\)</span> denote the <span class="math">\(f\)</span>-polynomial and the
<span class="math">\(h\)</span>-polynomial, respectively.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/h-vector">Wikipedia article h-vector</a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="sage.combinat.posets.posets.FinitePoset.is_bounded"><tt class="xref py py-meth docutils literal"><span class="pre">is_bounded()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.f_polynomial" title="sage.combinat.posets.posets.FinitePoset.f_polynomial"><tt class="xref py py-meth docutils literal"><span class="pre">f_polynomial()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="sage.combinat.posets.posets.FinitePoset.order_complex"><tt class="xref py py-meth docutils literal"><span class="pre">order_complex()</span></tt></a>,
<a class="reference external" href="../../../../homology/sage/homology/simplicial_complex.html#sage.homology.simplicial_complex.SimplicialComplex.h_vector" title="(in Sage Reference Manual: Cell complexes and their homology v6.9)"><tt class="xref py py-meth docutils literal"><span class="pre">sage.homology.simplicial_complex.SimplicialComplex.h_vector()</span></tt></a></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is slightly different from the <tt class="docutils literal"><span class="pre">hPolynomial</span></tt>
method in Macaulay2.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">order_ideals_lattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">h_polynomial</span><span class="p">()</span>
<span class="go">q^3 + 4*q^2 + q</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">h_polynomial</span><span class="p">()</span>
<span class="go">2*q^2 + q</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">h_polynomial</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.has_bottom">
<tt class="descname">has_bottom</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the poset has a unique minimal element, and
<tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">has_bottom</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">has_bottom</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.bottom" title="sage.combinat.posets.posets.FinitePoset.bottom"><tt class="xref py py-meth docutils literal"><span class="pre">bottom()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="sage.combinat.posets.posets.FinitePoset.has_top"><tt class="xref py py-meth docutils literal"><span class="pre">has_top()</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet">
<tt class="descname">has_isomorphic_subposet</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.has_isomorphic_subposet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the poset contains a subposet isomorphic to
<tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>By subposet we mean that there exist a set <tt class="docutils literal"><span class="pre">X</span></tt> of elements such
that <tt class="docutils literal"><span class="pre">self.subposet(X)</span></tt> is isomorphic to <tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; a finite poset</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">N5</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>

<span class="gp">sage: </span><span class="n">N5</span><span class="o">.</span><span class="n">has_isomorphic_subposet</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">N5</span><span class="o">.</span><span class="n">has_isomorphic_subposet</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="nb">len</span><span class="p">([</span><span class="n">P</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">has_isomorphic_subposet</span><span class="p">(</span><span class="n">D</span><span class="p">)])</span>
<span class="go">11</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.has_top">
<tt class="descname">has_top</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the poset has a unique maximal element, and
<tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[],</span><span class="mi">5</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">has_top</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">has_top</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.top" title="sage.combinat.posets.posets.FinitePoset.top"><tt class="xref py py-meth docutils literal"><span class="pre">top()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_bottom" title="sage.combinat.posets.posets.FinitePoset.has_bottom"><tt class="xref py py-meth docutils literal"><span class="pre">has_bottom()</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.hasse_diagram">
<tt class="descname">hasse_diagram</tt><big>(</big><em>wrapped=True</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.hasse_diagram" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Hasse diagram of <tt class="docutils literal"><span class="pre">self</span></tt> as a Sage <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">DiGraph</span></tt></a>. If
<tt class="docutils literal"><span class="pre">dot2tex</span></tt> is installed, then this sets the Hasse diagram&#8217;s latex
options to use the <tt class="docutils literal"><span class="pre">dot2tex</span></tt> formatting.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Should the vertices of the diagram have the poset as parent?</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">0</span><span class="p">]},</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span>
<span class="go">Digraph on 6 vertices</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">],</span><span class="s">&#39;b&#39;</span><span class="p">:[</span><span class="s">&#39;d&#39;</span><span class="p">],</span><span class="s">&#39;c&#39;</span><span class="p">:[</span><span class="s">&#39;d&#39;</span><span class="p">],</span><span class="s">&#39;d&#39;</span><span class="p">:[</span><span class="s">&#39;f&#39;</span><span class="p">],</span><span class="s">&#39;e&#39;</span><span class="p">:[</span><span class="s">&#39;f&#39;</span><span class="p">],</span><span class="s">&#39;f&#39;</span><span class="p">:[]},</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[e, f], [c, d], [a, b], [b, d], [d, f]]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(a, b, None), (c, d, None), (b, d, None), (e, f, None), (d, f, None)]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[1, 5, 3, 15]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(1, 3, None), (1, 5, None), (5, 15, None), (3, 15, None)]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">set_latex_options</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&quot;dot2tex&quot;</span><span class="p">)</span>   <span class="c"># optional - dot2tex</span>
<span class="gp">sage: </span><span class="n">view</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">tight_page</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># optional - dot2tex, not tested (opens external window)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.height">
<tt class="descname">height</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the height (number of elements in a longest chain) of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">height</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">height</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">height</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.incidence_algebra">
<tt class="descname">incidence_algebra</tt><big>(</big><em>R</em>, <em>prefix='I'</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.incidence_algebra" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the incidence algebra of <tt class="docutils literal"><span class="pre">self</span></tt> over <tt class="docutils literal"><span class="pre">R</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">incidence_algebra</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Incidence algebra of Finite lattice containing 16 elements</span>
<span class="go"> over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.incomparability_graph">
<tt class="descname">incomparability_graph</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.incomparability_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the incomparability graph of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This is the complement of the comparability graph.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.comparability_graph" title="sage.combinat.posets.posets.FinitePoset.comparability_graph"><tt class="xref py py-meth docutils literal"><span class="pre">comparability_graph()</span></tt></a>, <a class="reference external" href="../../../../graphs/sage/graphs/comparability.html#module-sage.graphs.comparability" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-mod docutils literal"><span class="pre">sage.graphs.comparability</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">incomparability_graph</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">0</span>

<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">incomparability_graph</span><span class="p">();</span> <span class="n">g</span>
<span class="go">Incomparability graph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.interval">
<tt class="descname">interval</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the elements <span class="math">\(z\)</span> such that <span class="math">\(x \le z \le y\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; any element of the poset</li>
<li><tt class="docutils literal"><span class="pre">y</span></tt> &#8211; any element of the poset</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">uc</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]]</span>
<span class="gp">sage: </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uc</span><span class="p">)),</span><span class="n">uc</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">P</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">dg</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="s">&quot;a&quot;</span><span class="p">:[</span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="s">&quot;c&quot;</span><span class="p">],</span> <span class="s">&quot;b&quot;</span><span class="p">:[</span><span class="s">&quot;d&quot;</span><span class="p">],</span> <span class="s">&quot;c&quot;</span><span class="p">:[</span><span class="s">&quot;d&quot;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">dg</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;d&quot;</span><span class="p">)</span>
<span class="go">[a, b, c, d]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.intervals">
<tt class="descname">intervals</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all relations of the poset.</p>
<p>A relation is a pair of elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> such that <span class="math">\(x\leq y\)</span>
in <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Relations are also often called intervals. The number of
intervals is the dimension of the incidence algebra.</p>
<p>OUTPUT:</p>
<p>A list of pairs (each pair is a list), where the first element
of the pair is less than or equal to the second element.</p>
<p>Pairs are produced in a rough sort of lexicographic order,
where earlier elements are from lower levels of the poset.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="sage.combinat.posets.posets.FinitePoset.relations_number"><tt class="xref py py-meth docutils literal"><span class="pre">relations_number()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><tt class="xref py py-meth docutils literal"><span class="pre">relations_iterator()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">relations</span><span class="p">()</span>
<span class="go">[[1, 1], [1, 2], [1, 3], [1, 4], [0, 0], [0, 2], [0, 3],</span>
<span class="go">[0, 4], [2, 2], [2, 3], [2, 4], [3, 3], [3, 4], [4, 4]]</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Rob Beezer (2011-05-04)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.intervals_iterator">
<tt class="descname">intervals_iterator</tt><big>(</big><em>strict=False</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.intervals_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator for all the relations of the poset.</p>
<p>A relation is a pair of elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> such that <span class="math">\(x\leq y\)</span>
in <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Relations are also often called intervals. The number of
intervals is the dimension of the incidence algebra.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">strict</span></tt> &#8211; boolean (default <tt class="docutils literal"><span class="pre">False</span></tt>) if <tt class="docutils literal"><span class="pre">True</span></tt>, returns
an iterator over relations <span class="math">\(x &lt; y\)</span>, excluding all
relations <span class="math">\(x \leq x\)</span>.</li>
</ul>
<p>OUTPUT:</p>
<p>A generator that produces pairs (each pair is a list), where the
first element of the pair is less than or equal to the second element.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="sage.combinat.posets.posets.FinitePoset.relations_number"><tt class="xref py py-meth docutils literal"><span class="pre">relations_number()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><tt class="xref py py-meth docutils literal"><span class="pre">relations()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="sage.combinat.posets.posets.FinitePoset.maximal_chains"><tt class="xref py py-meth docutils literal"><span class="pre">maximal_chains()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chains" title="sage.combinat.posets.posets.FinitePoset.chains"><tt class="xref py py-meth docutils literal"><span class="pre">chains()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">relations_iterator</span><span class="p">())</span>
<span class="go">&lt;type &#39;generator&#39;&gt;</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">relations_iterator</span><span class="p">()]</span>
<span class="go">[[1, 1], [1, 2], [1, 3], [1, 4], [0, 0], [0, 2], [0, 3],</span>
<span class="go">[0, 4], [2, 2], [2, 3], [2, 4], [3, 3], [3, 4], [4, 4]]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">relations_iterator</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">[[0, 1], [0, 2], [0, 4], [0, 3], [1, 4], [2, 3], [2, 4], [3, 4]]</span>

<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">relations_iterator</span><span class="p">()))</span>
<span class="go">13</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Rob Beezer (2011-05-04)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.intervals_number">
<tt class="descname">intervals_number</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.intervals_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of relations in the poset.</p>
<p>A relation is a pair of elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> such that <span class="math">\(x\leq y\)</span>
in the poset.</p>
<p>Relations are also often called intervals. The number of
intervals is the dimension of the incidence algebra.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><tt class="xref py py-meth docutils literal"><span class="pre">relations_iterator()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><tt class="xref py py-meth docutils literal"><span class="pre">relations()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">13</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.tamari_lattices</span> <span class="kn">import</span> <span class="n">TamariLattice</span>
<span class="gp">sage: </span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">68</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_EL_labelling">
<tt class="descname">is_EL_labelling</tt><big>(</big><em>f</em>, <em>return_raising_chains=False</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_EL_labelling" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">f</span></tt> is an EL labelling of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>A labelling <span class="math">\(f\)</span> of the edges of the Hasse diagram of a poset
is called an EL labelling (edge lexicographic labelling) if
for any two elements <span class="math">\(u\)</span> and <span class="math">\(v\)</span> with <span class="math">\(u \leq v\)</span>,</p>
<blockquote>
<div><ul class="simple">
<li>there is a unique <span class="math">\(f\)</span>-raising chain from <span class="math">\(u\)</span> to <span class="math">\(v\)</span> in
the Hasse diagram, and this chain is lexicographically
first among all chains from <span class="math">\(u\)</span> to <span class="math">\(v\)</span>.</li>
</ul>
</div></blockquote>
<p>For more details, see <a class="reference internal" href="#bj1980" id="id12">[Bj1980]</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> &#8211; a function taking two elements <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> in
<tt class="docutils literal"><span class="pre">self</span></tt> such that <tt class="docutils literal"><span class="pre">b</span></tt> covers <tt class="docutils literal"><span class="pre">a</span></tt> and returning elements
in a totally ordered set.</li>
<li><tt class="docutils literal"><span class="pre">return_raising_chains</span></tt> (optional; default:<tt class="docutils literal"><span class="pre">False</span></tt>) if
<tt class="docutils literal"><span class="pre">True</span></tt>, returns the set of all raising chains in <tt class="docutils literal"><span class="pre">self</span></tt>,
if possible.</li>
</ul>
<p>EXAMPLES:</p>
<p>Let us consider a Boolean poset:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)],[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)]]],</span><span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">label</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_EL_labelling</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_EL_labelling</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">return_raising_chains</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">{((0, 0), (0, 1)): [1],</span>
<span class="go"> ((0, 0), (1, 0)): [0],</span>
<span class="go"> ((0, 0), (1, 1)): [0, 1],</span>
<span class="go"> ((0, 1), (1, 1)): [0],</span>
<span class="go"> ((1, 0), (1, 1)): [1]}</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="bj1980" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[Bj1980]</a></td><td>Anders Björner,
<em>Shellable and Cohen-Macaulay partially ordered sets</em>,
Trans. Amer. Math. Soc. 260 (1980), 159-183,
<a class="reference external" href="https://dx.doi.org/10.1090/S0002-9947-1980-0570784-2">doi:10.1090/S0002-9947-1980-0570784-2</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_bounded">
<tt class="descname">is_bounded</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_bounded" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the poset <tt class="docutils literal"><span class="pre">self</span></tt> is bounded, and <tt class="docutils literal"><span class="pre">False</span></tt>
otherwise.</p>
<p>We call a poset bounded if it contains a unique maximal element
and a unique minimal element.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[],</span><span class="mi">5</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_chain">
<tt class="descname">is_chain</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the poset is totally ordered, and False otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">is_chain</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">is_chain</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_chain_of_poset">
<tt class="descname">is_chain_of_poset</tt><big>(</big><em>o</em>, <em>ordered=False</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_chain_of_poset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether an iterable <tt class="docutils literal"><span class="pre">o</span></tt> is a chain of <tt class="docutils literal"><span class="pre">self</span></tt>,
including a check for <tt class="docutils literal"><span class="pre">o</span></tt> being ordered from smallest
to largest element if the keyword <tt class="docutils literal"><span class="pre">ordered</span></tt> is set to
<tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">o</span></tt> &#8211; an iterable (e. g., list, set, or tuple)
containing some elements of <tt class="docutils literal"><span class="pre">self</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ordered</span></tt> &#8211; a Boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>) which
decides whether the notion of a chain includes being
ordered</li>
</ul>
<p>OUTPUT:</p>
<p>If <tt class="docutils literal"><span class="pre">ordered</span></tt> is set to <tt class="docutils literal"><span class="pre">False</span></tt>, the truth value of
the following assertion is returned: The subset of <tt class="docutils literal"><span class="pre">self</span></tt>
formed by the elements of <tt class="docutils literal"><span class="pre">o</span></tt> is a chain in <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>If <tt class="docutils literal"><span class="pre">ordered</span></tt> is set to <tt class="docutils literal"><span class="pre">True</span></tt>, the truth value of
the following assertion is returned: Every element of the
list <tt class="docutils literal"><span class="pre">o</span></tt> is (strictly!) smaller than its successor in
<tt class="docutils literal"><span class="pre">self</span></tt>. (This makes no sense if <tt class="docutils literal"><span class="pre">ordered</span></tt> is a set.)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">(())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((),</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_chain_of_poset</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_connected">
<tt class="descname">is_connected</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the poset is connected, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>Poset is not connected if it can be divided to disjoint parts
<span class="math">\(S_1\)</span> and <span class="math">\(S_2\)</span> so that every element of <span class="math">\(S_1\)</span> is incomparable to
every element of <span class="math">\(S_2\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span><span class="o">=</span><span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">=</span><span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_gequal">
<tt class="descname">is_gequal</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_gequal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if <span class="math">\(x\)</span> is greater than or equal to <span class="math">\(y\)</span> in the poset,
and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_gequal</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_graded">
<tt class="descname">is_graded</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_graded" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether this poset is graded.</p>
<p>A poset is <em>graded</em> if all its maximal chains have the same length.
There are various competing definitions for graded posets (see
<a class="reference external" href="https://en.wikipedia.org/wiki/Graded_poset">Wikipedia article Graded_poset</a>). This definition is from section 3.1 of
Richard Stanley&#8217;s <em>Enumerative Combinatorics, Vol. 1</em> <a class="reference internal" href="#enumcomb1" id="id13">[EnumComb1]</a>.</p>
<p>Note that every graded poset is ranked, but the converse is not
true.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_ranked" title="sage.combinat.posets.posets.FinitePoset.is_ranked"><tt class="xref py py-meth docutils literal"><span class="pre">is_ranked()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span> <span class="p">))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s">&#39;D&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">root_poset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Here we test that the empty poset is graded:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Poset</span><span class="p">([[],[]])</span><span class="o">.</span><span class="n">is_graded</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_greater_than">
<tt class="descname">is_greater_than</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_greater_than" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if <span class="math">\(x\)</span> is greater than but not equal to <span class="math">\(y\)</span> in the
poset, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_greater_than</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_incomparable_chain_free">
<tt class="descname">is_incomparable_chain_free</tt><big>(</big><em>m</em>, <em>n=None</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_incomparable_chain_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the poset is <span class="math">\((m+n)\)</span>-free (that is, there is no pair
of incomparable chains of lengths <span class="math">\(m\)</span> and <span class="math">\(n\)</span>), and <tt class="docutils literal"><span class="pre">False</span></tt> if not.</p>
<p>If <tt class="docutils literal"><span class="pre">m</span></tt> is a tuple of pairs of chain lengths, returns <tt class="docutils literal"><span class="pre">True</span></tt> if the poset
does not contain a pair of incomparable chains whose lengths comprise
one of the chain pairs, and <tt class="docutils literal"><span class="pre">False</span></tt> if not.
A poset is <span class="math">\((m+n)\)</span>-free if it contains no induced subposet that is
isomorphic to the poset consisting of two disjoint chains of lengths
<span class="math">\(m\)</span> and <span class="math">\(n\)</span>.  See, for example, Exercise 15 in Chapter 3 of
<a class="reference internal" href="#enumcomb1" id="id14">[EnumComb1]</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">m</span></tt> - tuple of pairs of nonnegative integers</li>
<li><tt class="docutils literal"><span class="pre">m</span></tt>, <tt class="docutils literal"><span class="pre">n</span></tt> - nonnegative integers</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(((</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="s">&quot;g&quot;</span><span class="p">,</span> <span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="s">&quot;j&quot;</span><span class="p">),</span> <span class="p">((</span><span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;g&quot;</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;g&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;j&quot;</span><span class="p">,</span> <span class="s">&quot;f&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="s">&quot;f&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;j&quot;</span><span class="p">,</span> <span class="s">&quot;g&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="s">&quot;g&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;j&quot;</span><span class="p">,</span> <span class="s">&quot;h&quot;</span><span class="p">))))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="p">[</span><span class="nb">len</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Posets</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span> <span class="c"># long time</span>
<span class="go">[1, 1, 2, 5, 14, 42]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">2 and pi must be integers.</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">2 and -1 must be nonnegative integers.</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">(3, 1) is not a tuple of tuples.</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">[3, 1] and [2, 2] must be integers.</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">[3, 1] and 2 must be integers.</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_incomparable_chain_free</span><span class="p">(([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">&#39;([3, 1], [2, 2, 2])&#39; is not a tuple of length-2 tuples.</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Eric Rowland (2013-05-28)</li>
</ul>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="enumcomb1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[EnumComb1]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id13">2</a>, <a class="fn-backref" href="#id14">3</a>, <a class="fn-backref" href="#id16">4</a>, <a class="fn-backref" href="#id19">5</a>, <a class="fn-backref" href="#id22">6</a>)</em> Richard P. Stanley,
<em>Enumerative Combinatorics, volume 1</em>,
Second Edition,
Cambridge University Press (2011).
<a class="reference external" href="http://math.mit.edu/~rstan/ec/ec1/">http://math.mit.edu/~rstan/ec/ec1/</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_isomorphic">
<tt class="descname">is_isomorphic</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_isomorphic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if both posets are isomorphic.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span> <span class="n">Q</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_join_semilattice">
<tt class="descname">is_join_semilattice</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_join_semilattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the poset has a join operation, and False
otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_join_semilattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_join_semilattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_join_semilattice</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_lequal">
<tt class="descname">is_lequal</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_lequal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if <span class="math">\(x\)</span> is less than or equal to <span class="math">\(y\)</span> in the poset, and
<tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_less_than">
<tt class="descname">is_less_than</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_less_than" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if <span class="math">\(x\)</span> is less than but not equal to <span class="math">\(y\)</span> in the poset,
and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_linear_extension">
<tt class="descname">is_linear_extension</tt><big>(</big><em>l</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <tt class="docutils literal"><span class="pre">l</span></tt> is a linear extension of <tt class="docutils literal"><span class="pre">self</span></tt></p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">l</span></tt> &#8211; a list (or iterable) containing all of the elements of <tt class="docutils literal"><span class="pre">self</span></tt> exactly once</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><tt class="xref py py-meth docutils literal"><span class="pre">linear_extension()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="sage.combinat.posets.posets.FinitePoset.linear_extensions"><tt class="xref py py-meth docutils literal"><span class="pre">linear_extensions()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Permutations</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">))</span> <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
<span class="go">[[1, 2, 3, 4, 6, 12],</span>
<span class="go"> [1, 2, 3, 6, 4, 12],</span>
<span class="go"> [1, 2, 4, 3, 6, 12],</span>
<span class="go"> [1, 3, 2, 4, 6, 12],</span>
<span class="go"> [1, 3, 2, 6, 4, 12]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">())</span>
<span class="go">[[1, 2, 3, 4, 6, 12],</span>
<span class="go"> [1, 2, 3, 6, 4, 12],</span>
<span class="go"> [1, 2, 4, 3, 6, 12],</span>
<span class="go"> [1, 3, 2, 4, 6, 12],</span>
<span class="go"> [1, 3, 2, 6, 4, 12]]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is used and systematically tested in
<tt class="xref py py-class docutils literal"><span class="pre">LinearExtensionsOfPosets</span></tt></p>
</div>
<p>TESTS:</p>
<p>Check that <a class="reference external" href="http://trac.sagemath.org/15313">trac ticket #15313</a> is fixed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">1337</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">666</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">1337</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_linear_extension</span><span class="p">([</span><span class="s">&#39;David&#39;</span><span class="p">,</span> <span class="s">&#39;McNeil&#39;</span><span class="p">,</span> <span class="s">&#39;La&#39;</span><span class="p">,</span> <span class="s">&#39;Lamentable&#39;</span><span class="p">,</span> <span class="s">&#39;Aventure&#39;</span><span class="p">,</span> <span class="s">&#39;de&#39;</span><span class="p">,</span> <span class="s">&#39;Simon&#39;</span><span class="p">,</span> <span class="s">&#39;Wiesenthal&#39;</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_meet_semilattice">
<tt class="descname">is_meet_semilattice</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_meet_semilattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if self has a meet operation, and False otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]],</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_meet_semilattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_meet_semilattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_meet_semilattice</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_parent_of">
<tt class="descname">is_parent_of</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_parent_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is an element of the poset.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.posets.posets</span> <span class="kn">import</span> <span class="n">FinitePoset</span>
<span class="gp">sage: </span><span class="n">P5</span> <span class="o">=</span> <span class="n">FinitePoset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({(</span><span class="mi">5</span><span class="p">,):[(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span> \
<span class="go">        (4,1):[(3,1,1),(2,2,1)], \</span>
<span class="go">        (3,2):[(3,1,1),(2,2,1)], \</span>
<span class="go">        (3,1,1):[(2,1,1,1)], \</span>
<span class="go">        (2,2,1):[(2,1,1,1)], \</span>
<span class="go">        (2,1,1,1):[(1,1,1,1,1)], \</span>
<span class="go">        (1,1,1,1,1):[]}))</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">P5</span><span class="o">.</span><span class="n">list</span><span class="p">()[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">in</span> <span class="n">P5</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For the sake of speed, an element with the right class and
parent is assumed to be in this parent. This can possibly be
counterfeited by feeding garbage to the constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">P5</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="n">P5</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">in</span> <span class="n">P5</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_rank_symmetric">
<tt class="descname">is_rank_symmetric</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_rank_symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the poset is rank symmetric, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>The poset is expected to be graded and connected.</p>
<p>A poset of rank <span class="math">\(h\)</span> (maximal chains have <span class="math">\(h+1\)</span> elements) is rank
symmetric if the number of elements are equal in ranks <span class="math">\(i\)</span> and
<span class="math">\(h-i\)</span> for every <span class="math">\(i\)</span> in <span class="math">\(0, 1, \ldots, h\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_rank_symmetric</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">7</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_rank_symmetric</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">is_rank_symmetric</span><span class="p">()</span>  <span class="c"># Test empty poset</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_ranked">
<tt class="descname">is_ranked</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_ranked" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether this poset is ranked.</p>
<p>A poset is <em>ranked</em> if it admits a rank function. For more information
about the rank function, see <a class="reference internal" href="hasse_diagram.html#sage.combinat.posets.hasse_diagram.HasseDiagram.rank_function" title="sage.combinat.posets.hasse_diagram.HasseDiagram.rank_function"><tt class="xref py py-meth docutils literal"><span class="pre">rank_function()</span></tt></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_graded" title="sage.combinat.posets.posets.FinitePoset.is_graded"><tt class="xref py py-meth docutils literal"><span class="pre">is_graded()</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_ranked</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_ranked</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span> <span class="p">))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_ranked</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.is_slender">
<tt class="descname">is_slender</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.is_slender" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the poset is slender, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>A finite graded poset is called slender if every rank 2
interval contains three or four elements, as defined in
<a class="reference internal" href="#stan2009" id="id15">[Stan2009]</a>. (This notion of &#8220;slender&#8221; is unrelated to
the eponymous notion defined by Graetzer and Kelly in
&#8220;The Free <span class="math">\(\mathfrak{m}\)</span>-Lattice on the Poset <span class="math">\(H\)</span>&#8221;,
Order 1 (1984), 47&#8211;65.)</p>
<p>This function <em>does not</em> check if the poset is graded or not.
Instead it just returns <tt class="docutils literal"><span class="pre">True</span></tt> if the poset does not contain
5 distinct elements <span class="math">\(x\)</span>, <span class="math">\(y\)</span>, <span class="math">\(a\)</span>, <span class="math">\(b\)</span> and <span class="math">\(c\)</span> such that
<span class="math">\(x \lessdot a,b,c \lessdot y\)</span> where <span class="math">\(\lessdot\)</span> is the covering
relation.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">WeylGroup</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">bruhat_poset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">WeylGroup</span><span class="p">([</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">bruhat_poset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_slender</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets">
<tt class="descname">isomorphic_subposets</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of subposets of <span class="math">\(self\)</span> isomorphic to <span class="math">\(other\)</span>.</p>
<p>By subposet we mean <tt class="docutils literal"><span class="pre">self.subposet(X)</span></tt> which is isomorphic to
<tt class="docutils literal"><span class="pre">other</span></tt> and where <tt class="docutils literal"><span class="pre">X</span></tt> is a subset of elements of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; a finite poset</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C2</span><span class="o">=</span><span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">C3</span><span class="o">=</span><span class="n">Poset</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">],</span> <span class="s">&#39;b&#39;</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">C3</span><span class="o">.</span><span class="n">isomorphic_subposets</span><span class="p">(</span><span class="n">C2</span><span class="p">):</span> <span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[&#39;b&#39;, &#39;c&#39;]]</span>
<span class="go">[[&#39;a&#39;, &#39;c&#39;]]</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;]]</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">N5</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">N5</span><span class="o">.</span><span class="n">isomorphic_subposets</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>
<span class="go">2</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If this function takes too much time, try using
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator"><tt class="xref py py-meth docutils literal"><span class="pre">isomorphic_subposets_iterator()</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator">
<tt class="descname">isomorphic_subposets_iterator</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the subposets of <span class="math">\(self\)</span> isomorphic to
<span class="math">\(other\)</span>.</p>
<p>By subposet we mean <tt class="docutils literal"><span class="pre">self.subposet(X)</span></tt> which is isomorphic
to <tt class="docutils literal"><span class="pre">other</span></tt> and where <tt class="docutils literal"><span class="pre">X</span></tt> is a subset of elements of
<tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; a finite poset</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">N5</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">N5</span><span class="o">.</span><span class="n">isomorphic_subposets_iterator</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
<span class="go">....:     print P.cover_relations()</span>
<span class="go">[[0, 1], [0, 2], [1, 4], [2, 4]]</span>
<span class="go">[[0, 1], [0, 3], [1, 4], [3, 4]]</span>
<span class="go">[[0, 1], [0, 2], [1, 4], [2, 4]]</span>
<span class="go">[[0, 1], [0, 3], [1, 4], [3, 4]]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function will return same subposet as many times as
there are automorphism on it. This is due to
<a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.subgraph_search_iterator" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-meth docutils literal"><span class="pre">subgraph_search_iterator()</span></tt></a>
returning labelled subgraphs. On the other hand, this
function does not eat memory like
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.isomorphic_subposets" title="sage.combinat.posets.posets.FinitePoset.isomorphic_subposets"><tt class="xref py py-meth docutils literal"><span class="pre">isomorphic_subposets()</span></tt></a> does.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.join_matrix">
<tt class="descname">join_matrix</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.join_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated as a function of posets, moved to lattices.</p>
<p>Convert a poset <span class="math">\(P\)</span> to join-semilattice and use it like
<tt class="docutils literal"><span class="pre">JoinSemilattice(P).join_matrix()</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.le">
<tt class="descname">le</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.le" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if <span class="math">\(x\)</span> is less than or equal to <span class="math">\(y\)</span> in the poset, and
<tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_lequal</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.lequal_matrix">
<tt class="descname">lequal_matrix</tt><big>(</big><em>ring=Integer Ring</em>, <em>sparse=False</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lequal_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the matrix whose <tt class="docutils literal"><span class="pre">(i,j)</span></tt> entry is 1 if
<tt class="docutils literal"><span class="pre">self.linear_extension()[i]</span> <span class="pre">&lt;</span> <span class="pre">self.linear_extension()[j]</span></tt> and 0
otherwise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ring</span></tt> &#8211; the ring of coefficients (default: <tt class="docutils literal"><span class="pre">ZZ</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">sparse</span></tt> &#8211; whether the returned matrix is sparse or not
(default: <tt class="docutils literal"><span class="pre">True</span></tt>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]],</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">LEQM</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">lequal_matrix</span><span class="p">();</span> <span class="n">LEQM</span>
<span class="go">[1 1 1 1 1 1 1 1]</span>
<span class="go">[0 1 0 1 0 0 0 1]</span>
<span class="go">[0 0 1 1 1 0 1 1]</span>
<span class="go">[0 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 0 1 0 0 1]</span>
<span class="go">[0 0 0 0 0 1 1 1]</span>
<span class="go">[0 0 0 0 0 0 1 1]</span>
<span class="go">[0 0 0 0 0 0 0 1]</span>
<span class="gp">sage: </span><span class="n">LEQM</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">LEQM</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We now demonstrate the usage of the optional parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">lequal_matrix</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 8 by 8 dense matrices over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.level_sets">
<tt class="descname">level_sets</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.level_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list <tt class="docutils literal"><span class="pre">l</span></tt> such that <tt class="docutils literal"><span class="pre">l[i]</span></tt> is the set of minimal
elements of the poset obtained from <tt class="docutils literal"><span class="pre">self</span></tt> by removing the
elements in <tt class="docutils literal"><span class="pre">l[0],</span> <span class="pre">l[1],</span> <span class="pre">...,</span> <span class="pre">l[i-1]</span></tt>. (In particular,
<tt class="docutils literal"><span class="pre">l[0]</span></tt> is the set of minimal elements of <tt class="docutils literal"><span class="pre">self</span></tt>.)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">level_sets</span><span class="p">()]</span>
<span class="go">[1, 2, 1]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">level_sets</span><span class="p">()]</span>
<span class="go">[1, 2, 1, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.linear_extension">
<tt class="descname">linear_extension</tt><big>(</big><em>linear_extension=None</em>, <em>check=True</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a linear extension of this poset.</p>
<p>A linear extension of a finite poset <span class="math">\(P\)</span> of size <span class="math">\(n\)</span> is a total
ordering <span class="math">\(\pi := \pi_0 \pi_1 \ldots \pi_{n-1}\)</span> of its elements
such that <span class="math">\(i&lt;j\)</span> whenever <span class="math">\(\pi_i &lt; \pi_j\)</span> in the poset <span class="math">\(P\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">linear_extension</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>) a list of the
elements of <tt class="docutils literal"><span class="pre">self</span></tt></li>
<li><tt class="docutils literal"><span class="pre">check</span></tt> &#8211; a boolean (default: True);
whether to check that <tt class="docutils literal"><span class="pre">linear_extension</span></tt> is indeed a
linear extension of <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="sage.combinat.posets.posets.FinitePoset.is_linear_extension"><tt class="xref py py-meth docutils literal"><span class="pre">is_linear_extension()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="sage.combinat.posets.posets.FinitePoset.linear_extensions"><tt class="xref py py-meth docutils literal"><span class="pre">linear_extensions()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Without optional argument, the default linear extension of the
poset is returned, as a plain list:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()</span>
<span class="go">[1, 3, 5, 15]</span>
</pre></div>
</div>
<p>Otherwise, a full-featured linear extension is constructed
as an element of <tt class="docutils literal"><span class="pre">P.linear_extensions()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">]);</span> <span class="n">l</span>
<span class="go">[1, 5, 3, 15]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.combinat.posets.linear_extensions.LinearExtensionsOfPoset_with_category.element_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">l</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">The set of all linear extensions of Finite poset containing 4 elements</span>
</pre></div>
</div>
<p>By default, the linear extension is checked for correctness:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">[1, 3, 15, 5] is not a linear extension of Finite poset containing 4 elements</span>
</pre></div>
</div>
<p>This can be disabled (at your own risks!) with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">[1, 3, 15, 5]</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<ul class="last simple">
<li>Is it acceptable to have those two features for a single method?</li>
<li>In particular, we miss a short idiom to get the default
linear extension</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.linear_extensions">
<tt class="descname">linear_extensions</tt><big>(</big><em>facade=False</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the enumerated set of all the linear extensions of this poset</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">facade</span></tt> &#8211; a boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>);
whether to return the linear extensions as plain lists</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>The <tt class="docutils literal"><span class="pre">facade</span></tt> option is not yet fully functional:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">L</span>
<span class="go">The set of all linear extensions of Finite poset containing 6 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Cannot convert list to sage.structure.element.Element</span>
</pre></div>
</div>
</div>
</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><tt class="xref py py-meth docutils literal"><span class="pre">linear_extension()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.is_linear_extension" title="sage.combinat.posets.posets.FinitePoset.is_linear_extension"><tt class="xref py py-meth docutils literal"><span class="pre">is_linear_extension()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">();</span> <span class="n">L</span>
<span class="go">The set of all linear extensions of Finite poset containing 6 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">l</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[1, 2, 3, 4, 6, 12],</span>
<span class="go"> [1, 2, 3, 6, 4, 12],</span>
<span class="go"> [1, 2, 4, 3, 6, 12],</span>
<span class="go"> [1, 3, 2, 4, 6, 12],</span>
<span class="go"> [1, 3, 2, 6, 4, 12]]</span>
</pre></div>
</div>
<p>Each element is aware that it is a linear extension of <span class="math">\(P\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
<span class="go">&lt;class &#39;sage.combinat.posets.linear_extensions.LinearExtensionsOfPoset_with_category&#39;&gt;</span>
</pre></div>
</div>
<p>With <tt class="docutils literal"><span class="pre">facade=True</span></tt>, the elements of <tt class="docutils literal"><span class="pre">L</span></tt> are plain lists instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>In Sage &lt;= 4.8, this function used to return a plain list
of lists. To recover the previous functionality, please use:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">));</span> <span class="n">L</span>
<span class="go">[[1, 2, 3, 4, 6, 12],</span>
<span class="go"> [1, 2, 3, 6, 4, 12],</span>
<span class="go"> [1, 2, 4, 3, 6, 12],</span>
<span class="go"> [1, 3, 2, 4, 6, 12],</span>
<span class="go"> [1, 3, 2, 6, 4, 12]]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>
</pre></div>
</div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">())</span>
<span class="go">[[0, 1, 2, 3, 4], [0, 1, 2, 4, 3], [0, 2, 1, 3, 4], [0, 2, 1, 4, 3], [0, 2, 4, 1, 3]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.list">
<tt class="descname">list</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.list" title="Permalink to this definition">¶</a></dt>
<dd><p>List the elements of the poset. This just returns the result
of <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><tt class="xref py py-meth docutils literal"><span class="pre">linear_extension()</span></tt></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">},</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">list</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;class &#39;sage.combinat.posets.elements.FinitePoset_with_category.element_class&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.lower_covers">
<tt class="descname">lower_covers</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lower_covers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of lower covers of the element <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>A lower cover of <span class="math">\(x\)</span> is an element <span class="math">\(y\)</span> such that <span class="math">\(y &lt; x\)</span> and
there is no element <span class="math">\(z\)</span> so that <span class="math">\(y &lt; z &lt; x\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">lower_covers</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[2, 5]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">lower_covers</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.upper_covers" title="sage.combinat.posets.posets.FinitePoset.upper_covers"><tt class="xref py py-meth docutils literal"><span class="pre">upper_covers()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.lower_covers_iterator">
<tt class="descname">lower_covers_iterator</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lower_covers_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the lower covers of the element <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">l0</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">lower_covers_iterator</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">l0</span><span class="p">)</span>
<span class="go">&lt;type &#39;generator&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">l0</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.lt">
<tt class="descname">lt</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.lt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if <span class="math">\(x\)</span> is less than but not equal to <span class="math">\(y\)</span> in the poset,
and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_less_than</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.maximal_antichains">
<tt class="descname">maximal_antichains</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.maximal_antichains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all maximal antichains of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span><span class="o">=</span><span class="n">Poset</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">],</span> <span class="s">&#39;b&#39;</span><span class="p">:[</span><span class="s">&#39;d&#39;</span><span class="p">,</span><span class="s">&#39;e&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">maximal_antichains</span><span class="p">()</span>
<span class="go">[[&#39;a&#39;], [&#39;b&#39;, &#39;c&#39;], [&#39;c&#39;, &#39;d&#39;, &#39;e&#39;]]</span>

<span class="gp">sage: </span><span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">maximal_antichains</span><span class="p">()</span>
<span class="go">[[0], [1, 2], [1, 3], [4]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="sage.combinat.posets.posets.FinitePoset.maximal_chains"><tt class="xref py py-meth docutils literal"><span class="pre">maximal_chains()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.antichains" title="sage.combinat.posets.posets.FinitePoset.antichains"><tt class="xref py py-meth docutils literal"><span class="pre">antichains()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.maximal_chains">
<tt class="descname">maximal_chains</tt><big>(</big><em>partial=None</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all maximal chains of this poset.</p>
<p>Each chain is listed in increasing order.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">partial</span></tt> &#8211; list (optional); if present, find all maximal
chains starting with the elements in partial</li>
</ul>
<p>Returns list of the maximal chains of this poset.</p>
<p>This is used in constructing the order complex for the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">maximal_chains</span><span class="p">()</span>
<span class="go">[[0, 1, 3, 7], [0, 1, 5, 7], [0, 2, 3, 7], [0, 2, 6, 7], [0, 4, 5, 7], [0, 4, 6, 7]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">maximal_chains</span><span class="p">(</span><span class="n">partial</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[[0, 2, 3, 7], [0, 2, 6, 7]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">maximal_chains</span><span class="p">()</span>
<span class="go">[[0, 1, 2, 3, 4, 5]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_antichains" title="sage.combinat.posets.posets.FinitePoset.maximal_antichains"><tt class="xref py py-meth docutils literal"><span class="pre">maximal_antichains()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chains" title="sage.combinat.posets.posets.FinitePoset.chains"><tt class="xref py py-meth docutils literal"><span class="pre">chains()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.maximal_elements">
<tt class="descname">maximal_elements</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.maximal_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of the maximal elements of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">maximal_elements</span><span class="p">()</span>
<span class="go">[4]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.minimal_elements" title="sage.combinat.posets.posets.FinitePoset.minimal_elements"><tt class="xref py py-meth docutils literal"><span class="pre">minimal_elements()</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.meet_matrix">
<tt class="descname">meet_matrix</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.meet_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated as a function of posets, moved to lattices.</p>
<p>Convert a poset <span class="math">\(P\)</span> to meet-semilattice and use it like
<tt class="docutils literal"><span class="pre">MeetSemilattice(P).join_matrix()</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.minimal_elements">
<tt class="descname">minimal_elements</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.minimal_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of the minimal elements of the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span><span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_elements" title="sage.combinat.posets.posets.FinitePoset.maximal_elements"><tt class="xref py py-meth docutils literal"><span class="pre">maximal_elements()</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.mobius_function">
<tt class="descname">mobius_function</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.mobius_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the Mobius function of the poset on the
elements x and y.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">mobius_function</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">P</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">([</span><span class="n">P</span><span class="o">.</span><span class="n">mobius_function</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">mobius_function</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">v</span><span class="p">))</span> \
<span class="go">....:      for v in P])</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">cover_relations_iterator</span><span class="p">():</span>
<span class="go">....:     if P.mobius_function(u,v) != -1:</span>
<span class="go">....:         print &quot;Bug in mobius_function!&quot;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">mobius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">mobius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">mobius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">mobius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">Q</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">([</span><span class="n">Q</span><span class="o">.</span><span class="n">mobius_function</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Q</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.mobius_function_matrix">
<tt class="descname">mobius_function_matrix</tt><big>(</big><em>ring=Integer Ring</em>, <em>sparse=False</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.mobius_function_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a matrix whose <tt class="docutils literal"><span class="pre">(i,j)</span></tt> entry is the value of the Mobius
function evaluated at <tt class="docutils literal"><span class="pre">self.linear_extension()[i]</span></tt> and
<tt class="docutils literal"><span class="pre">self.linear_extension()[j]</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ring</span></tt> &#8211; the ring of coefficients (default: <tt class="docutils literal"><span class="pre">ZZ</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">sparse</span></tt> &#8211; whether the returned matrix is sparse or not
(default: <tt class="docutils literal"><span class="pre">True</span></tt>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">mobius_function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">mobius_function_matrix</span><span class="p">();</span> <span class="n">M</span>
<span class="go">[ 1 -1 -1 -1  2]</span>
<span class="go">[ 0  1  0  0 -1]</span>
<span class="go">[ 0  0  1  0 -1]</span>
<span class="go">[ 0  0  0  1 -1]</span>
<span class="go">[ 0  0  0  0  1]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">-1</span>
</pre></div>
</div>
<p>We now demonstrate the usage of the optional parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">mobius_function_matrix</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 5 by 5 dense matrices over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.open_interval">
<tt class="descname">open_interval</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.open_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the elements <span class="math">\(z\)</span> such that <span class="math">\(x &lt; z &lt; y\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">uc</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]]</span>
<span class="gp">sage: </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uc</span><span class="p">)),</span><span class="n">uc</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">P</span><span class="p">,[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">open_interval</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">dg</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="s">&quot;a&quot;</span><span class="p">:[</span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="s">&quot;c&quot;</span><span class="p">],</span> <span class="s">&quot;b&quot;</span><span class="p">:[</span><span class="s">&quot;d&quot;</span><span class="p">],</span> <span class="s">&quot;c&quot;</span><span class="p">:[</span><span class="s">&quot;d&quot;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">dg</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">open_interval</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;d&quot;</span><span class="p">)</span>
<span class="go">[b, c]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.order_complex">
<tt class="descname">order_complex</tt><big>(</big><em>on_ints=False</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order complex associated to this poset.</p>
<p>The order complex is the simplicial complex with vertices equal
to the elements of the poset, and faces given by the chains.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">on_ints</span></tt> &#8211; a boolean (default: False)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_complex</span><span class="p">();</span> <span class="n">S</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3, 4, 5, 6, 7) and 6 facets</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 8, 19, 18, 6]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>      <span class="c"># S is contractible</span>
<span class="go">{0: 0, 1: 0, 2: 0, 3: 0}</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">order_complex</span><span class="p">()</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>    <span class="c"># a circle</span>
<span class="go">{0: 0, 1: Z}</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_complex</span><span class="p">()</span>
<span class="go">Simplicial complex with vertex set (1, 3, 5, 15) and facets {(1, 3, 15), (1, 5, 15)}</span>
</pre></div>
</div>
<p>If <tt class="docutils literal"><span class="pre">on_ints</span></tt>, then the elements of the poset are labelled
<span class="math">\(0,1,\dots\)</span> in the chain complex:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_complex</span><span class="p">(</span><span class="n">on_ints</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Simplicial complex with vertex set (0, 1, 2, 3) and facets {(0, 2, 3), (0, 1, 3)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.order_filter">
<tt class="descname">order_filter</tt><big>(</big><em>elements</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the order filter generated by the elements of an
iterable <tt class="docutils literal"><span class="pre">elements</span></tt>.</p>
<p><span class="math">\(I\)</span> is an order filter if, for any <span class="math">\(x\)</span> in <span class="math">\(I\)</span> and <span class="math">\(y\)</span> such that
<span class="math">\(y \ge x\)</span>, then <span class="math">\(y\)</span> is in <span class="math">\(I\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">order_filter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
<span class="go">[3, 7, 8, 9, 10, 11, 12, 13, 14, 15]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.order_ideal">
<tt class="descname">order_ideal</tt><big>(</big><em>elements</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_ideal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the order ideal generated by the elements of an
iterable <tt class="docutils literal"><span class="pre">elements</span></tt>.</p>
<p><span class="math">\(I\)</span> is an order ideal if, for any <span class="math">\(x\)</span> in <span class="math">\(I\)</span> and <span class="math">\(y\)</span> such that
<span class="math">\(y \le x\)</span>, then <span class="math">\(y\)</span> is in <span class="math">\(I\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">order_ideal</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 10]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">order_ideal</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">)))</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.order_polynomial">
<tt class="descname">order_polynomial</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order polynomial of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The order polynomial <span class="math">\(\Omega_P(q)\)</span> of a poset <span class="math">\(P\)</span> is defined
as the unique polynomial <span class="math">\(S\)</span> such that for each integer
<span class="math">\(m \geq 1\)</span>, <span class="math">\(S(m)\)</span> is the number of order-preserving maps
from <span class="math">\(P\)</span> to <span class="math">\(\{1,\ldots,m\}\)</span>.</p>
<p>See sections 3.12 and 3.15 of <a class="reference internal" href="#enumcomb1" id="id16">[EnumComb1]</a>, and also
<a class="reference internal" href="#st1986" id="id17">[St1986]</a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.order_polytope" title="sage.combinat.posets.posets.FinitePoset.order_polytope"><tt class="xref py py-meth docutils literal"><span class="pre">order_polytope()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_polynomial</span><span class="p">()</span>
<span class="go">q^3</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_polynomial</span><span class="p">();</span> <span class="n">f</span>
<span class="go">1/6*q^3 + 1/2*q^2 + 1/3*q</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="go">[0, 1, 4, 10]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.order_polytope">
<tt class="descname">order_polytope</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.order_polytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order polytope of the poset <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The order polytope of a finite poset <span class="math">\(P\)</span> is defined as the subset
of <span class="math">\(\RR^P\)</span> consisting of all maps <span class="math">\(x : P \to \RR\)</span> satisfying</p>
<div class="math">
\[0 \leq x(p) \leq 1 \mbox{ for all } p \in P,\]</div>
<p>and</p>
<div class="math">
\[\begin{split}x(p) \leq x(q) \mbox{ for all } p, q \in P
\mbox{ satisfying } p &lt; q.\end{split}\]</div>
<p>This polytope was defined and studied in <a class="reference internal" href="#st1986" id="id18">[St1986]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_polytope</span><span class="p">();</span><span class="n">Q</span>
<span class="go">A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 8 vertices</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_polytope</span><span class="p">();</span><span class="n">Q</span>
<span class="go">A 5-dimensional polyhedron in QQ^5 defined as the convex hull of 8 vertices</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_polytope</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="st1986" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[St1986]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>, <a class="fn-backref" href="#id17">3</a>, <a class="fn-backref" href="#id18">4</a>)</em> Richard Stanley. <em>Two poset polytopes</em>,
Discrete Comput. Geom. (1986), <a class="reference external" href="https://dx.doi.org/10.1007/BF02187680">doi:10.1007/BF02187680</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.ordinal_product">
<tt class="descname">ordinal_product</tt><big>(</big><em>other</em>, <em>labels='pairs'</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.ordinal_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ordinal product of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>The ordinal product of two posets <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> is a partial
order on the cartesian product of the underlying sets of <span class="math">\(P\)</span>
and <span class="math">\(Q\)</span>, defined as follows (see <a class="reference internal" href="#enumcomb1" id="id19">[EnumComb1]</a>, p. 284).</p>
<p>In the ordinal product, <span class="math">\((p,q) \leq (p',q')\)</span> if either <span class="math">\(p \leq
p'\)</span> or <span class="math">\(p = p'\)</span> and <span class="math">\(q \leq q'\)</span>.</p>
<p>This construction is not symmetric in <span class="math">\(P\)</span> and <span class="math">\(Q\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt> &#8211; a poset</li>
<li><tt class="docutils literal"><span class="pre">labels</span></tt> &#8211; either <tt class="docutils literal"><span class="pre">'integers'</span></tt> or <tt class="docutils literal"><span class="pre">'pairs'</span></tt> (default); how
the resulting poset will be labeled</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.product" title="sage.combinat.posets.posets.FinitePoset.product"><tt class="xref py py-meth docutils literal"><span class="pre">product()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="sage.combinat.posets.posets.FinitePoset.ordinal_sum"><tt class="xref py py-meth docutils literal"><span class="pre">ordinal_sum()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">ordinal_product</span><span class="p">(</span><span class="n">P2</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">[[(&#39;a&#39;, &#39;c&#39;), (&#39;a&#39;, &#39;d&#39;)], [(&#39;a&#39;, &#39;d&#39;), (&#39;b&#39;, &#39;c&#39;)],</span>
<span class="go">[(&#39;b&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;d&#39;)]]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">ordinal_product</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">the input is not a finite poset</span>
<span class="gp">sage: </span><span class="n">P1</span><span class="o">.</span><span class="n">ordinal_product</span><span class="p">(</span><span class="n">P2</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s">&#39;camembert&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">labels must be either &#39;pairs&#39; or &#39;integers&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.ordinal_sum">
<tt class="descname">ordinal_sum</tt><big>(</big><em>other</em>, <em>labels='pairs'</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.ordinal_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a poset or (semi)lattice isomorphic to ordinal sum of the
poset with <tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>The ordinal sum of <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> is a poset that contains every
element and relation from both <span class="math">\(P\)</span> and <span class="math">\(Q\)</span>, and where every
element of <span class="math">\(P\)</span> is smaller than every element of <span class="math">\(Q\)</span>.</p>
<p>Mathematically, it is only defined when <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> have no
common element; here we force that by giving them different
names in the resulting poset.</p>
<p>The ordinal sum on lattices is lattice; resp. for meet- and
join-semilattices. Hence we check if we can return
(semi)lattice instead of plain poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">other</span></tt>, a poset.</li>
<li><tt class="docutils literal"><span class="pre">labels</span></tt> - (defaults to &#8216;pairs&#8217;) If set to &#8216;pairs&#8217;, each
element <tt class="docutils literal"><span class="pre">v</span></tt> in this poset will be named <tt class="docutils literal"><span class="pre">(0,v)</span></tt> and each
element <tt class="docutils literal"><span class="pre">u</span></tt> in <tt class="docutils literal"><span class="pre">other</span></tt> will be named <tt class="docutils literal"><span class="pre">(1,u)</span></tt> in the
result. If set to &#8216;integers&#8217;, the elements of the result
will be relabeled with consecutive integers.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,],</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P3</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">P2</span><span class="p">);</span> <span class="n">P3</span>
<span class="go">Finite poset containing 7 elements</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">maximal_elements</span><span class="p">())</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">P2</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">())</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span><span class="o">+</span><span class="n">P2</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P3</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span> <span class="c"># Every element of P2 is greater than elements of P1.</span>
<span class="go">11</span>
<span class="gp">sage: </span><span class="n">P3</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>  <span class="c"># random</span>
<span class="go">[(0, 1), (0, 2), (0, 4), (0, 3), (1, 2), (1, 3), (1, 1)]</span>
<span class="gp">sage: </span><span class="n">P4</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">P2</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="s">&#39;integers&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P4</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>  <span class="c"># random</span>
<span class="go">[0, 1, 2, 3, 5, 6, 4]</span>
</pre></div>
</div>
<p>Return type depends on input types:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]});</span> <span class="n">P</span>
<span class="go">Finite poset containing 2 elements</span>
<span class="gp">sage: </span><span class="n">JL</span> <span class="o">=</span> <span class="n">JoinSemilattice</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]});</span> <span class="n">JL</span>
<span class="go">Finite join-semilattice containing 2 elements</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">LatticePoset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]});</span> <span class="n">L</span>
<span class="go">Finite lattice containing 2 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">JL</span><span class="p">)</span>
<span class="go">Finite join-semilattice containing 4 elements</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">ordinal_sum</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="go">Finite lattice containing 4 elements</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.disjoint_union" title="sage.combinat.posets.posets.FinitePoset.disjoint_union"><tt class="xref py py-meth docutils literal"><span class="pre">disjoint_union()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.ordinal_product" title="sage.combinat.posets.posets.FinitePoset.ordinal_product"><tt class="xref py py-meth docutils literal"><span class="pre">ordinal_product()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.p_partition_enumerator">
<tt class="descname">p_partition_enumerator</tt><big>(</big><em>tup</em>, <em>R</em>, <em>check=False</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.p_partition_enumerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <span class="math">\(P\)</span>-partition enumerator of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Given a total order <span class="math">\(\prec\)</span> on the elements of a finite poset <span class="math">\(P\)</span>
(the order of <span class="math">\(P\)</span> and the total order <span class="math">\(\prec\)</span> can be unrelated; in
particular, the latter does not have to extend the former), a
<span class="math">\(P\)</span>-partition enumerator is the quasisymmetric function
<span class="math">\(\sum_f \prod_{p \in P} x_{f(p)}\)</span>, where the first sum is taken over
all <span class="math">\(P\)</span>-partitions <span class="math">\(f\)</span>.</p>
<p>A <span class="math">\(P\)</span>-partition is a function <span class="math">\(f : P \to \{1,2,3,...\}\)</span> satisfying
the following properties for any two elements <span class="math">\(i\)</span> and <span class="math">\(j\)</span> of <span class="math">\(P\)</span>
satisfying <span class="math">\(i &lt;_P j\)</span>:</p>
<ul class="simple">
<li>if <span class="math">\(i \prec j\)</span> then <span class="math">\(f(i) \leq f(j)\)</span>,</li>
<li>if <span class="math">\(j \prec i\)</span> then <span class="math">\(f(i) &lt; f(j)\)</span>.</li>
</ul>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">tup</span></tt> &#8211; the tuple containing all elements of <span class="math">\(P\)</span> (each of
them exactly once), in the order dictated by the total order
<span class="math">\(\prec\)</span></li>
<li><tt class="docutils literal"><span class="pre">R</span></tt> &#8211; a commutative ring</li>
</ul>
<p>OUTPUT:</p>
<p>The <span class="math">\(P\)</span>-partition enumerator of <tt class="docutils literal"><span class="pre">self</span></tt> according to <tt class="docutils literal"><span class="pre">tup</span></tt> in the
algebra <span class="math">\(QSym\)</span> of quasisymmetric functions over the base ring <span class="math">\(R\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">2*M[1, 1, 1, 1] + 2*M[1, 2, 1] + M[2, 1, 1] + M[3, 1]</span>

<span class="gp">sage: </span><span class="n">expansion</span> <span class="o">=</span> <span class="n">FP</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">xs</span> <span class="o">=</span> <span class="n">expansion</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">expansion</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">xs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">*</span><span class="n">xs</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">*</span><span class="n">xs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">*</span><span class="n">xs</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">])</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">FP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">p_partition_enumerator</span><span class="p">((),</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">FP</span>
<span class="go">M[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.plot">
<tt class="descname">plot</tt><big>(</big><em>label_elements=True</em>, <em>element_labels=None</em>, <em>layout='acyclic'</em>, <em>cover_labels=None</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Graphic object for the Hasse diagram of the poset.</p>
<p>If the poset is ranked, the plot uses the rank function for
the heights of the vertices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">label_elements</span></tt> (default: <tt class="docutils literal"><span class="pre">True</span></tt>) - whether to display
element labels</li>
<li><tt class="docutils literal"><span class="pre">element_labels</span></tt> (default: <tt class="docutils literal"><span class="pre">None</span></tt>) - a dictionary of
element labels</li>
<li><tt class="docutils literal"><span class="pre">cover_labels</span></tt> - a dictionary, list or function representing labels
of the covers of <tt class="docutils literal"><span class="pre">self</span></tt>. When set to <tt class="docutils literal"><span class="pre">None</span></tt> (default) no label is
displayed on the edges of the Hasse Diagram.</li>
<li><tt class="docutils literal"><span class="pre">layout</span></tt> &#8211; the type of layout used to display the Diagram. Set to
<tt class="docutils literal"><span class="pre">'acyclic'</span></tt> by default (see <a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.plot" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-meth docutils literal"><span class="pre">GenericGraph.plot</span></tt></a> for more information).</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All options of <a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.plot" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-meth docutils literal"><span class="pre">GenericGraph.plot</span></tt></a> are also available
through this function.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_elements</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Graphics object consisting of 6 graphics primitives</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 11 graphics primitives</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">())</span>
<span class="go">&lt;class &#39;sage.plot.graphics.Graphics&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">elm_labs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="s">&#39;e&#39;</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">element_labels</span><span class="o">=</span><span class="n">elm_labs</span><span class="p">)</span>
<span class="go">Graphics object consisting of 11 graphics primitives</span>
</pre></div>
</div>
<p>Plot of a ranked poset:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">(</span><span class="s">&#39;E@ACA@?&#39;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_ranked</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 12 graphics primitives</span>
</pre></div>
</div>
<p>The keyword <tt class="docutils literal"><span class="pre">cover_labels</span></tt> can be used to decorate edges:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cover_labels</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
<span class="go">Graphics object consisting of 8 graphics primitives</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cover_labels</span><span class="o">=</span><span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span> <span class="s">&#39;here&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span> <span class="s">&#39;there&#39;</span><span class="p">})</span>
<span class="go">Graphics object consisting of 8 graphics primitives</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cover_labels</span><span class="o">=</span><span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;da&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;niet&#39;</span><span class="p">)])</span>
<span class="go">Graphics object consisting of 8 graphics primitives</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>We check that <tt class="docutils literal"><span class="pre">label_elements</span></tt> and <tt class="docutils literal"><span class="pre">element_labels</span></tt> are honored:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">get_plot_labels</span><span class="p">(</span><span class="n">P</span><span class="p">):</span> <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">string</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">P</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">Text</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">get_plot_labels</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_elements</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">get_plot_labels</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_elements</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">[&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]</span>
<span class="gp">sage: </span><span class="n">element_labels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="s">&#39;e&#39;</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">get_plot_labels</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">element_labels</span><span class="o">=</span><span class="n">element_labels</span><span class="p">))</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span>
<span class="gp">sage: </span><span class="n">get_plot_labels</span><span class="p">(</span><span class="n">P2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">element_labels</span><span class="o">=</span><span class="n">element_labels</span><span class="p">))</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>Plot of the empy poset:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 0 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.product">
<tt class="descname">product</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cartesian product of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">other</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">PQ</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="p">;</span> <span class="n">PQ</span>
<span class="go">Finite lattice containing 12 elements</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">PQ</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
<span class="go">17</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">PQ</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.promotion">
<tt class="descname">promotion</tt><big>(</big><em>i=1</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.promotion" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the (extended) promotion on the linear extension
of the poset <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">i</span></tt> &#8211; an integer between <span class="math">\(1\)</span> and <span class="math">\(n\)</span> (default: <span class="math">\(1\)</span>)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an isomorphic poset, with the same default linear extension</li>
</ul>
<p>The extended promotion is defined on a poset <tt class="docutils literal"><span class="pre">self</span></tt> of size
<span class="math">\(n\)</span> by applying the promotion operator <span class="math">\(\tau_i \tau_{i+1}
\cdots \tau_{n-1}\)</span> to the default linear extension <span class="math">\(\pi\)</span> of <tt class="docutils literal"><span class="pre">self</span></tt>
(see <a class="reference internal" href="linear_extensions.html#sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.promotion" title="sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.promotion"><tt class="xref py py-meth docutils literal"><span class="pre">promotion()</span></tt></a>),
and relabeling <tt class="docutils literal"><span class="pre">self</span></tt> accordingly. For more details see <a class="reference internal" href="#stan2009" id="id20">[Stan2009]</a>.</p>
<p>When the vertices of the poset <tt class="docutils literal"><span class="pre">self</span></tt> are labelled by
<span class="math">\(\{1,2,\ldots,n\}\)</span>, the linear extension is the identity, and
<span class="math">\(i=1\)</span>, the above algorithm corresponds to the promotion
operator on posets defined by Schützenberger as
follows. Remove <span class="math">\(1\)</span> from <tt class="docutils literal"><span class="pre">self</span></tt> and replace it by the
minimum <span class="math">\(j\)</span> of all labels covering <span class="math">\(1\)</span> in the poset. Then,
remove <span class="math">\(j\)</span> and replace it by the minimum of all labels
covering <span class="math">\(j\)</span>, and so on.  This process ends when a label is a
local maximum. Place the label <span class="math">\(n+1\)</span> at this vertex.  Finally,
decrease all labels by <span class="math">\(1\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">()</span>
<span class="go">Finite poset containing 2 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">==</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 6, 4, 7]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 7 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 6], [2, 3], [2, 5], [3, 7], [5, 7], [6, 4]]</span>
</pre></div>
</div>
<p>Note that if one wants to obtain the promotion defined by
Schützenberger&#8217;s algorithm directly on the poset, one needs
to make sure the linear extension is the identity:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">with_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 7 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 6], [2, 3], [2, 4], [3, 5], [4, 5], [6, 7]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [4, 7], [5, 7]]</span>
</pre></div>
</div>
<p>Here is an example for a poset not labelled by <span class="math">\(\{1, 2, \ldots, n\}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 6, 10, 15, 30]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [1, 5], [2, 6], [2, 10], [3, 6], [3, 15],</span>
<span class="go"> [5, 10], [5, 15], [6, 30], [10, 30], [15, 30]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">promotion</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 8 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [1, 6], [2, 5], [2, 15], [3, 5], [3, 10],</span>
<span class="go"> [5, 30], [6, 10], [6, 15], [10, 30], [15, 30]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extension" title="sage.combinat.posets.posets.FinitePoset.linear_extension"><tt class="xref py py-meth docutils literal"><span class="pre">linear_extension()</span></tt></a></li>
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.with_linear_extension" title="sage.combinat.posets.posets.FinitePoset.with_linear_extension"><tt class="xref py py-meth docutils literal"><span class="pre">with_linear_extension()</span></tt></a> and the <tt class="docutils literal"><span class="pre">linear_extension</span></tt> option of <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><tt class="xref py py-func docutils literal"><span class="pre">Poset()</span></tt></a></li>
<li><a class="reference internal" href="linear_extensions.html#sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.promotion" title="sage.combinat.posets.linear_extensions.LinearExtensionOfPoset.promotion"><tt class="xref py py-meth docutils literal"><span class="pre">promotion()</span></tt></a></li>
<li><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.evacuation" title="sage.combinat.posets.posets.FinitePoset.evacuation"><tt class="xref py py-meth docutils literal"><span class="pre">evacuation()</span></tt></a></li>
</ul>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Anne Schilling (2012-02-18)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.random_order_ideal">
<tt class="descname">random_order_ideal</tt><big>(</big><em>direction='down'</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.random_order_ideal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random order ideal with uniform probability.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">direction</span></tt> &#8211; <tt class="docutils literal"><span class="pre">'up'</span></tt>, <tt class="docutils literal"><span class="pre">'down'</span></tt> or <tt class="docutils literal"><span class="pre">'antichain'</span></tt>
(default: <tt class="docutils literal"><span class="pre">'down'</span></tt>)</li>
</ul>
<p>OUTPUT:</p>
<p>A randomly selected order ideal (or order filter if
<tt class="docutils literal"><span class="pre">direction='up'</span></tt>, or antichain if <tt class="docutils literal"><span class="pre">direction='antichain'</span></tt>)
where all order ideals have equal probability of occurring.</p>
<p>ALGORITHM:</p>
<p>Uses the coupling from the past algorithm described in <a class="reference internal" href="#propp1997" id="id21">[Propp1997]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s">&#39;up&#39;</span><span class="p">)</span>
<span class="go">[6, 7]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s">&#39;antichain&#39;</span><span class="p">)</span>
<span class="go">[1, 2]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="s">&#39;antichain&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_antichain_of_poset</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="s">&#39;up&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_order_filter</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">random_order_ideal</span><span class="p">(</span><span class="s">&#39;down&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_order_ideal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="propp1997" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[Propp1997]</a></td><td>James Propp,
<em>Generating Random Elements of Finite Distributive Lattices</em>,
Electron. J. Combin. 4 (1997), no. 2, The Wilf Festschrift volume,
Research Paper 15.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.random_subposet">
<tt class="descname">random_subposet</tt><big>(</big><em>p</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.random_subposet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random subposet that contains each element with
probability <tt class="docutils literal"><span class="pre">p</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">random_subposet</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 2], [0, 5], [2, 3], [3, 7], [5, 7]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.rank">
<tt class="descname">rank</tt><big>(</big><em>element=None</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the rank of an element <tt class="docutils literal"><span class="pre">element</span></tt> in the poset <tt class="docutils literal"><span class="pre">self</span></tt>,
or the rank of the poset if <tt class="docutils literal"><span class="pre">element</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<p>(The rank of a poset is the length of the longest chain of
elements of the poset.)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]],</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[],[]])</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">SymmetricGroupBruhatOrderPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">v</span><span class="p">,</span><span class="n">P</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="p">]</span>
<span class="go">[(&#39;1234&#39;, 0),</span>
<span class="go"> (&#39;1243&#39;, 1),</span>
<span class="gp">...</span>
<span class="go"> (&#39;4312&#39;, 5),</span>
<span class="go"> (&#39;4321&#39;, 6)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.rank_function">
<tt class="descname">rank_function</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.rank_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the (normalized) rank function of the poset,
if it exists.</p>
<p>A <em>rank function</em> of a poset <span class="math">\(P\)</span> is a function <span class="math">\(r\)</span>
that maps elements of <span class="math">\(P\)</span> to integers and satisfies:
<span class="math">\(r(x) = r(y) + 1\)</span> if <span class="math">\(x\)</span> covers <span class="math">\(y\)</span>. The function <span class="math">\(r\)</span>
is normalized such that its minimum value on every
connected component of the Hasse diagram of <span class="math">\(P\)</span> is
<span class="math">\(0\)</span>. This determines the function <span class="math">\(r\)</span> uniquely (when
it exists).</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a lambda function, if the poset admits a rank function</li>
<li><tt class="docutils literal"><span class="pre">None</span></tt>, if the poset does not admit a rank function</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rank_function</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rank_function</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]]),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">rank_function</span><span class="p">();</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">rank_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">cover_relations_iterator</span><span class="p">():</span>
<span class="go">....:     if r(v) != r(u) + 1:</span>
<span class="go">....:         print &quot;Bug in rank_function!&quot;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">rank_function</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.relabel">
<tt class="descname">relabel</tt><big>(</big><em>relabeling</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.relabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of this poset with its elements relabelled.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">relabeling</span></tt> &#8211; a function or dictionary</li>
</ul>
<p>This function should map each (non-wrapped) element of
<tt class="docutils literal"><span class="pre">self</span></tt> to some distinct object.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 6], [3, 6], [4, 12], [6, 12]]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">12</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[12, 6, 4, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[12, 6], [12, 4], [6, 3], [6, 2], [4, 2], [3, 1], [2, 1]]</span>
</pre></div>
</div>
<p>Here we relabel the elements of a poset by <span class="math">\(\{0,1,2, ...\}\)</span>, using
a dictionary:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">relabeling</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="o">.</span><span class="n">element</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">P</span><span class="p">)};</span> <span class="n">relabeling</span>
<span class="go">{1: 0, 2: 1, 3: 2, 4: 3, 6: 4, 12: 5}</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">relabeling</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 2], [1, 3], [1, 4], [2, 4], [3, 5], [4, 5]]</span>
</pre></div>
</div>
<p>Mind the <tt class="docutils literal"><span class="pre">c.element</span></tt>; this is because the relabeling is
applied to the elements of the poset without the wrapping.
Thanks to this convention, the same relabeling function can
be used both for facade or non facade posets:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">12</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[12, 6, 4, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[12, 6], [12, 4], [6, 3], [6, 2], [4, 2], [3, 1], [2, 1]]</span>
</pre></div>
</div>
<p>Relabeling a (semi)lattice gives a (semi)lattice:</p>
<blockquote>
<div>sage: P=JoinSemilattice({0:[1]})
sage: type(P.relabel(lambda n: n+1))
&lt;class &#8216;sage.combinat.posets.lattices.FiniteJoinSemilattice_with_category&#8217;&gt;</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As can be seen in the above examples, the default linear
extension of <tt class="docutils literal"><span class="pre">Q</span></tt> is that of <tt class="docutils literal"><span class="pre">P</span></tt> after relabeling. In
particular, <tt class="docutils literal"><span class="pre">P</span></tt> and <tt class="docutils literal"><span class="pre">Q</span></tt> share the same internal Hasse
diagram.</p>
</div>
<p>TESTS:</p>
<p>The following checks that <a class="reference external" href="http://trac.sagemath.org/14019">trac ticket #14019</a> has been fixed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">2</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">p1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">relabel</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">p1</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span> <span class="o">==</span> <span class="n">p2</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">p1</span> <span class="o">==</span> <span class="n">p2</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">2</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">p1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">relabel</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">1</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="n">relabel</span><span class="p">({</span><span class="mi">2</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">p1</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span> <span class="o">==</span> <span class="n">p3</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">p1</span> <span class="o">==</span> <span class="n">p3</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.relations">
<tt class="descname">relations</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.relations" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all relations of the poset.</p>
<p>A relation is a pair of elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> such that <span class="math">\(x\leq y\)</span>
in <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Relations are also often called intervals. The number of
intervals is the dimension of the incidence algebra.</p>
<p>OUTPUT:</p>
<p>A list of pairs (each pair is a list), where the first element
of the pair is less than or equal to the second element.</p>
<p>Pairs are produced in a rough sort of lexicographic order,
where earlier elements are from lower levels of the poset.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="sage.combinat.posets.posets.FinitePoset.relations_number"><tt class="xref py py-meth docutils literal"><span class="pre">relations_number()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><tt class="xref py py-meth docutils literal"><span class="pre">relations_iterator()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">relations</span><span class="p">()</span>
<span class="go">[[1, 1], [1, 2], [1, 3], [1, 4], [0, 0], [0, 2], [0, 3],</span>
<span class="go">[0, 4], [2, 2], [2, 3], [2, 4], [3, 3], [3, 4], [4, 4]]</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Rob Beezer (2011-05-04)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.relations_iterator">
<tt class="descname">relations_iterator</tt><big>(</big><em>strict=False</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator for all the relations of the poset.</p>
<p>A relation is a pair of elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> such that <span class="math">\(x\leq y\)</span>
in <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Relations are also often called intervals. The number of
intervals is the dimension of the incidence algebra.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">strict</span></tt> &#8211; boolean (default <tt class="docutils literal"><span class="pre">False</span></tt>) if <tt class="docutils literal"><span class="pre">True</span></tt>, returns
an iterator over relations <span class="math">\(x &lt; y\)</span>, excluding all
relations <span class="math">\(x \leq x\)</span>.</li>
</ul>
<p>OUTPUT:</p>
<p>A generator that produces pairs (each pair is a list), where the
first element of the pair is less than or equal to the second element.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="sage.combinat.posets.posets.FinitePoset.relations_number"><tt class="xref py py-meth docutils literal"><span class="pre">relations_number()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><tt class="xref py py-meth docutils literal"><span class="pre">relations()</span></tt></a>,
<a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.maximal_chains" title="sage.combinat.posets.posets.FinitePoset.maximal_chains"><tt class="xref py py-meth docutils literal"><span class="pre">maximal_chains()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.chains" title="sage.combinat.posets.posets.FinitePoset.chains"><tt class="xref py py-meth docutils literal"><span class="pre">chains()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">relations_iterator</span><span class="p">())</span>
<span class="go">&lt;type &#39;generator&#39;&gt;</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">relations_iterator</span><span class="p">()]</span>
<span class="go">[[1, 1], [1, 2], [1, 3], [1, 4], [0, 0], [0, 2], [0, 3],</span>
<span class="go">[0, 4], [2, 2], [2, 3], [2, 4], [3, 3], [3, 4], [4, 4]]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">relations_iterator</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">[[0, 1], [0, 2], [0, 4], [0, 3], [1, 4], [2, 3], [2, 4], [3, 4]]</span>

<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">relations_iterator</span><span class="p">()))</span>
<span class="go">13</span>
</pre></div>
</div>
<p>AUTHOR:</p>
<ul class="simple">
<li>Rob Beezer (2011-05-04)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.relations_number">
<tt class="descname">relations_number</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.relations_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of relations in the poset.</p>
<p>A relation is a pair of elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> such that <span class="math">\(x\leq y\)</span>
in the poset.</p>
<p>Relations are also often called intervals. The number of
intervals is the dimension of the incidence algebra.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations_iterator" title="sage.combinat.posets.posets.FinitePoset.relations_iterator"><tt class="xref py py-meth docutils literal"><span class="pre">relations_iterator()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.relations" title="sage.combinat.posets.posets.FinitePoset.relations"><tt class="xref py py-meth docutils literal"><span class="pre">relations()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">13</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.tamari_lattices</span> <span class="kn">import</span> <span class="n">TamariLattice</span>
<span class="gp">sage: </span><span class="n">TamariLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">68</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">relations_number</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.show">
<tt class="descname">show</tt><big>(</big><em>label_elements=True</em>, <em>element_labels=None</em>, <em>cover_labels=None</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays the Hasse diagram of the poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">label_elements</span></tt> (default: <tt class="docutils literal"><span class="pre">True</span></tt>) - whether to display
element labels</li>
<li><tt class="docutils literal"><span class="pre">element_labels</span></tt> (default: <tt class="docutils literal"><span class="pre">None</span></tt>) - a dictionary of
element labels</li>
<li><tt class="docutils literal"><span class="pre">cover_labels</span></tt> - a dictionary, list or function representing labels
of the covers of <tt class="docutils literal"><span class="pre">self</span></tt>. When set to <tt class="docutils literal"><span class="pre">None</span></tt> (default) no label is
displayed on the edges of the Hasse Diagram.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This method also accepts:</p>
<blockquote class="last">
<div><ul class="simple">
<li>All options of <a class="reference external" href="../../../../graphs/sage/graphs/generic_graph.html#sage.graphs.generic_graph.GenericGraph.plot" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-meth docutils literal"><span class="pre">GenericGraph.plot</span></tt></a></li>
<li>All options of <a class="reference external" href="../../../../plotting/sage/plot/graphics.html#sage.plot.graphics.Graphics.show" title="(in Sage Reference Manual: 2D Graphics v6.9)"><tt class="xref py py-meth docutils literal"><span class="pre">Graphics.show</span></tt></a></li>
</ul>
</div></blockquote>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_elements</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Graphics object consisting of 6 graphics primitives</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">elm_labs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="s">&#39;e&#39;</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">element_labels</span><span class="o">=</span><span class="n">elm_labs</span><span class="p">)</span>
</pre></div>
</div>
<p>One more example with cover labels:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">cover_labels</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.subposet">
<tt class="descname">subposet</tt><big>(</big><em>elements</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.subposet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the poset containing elements with partial order induced by
that of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s">&quot;a&quot;</span><span class="p">:[</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="s">&quot;d&quot;</span><span class="p">],</span> <span class="s">&quot;b&quot;</span><span class="p">:[</span><span class="s">&quot;d&quot;</span><span class="p">,</span><span class="s">&quot;e&quot;</span><span class="p">],</span> <span class="s">&quot;c&quot;</span><span class="p">:[</span><span class="s">&quot;f&quot;</span><span class="p">],</span> <span class="s">&quot;d&quot;</span><span class="p">:[</span><span class="s">&quot;f&quot;</span><span class="p">],</span> <span class="s">&quot;e&quot;</span><span class="p">:[</span><span class="s">&quot;f&quot;</span><span class="p">]},</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">([</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="s">&quot;f&quot;</span><span class="p">]);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[b, f], [a, f]]</span>
</pre></div>
</div>
<p>A subposet of a facade poset is again a facade poset:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s">&quot;a&quot;</span><span class="p">:[</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="s">&quot;d&quot;</span><span class="p">],</span> <span class="s">&quot;b&quot;</span><span class="p">:[</span><span class="s">&quot;d&quot;</span><span class="p">,</span><span class="s">&quot;e&quot;</span><span class="p">],</span> <span class="s">&quot;c&quot;</span><span class="p">:[</span><span class="s">&quot;f&quot;</span><span class="p">],</span> <span class="s">&quot;d&quot;</span><span class="p">:[</span><span class="s">&quot;f&quot;</span><span class="p">],</span> <span class="s">&quot;e&quot;</span><span class="p">:[</span><span class="s">&quot;f&quot;</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">([</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="s">&quot;f&quot;</span><span class="p">]);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[&#39;b&#39;, &#39;f&#39;], [&#39;a&#39;, &#39;f&#39;]]</span>
</pre></div>
</div>
<p>One may specified wrapped elements or not:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s">&quot;a&quot;</span><span class="p">:[</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="s">&quot;d&quot;</span><span class="p">],</span> <span class="s">&quot;b&quot;</span><span class="p">:[</span><span class="s">&quot;d&quot;</span><span class="p">,</span><span class="s">&quot;e&quot;</span><span class="p">],</span> <span class="s">&quot;c&quot;</span><span class="p">:[</span><span class="s">&quot;f&quot;</span><span class="p">],</span> <span class="s">&quot;d&quot;</span><span class="p">:[</span><span class="s">&quot;f&quot;</span><span class="p">],</span> <span class="s">&quot;e&quot;</span><span class="p">:[</span><span class="s">&quot;f&quot;</span><span class="p">]},</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">([</span><span class="n">P</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">),</span><span class="n">P</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">),</span><span class="n">P</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">)]);</span> <span class="n">Q</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[b, f], [a, f]]</span>

<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">above</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">principal_order_filter</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">subposet</span><span class="p">(</span><span class="n">above</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">above_new</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">principal_order_filter</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">list</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">subposet</span><span class="p">(</span><span class="n">above_new</span><span class="p">)</span>
<span class="go">Finite poset containing 4 elements</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">((</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="s">&quot;f&quot;</span><span class="p">))</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">([</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="s">&quot;x&quot;</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">&lt;type &#39;str&#39;&gt; is not an element of this poset</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">subposet</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;sage.rings.integer.Integer&#39; object is not iterable</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.to_graph">
<tt class="descname">to_graph</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.to_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.cover_relations_graph" title="sage.combinat.posets.posets.FinitePoset.cover_relations_graph"><tt class="xref py py-func docutils literal"><span class="pre">cover_relations_graph()</span></tt></a> instead.
See <a class="reference external" href="http://trac.sagemath.org/17449">trac ticket #17449</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.top">
<tt class="descname">top</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.top" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique maximal element of the poset, if it exists.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="mi">4</span><span class="p">:[],</span><span class="mi">5</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">top</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">top</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.has_top" title="sage.combinat.posets.posets.FinitePoset.has_top"><tt class="xref py py-meth docutils literal"><span class="pre">has_top()</span></tt></a>, <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.bottom" title="sage.combinat.posets.posets.FinitePoset.bottom"><tt class="xref py py-meth docutils literal"><span class="pre">bottom()</span></tt></a>.</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">0</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">top</span><span class="p">()</span> <span class="c">#Trac #10776</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.unwrap">
<tt class="descname">unwrap</tt><big>(</big><em>element</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the element <tt class="docutils literal"><span class="pre">element</span></tt> of the poset <tt class="docutils literal"><span class="pre">self</span></tt> in
unwrapped form.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">element</span></tt> &#8211; an element of <tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Integer Ring</span>
</pre></div>
</div>
<p>For a non facade poset, this is equivalent to using the
<tt class="docutils literal"><span class="pre">.element</span></tt> attribute:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span><span class="o">.</span><span class="n">element</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For a facade poset, this does nothing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This method is useful in code where we don&#8217;t know if <tt class="docutils literal"><span class="pre">P</span></tt> is
a facade poset or not.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.upper_covers">
<tt class="descname">upper_covers</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.upper_covers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of upper covers of the element <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>An upper cover of <span class="math">\(x\)</span> is an element <span class="math">\(y\)</span> such that <span class="math">\(x &lt; y\)</span> and
there is no element <span class="math">\(z\)</span> so that <span class="math">\(x &lt; z &lt; y\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">upper_covers</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[2, 6]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.lower_covers" title="sage.combinat.posets.posets.FinitePoset.lower_covers"><tt class="xref py py-meth docutils literal"><span class="pre">lower_covers()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.upper_covers_iterator">
<tt class="descname">upper_covers_iterator</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.upper_covers_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the upper covers of the element <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[]})</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">upper_covers_iterator</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">&lt;type &#39;generator&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.width">
<tt class="descname">width</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.width" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the width of the poset (the size of its longest antichain).</p>
<p>It is computed through a matching in a bipartite graph. See
<a class="reference external" href="https://en.wikipedia.org/wiki/Dilworth's_theorem">Wikipedia article Dilworth&#8217;s_theorem</a> for more information.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">BooleanLattice</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">width</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">width</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.with_linear_extension">
<tt class="descname">with_linear_extension</tt><big>(</big><em>linear_extension</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.with_linear_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of <tt class="docutils literal"><span class="pre">self</span></tt> with a different default linear extension.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 4], [2, 6], [3, 6], [4, 12], [6, 12]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">with_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="go">[1, 3, 2, 6, 4, 12]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 3], [1, 2], [3, 6], [2, 6], [2, 4], [6, 12], [4, 12]]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>We check that we can pass in a list of elements of <tt class="docutils literal"><span class="pre">P</span></tt> instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">with_linear_extension</span><span class="p">([</span><span class="n">P</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">12</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="go">[1, 3, 2, 6, 4, 12]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 3], [1, 2], [3, 6], [2, 6], [2, 4], [6, 12], [4, 12]]</span>
</pre></div>
</div>
<p>We check that this works for facade posets too:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">with_linear_extension</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="go">[1, 3, 2, 6, 4, 12]</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 3], [1, 2], [3, 6], [2, 6], [2, 4], [6, 12], [4, 12]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">With the current implementation, this requires relabeling
the internal <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">DiGraph</span></tt></a> which is <span class="math">\(O(n+m)\)</span>, where <span class="math">\(n\)</span>
is the number of elements and <span class="math">\(m\)</span> the number of cover relations.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePoset.zeta_polynomial">
<tt class="descname">zeta_polynomial</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePoset.zeta_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the zeta polynomial of the poset <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The zeta polynomial of a poset is the unique polynomial <span class="math">\(Z(q)\)</span>
such that for every integer <span class="math">\(m &gt; 1\)</span>, <span class="math">\(Z(m)\)</span> is the number of
weakly increasing sequences <span class="math">\(x_1 \leq x_2 \leq \dots \leq x_{m-1}\)</span>
of elements of the poset.</p>
<p>The polynomial <span class="math">\(Z(q)\)</span> is integral-valued, but generally doesn&#8217;t
have integer coefficients. It can be computed as</p>
<div class="math">
\[Z(q) = \sum_{k \geq 1} \dbinom{q-2}{k-1} c_k,\]</div>
<p>where <span class="math">\(c_k\)</span> is the number of all chains of length <span class="math">\(k\)</span> in the
poset.</p>
<p>For more information, see section 3.12 of <a class="reference internal" href="#enumcomb1" id="id22">[EnumComb1]</a>.</p>
<p>In particular, <span class="math">\(Z(2)\)</span> is the number of vertices and <span class="math">\(Z(3)\)</span> is
the number of intervals.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">q</span>
<span class="gp">sage: </span><span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">1/2*q^2 + 1/2*q</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">1/6*q^3 + q^2 - 1/6*q</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">3/2*q^2 - 1/2*q</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Checking the simplest cases:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Poset</span><span class="p">({})</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[]})</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[]})</span><span class="o">.</span><span class="n">zeta_polynomial</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.posets.posets.FinitePosets_n">
<em class="property">class </em><tt class="descclassname">sage.combinat.posets.posets.</tt><tt class="descname">FinitePosets_n</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePosets_n" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></tt></a>, <a class="reference external" href="../../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.parent.Parent</span></tt></a></p>
<p>The finite enumerated set of all posets on <span class="math">\(n\)</span> vertices, up to an isomorphism.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span><span class="p">:</span> <span class="k">print</span> <span class="n">p</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[]</span>
<span class="go">[[1, 2]]</span>
<span class="go">[[0, 1], [0, 2]]</span>
<span class="go">[[0, 1], [1, 2]]</span>
<span class="go">[[1, 2], [0, 2]]</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.posets.posets.FinitePosets_n.cardinality">
<tt class="descname">cardinality</tt><big>(</big><em>from_iterator=False</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.FinitePosets_n.cardinality" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cardinality of this object.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">By default, this returns pre-computed values obtained from
the On-Line Encyclopedia of Integer Sequences (<a class="reference external" href="https://oeis.org/A000112">OEIS sequence A000112</a>).
To override this, pass the argument <tt class="docutils literal"><span class="pre">from_iterator=True</span></tt>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cardinality</span><span class="p">(</span><span class="n">from_iterator</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.combinat.posets.posets.Poset">
<tt class="descclassname">sage.combinat.posets.posets.</tt><tt class="descname">Poset</tt><big>(</big><em>data=None</em>, <em>element_labels=None</em>, <em>cover_relations=False</em>, <em>linear_extension=False</em>, <em>category=None</em>, <em>facade=None</em>, <em>key=None</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.Poset" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a finite poset from various forms of input data.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">data</span></tt> &#8211; different input are accepted by this constructor:</p>
<ol class="arabic">
<li><p class="first">A two-element list or tuple <tt class="docutils literal"><span class="pre">(E,</span> <span class="pre">R)</span></tt>, where <tt class="docutils literal"><span class="pre">E</span></tt> is a
collection of elements of the poset and <tt class="docutils literal"><span class="pre">R</span></tt> is a collection
of relations <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></tt>, each represented as a two-element
lists/tuples/iterables such as <tt class="docutils literal"><span class="pre">[x,</span> <span class="pre">y]</span></tt>. The poset is then
the transitive closure of the provided relations. If
<tt class="docutils literal"><span class="pre">cover_relations=True</span></tt>, then <tt class="docutils literal"><span class="pre">R</span></tt> is assumed to contain
exactly the cover relations of the poset. If <tt class="docutils literal"><span class="pre">E</span></tt> is empty,
then <tt class="docutils literal"><span class="pre">E</span></tt> is taken to be the set of elements appearing in
the relations <tt class="docutils literal"><span class="pre">R</span></tt>.</p>
</li>
<li><p class="first">A two-element list or tuple <tt class="docutils literal"><span class="pre">(E,</span> <span class="pre">f)</span></tt>, where <tt class="docutils literal"><span class="pre">E</span></tt> is the set
of elements of the poset and <tt class="docutils literal"><span class="pre">f</span></tt> is a function such that,
for any pair <tt class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span></tt> of elements of <tt class="docutils literal"><span class="pre">E</span></tt>, <tt class="docutils literal"><span class="pre">f(x,</span> <span class="pre">y)</span></tt>
returns whether <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></tt>. If <tt class="docutils literal"><span class="pre">cover_relations=True</span></tt>, then
<tt class="docutils literal"><span class="pre">f(x,y)</span></tt> should return whether <tt class="docutils literal"><span class="pre">x</span></tt> is covered by <tt class="docutils literal"><span class="pre">y</span></tt>.</p>
</li>
<li><p class="first">A dictionary, list or tuple of upper covers: <tt class="docutils literal"><span class="pre">data[x]</span></tt> is
a list of the elements that cover the element <span class="math">\(x\)</span> in the poset.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If data is a list or tuple of length <span class="math">\(2\)</span>, then it is
handled by the above case..</p>
</div>
</li>
<li><p class="first">An acyclic, loop-free and multi-edge free <tt class="docutils literal"><span class="pre">DiGraph</span></tt>. If
<tt class="docutils literal"><span class="pre">cover_relations</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt>, then the edges of the
digraph are assumed to correspond to the cover relations of
the poset. Otherwise, the cover relations are computed.</p>
</li>
<li><p class="first">A previously constructed poset (the poset itself is returned).</p>
</li>
</ol>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">element_labels</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">None</span></tt>); an optional list or
dictionary of objects that label the poset elements.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">cover_relations</span></tt> &#8211; a boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>); whether the
data can be assumed to describe a directed acyclic graph whose
arrows are cover relations; otherwise, the cover relations are
first computed.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">linear_extension</span></tt> &#8211; a boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>); whether to
use the provided list of elements as default linear extension
for the poset; otherwise a linear extension is computed. If the data
is given as the pair <tt class="docutils literal"><span class="pre">(E,</span> <span class="pre">f)</span></tt>, then <tt class="docutils literal"><span class="pre">E</span></tt> is taken to be the linear
extension.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">facade</span></tt> &#8211; a boolean or <tt class="docutils literal"><span class="pre">None</span></tt> (default); whether the
<a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><tt class="xref py py-meth docutils literal"><span class="pre">Poset()</span></tt></a>&#8216;s elements should be wrapped to make them aware of the
Poset they belong to.</p>
<ul class="simple">
<li>If <tt class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">True</span></tt>, the <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><tt class="xref py py-meth docutils literal"><span class="pre">Poset()</span></tt></a>&#8216;s elements are exactly those
given as input.</li>
<li>If <tt class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></tt>, the <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><tt class="xref py py-meth docutils literal"><span class="pre">Poset()</span></tt></a>&#8216;s elements will become
<tt class="xref py py-class docutils literal"><span class="pre">PosetElement</span></tt> objects.</li>
<li>If <tt class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">None</span></tt> (default) the expected behaviour is the behaviour
of <tt class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">True</span></tt>, unless the opposite can be deduced from the
context (i.e. for instance if a <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><tt class="xref py py-meth docutils literal"><span class="pre">Poset()</span></tt></a> is built from another
<a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><tt class="xref py py-meth docutils literal"><span class="pre">Poset()</span></tt></a>, itself built with <tt class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></tt>)</li>
</ul>
</li>
</ul>
<p>OUTPUT:</p>
<p><tt class="docutils literal"><span class="pre">FinitePoset</span></tt> &#8211; an instance of the <a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset" title="sage.combinat.posets.posets.FinitePoset"><tt class="xref py py-class docutils literal"><span class="pre">FinitePoset</span></tt></a> class.</p>
<p>If <tt class="docutils literal"><span class="pre">category</span></tt> is specified, then the poset is created in this
category instead of <a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets" title="(in Sage Reference Manual: Category Framework v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">FinitePosets</span></tt></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="poset_examples.html#sage.combinat.posets.poset_examples.Posets" title="sage.combinat.posets.poset_examples.Posets"><tt class="xref py py-class docutils literal"><span class="pre">Posets</span></tt></a>, <a class="reference external" href="../../../../categories/sage/categories/posets.html#sage.categories.posets.Posets" title="(in Sage Reference Manual: Category Framework v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">Posets</span></tt></a>,
<a class="reference external" href="../../../../categories/sage/categories/finite_posets.html#sage.categories.finite_posets.FinitePosets" title="(in Sage Reference Manual: Category Framework v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">FinitePosets</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<ol class="arabic">
<li><p class="first">Elements and cover relations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">elms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">rels</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">((</span><span class="n">elms</span><span class="p">,</span> <span class="n">rels</span><span class="p">),</span> <span class="n">cover_relations</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="go">Finite poset containing 7 elements</span>
</pre></div>
</div>
<p>Elements and non-cover relations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">elms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">rels</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">[</span><span class="n">elms</span><span class="p">,</span><span class="n">rels</span><span class="p">]</span> <span class="p">,</span><span class="n">cover_relations</span><span class="o">=</span><span class="bp">False</span><span class="p">);</span> <span class="n">P</span>
<span class="go">Finite poset containing 4 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [2, 3], [3, 4]]</span>
</pre></div>
</div>
</li>
<li><p class="first">Elements and function: the standard permutations of [1, 2, 3, 4]
with the Bruhat order:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">elms</span> <span class="o">=</span> <span class="n">Permutations</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fcn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">bruhat_lequal</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">((</span><span class="n">elms</span><span class="p">,</span> <span class="n">fcn</span><span class="p">))</span>
<span class="go">Finite poset containing 24 elements</span>
</pre></div>
</div>
<p>With a function that identifies the cover relations: the set
partitions of <span class="math">\(\{1, 2, 3\}\)</span> ordered by refinement:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">elms</span> <span class="o">=</span> <span class="n">SetPartitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">fcn</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
<span class="go">....:     if len(A) != len(B)+1:</span>
<span class="go">....:         return False</span>
<span class="go">....:     for a in A:</span>
<span class="go">....:         if not any(set(a).issubset(b) for b in B):</span>
<span class="go">....:             return False</span>
<span class="go">....:     return True</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">((</span><span class="n">elms</span><span class="p">,</span> <span class="n">fcn</span><span class="p">),</span> <span class="n">cover_relations</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Finite poset containing 5 elements</span>
</pre></div>
</div>
</li>
<li><p class="first">A dictionary of upper covers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Poset</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:[</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;c&#39;</span><span class="p">],</span> <span class="s">&#39;b&#39;</span><span class="p">:[</span><span class="s">&#39;d&#39;</span><span class="p">],</span> <span class="s">&#39;c&#39;</span><span class="p">:[</span><span class="s">&#39;d&#39;</span><span class="p">],</span> <span class="s">&#39;d&#39;</span><span class="p">:[]})</span>
<span class="go">Finite poset containing 4 elements</span>
</pre></div>
</div>
<p>A list of upper covers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]])</span>
<span class="go">Finite poset containing 5 elements</span>
</pre></div>
</div>
<p>A list of upper covers and a dictionary of labels:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">elm_labs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="s">&quot;d&quot;</span><span class="p">,</span><span class="mi">4</span><span class="p">:</span><span class="s">&quot;e&quot;</span><span class="p">}</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[]],</span> <span class="n">elm_labs</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[a, b, c, d, e]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The special case where the argument data is a list or tuple of
length 2 is handled by the above cases. So you cannot use this
method to input a 2-element poset.</p>
</div>
</li>
<li><p class="first">An acyclic DiGraph.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span>
<span class="go">Finite poset containing 6 elements</span>
</pre></div>
</div>
<p>Any directed acyclic graph without loops or multiple edges, as long
as <tt class="docutils literal"><span class="pre">cover_relations=False</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">dig</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">dig</span><span class="o">.</span><span class="n">allows_multiple_edges</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">dig</span><span class="o">.</span><span class="n">allows_loops</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">dig</span><span class="o">.</span><span class="n">transitive_reduction</span><span class="p">()</span> <span class="o">==</span> <span class="n">dig</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">dig</span><span class="p">,</span> <span class="n">cover_relations</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Finite poset containing 6 elements</span>
<span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">dig</span><span class="p">,</span> <span class="n">cover_relations</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Hasse diagram is not transitively reduced.</span>
</pre></div>
</div>
</li>
</ol>
<p class="rubric">Default Linear extension</p>
<p>Every poset <span class="math">\(P\)</span> obtained with <tt class="docutils literal"><span class="pre">Poset</span></tt> comes equipped with a
default linear extension, which is also used for enumerating
its elements. By default, this linear extension is computed,
and has no particular significance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 4, 3, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()</span>
<span class="go">[1, 2, 4, 3, 6, 12]</span>
</pre></div>
</div>
<p>You may enforce a specific linear extension using the
<tt class="docutils literal"><span class="pre">linear_extension</span></tt> option:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">linear_extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 12]</span>
</pre></div>
</div>
<p>Depending on popular request, <tt class="docutils literal"><span class="pre">Poset</span></tt> might eventually get
modified to always use the provided list of elements as
default linear extension, when it is one.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.posets.posets.FinitePoset.linear_extensions" title="sage.combinat.posets.posets.FinitePoset.linear_extensions"><tt class="xref py py-meth docutils literal"><span class="pre">FinitePoset.linear_extensions()</span></tt></a></p>
</div>
<p class="rubric">Facade posets</p>
<p>When <tt class="docutils literal"><span class="pre">facade</span> <span class="pre">=</span> <span class="pre">False</span></tt>, the elements of a poset are wrapped so as to make
them aware that they belong to that poset:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({</span><span class="s">&#39;d&#39;</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">],</span><span class="s">&#39;c&#39;</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">],</span><span class="s">&#39;b&#39;</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">]}),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This allows for comparing elements according to <span class="math">\(P\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<p>However, this may have surprising effects:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">my_elements</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">my_elements</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">P</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>and can be annoying when one wants to manipulate the elements of
the poset:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">unsupported operand type(s) for +: &#39;FinitePoset_with_category.element_class&#39; and &#39;FinitePoset_with_category.element_class&#39;</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">element</span>
<span class="go">&#39;ab&#39;</span>
</pre></div>
</div>
<p>By default, facade posets are constructed instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">({</span><span class="s">&#39;d&#39;</span><span class="p">:[</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">],</span><span class="s">&#39;c&#39;</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">],</span><span class="s">&#39;b&#39;</span><span class="p">:[</span><span class="s">&#39;a&#39;</span><span class="p">]}))</span>
</pre></div>
</div>
<p>In this example, the elements of the poset remain plain strings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;type &#39;str&#39;&gt;</span>
</pre></div>
</div>
<p>Of course, those strings are not aware of <span class="math">\(P\)</span>. So to compare two
such strings, one needs to query <span class="math">\(P\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>which models the usual mathematical notation <span class="math">\(a &lt;_P b\)</span>.</p>
<p>Most operations seem to still work, but at this point there is no
guarantee whatsoever:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">principal_order_ideal</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="go">[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">principal_order_ideal</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">)</span>
<span class="go">[&#39;d&#39;, &#39;b&#39;]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">principal_order_ideal</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
<span class="go">[&#39;d&#39;]</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p><a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">DiGraph</span></tt></a> is used to construct the poset, and the
vertices of a <a class="reference external" href="../../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">DiGraph</span></tt></a> are converted to plain Python
<tt class="xref py py-class docutils literal"><span class="pre">int</span></tt>&#8216;s if they are <a class="reference external" href="../../../../rings_standard/sage/rings/integer.html#sage.rings.integer.Integer" title="(in Sage Reference Manual: Standard Commutative Rings v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">Integer</span></tt></a>&#8216;s:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>This is worked around by systematically converting back the
vertices of a poset to <a class="reference external" href="../../../../rings_standard/sage/rings/integer.html#sage.rings.integer.Integer" title="(in Sage Reference Manual: Standard Commutative Rings v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">Integer</span></tt></a>&#8216;s if they are
<tt class="xref py py-class docutils literal"><span class="pre">int</span></tt>&#8216;s:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">element</span><span class="p">)</span>
<span class="go">&lt;type &#39;sage.rings.integer.Integer&#39;&gt;</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">())</span>
<span class="go">&lt;type &#39;sage.rings.integer.Integer&#39;&gt;</span>
</pre></div>
</div>
<p>This may be abusive:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">),</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Integer Ring</span>
</pre></div>
</div>
</div>
<p class="rubric">Unique representation</p>
<p>As most parents, <a class="reference internal" href="#sage.combinat.posets.posets.Poset" title="sage.combinat.posets.posets.Poset"><tt class="xref py py-class docutils literal"><span class="pre">Poset</span></tt></a> have unique representation (see
<a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></tt></a>). Namely if two posets are created
from two equal data, then they are not only equal but actually
identical:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">data1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">data2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">==</span> <span class="n">P2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="ow">is</span> <span class="n">P2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In situations where this behaviour is not desired, one can use the
<tt class="docutils literal"><span class="pre">key</span></tt> option:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s">&quot;foo&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span><span class="n">data2</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s">&quot;bar&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="ow">is</span> <span class="n">P2</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">==</span> <span class="n">P2</span>
<span class="go">False</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">key</span></tt> can be any hashable value and is passed down to
<a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Basic Structures v6.9)"><tt class="xref py py-class docutils literal"><span class="pre">UniqueRepresentation</span></tt></a>. It is otherwise ignored by the
poset constructor.</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">P</span><span class="p">))</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>Bad input:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Poset</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="p">:</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">element_labels should be a dict or a list if different from None. (Did you intend data to be equal to a pair ?)</span>
</pre></div>
</div>
<p>Another kind of bad input, digraphs with oriented cycles:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Poset</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]]))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The graph is not directed acyclic</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.posets.posets.is_poset">
<tt class="descclassname">sage.combinat.posets.posets.</tt><tt class="descname">is_poset</tt><big>(</big><em>dig</em><big>)</big><a class="headerlink" href="#sage.combinat.posets.posets.is_poset" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether a directed graph is acyclic and transitively
reduced.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.posets.posets</span> <span class="kn">import</span> <span class="n">is_poset</span>
<span class="gp">sage: </span><span class="n">dig</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">5</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">is_poset</span><span class="p">(</span><span class="n">dig</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">is_poset</span><span class="p">(</span><span class="n">dig</span><span class="o">.</span><span class="n">transitive_reduction</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../../../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Finite posets</a><ul>
<li><a class="reference internal" href="#list-of-poset-methods">List of Poset methods</a></li>
<li><a class="reference internal" href="#classes-and-functions">Classes and functions</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="poset_examples.html"
                                  title="previous chapter">A catalog of posets and lattices.</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="../q_analogues.html"
                                  title="next chapter">q-Analogues</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../../_sources/sage/combinat/posets/posets.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../q_analogues.html" title="q-Analogues"
             >next</a> |</li>
        <li class="right" >
          <a href="poset_examples.html" title="A catalog of posets and lattices."
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">Combinatorics</a> &raquo;</li>

          <li><a href="../../../module_list.html" >Comprehensive Module list</a> &raquo;</li> 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2015, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>