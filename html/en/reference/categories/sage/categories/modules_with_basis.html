<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Modules With Basis &mdash; Sage Reference Manual v6.6: Category Theory</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '6.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v6.6: Category Theory" href="../../index.html" />
    <link rel="next" title="Monoid algebras" href="monoid_algebras.html" />
    <link rel="prev" title="Modules" href="modules.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="monoid_algebras.html" title="Monoid algebras"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="Modules"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Category Theory</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="modules-with-basis">
<span id="sage-categories-modules-with-basis"></span><h1>Modules With Basis<a class="headerlink" href="#modules-with-basis" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.categories.modules_with_basis"></span><p>AUTHORS:</p>
<ul class="simple">
<li>Nicolas M. Thiery (2008-2014): initial revision, axiomatization</li>
<li>Jason Bandlow and Florent Hivert (2010): Triangular Morphisms</li>
<li>Christian Stump (2010): <a class="reference external" href="http://trac.sagemath.org/9648">trac ticket #9648</a> module_morphism&#8217;s to a wider class
of codomains</li>
</ul>
<dl class="class">
<dt id="sage.categories.modules_with_basis.DiagonalModuleMorphism">
<em class="property">class </em><tt class="descclassname">sage.categories.modules_with_basis.</tt><tt class="descname">DiagonalModuleMorphism</tt><big>(</big><em>diagonal</em>, <em>domain</em>, <em>codomain=None</em>, <em>category=None</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.DiagonalModuleMorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.modules_with_basis.ModuleMorphismByLinearity" title="sage.categories.modules_with_basis.ModuleMorphismByLinearity"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.modules_with_basis.ModuleMorphismByLinearity</span></tt></a></p>
<p>A class for diagonal module morphisms.</p>
<p>See <a class="reference internal" href="#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism"><tt class="xref py py-meth docutils literal"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></tt></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">domain</span></tt>, <tt class="docutils literal"><span class="pre">codomain</span></tt> &#8211; two modules with basis <span class="math">\(F\)</span> and <span class="math">\(G\)</span>,
respectively</li>
<li><tt class="docutils literal"><span class="pre">diagonal</span></tt> &#8211; a function <span class="math">\(d\)</span></li>
</ul>
<p>Assumptions:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">domain</span></tt> and <tt class="docutils literal"><span class="pre">codomain</span></tt> have the same base ring <span class="math">\(R\)</span>,</li>
<li>their respective bases <span class="math">\(F\)</span> and <span class="math">\(G\)</span> have the same index set <span class="math">\(I\)</span>,</li>
<li><span class="math">\(d\)</span> is a function <span class="math">\(I \to R\)</span>.</li>
</ul>
<p>Return the diagonal module morphism from <tt class="docutils literal"><span class="pre">domain</span></tt> to <tt class="docutils literal"><span class="pre">codomain</span></tt>
sending <span class="math">\(F(i) \mapsto d(i) G(i)\)</span> for all <span class="math">\(i \in I\)</span>.</p>
<p>By default, <tt class="docutils literal"><span class="pre">codomain</span></tt> is currently assumed to be <tt class="docutils literal"><span class="pre">domain</span></tt>.
(Todo: make a consistent choice with <tt class="docutils literal"><span class="pre">*ModuleMorphism</span></tt>.)</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<ul class="last simple">
<li>Implement an optimized <tt class="docutils literal"><span class="pre">_call_()</span></tt> function.</li>
<li>Generalize to a mapcoeffs.</li>
<li>Generalize to a mapterms.</li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">diagonal</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">X</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">(B[1], 2*B[2], 6*B[3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.categories.modules_with_basis.ModuleMorphismByLinearity">
<em class="property">class </em><tt class="descclassname">sage.categories.modules_with_basis.</tt><tt class="descname">ModuleMorphismByLinearity</tt><big>(</big><em>domain</em>, <em>on_basis=None</em>, <em>position=0</em>, <em>zero=None</em>, <em>codomain=None</em>, <em>category=None</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModuleMorphismByLinearity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="morphism.html#sage.categories.morphism.Morphism" title="sage.categories.morphism.Morphism"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.morphism.Morphism</span></tt></a></p>
<p>A class for module morphisms obtained by extending a function by linearity.</p>
<dl class="method">
<dt id="sage.categories.modules_with_basis.ModuleMorphismByLinearity.on_basis">
<tt class="descname">on_basis</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModuleMorphismByLinearity.on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the action of this morphism on basis elements, as per
<tt class="xref py py-meth docutils literal"><span class="pre">ModulesWithBasis.Homsets.ElementMethods.on_basis()</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a function from the indices of the basis of the domain to the
codomain</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">phi_on_basis</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">monomial</span> <span class="o">*</span> <span class="nb">abs</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">modules_with_basis</span><span class="o">.</span><span class="n">ModuleMorphismByLinearity</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">on_basis</span> <span class="o">=</span> <span class="n">phi_on_basis</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">on_basis</span><span class="p">()(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">B[2]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">on_basis</span><span class="p">()</span> <span class="o">==</span> <span class="n">phi_on_basis</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis">
<em class="property">class </em><tt class="descclassname">sage.categories.modules_with_basis.</tt><tt class="descname">ModulesWithBasis</tt><big>(</big><em>base_category</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="category_with_axiom.html#sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring" title="sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring</span></tt></a></p>
<p>The category of modules with a distinguished basis.</p>
<p>The elements are represented by expanding them in the distinguished basis.
The morphisms are not required to respect the distinguished basis.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Category of modules with basis over Integer Ring</span>
<span class="gp">sage: </span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of modules over Integer Ring]</span>
</pre></div>
</div>
<p>If the base ring is actually a field, this constructs instead the
category of vector spaces with basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Category of vector spaces with basis over Rational Field</span>

<span class="gp">sage: </span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of modules with basis over Rational Field,</span>
<span class="go"> Category of vector spaces over Rational Field]</span>
</pre></div>
</div>
<p>Let <span class="math">\(X\)</span> and <span class="math">\(Y\)</span> be two modules with basis. We can build <span class="math">\(Hom(X,Y)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">__custom_name</span> <span class="o">=</span> <span class="s">&quot;X&quot;</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span> <span class="n">Y</span><span class="o">.</span><span class="n">__custom_name</span> <span class="o">=</span> <span class="s">&quot;Y&quot;</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Hom</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">);</span> <span class="n">H</span>
<span class="go">Set of Morphisms from X to Y in Category of vector spaces with basis over Rational Field</span>
</pre></div>
</div>
<p>The simplest morphism is the zero map:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>         <span class="c"># todo: move this test into module once we have an example</span>
<span class="go">Generic morphism:</span>
<span class="go">  From: X</span>
<span class="go">  To:   Y</span>
</pre></div>
</div>
<p>which we can apply to elements of <span class="math">\(X\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">zero</span><span class="p">()(</span><span class="n">x</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">on_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>EXAMPLES:</p>
<p>We now construct a more interesting morphism by extending a
function by linearity:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span><span class="n">on_basis</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">Y</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">));</span> <span class="n">phi</span>
<span class="go">Generic morphism:</span>
<span class="go">  From: X</span>
<span class="go">  To:   Y</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">B[3] + 3*B[4]</span>
</pre></div>
</div>
<p>We can retrieve the function acting on indices of the basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">phi</span><span class="o">.</span><span class="n">on_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(B[3], B[4])</span>
</pre></div>
</div>
<p><span class="math">\(Hom(X,Y)\)</span> has a natural module structure (except for the zero,
the operations are not yet implemented though). However since the
dimension is not necessarily finite, it is not a module with
basis; but see <a class="reference internal" href="finite_dimensional_modules_with_basis.html#sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis" title="sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis"><tt class="xref py py-class docutils literal"><span class="pre">FiniteDimensionalModulesWithBasis</span></tt></a> and
<a class="reference internal" href="graded_modules_with_basis.html#sage.categories.graded_modules_with_basis.GradedModulesWithBasis" title="sage.categories.graded_modules_with_basis.GradedModulesWithBasis"><tt class="xref py py-class docutils literal"><span class="pre">GradedModulesWithBasis</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">H</span> <span class="ow">in</span> <span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">),</span> <span class="n">H</span> <span class="ow">in</span> <span class="n">Modules</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">(False, True)</span>
</pre></div>
</div>
<p>Some more playing around with categories and higher order homsets:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of homsets of modules with basis over Rational Field</span>
<span class="gp">sage: </span><span class="n">Hom</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of endsets of homsets of modules with basis over Rational Field</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last"><tt class="docutils literal"><span class="pre">End(X)</span></tt> is an algebra.</p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">ZZ</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.CartesianProducts">
<em class="property">class </em><tt class="descname">CartesianProducts</tt><big>(</big><em>category</em>, <em>*args</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.CartesianProducts" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="cartesian_product.html#sage.categories.cartesian_product.CartesianProductsCategory" title="sage.categories.cartesian_product.CartesianProductsCategory"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.cartesian_product.CartesianProductsCategory</span></tt></a></p>
<p>The category of modules with basis constructed by cartesian products
of modules with basis.</p>
<dl class="class">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.CartesianProducts.ParentMethods">
<em class="property">class </em><tt class="descname">ParentMethods</tt><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.CartesianProducts.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.CartesianProducts.extra_super_categories">
<tt class="descclassname">ModulesWithBasis.CartesianProducts.</tt><tt class="descname">extra_super_categories</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.CartesianProducts.extra_super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">CartesianProducts</span><span class="p">()</span><span class="o">.</span><span class="n">extra_super_categories</span><span class="p">()</span>
<span class="go">[Category of vector spaces with basis over Rational Field]</span>
<span class="gp">sage: </span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">CartesianProducts</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of Cartesian products of modules with basis over Rational Field,</span>
<span class="go"> Category of vector spaces with basis over Rational Field,</span>
<span class="go"> Category of Cartesian products of vector spaces over Rational Field]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.DualObjects">
<em class="property">class </em><tt class="descclassname">ModulesWithBasis.</tt><tt class="descname">DualObjects</tt><big>(</big><em>category</em>, <em>*args</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.DualObjects" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="dual.html#sage.categories.dual.DualObjectsCategory" title="sage.categories.dual.DualObjectsCategory"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.dual.DualObjectsCategory</span></tt></a></p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.covariant_functorial_construction</span> <span class="kn">import</span> <span class="n">CovariantConstructionCategory</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">FooBars</span><span class="p">(</span><span class="n">CovariantConstructionCategory</span><span class="p">):</span>
<span class="gp">... </span>      <span class="n">_functor_category</span> <span class="o">=</span> <span class="s">&quot;FooBars&quot;</span>
<span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">FooBars</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="n">FooBars</span><span class="o">.</span><span class="n">category_of</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">FooBars</span><span class="p">(</span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">ZZ</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">Category of foo bars of modules with basis over Integer Ring</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">base_category</span><span class="p">()</span>
<span class="go">Category of modules with basis over Integer Ring</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">\mathbf{FooBars}(\mathbf{ModulesWithBasis}_{\Bold{Z}})</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span><span class="p">;</span> <span class="n">__main__</span><span class="o">.</span><span class="n">FooBars</span> <span class="o">=</span> <span class="n">FooBars</span> <span class="c"># Fake FooBars being defined in a python module</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.DualObjects.extra_super_categories">
<tt class="descname">extra_super_categories</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.DualObjects.extra_super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">DualObjects</span><span class="p">()</span><span class="o">.</span><span class="n">extra_super_categories</span><span class="p">()</span>
<span class="go">[Category of modules over Integer Ring]</span>
<span class="gp">sage: </span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">DualObjects</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of duals of vector spaces over Rational Field, Category of duals of modules with basis over Rational Field]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods">
<em class="property">class </em><tt class="descclassname">ModulesWithBasis.</tt><tt class="descname">ElementMethods</tt><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.leading_coefficient">
<tt class="descname">leading_coefficient</tt><big>(</big><em>cmp=None</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.leading_coefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the leading coefficient of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This is the coefficient of the term whose corresponding basis element is
maximal. Note that this may not be the term which actually appears
first when <tt class="docutils literal"><span class="pre">self</span></tt> is printed.  If the default term ordering is not
what is desired, a comparison function, <tt class="docutils literal"><span class="pre">cmp(x,y)</span></tt>, can be provided.
This should return a negative value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt>, 0 if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></tt>
and a positive value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">leading_coefficient</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">y</span><span class="o">-</span><span class="n">x</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">leading_coefficient</span><span class="p">(</span><span class="nb">cmp</span><span class="o">=</span><span class="nb">cmp</span><span class="p">)</span>
<span class="go">3</span>

<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">leading_coefficient</span><span class="p">()</span>
<span class="go">-5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.leading_item">
<tt class="descname">leading_item</tt><big>(</big><em>cmp=None</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.leading_item" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pair <tt class="docutils literal"><span class="pre">(k,</span> <span class="pre">c)</span></tt> where</p>
<div class="math">
\[c \cdot (\mbox{the basis element indexed by } k)\]</div>
<p>is the leading term of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Here &#8216;leading term&#8217; means that the corresponding basis element is
maximal.  Note that this may not be the term which actually appears
first when <tt class="docutils literal"><span class="pre">self</span></tt> is printed.  If the default term ordering is not
what is desired, a comparison function, <tt class="docutils literal"><span class="pre">cmp(x,y)</span></tt>, can be
provided.  This should return a negative value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt>, <tt class="docutils literal"><span class="pre">0</span></tt>
if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></tt> and a positive value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">leading_item</span><span class="p">()</span>
<span class="go">(3, 4)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">y</span><span class="o">-</span><span class="n">x</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">leading_item</span><span class="p">(</span><span class="nb">cmp</span><span class="o">=</span><span class="nb">cmp</span><span class="p">)</span>
<span class="go">(1, 3)</span>

<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">leading_item</span><span class="p">()</span>
<span class="go">([3], -5)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.leading_monomial">
<tt class="descname">leading_monomial</tt><big>(</big><em>cmp=None</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.leading_monomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the leading monomial of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This is the monomial whose corresponding basis element is
maximal. Note that this may not be the term which actually appears
first when <tt class="docutils literal"><span class="pre">self</span></tt> is printed. If the default term ordering is not
what is desired, a comparison function, <tt class="docutils literal"><span class="pre">cmp(x,y)</span></tt>, can be provided.
This should return a negative value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt>, <tt class="docutils literal"><span class="pre">0</span></tt> if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></tt>
and a positive value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">leading_monomial</span><span class="p">()</span>
<span class="go">B[3]</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">y</span><span class="o">-</span><span class="n">x</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">leading_monomial</span><span class="p">(</span><span class="nb">cmp</span><span class="o">=</span><span class="nb">cmp</span><span class="p">)</span>
<span class="go">B[1]</span>

<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">leading_monomial</span><span class="p">()</span>
<span class="go">s[3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.leading_support">
<tt class="descname">leading_support</tt><big>(</big><em>cmp=None</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.leading_support" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximal element of the support of <tt class="docutils literal"><span class="pre">self</span></tt>. Note
that this may not be the term which actually appears first when
<tt class="docutils literal"><span class="pre">self</span></tt> is printed.</p>
<p>If the default ordering of the basis elements is not what is
desired, a comparison function, <tt class="docutils literal"><span class="pre">cmp(x,y)</span></tt>, can be provided.
This should return a negative value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt>, <tt class="docutils literal"><span class="pre">0</span></tt> if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></tt>
and a positive value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">leading_support</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">y</span><span class="o">-</span><span class="n">x</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">leading_support</span><span class="p">(</span><span class="nb">cmp</span><span class="o">=</span><span class="nb">cmp</span><span class="p">)</span>
<span class="go">1</span>

<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">leading_support</span><span class="p">()</span>
<span class="go">[3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.leading_term">
<tt class="descname">leading_term</tt><big>(</big><em>cmp=None</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.leading_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the leading term of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This is the term whose corresponding basis element is
maximal. Note that this may not be the term which actually appears
first when <tt class="docutils literal"><span class="pre">self</span></tt> is printed. If the default term ordering is not
what is desired, a comparison function, <tt class="docutils literal"><span class="pre">cmp(x,y)</span></tt>, can be provided.
This should return a negative value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt>, 0 if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></tt>
and a positive value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">leading_term</span><span class="p">()</span>
<span class="go">B[3]</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">y</span><span class="o">-</span><span class="n">x</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">leading_term</span><span class="p">(</span><span class="nb">cmp</span><span class="o">=</span><span class="nb">cmp</span><span class="p">)</span>
<span class="go">3*B[1]</span>

<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">leading_term</span><span class="p">()</span>
<span class="go">-5*s[3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.map_coefficients">
<tt class="descname">map_coefficients</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.map_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping a function on coefficients.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> &#8211; an endofunction on the coefficient ring of the
free module</li>
</ul>
<p>Return a new element of <tt class="docutils literal"><span class="pre">self.parent()</span></tt> obtained by applying the
function <tt class="docutils literal"><span class="pre">f</span></tt> to all of the coefficients of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;c&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">B</span><span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">map_coefficients</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span>
<span class="go">6*B[&#39;a&#39;] + 2*B[&#39;c&#39;]</span>
</pre></div>
</div>
<p>Killed coefficients are handled properly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">map_coefficients</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">map_coefficients</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">map_coefficients</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2*s[2, 1] + 4*s[3, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.map_item">
<tt class="descname">map_item</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.map_item" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping a function on items.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> &#8211; a function mapping pairs <tt class="docutils literal"><span class="pre">(index,</span> <span class="pre">coeff)</span></tt> to
other such pairs</li>
</ul>
<p>Return a new element of <tt class="docutils literal"><span class="pre">self.parent()</span></tt> obtained by
applying the function <span class="math">\(f\)</span> to all items <tt class="docutils literal"><span class="pre">(index,</span> <span class="pre">coeff)</span></tt> of
<tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*B[-1] + 2*B[0] + 3*B[1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">map_item</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="p">))</span>
<span class="go">6*B[-1] + 4*B[0] + 4*B[1]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">f</span></tt> needs not be injective:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">map_item</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="p">))</span>
<span class="go">14*B[1]</span>

<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">m</span><span class="p">,</span><span class="n">c</span><span class="p">:</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(),</span> <span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">map_item</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">2*s[2, 1] + 2*s[3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.map_support">
<tt class="descname">map_support</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.map_support" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping a function on the support.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> &#8211; an endofunction on the indices of the free module</li>
</ul>
<p>Return a new element of <tt class="docutils literal"><span class="pre">self.parent()</span></tt> obtained by
applying the function <tt class="docutils literal"><span class="pre">f</span></tt> to all of the objects indexing
the basis elements.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*B[-1] + 2*B[0] + 3*B[1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">map_support</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="o">-</span><span class="n">i</span><span class="p">)</span>
<span class="go">3*B[-1] + 2*B[0] + 2*B[1]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">f</span></tt> needs not be injective:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">map_support</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">7*B[1]</span>

<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">map_support</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>
<span class="go">s[2, 1] + 2*s[2, 2, 1]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>      <span class="c"># This actually failed at some point!!! See #8890</span>
<span class="go">0</span>

<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">map_support</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">/</span><span class="mi">0</span><span class="p">);</span> <span class="n">y</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="n">B</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.map_support_skip_none">
<tt class="descname">map_support_skip_none</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.map_support_skip_none" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping a function on the support.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> &#8211; an endofunction on the indices of the free module</li>
</ul>
<p>Returns a new element of <tt class="docutils literal"><span class="pre">self.parent()</span></tt> obtained by
applying the function <span class="math">\(f\)</span> to all of the objects indexing
the basis elements.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*B[-1] + 2*B[0] + 3*B[1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">map_support_skip_none</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="o">-</span><span class="n">i</span> <span class="k">if</span> <span class="n">i</span> <span class="k">else</span> <span class="bp">None</span><span class="p">)</span>
<span class="go">3*B[-1] + 2*B[1]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">f</span></tt> needs not be injective:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">map_support_skip_none</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="k">else</span> <span class="bp">None</span><span class="p">)</span>
<span class="go">5*B[1]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">map_support_skip_none</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="bp">None</span><span class="p">);</span> <span class="n">y</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="n">B</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.support_of_term">
<tt class="descname">support_of_term</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.support_of_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the support of <tt class="docutils literal"><span class="pre">self</span></tt>, where <tt class="docutils literal"><span class="pre">self</span></tt> is a monomial
(possibly with coefficient).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">support_of_term</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">term</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">support_of_term</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>An exception is raised if <tt class="docutils literal"><span class="pre">self</span></tt> has more than one term:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">support_of_term</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">B[2] + B[3] is not a single term</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.tensor">
<tt class="descname">tensor</tt><big>(</big><em>*elements</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tensor product of its arguments, as an element of
the tensor product of the parents of those elements.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">AlgebrasWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">algebra_generators</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">B[word: a] # B[word: b] # B[word: c]</span>
</pre></div>
</div>
<p>FIXME: is this a policy that we want to enforce on all parents?</p>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.trailing_coefficient">
<tt class="descname">trailing_coefficient</tt><big>(</big><em>cmp=None</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.trailing_coefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trailing coefficient of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This is the coefficient of the monomial whose corresponding basis element is
minimal. Note that this may not be the term which actually appears
last when <tt class="docutils literal"><span class="pre">self</span></tt> is printed. If the default term ordering is not
what is desired, a comparison function <tt class="docutils literal"><span class="pre">cmp(x,y)</span></tt>, can be provided.
This should return a negative value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt>, 0 if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></tt>
and a positive value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">trailing_coefficient</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">y</span><span class="o">-</span><span class="n">x</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">trailing_coefficient</span><span class="p">(</span><span class="nb">cmp</span><span class="o">=</span><span class="nb">cmp</span><span class="p">)</span>
<span class="go">1</span>

<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">trailing_coefficient</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.trailing_item">
<tt class="descname">trailing_item</tt><big>(</big><em>cmp=None</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.trailing_item" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pair <tt class="docutils literal"><span class="pre">(c,</span> <span class="pre">k)</span></tt> where <tt class="docutils literal"><span class="pre">c*self.parent().monomial(k)</span></tt>
is the trailing term of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This is the monomial whose corresponding basis element is
minimal. Note that this may not be the term which actually appears
last when <tt class="docutils literal"><span class="pre">self</span></tt> is printed.  If the default term ordering is not
what is desired, a comparison function <tt class="docutils literal"><span class="pre">cmp(x,y)</span></tt>, can be provided.
This should return a negative value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt>, 0 if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></tt>
and a positive value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">trailing_item</span><span class="p">()</span>
<span class="go">(1, 3)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">y</span><span class="o">-</span><span class="n">x</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">trailing_item</span><span class="p">(</span><span class="nb">cmp</span><span class="o">=</span><span class="nb">cmp</span><span class="p">)</span>
<span class="go">(3, 1)</span>

<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">trailing_item</span><span class="p">()</span>
<span class="go">([1], 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.trailing_monomial">
<tt class="descname">trailing_monomial</tt><big>(</big><em>cmp=None</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.trailing_monomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trailing monomial of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This is the monomial whose corresponding basis element is
minimal. Note that this may not be the term which actually appears
last when <tt class="docutils literal"><span class="pre">self</span></tt> is printed. If the default term ordering is not
what is desired, a comparison function <tt class="docutils literal"><span class="pre">cmp(x,y)</span></tt>, can be provided.
This should return a negative value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt>, 0 if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></tt>
and a positive value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">trailing_monomial</span><span class="p">()</span>
<span class="go">B[1]</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">y</span><span class="o">-</span><span class="n">x</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">trailing_monomial</span><span class="p">(</span><span class="nb">cmp</span><span class="o">=</span><span class="nb">cmp</span><span class="p">)</span>
<span class="go">B[3]</span>

<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">trailing_monomial</span><span class="p">()</span>
<span class="go">s[1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.trailing_support">
<tt class="descname">trailing_support</tt><big>(</big><em>cmp=None</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.trailing_support" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimal element of the support of <tt class="docutils literal"><span class="pre">self</span></tt>. Note
that this may not be the term which actually appears last when
<tt class="docutils literal"><span class="pre">self</span></tt> is printed.</p>
<p>If the default ordering of the basis elements is not what is
desired, a comparison function, <tt class="docutils literal"><span class="pre">cmp(x,y)</span></tt>, can be provided.
This should return a negative value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt>, <span class="math">\(0\)</span> if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></tt>
and a positive value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">trailing_support</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">y</span><span class="o">-</span><span class="n">x</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">trailing_support</span><span class="p">(</span><span class="nb">cmp</span><span class="o">=</span><span class="nb">cmp</span><span class="p">)</span>
<span class="go">3</span>

<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">trailing_support</span><span class="p">()</span>
<span class="go">[1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.trailing_term">
<tt class="descname">trailing_term</tt><big>(</big><em>cmp=None</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ElementMethods.trailing_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trailing term of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This is the term whose corresponding basis element is
minimal. Note that this may not be the term which actually appears
last when <tt class="docutils literal"><span class="pre">self</span></tt> is printed. If the default term ordering is not
what is desired, a comparison function <tt class="docutils literal"><span class="pre">cmp(x,y)</span></tt>, can be provided.
This should return a negative value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt>, 0 if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></tt>
and a positive value if <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">trailing_term</span><span class="p">()</span>
<span class="go">3*B[1]</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="n">y</span><span class="o">-</span><span class="n">x</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">trailing_term</span><span class="p">(</span><span class="nb">cmp</span><span class="o">=</span><span class="nb">cmp</span><span class="p">)</span>
<span class="go">B[3]</span>

<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">trailing_term</span><span class="p">()</span>
<span class="go">2*s[1]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.FiniteDimensional">
<tt class="descclassname">ModulesWithBasis.</tt><tt class="descname">FiniteDimensional</tt><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.FiniteDimensional" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="finite_dimensional_modules_with_basis.html#sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis" title="sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis"><tt class="xref py py-class docutils literal"><span class="pre">FiniteDimensionalModulesWithBasis</span></tt></a></p>
</dd></dl>

<dl class="attribute">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.Graded">
<tt class="descclassname">ModulesWithBasis.</tt><tt class="descname">Graded</tt><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.Graded" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="graded_modules_with_basis.html#sage.categories.graded_modules_with_basis.GradedModulesWithBasis" title="sage.categories.graded_modules_with_basis.GradedModulesWithBasis"><tt class="xref py py-class docutils literal"><span class="pre">GradedModulesWithBasis</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.Homsets">
<em class="property">class </em><tt class="descclassname">ModulesWithBasis.</tt><tt class="descname">Homsets</tt><big>(</big><em>category</em>, <em>*args</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.Homsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="homsets.html#sage.categories.homsets.HomsetsCategory" title="sage.categories.homsets.HomsetsCategory"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.homsets.HomsetsCategory</span></tt></a></p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.covariant_functorial_construction</span> <span class="kn">import</span> <span class="n">CovariantConstructionCategory</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">FooBars</span><span class="p">(</span><span class="n">CovariantConstructionCategory</span><span class="p">):</span>
<span class="gp">... </span>      <span class="n">_functor_category</span> <span class="o">=</span> <span class="s">&quot;FooBars&quot;</span>
<span class="gp">sage: </span><span class="n">Category</span><span class="o">.</span><span class="n">FooBars</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="n">FooBars</span><span class="o">.</span><span class="n">category_of</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">FooBars</span><span class="p">(</span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">ZZ</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">Category of foo bars of modules with basis over Integer Ring</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">base_category</span><span class="p">()</span>
<span class="go">Category of modules with basis over Integer Ring</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">\mathbf{FooBars}(\mathbf{ModulesWithBasis}_{\Bold{Z}})</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span><span class="p">;</span> <span class="n">__main__</span><span class="o">.</span><span class="n">FooBars</span> <span class="o">=</span> <span class="n">FooBars</span> <span class="c"># Fake FooBars being defined in a python module</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.Homsets.ParentMethods">
<em class="property">class </em><tt class="descname">ParentMethods</tt><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.Homsets.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.MorphismMethods">
<em class="property">class </em><tt class="descclassname">ModulesWithBasis.</tt><tt class="descname">MorphismMethods</tt><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.MorphismMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.MorphismMethods.on_basis">
<tt class="descname">on_basis</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.MorphismMethods.on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the action of this morphism on basis elements.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a function from the indices of the basis of the domain to
the codomain</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span>   <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span> <span class="n">Y</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;Y&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Hom</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>

<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Y</span><span class="o">.</span><span class="n">zero</span><span class="p">())</span><span class="o">.</span><span class="n">on_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>

<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">Y</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span><span class="n">on_basis</span> <span class="o">=</span> <span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">on_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">B[2] + 2*B[3]</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">==</span> <span class="n">f</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods">
<em class="property">class </em><tt class="descclassname">ModulesWithBasis.</tt><tt class="descname">ParentMethods</tt><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.basis">
<tt class="descname">basis</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the basis of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;c&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="go">Finite family {&#39;a&#39;: B[&#39;a&#39;], &#39;c&#39;: B[&#39;c&#39;], &#39;b&#39;: B[&#39;b&#39;]}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">QS3</span> <span class="o">=</span> <span class="n">SymmetricGroupAlgebra</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">QS3</span><span class="o">.</span><span class="n">basis</span><span class="p">())</span>
<span class="go">[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism">
<tt class="descname">module_morphism</tt><big>(</big><em>on_basis=None</em>, <em>diagonal=None</em>, <em>triangular=None</em>, <em>**keywords</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a morphism from <tt class="docutils literal"><span class="pre">self</span></tt> to <tt class="docutils literal"><span class="pre">codomain</span></tt> by
linearity from its restriction <tt class="docutils literal"><span class="pre">on_basis</span></tt> to the basis of
<tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Let <tt class="docutils literal"><span class="pre">self</span></tt> be the module <span class="math">\(X\)</span> with a basis indexed by <span class="math">\(I\)</span>.
This constructs a morphism <span class="math">\(f: X \to Y\)</span> by linearity from
a map <span class="math">\(I \to Y\)</span> which is to be its restriction to the
basis <span class="math">\((x_i)_{i \in I}\)</span> of <span class="math">\(X\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">codomain</span></tt> &#8211; the codomain <span class="math">\(Y\)</span> of <span class="math">\(f\)</span>: defaults to
<tt class="docutils literal"><span class="pre">f.codomain()</span></tt> if the latter is defined</li>
<li><tt class="docutils literal"><span class="pre">zero</span></tt> &#8211; the zero of the codomain; defaults to
<tt class="docutils literal"><span class="pre">codomain.zero()</span></tt>; can be used (with care) to define affine maps</li>
<li><tt class="docutils literal"><span class="pre">position</span></tt> &#8211; a non-negative integer; defaults to 0</li>
<li><tt class="docutils literal"><span class="pre">on_basis</span></tt> &#8211; a function <span class="math">\(f\)</span> which accepts elements of <span class="math">\(I\)</span>
(the indexing set of the basis of <span class="math">\(X\)</span>) as <tt class="docutils literal"><span class="pre">position</span></tt>-th argument
and returns elements of <span class="math">\(Y\)</span></li>
<li><tt class="docutils literal"><span class="pre">diagonal</span></tt> &#8211; a function <span class="math">\(d\)</span> from <span class="math">\(I\)</span> to <span class="math">\(R\)</span> (the base ring
of <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">codomain</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">triangular</span></tt> &#8211;  (default: <tt class="docutils literal"><span class="pre">None</span></tt>) <tt class="docutils literal"><span class="pre">&quot;upper&quot;</span></tt> or
<tt class="docutils literal"><span class="pre">&quot;lower&quot;</span></tt> or <tt class="docutils literal"><span class="pre">None</span></tt>:<ul>
<li><tt class="docutils literal"><span class="pre">&quot;upper&quot;</span></tt> - if the <tt class="xref py py-meth docutils literal"><span class="pre">leading_support()</span></tt> of the image
of the basis vector <span class="math">\(x_i\)</span> is <span class="math">\(i\)</span>, or</li>
<li><tt class="docutils literal"><span class="pre">&quot;lower&quot;</span></tt> - if the <tt class="xref py py-meth docutils literal"><span class="pre">trailing_support()</span></tt> of the image
of the basis vector <span class="math">\(x_i\)</span> is <span class="math">\(i\)</span></li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">category</span></tt> &#8211; a category; by default, this is
<tt class="docutils literal"><span class="pre">ModulesWithBasis(R)</span></tt> if <span class="math">\(Y\)</span> is in this category, and
otherwise this lets <span class="math">\(Hom(X,Y)\)</span> decide</li>
</ul>
<p>Exactly one of <tt class="docutils literal"><span class="pre">on_basis</span></tt> and <tt class="docutils literal"><span class="pre">diagonal</span></tt> options should
be specified.</p>
<p>With the <tt class="docutils literal"><span class="pre">on_basis</span></tt> option, this returns a function <span class="math">\(g\)</span>
obtained by extending <span class="math">\(f\)</span> by linearity on the <tt class="docutils literal"><span class="pre">position</span></tt>-th
positional argument. For example, for <tt class="docutils literal"><span class="pre">position</span> <span class="pre">==</span> <span class="pre">1</span></tt> and a
ternary function <span class="math">\(f\)</span>, one has:</p>
<div class="math">
\[g\left( a,\ \sum_i \lambda_i x_i,\ c \right)
= \sum_i \lambda_i f(a, i, c).\]</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span>   <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span> <span class="n">Y</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;Y&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">Y</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span>
<span class="go">Generic morphism:</span>
<span class="go">From: X</span>
<span class="go">To:   Y</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">category_for</span><span class="p">()</span>
<span class="go">Category of vector spaces with basis over Rational Field</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">();</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">B[1] + 2*B[2] + B[3] + 2*B[4]</span>
</pre></div>
</div>
<p>With the <tt class="docutils literal"><span class="pre">zero</span></tt> argument, one can define affine morphisms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">Y</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Y</span><span class="p">,</span> <span class="n">zero</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">11*B[1] + 2*B[2] + B[3] + 2*B[4]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">category_for</span><span class="p">()</span>
<span class="go">Category of sets</span>
</pre></div>
</div>
<p>One can construct morphisms with the base ring as codomain:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span> <span class="n">on_basis</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">ZZ</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">category_for</span><span class="p">()</span>
<span class="go">Category of commutative additive semigroups</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">category_for</span><span class="p">()</span> <span class="c"># todo: not implemented (ZZ is currently not in Modules(ZZ))</span>
<span class="go">Category of modules over Integer Ring</span>
</pre></div>
</div>
<p>Or more generaly any ring admitting a coercion map from the base ring:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">on_basis</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">RR</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
<span class="go">-1.00000000000000</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">category_for</span><span class="p">()</span>
<span class="go">Category of commutative additive semigroups</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">category_for</span><span class="p">()</span> <span class="c"># todo: not implemented (RR is currently not in Modules(ZZ))</span>
<span class="go">Category of modules over Integer Ring</span>

<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">on_basis</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Zmod</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
<span class="go">3</span>

<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">on_basis</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Zmod</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">codomain(=Ring of integers modulo 4) should be a module over the base ring of the domain(=Y)</span>
</pre></div>
</div>
<p>On can also define module morphisms between free modules
over different base rings; here we implement the natural
map from <span class="math">\(X = \RR^2\)</span> to <span class="math">\(Y = \CC\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">RR</span><span class="p">,[</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">CC</span><span class="p">,[</span><span class="s">&#39;z&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="s">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">on_basis</span><span class="p">(</span> <span class="n">a</span> <span class="p">):</span>
<span class="go">....:     if a == &#39;x&#39;:</span>
<span class="go">....:         return CC(1) * z</span>
<span class="go">....:     elif a == &#39;y&#39;:</span>
<span class="go">....:         return CC(I) * z</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span> <span class="n">on_basis</span><span class="o">=</span><span class="n">on_basis</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span> <span class="n">v</span>
<span class="go">3.00000000000000*B[&#39;x&#39;] + 2.00000000000000*B[&#39;y&#39;]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">(3.00000000000000+2.00000000000000*I)*B[&#39;z&#39;]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">category_for</span><span class="p">()</span>
<span class="go">Category of commutative additive semigroups</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">category_for</span><span class="p">()</span> <span class="c"># todo: not implemented (CC is currently not in Modules(RR)!)</span>
<span class="go">Category of vector spaces over Real Field with 53 bits of precision</span>

<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">CC</span><span class="p">[</span><span class="s">&#39;q&#39;</span><span class="p">],[</span><span class="s">&#39;z&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="s">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span> <span class="n">on_basis</span><span class="o">=</span><span class="n">on_basis</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">(3.00000000000000+2.00000000000000*I)*B[&#39;z&#39;]</span>
</pre></div>
</div>
<p>Of course, there should be a coercion between the
respective base rings of the domain and the codomain for
this to be meaningful:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,[</span><span class="s">&#39;z&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span> <span class="n">on_basis</span><span class="o">=</span><span class="n">on_basis</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">Y</span> <span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">codomain(=Free module generated by {&#39;z&#39;} over Rational Field) should be a module over the base ring of the domain(=Free module generated by {&#39;x&#39;, &#39;y&#39;} over Real Field with 53 bits of precision)</span>

<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">RR</span><span class="p">[</span><span class="s">&#39;q&#39;</span><span class="p">],[</span><span class="s">&#39;z&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span> <span class="n">on_basis</span><span class="o">=</span><span class="n">on_basis</span><span class="p">,</span> <span class="n">codomain</span><span class="o">=</span><span class="n">X</span> <span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">codomain(=Free module generated by {&#39;x&#39;, &#39;y&#39;} over Real Field with 53 bits of precision) should be a module over the base ring of the domain(=Free module generated by {&#39;z&#39;} over Univariate Polynomial Ring in q over Real Field with 53 bits of precision)</span>
</pre></div>
</div>
<p>With the <tt class="docutils literal"><span class="pre">diagonal</span></tt> argument, this returns the module
morphism <span class="math">\(g\)</span> such that:</p>
<blockquote>
<div><span class="math">\(g(x_i) = d(i) y_i\)</span></div></blockquote>
<p>This assumes that the respective bases <span class="math">\(x\)</span> and <span class="math">\(y\)</span> of <span class="math">\(X\)</span>
and <span class="math">\(Y\)</span> have the same index set <span class="math">\(I\)</span>.</p>
<p>With <tt class="docutils literal"><span class="pre">triangular</span> <span class="pre">=</span> <span class="pre">upper</span></tt>, the constructed module
morphism is assumed to be upper triangular; that is its
matrix in the distinguished basis of <span class="math">\(X\)</span> and <span class="math">\(Y\)</span> would be
upper triangular with invertible elements on its
diagonal. This is used to compute preimages and
inverting the morphism:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">200</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span> <span class="n">Y</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;Y&quot;</span><span class="p">);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">sum_of_monomials</span> <span class="o">*</span> <span class="n">divisors</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[1] + B[2]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
<span class="go">B[1] + B[2] + B[3] + B[6]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">30</span><span class="p">])</span>
<span class="go">B[1] + B[2] + B[3] + B[5] + B[6] + B[10] + B[15] + B[30]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">-B[1] + B[2]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
<span class="go">B[1] - B[2] - B[3] + B[6]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">30</span><span class="p">])</span>
<span class="go">-B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">phi</span><span class="o">^-</span><span class="mi">1</span><span class="p">)(</span><span class="n">y</span><span class="p">[</span><span class="mi">30</span><span class="p">])</span>
<span class="go">-B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]</span>
</pre></div>
</div>
<p>For details and further optional arguments, see
<a class="reference internal" href="#sage.categories.modules_with_basis.TriangularModuleMorphism" title="sage.categories.modules_with_basis.TriangularModuleMorphism"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.modules_with_basis.TriangularModuleMorphism</span></tt></a>.</p>
<p>Caveat: the returned element is in <tt class="docutils literal"><span class="pre">Hom(codomain,</span> <span class="pre">domain,</span>
<span class="pre">category</span></tt>). This is only correct for unary functions.</p>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">Should codomain be <tt class="docutils literal"><span class="pre">self</span></tt> by default in the
diagonal and triangular cases?</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.tensor">
<tt class="descname">tensor</tt><big>(</big><em>*parents</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tensor product of the parents.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">AlgebrasWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">example</span><span class="p">();</span> <span class="n">A</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>
<span class="go">A # A # A</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts">
<em class="property">class </em><tt class="descclassname">ModulesWithBasis.</tt><tt class="descname">TensorProducts</tt><big>(</big><em>category</em>, <em>*args</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="tensor.html#sage.categories.tensor.TensorProductsCategory" title="sage.categories.tensor.TensorProductsCategory"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.tensor.TensorProductsCategory</span></tt></a></p>
<p>The category of modules with basis constructed by tensor product of
modules with basis.</p>
<dl class="class">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts.ElementMethods">
<em class="property">class </em><tt class="descname">ElementMethods</tt><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts.ElementMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements operations on elements of tensor products of modules
with basis.</p>
<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts.ElementMethods.apply_multilinear_morphism">
<tt class="descname">apply_multilinear_morphism</tt><big>(</big><em>f</em>, <em>codomain=None</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts.ElementMethods.apply_multilinear_morphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of applying the morphism induced by <tt class="docutils literal"><span class="pre">f</span></tt>
to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> &#8211; a multilinear morphism from the component
modules of the parent tensor product to any module</li>
<li><tt class="docutils literal"><span class="pre">codomain</span></tt> &#8211; the codomain of <tt class="docutils literal"><span class="pre">f</span></tt> (optional)</li>
</ul>
<p>By the universal property of the tensor product, <tt class="docutils literal"><span class="pre">f</span></tt>
induces a linear morphism from <span class="math">\(self.parent()\)</span> to the
target module. Returns the result of applying that
morphism to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The codomain is used for optimizations purposes
only. If it&#8217;s not provided, it&#8217;s recovered by calling
<tt class="docutils literal"><span class="pre">f</span></tt> on the zero input.</p>
<p>EXAMPLES:</p>
<p>We start with simple (admittedly not so interesting)
examples, with two modules <span class="math">\(A\)</span> and <span class="math">\(B\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">prefix</span><span class="o">=</span><span class="s">&quot;A&quot;</span><span class="p">);</span> <span class="n">A</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">prefix</span><span class="o">=</span><span class="s">&quot;B&quot;</span><span class="p">);</span> <span class="n">B</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>and <span class="math">\(f\)</span> the bilinear morphism <span class="math">\((a,b) \mapsto b \otimes a\)</span>
from <span class="math">\(A \times B\)</span> to <span class="math">\(B \otimes A\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
<span class="go">....:     return tensor([b,a])</span>
</pre></div>
</div>
<p>Now, calling applying <span class="math">\(f\)</span> on <span class="math">\(a \otimes b\)</span> returns the same
as <span class="math">\(f(a,b)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span>
<span class="go">A[1] + 2*A[2]</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">B</span><span class="o">.</span><span class="n">monomial</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">b</span>
<span class="go">B[3] - 2*B[4]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="go">B[3] # A[1] + 2*B[3] # A[2] - 2*B[4] # A[1] - 4*B[4] # A[2]</span>
<span class="gp">sage: </span><span class="n">tensor</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">])</span><span class="o">.</span><span class="n">apply_multilinear_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">B[3] # A[1] + 2*B[3] # A[2] - 2*B[4] # A[1] - 4*B[4] # A[2]</span>
</pre></div>
</div>
<p><span class="math">\(f\)</span> may be a bilinear morphism to any module over the
base ring of <span class="math">\(A\)</span> and <span class="math">\(B\)</span>. Here the codomain is <span class="math">\(\ZZ\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
<span class="go">....:     return sum(a.coefficients(), 0) * sum(b.coefficients(), 0)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="go">-3</span>
<span class="gp">sage: </span><span class="n">tensor</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">])</span><span class="o">.</span><span class="n">apply_multilinear_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">-3</span>
</pre></div>
</div>
<p>Mind the <span class="math">\(0\)</span> in the sums above; otherwise <span class="math">\(f\)</span> would
not return <span class="math">\(0\)</span> in <span class="math">\(\ZZ\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
<span class="go">....:     return sum(a.coefficients()) * sum(b.coefficients())</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">zero</span><span class="p">(),</span> <span class="n">B</span><span class="o">.</span><span class="n">zero</span><span class="p">()))</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>Which would be wrong and break this method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">tensor</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">])</span><span class="o">.</span><span class="n">apply_multilinear_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">AttributeError</span>: <span class="n-Identifier">&#39;int&#39; object has no attribute &#39;parent&#39;</span>
</pre></div>
</div>
<p>Here we consider an example where the codomain is a
module with basis with a different base ring:</p>
<div class="highlight-python"><div class="highlight"><pre>   sage: C = CombinatorialFreeModule(QQ, [(1,3),(2,4)], prefix=&quot;C&quot;); C.rename(&quot;C&quot;)
   sage: def f(a,b):
   ....:     return C.sum_of_terms( [((1,3), QQ(a[1]*b[3])), ((2,4), QQ(a[2]*b[4]))] )
   sage: f(a,b)
   C[(1, 3)] - 4*C[(2, 4)]
   sage: tensor([a,b]).apply_multilinear_morphism(f)
   C[(1, 3)] - 4*C[(2, 4)]

We conclude with a real life application, where we
check that the antipode of the Hopf algebra of
Symmetric functions on the Schur basis satisfies its
defining formula::

   sage: Sym = SymmetricFunctions(QQ)
   sage: s = Sym.schur()
   sage: def f(a,b): return a*b.antipode()
   sage: x = 4*s.an_element(); x
   8*s[] + 8*s[1] + 12*s[2]
   sage: x.coproduct().apply_multilinear_morphism(f)
   8*s[]
   sage: x.coproduct().apply_multilinear_morphism(f) == x.counit()
   True
</pre></div>
</div>
<p>We recover the constant term of <span class="math">\(x\)</span>, as desired.</p>
<div class="admonition-todo admonition" id="index-3">
<p class="first admonition-title">Todo</p>
<p class="last">Extract a method to linearize a multilinear
morphism, and delegate the work there.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts.ParentMethods">
<em class="property">class </em><tt class="descclassname">ModulesWithBasis.TensorProducts.</tt><tt class="descname">ParentMethods</tt><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements operations on tensor products of modules with basis.</p>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts.extra_super_categories">
<tt class="descclassname">ModulesWithBasis.TensorProducts.</tt><tt class="descname">extra_super_categories</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts.extra_super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">TensorProducts</span><span class="p">()</span><span class="o">.</span><span class="n">extra_super_categories</span><span class="p">()</span>
<span class="go">[Category of vector spaces with basis over Rational Field]</span>
<span class="gp">sage: </span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">TensorProducts</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of tensor products of modules with basis over Rational Field,</span>
<span class="go"> Category of vector spaces with basis over Rational Field,</span>
<span class="go"> Category of tensor products of vector spaces over Rational Field]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.ModulesWithBasis.is_abelian">
<tt class="descclassname">ModulesWithBasis.</tt><tt class="descname">is_abelian</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.ModulesWithBasis.is_abelian" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether this category is abelian.</p>
<p>This is the case if and only if the base ring is a field.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">is_abelian</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">ModulesWithBasis</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">is_abelian</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.categories.modules_with_basis.PointwiseInverseFunction">
<em class="property">class </em><tt class="descclassname">sage.categories.modules_with_basis.</tt><tt class="descname">PointwiseInverseFunction</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.PointwiseInverseFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Basic Structures v6.6)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.sage_object.SageObject</span></tt></a></p>
<p>A class for pointwise inverse functions.</p>
<p>The pointwise inverse function of a function <span class="math">\(f\)</span> is the function
sending every <span class="math">\(x\)</span> to <span class="math">\(1 / f(x)\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.modules_with_basis</span> <span class="kn">import</span> <span class="n">PointwiseInverseFunction</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">PointwiseInverseFunction</span><span class="p">(</span><span class="n">factorial</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(1, 1, 1/2, 1/6)</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.categories.modules_with_basis.PointwiseInverseFunction.pointwise_inverse">
<tt class="descname">pointwise_inverse</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.PointwiseInverseFunction.pointwise_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.modules_with_basis</span> <span class="kn">import</span> <span class="n">PointwiseInverseFunction</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">PointwiseInverseFunction</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">pointwise_inverse</span><span class="p">()</span> <span class="ow">is</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.categories.modules_with_basis.TriangularModuleMorphism">
<em class="property">class </em><tt class="descclassname">sage.categories.modules_with_basis.</tt><tt class="descname">TriangularModuleMorphism</tt><big>(</big><em>on_basis</em>, <em>domain</em>, <em>triangular='upper'</em>, <em>unitriangular=False</em>, <em>codomain=None</em>, <em>category=None</em>, <em>cmp=None</em>, <em>inverse=None</em>, <em>inverse_on_support=None</em>, <em>invertible=None</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.TriangularModuleMorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.categories.modules_with_basis.ModuleMorphismByLinearity" title="sage.categories.modules_with_basis.ModuleMorphismByLinearity"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.modules_with_basis.ModuleMorphismByLinearity</span></tt></a></p>
<p>A class for triangular module morphisms; that is, module morphisms
from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span> whose representing matrix in the distinguished
bases of <span class="math">\(X\)</span> and <span class="math">\(Y\)</span> is upper triangular with invertible elements
on its diagonal.</p>
<p>See <a class="reference internal" href="#sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism" title="sage.categories.modules_with_basis.ModulesWithBasis.ParentMethods.module_morphism"><tt class="xref py py-meth docutils literal"><span class="pre">ModulesWithBasis.ParentMethods.module_morphism()</span></tt></a></p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">domain</span></tt> &#8211; a module <span class="math">\(X\)</span> with basis <span class="math">\(F\)</span></li>
<li><tt class="docutils literal"><span class="pre">codomain</span></tt> &#8211; a module <span class="math">\(Y\)</span> with basis <span class="math">\(G\)</span> (defaults to <span class="math">\(X\)</span>)</li>
<li><tt class="docutils literal"><span class="pre">on_basis</span></tt> &#8211; a function from the index set of the basis <span class="math">\(F\)</span>
to the module <span class="math">\(Y\)</span> which determines the morphism by linearity</li>
<li><tt class="docutils literal"><span class="pre">unitriangular</span></tt> &#8211; boolean (default: <tt class="docutils literal"><span class="pre">False</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">triangular</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">&quot;upper&quot;</span></tt>) <tt class="docutils literal"><span class="pre">&quot;upper&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;lower&quot;</span></tt>:<ul>
<li><tt class="docutils literal"><span class="pre">&quot;upper&quot;</span></tt> - if the <tt class="xref py py-meth docutils literal"><span class="pre">leading_support()</span></tt> of the image of
<span class="math">\(F(i)\)</span> is <span class="math">\(i\)</span>, or</li>
<li><tt class="docutils literal"><span class="pre">&quot;lower&quot;</span></tt> - if the <tt class="xref py py-meth docutils literal"><span class="pre">trailing_support()</span></tt> of the image of
<span class="math">\(F(i)\)</span> is <span class="math">\(i\)</span></li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">cmp</span></tt> &#8211; an optional comparison function on the index set <span class="math">\(J\)</span> of
the basis <span class="math">\(G\)</span> of the codomain.</li>
<li><tt class="docutils literal"><span class="pre">invertible</span></tt> &#8211; boolean or <tt class="docutils literal"><span class="pre">None</span></tt> (default: <tt class="docutils literal"><span class="pre">None</span></tt>); should
be set to <tt class="docutils literal"><span class="pre">True</span></tt> if Sage is to compute an inverse for <tt class="docutils literal"><span class="pre">self</span></tt>.
Automatically set to <tt class="docutils literal"><span class="pre">True</span></tt> if the domain and codomain share the
same indexing set and to <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</li>
<li><tt class="docutils literal"><span class="pre">inverse_on_support</span></tt> - compute the inverse on the support if the
codomain and domain have different index sets. See assumptions
below.</li>
</ul>
<p>Assumptions:</p>
<ul class="simple">
<li><span class="math">\(X\)</span> and <span class="math">\(Y\)</span> have the same base ring <span class="math">\(R\)</span>.</li>
<li>Let <span class="math">\(I\)</span> and <span class="math">\(J\)</span> be the respective index sets of the bases <span class="math">\(F\)</span> and
<span class="math">\(G\)</span>. Either <span class="math">\(I = J\)</span>, or <tt class="docutils literal"><span class="pre">inverse_on_support</span></tt> is a
function <span class="math">\(r : J \to I\)</span> with the following property: for any <span class="math">\(j \in J\)</span>,
<span class="math">\(r(j)\)</span> should return an <span class="math">\(i \in I\)</span> such that the leading term (or
trailing term, if <tt class="docutils literal"><span class="pre">triangular</span></tt> is set to <tt class="docutils literal"><span class="pre">&quot;lower&quot;</span></tt>) of
<tt class="docutils literal"><span class="pre">on_basis(i)</span></tt> (with respect to the comparison <tt class="docutils literal"><span class="pre">cmp</span></tt>, if the
latter is set, or just the default comparison otherwise) is <span class="math">\(j\)</span> if
there exists such an <span class="math">\(i\)</span>, or <tt class="docutils literal"><span class="pre">None</span></tt> if not.</li>
</ul>
<p>OUTPUT:</p>
<p>The triangular module morphism from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span> which maps <span class="math">\(F(i)\)</span>
to <tt class="docutils literal"><span class="pre">on_basis(i)</span></tt> and is extended by linearity.</p>
<p>EXAMPLES:</p>
<p>We construct and invert an upper unitriangular module morphism between
two free <span class="math">\(\QQ\)</span>-modules:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">200</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span> <span class="n">Y</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;Y&quot;</span><span class="p">);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">sum_of_monomials</span> <span class="o">*</span> <span class="n">divisors</span>   <span class="c"># This * is map composition.</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;upper&quot;</span><span class="p">,</span> <span class="n">unitriangular</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[1] + B[2]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
<span class="go">B[1] + B[2] + B[3] + B[6]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">30</span><span class="p">])</span>
<span class="go">B[1] + B[2] + B[3] + B[5] + B[6] + B[10] + B[15] + B[30]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">-B[1] + B[2]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
<span class="go">B[1] - B[2] - B[3] + B[6]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">30</span><span class="p">])</span>
<span class="go">-B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">phi</span><span class="o">^-</span><span class="mi">1</span><span class="p">)(</span><span class="n">y</span><span class="p">[</span><span class="mi">30</span><span class="p">])</span>
<span class="go">-B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]</span>
</pre></div>
</div>
<p>A lower triangular (but not unitriangular) morphism:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">ut</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">ut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">X</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">2*B[2] + 3*B[3]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">1/2*B[2] - 1/2*B[3]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">B[2]</span>
</pre></div>
</div>
<p>Using the <tt class="docutils literal"><span class="pre">cmp</span></tt> keyword, we can use triangularity even if
the map becomes triangular only after a permutation of the basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">vt</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">vt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">X</span><span class="p">,</span>
<span class="go">....:                         cmp=lambda a, b: cmp(perm[a], perm[b]))</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[1] + B[2], B[2], B[2] + B[3]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[1] - B[2], B[2], -B[2] + B[3]]</span>
</pre></div>
</div>
<p>The same works in the lower-triangular case:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">def</span> <span class="nf">wt</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">X</span><span class="p">,</span>
<span class="go">....:                         cmp=lambda a, b: cmp(perm[a], perm[b]))</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[1], B[1] + B[2] + B[3], B[3]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[1], -B[1] + B[2] - B[3], B[3]]</span>
</pre></div>
</div>
<p>An injective but not surjective morphism cannot be inverted,
but the <tt class="docutils literal"><span class="pre">inverse_on_support</span></tt> keyword allows Sage to find a
partial inverse:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">uut</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">uut</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Y</span><span class="p">,</span>
<span class="go">....:        triangular=True, unitriangular=True,</span>
<span class="go">....:        inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[3] + B[4] + B[5]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">B[2] - B[3]</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">inverse_on_support</span></tt> keyword can also be used if the
bases of the domain and the codomain are identical but one of
them has to be permuted in order to render the morphism
triangular. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">zt</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return (x[3] if i == 1 else x[1] if i == 2</span>
<span class="go">....:             else x[1] + x[2])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return (2 if i == 1 else 3 if i == 2 else 1)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">zt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">X</span><span class="p">,</span>
<span class="go">....:                         inverse_on_support=perm)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[3], B[1], B[1] + B[2]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[2], -B[2] + B[3], B[1]]</span>
</pre></div>
</div>
<p>The same works if the permutation induces lower triangularity:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">zt</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return (x[3] if i == 1 else x[2] if i == 2</span>
<span class="go">....:             else x[1] + x[2])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return 4 - i</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">zt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;lower&quot;</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">X</span><span class="p">,</span>
<span class="go">....:                         inverse_on_support=perm)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[B[3], B[2], B[1] + B[2]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[-B[2] + B[3], B[2], B[1]]</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">inverse_on_basis</span></tt> and <tt class="docutils literal"><span class="pre">cmp</span></tt> keywords can be combined:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">zt</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return (2*x[2] + 3*x[3] if i == 1</span>
<span class="go">....:             else x[1] + x[2] + x[3] if i == 2</span>
<span class="go">....:             else 4*x[2])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="go">....:     return (2 if i == 1 else 3 if i == 2 else 1)</span>
<span class="gp">sage: </span><span class="n">perverse_cmp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">cmp</span><span class="p">((</span><span class="n">a</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">zt</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="s">&quot;upper&quot;</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">X</span><span class="p">,</span>
<span class="go">....:                         inverse_on_support=perm, cmp=perverse_cmp)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[2*B[2] + 3*B[3], B[1] + B[2] + B[3], 4*B[2]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">[-1/3*B[1] + B[2] - 1/12*B[3], 1/4*B[3], 1/3*B[1] - 1/6*B[3]]</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.categories.modules_with_basis.TriangularModuleMorphism.co_kernel_projection">
<tt class="descname">co_kernel_projection</tt><big>(</big><em>category=None</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.TriangularModuleMorphism.co_kernel_projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a projection on the co-kernel of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">category</span></tt> &#8211; the category of the result</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">uut</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span> <span class="c"># uni-upper</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">uut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Y</span><span class="p">,</span>
<span class="go">....:      inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="n">phipro</span> <span class="o">=</span> <span class="n">phi</span><span class="o">.</span><span class="n">co_kernel_projection</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phipro</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[1]</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">phipro</span><span class="p">(</span><span class="n">phi</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">phipro</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">B[1]</span>
<span class="gp">sage: </span><span class="n">phipro</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="go">-B[5]</span>
<span class="gp">sage: </span><span class="n">phipro</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
<span class="go">B[5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.TriangularModuleMorphism.co_reduced">
<tt class="descname">co_reduced</tt><big>(</big><em>y</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.TriangularModuleMorphism.co_reduced" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce element <span class="math">\(y\)</span> of codomain of <tt class="docutils literal"><span class="pre">self</span></tt> w.r.t. the image of
<tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Suppose that <tt class="docutils literal"><span class="pre">self</span></tt> is a morphism from <span class="math">\(X\)</span> to <span class="math">\(Y\)</span>. Then for any
<span class="math">\(y \in Y\)</span>, the call <tt class="docutils literal"><span class="pre">self.co_reduced(y)</span></tt> returns a normal form for
<span class="math">\(y\)</span> in the quotient <span class="math">\(Y / I\)</span> where <span class="math">\(I\)</span> is the image of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">uut</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>  <span class="p">)</span> <span class="c"># uni-upper</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">uut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">co_reduced</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.TriangularModuleMorphism.preimage">
<tt class="descname">preimage</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.TriangularModuleMorphism.preimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the preimage of <span class="math">\(f\)</span> under <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">uut</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>  <span class="p">)</span> <span class="c"># uni-upper</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">uut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[1] - B[3]</span>

<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">uut</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>  <span class="p">)</span> <span class="c"># uni-upper</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">uut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">B[1] - B[3]</span>

<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">uut</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span> <span class="c"># uni-upper</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">uut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Y</span><span class="p">,</span>
<span class="go">....:         inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">B[1] - B[3]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">el</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">phi</span><span class="p">(</span><span class="n">el</span><span class="p">))</span> <span class="o">==</span> <span class="n">el</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">uut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Y</span><span class="p">,</span>
<span class="go">....:         inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="o">.</span><span class="n">preimage</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">B[1] is not in the image</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.modules_with_basis.TriangularModuleMorphism.section">
<tt class="descname">section</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.TriangularModuleMorphism.section" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the section (partial inverse) of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Return a partial triangular morphism which is a section of
<tt class="docutils literal"><span class="pre">self</span></tt>. The section morphism raise a <tt class="docutils literal"><span class="pre">ValueError</span></tt> if asked to
apply on an element which is not in the image of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">CombinatorialFreeModule</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">uut</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span>  <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>  <span class="p">)</span> <span class="c"># uni-upper</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">uut</span><span class="p">,</span> <span class="n">triangular</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Y</span><span class="p">,</span>
<span class="go">....:      inverse_on_support=lambda i: i-1 if i in [2,3,4] else None)</span>
<span class="gp">sage: </span><span class="o">~</span><span class="n">phi</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">Non invertible morphism</span>
<span class="gp">sage: </span><span class="n">phiinv</span> <span class="o">=</span> <span class="n">phi</span><span class="o">.</span><span class="n">section</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">map</span><span class="p">(</span><span class="n">phiinv</span><span class="o">*</span><span class="n">phi</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="p">())</span> <span class="o">==</span> <span class="n">X</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">phiinv</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">B[1] is not in the image</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.categories.modules_with_basis.pointwise_inverse_function">
<tt class="descclassname">sage.categories.modules_with_basis.</tt><tt class="descname">pointwise_inverse_function</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.categories.modules_with_basis.pointwise_inverse_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the function <span class="math">\(x \mapsto 1 / f(x)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> &#8211; a function</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.modules_with_basis</span> <span class="kn">import</span> <span class="n">pointwise_inverse_function</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span>
<span class="go">....:</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">pointwise_inverse_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(1, 1/2, 1/3)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#sage.categories.modules_with_basis.pointwise_inverse_function" title="sage.categories.modules_with_basis.pointwise_inverse_function"><tt class="xref py py-func docutils literal"><span class="pre">pointwise_inverse_function()</span></tt></a> is an involution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="ow">is</span> <span class="n">pointwise_inverse_function</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-4">
<p class="first admonition-title">Todo</p>
<p class="last">This has nothing to do here!!! Should there be a library for
pointwise operations on functions somewhere in Sage?</p>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="modules.html"
                                  title="previous chapter">Modules</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="monoid_algebras.html"
                                  title="next chapter">Monoid algebras</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/categories/modules_with_basis.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="monoid_algebras.html" title="Monoid algebras"
             >next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="Modules"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Category Theory</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2015, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>