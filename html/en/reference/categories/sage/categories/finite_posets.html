<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Finite posets &mdash; Sage Reference Manual v7.1: Category Framework</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v7.1: Category Framework" href="../../index.html" />
    <link rel="next" title="Finite semigroups" href="finite_semigroups.html" />
    <link rel="prev" title="Finite Permutation Groups" href="finite_permutation_groups.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="finite_semigroups.html" title="Finite semigroups"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="finite_permutation_groups.html" title="Finite Permutation Groups"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Category Framework</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="finite-posets">
<span id="sage-categories-finite-posets"></span><h1>Finite posets<a class="headerlink" href="#finite-posets" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.categories.finite_posets"></span><p>Here is some terminology used in this file:</p>
<ul class="simple">
<li>An <em>order filter</em> (or <em>upper set</em>) of a poset <span class="math">\(P\)</span> is a subset <span class="math">\(S\)</span> of <span class="math">\(P\)</span>
such that if <span class="math">\(x \leq y\)</span> and <span class="math">\(x\in S\)</span> then <span class="math">\(y\in S\)</span>.</li>
<li>An <em>order ideal</em> (or <em>lower set</em>) of a poset <span class="math">\(P\)</span> is a subset <span class="math">\(S\)</span> of <span class="math">\(P\)</span>
such that if <span class="math">\(x \leq y\)</span> and <span class="math">\(y\in S\)</span> then <span class="math">\(x\in S\)</span>.</li>
</ul>
<dl class="class">
<dt id="sage.categories.finite_posets.FinitePosets">
<em class="property">class </em><tt class="descclassname">sage.categories.finite_posets.</tt><tt class="descname">FinitePosets</tt><big>(</big><em>base_category</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="category_with_axiom.html#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><tt class="xref py py-class docutils literal"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></tt></a></p>
<p>The category of finite posets i.e. finite sets with a partial
order structure.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FinitePosets</span><span class="p">()</span>
<span class="go">Category of finite posets</span>
<span class="gp">sage: </span><span class="n">FinitePosets</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of posets, Category of finite sets]</span>
<span class="gp">sage: </span><span class="n">FinitePosets</span><span class="p">()</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">NotImplemented</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="posets.html#sage.categories.posets.Posets" title="sage.categories.posets.Posets"><tt class="xref py py-class docutils literal"><span class="pre">Posets</span></tt></a>, <a class="reference external" href="../../../combinat/sage/combinat/posets/posets.html#sage.combinat.posets.posets.Poset" title="(in Sage Reference Manual: Combinatorics v7.1)"><tt class="xref py py-func docutils literal"><span class="pre">Poset()</span></tt></a></p>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">FinitePosets</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="ow">is</span> <span class="n">Posets</span><span class="p">()</span><span class="o">.</span><span class="n">Finite</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">TestSuite</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods">
<em class="property">class </em><tt class="descname">ParentMethods</tt><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.antichains">
<tt class="descname">antichains</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.antichains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all antichains of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">antichains</span><span class="p">();</span> <span class="n">A</span>
<span class="go">Set of antichains of Finite lattice containing 5 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[[], [0], [1], [1, 2], [1, 3], [2], [3], [4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling">
<tt class="descname">birational_free_labelling</tt><big>(</big><em>linear_extension=None</em>, <em>prefix='x'</em>, <em>base_field=None</em>, <em>reduced=False</em>, <em>addvars=None</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the birational free labelling of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Let us hold back defining this, and introduce birational
toggles and birational rowmotion first. These notions have
been introduced in <a class="reference internal" href="#ep13" id="id1">[EP13]</a> as generalizations of the notions
of toggles (<tt class="xref py py-meth docutils literal"><span class="pre">order_ideal_toggle()</span></tt>) and <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><tt class="xref py py-meth docutils literal"><span class="pre">rowmotion</span></tt></a> on order ideals of a finite poset. They
have been studied further in <a class="reference internal" href="#gr13" id="id2">[GR13]</a>.</p>
<p>Let <span class="math">\(\mathbf{K}\)</span> be a field, and <span class="math">\(P\)</span> be a finite poset. Let
<span class="math">\(\widehat{P}\)</span> denote the poset obtained from <span class="math">\(P\)</span> by adding a
new element <span class="math">\(1\)</span> which is greater than all existing elements
of <span class="math">\(P\)</span>, and a new element <span class="math">\(0\)</span> which is smaller than all
existing elements of <span class="math">\(P\)</span> and <span class="math">\(1\)</span>. Now, a <span class="math">\(\mathbf{K}\)</span>-<em>labelling
of</em> <span class="math">\(P\)</span> will mean any function from <span class="math">\(\widehat{P}\)</span> to <span class="math">\(\mathbf{K}\)</span>.
The image of an element <span class="math">\(v\)</span> of <span class="math">\(\widehat{P}\)</span> under this labelling
will be called the <em>label</em> of this labelling at <span class="math">\(v\)</span>. The set
of all <span class="math">\(\mathbf{K}\)</span>-labellings of <span class="math">\(P\)</span> is clearly
<span class="math">\(\mathbf{K}^{\widehat{P}}\)</span>.</p>
<p>For any <span class="math">\(v \in P\)</span>, we now define a rational map
<span class="math">\(T_v : \mathbf{K}^{\widehat{P}} \dashrightarrow
\mathbf{K}^{\widehat{P}}\)</span> as follows: For every <span class="math">\(f \in
\mathbf{K}^{\widehat{P}}\)</span>, the image <span class="math">\(T_v f\)</span> should send every
element <span class="math">\(u \in \widehat{P}\)</span> distinct from <span class="math">\(v\)</span> to <span class="math">\(f(u)\)</span> (so the
labels at all <span class="math">\(u \neq v\)</span> don&#8217;t change), while <span class="math">\(v\)</span> is sent to</p>
<div class="math">
\[\frac{1}{f(v)} \cdot
\frac{\sum_{u \lessdot v} f(u)}
{\sum_{u \gtrdot v} \frac{1}{f(u)}}\]</div>
<p>(both sums are over all <span class="math">\(u \in \widehat{P}\)</span> satisfying the
respectively given conditions). Here, <span class="math">\(\lessdot\)</span> and <span class="math">\(\gtrdot\)</span>
mean (respectively) &#8220;covered by&#8221; and &#8220;covers&#8221;, interpreted with
respect to the poset <span class="math">\(\widehat{P}\)</span>. This rational map <span class="math">\(T_v\)</span>
is an involution and is called the <em>(birational)</em> <span class="math">\(v\)</span>-<em>toggle</em>; see
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle"><tt class="xref py py-meth docutils literal"><span class="pre">birational_toggle()</span></tt></a> for its implementation.</p>
<p>Now, <em>birational rowmotion</em> is defined as the composition
<span class="math">\(T_{v_1} \circ T_{v_2} \circ \cdots \circ T_{v_n}\)</span>, where
<span class="math">\((v_1, v_2, \ldots, v_n)\)</span> is a linear extension of <span class="math">\(P\)</span>
(written as a linear ordering of the elements of <span class="math">\(P\)</span>). This
is a rational map
<span class="math">\(\mathbf{K}^{\widehat{P}} \dashrightarrow \mathbf{K}^{\widehat{P}}\)</span>
which does not depend on the choice of the linear extension;
it is denoted by <span class="math">\(R\)</span>. See <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion"><tt class="xref py py-meth docutils literal"><span class="pre">birational_rowmotion()</span></tt></a> for
its implementation.</p>
<p>The definitions of birational toggles and birational
rowmotion extend to the case of <span class="math">\(\mathbf{K}\)</span> being any semifield
rather than necessarily a field (although it becomes less
clear what constitutes a rational map in this generality).
The most useful case is that of the <a class="reference external" href="../../../semirings/sage/rings/semirings/tropical_semiring.html#sage.rings.semirings.tropical_semiring.TropicalSemiring" title="(in Sage Reference Manual: Standard Semirings v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">tropical</span> <span class="pre">semiring</span></tt></a>,
in which case birational rowmotion relates to classical
constructions such as promotion of rectangular semistandard
Young tableaux (page 5 of <a class="reference internal" href="#ep13b" id="id3">[EP13b]</a> and future work, via the
related notion of birational <em>promotion</em>) and rowmotion on
order ideals of the poset (<a class="reference internal" href="#ep13" id="id4">[EP13]</a>).</p>
<p>The <em>birational free labelling</em> is a special labelling
defined for every finite poset <span class="math">\(P\)</span> and every linear extension
<span class="math">\((v_1, v_2, \ldots, v_n)\)</span> of <span class="math">\(P\)</span>. It is given by sending
every element <span class="math">\(v_i\)</span> in <span class="math">\(P\)</span> to <span class="math">\(x_i\)</span>, sending the element <span class="math">\(0\)</span>
of <span class="math">\(\widehat{P}\)</span> to <span class="math">\(a\)</span>, and sending the element <span class="math">\(1\)</span> of
<span class="math">\(\widehat{P}\)</span> to <span class="math">\(b\)</span>, where the ground field <span class="math">\(\mathbf{K}\)</span> is the
field of rational functions in <span class="math">\(n+2\)</span> indeterminates
<span class="math">\(a, x_1, x_2, \ldots, x_n, b\)</span> over <span class="math">\(\mathbb Q\)</span>.</p>
<p>In Sage, a labelling <span class="math">\(f\)</span> of a poset <span class="math">\(P\)</span> is encoded as a
<span class="math">\(4\)</span>-tuple <span class="math">\((\mathbf{K}, d, u, v)\)</span>, where <span class="math">\(\mathbf{K}\)</span> is the
ground field of the labelling (i. e., its target), <span class="math">\(d\)</span> is the
dictionary containing the values of <span class="math">\(f\)</span> at the elements of
<span class="math">\(P\)</span> (the keys being the respective elements of <span class="math">\(P\)</span>), <span class="math">\(u\)</span>
is the label of <span class="math">\(f\)</span> at <span class="math">\(0\)</span>, and <span class="math">\(v\)</span> is the label of <span class="math">\(f\)</span> at
<span class="math">\(1\)</span>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The dictionary <span class="math">\(d\)</span> is labelled by the elements of <span class="math">\(P\)</span>.
If <span class="math">\(P\)</span> is a poset with <tt class="docutils literal"><span class="pre">facade</span></tt> option set to
<tt class="docutils literal"><span class="pre">False</span></tt>, these might not be what they seem to be!
(For instance, if
<tt class="docutils literal"><span class="pre">P</span> <span class="pre">==</span> <span class="pre">Poset({1:</span> <span class="pre">[2,</span> <span class="pre">3]},</span> <span class="pre">facade=False)</span></tt>, then the
value of <span class="math">\(d\)</span> at <span class="math">\(1\)</span> has to be accessed by <tt class="docutils literal"><span class="pre">d[P(1)]</span></tt>, not
by <tt class="docutils literal"><span class="pre">d[1]</span></tt>.)</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Dictionaries are mutable. They do compare correctly,
but are not hashable and need to be cloned to avoid
spooky action at a distance. Be careful!</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">linear_extension</span></tt> &#8211; (default: the default linear
extension of <tt class="docutils literal"><span class="pre">self</span></tt>) a linear extension of <tt class="docutils literal"><span class="pre">self</span></tt>
(as a linear extension or as a list), or more generally
a list of all elements of all elements of <tt class="docutils literal"><span class="pre">self</span></tt> each
occurring exactly once</li>
<li><tt class="docutils literal"><span class="pre">prefix</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">'x'</span></tt>) the prefix to name
the indeterminates corresponding to the elements of
<tt class="docutils literal"><span class="pre">self</span></tt> in the labelling (so, setting it to
<tt class="docutils literal"><span class="pre">'frog'</span></tt> will result in these indeterminates being
called <tt class="docutils literal"><span class="pre">frog1,</span> <span class="pre">frog2,</span> <span class="pre">...,</span> <span class="pre">frogn</span></tt> rather than
<tt class="docutils literal"><span class="pre">x1,</span> <span class="pre">x2,</span> <span class="pre">...,</span> <span class="pre">xn</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">base_field</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">QQ</span></tt>) the base field to
be used instead of <span class="math">\(\QQ\)</span> to define the rational
function field over; this is not going to be the base
field of the labelling, because the latter will have
indeterminates adjoined!</li>
<li><tt class="docutils literal"><span class="pre">reduced</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) if set to
<tt class="docutils literal"><span class="pre">True</span></tt>, the result will be the <em>reduced</em> birational
free labelling, which differs from the regular one by
having <span class="math">\(0\)</span> and <span class="math">\(1\)</span> both sent to <span class="math">\(1\)</span> instead of <span class="math">\(a\)</span> and
<span class="math">\(b\)</span> (the indeterminates <span class="math">\(a\)</span> and <span class="math">\(b\)</span> then also won&#8217;t
appear in the ground field)</li>
<li><tt class="docutils literal"><span class="pre">addvars</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">''</span></tt>) a string containing
names of extra variables to be adjoined to the ground
field (these don&#8217;t have an effect on the labels)</li>
</ul>
<p>OUTPUT:</p>
<p>The birational free labelling of the poset <tt class="docutils literal"><span class="pre">self</span></tt> and the
linear extension <tt class="docutils literal"><span class="pre">linear_extension</span></tt>. Or, if <tt class="docutils literal"><span class="pre">reduced</span></tt>
is set to <tt class="docutils literal"><span class="pre">True</span></tt>, the reduced birational free labelling.</p>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="ep13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[EP13]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> David Einstein, James Propp.
<em>Combinatorial, piecewise-linear, and birational homomesy
for products of two chains</em>.
<a class="reference external" href="http://arxiv.org/abs/1310.5294v1">Arxiv 1310.5294v1</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ep13b" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[EP13b]</a></td><td>David Einstein, James Propp.
<em>Piecewise-linear and birational toggling</em>.
Extended abstract for FPSAC 2014.
<a class="reference external" href="http://faculty.uml.edu/jpropp/fpsac14.pdf">http://faculty.uml.edu/jpropp/fpsac14.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="gr13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[GR13]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> Darij Grinberg, Tom Roby.
<em>Iterative properties of birational rowmotion I</em>.
<a class="reference external" href="http://web.mit.edu/~darij/www/algebra/skeletal.pdf">http://web.mit.edu/~darij/www/algebra/skeletal.pdf</a></td></tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<p>We construct the birational free labelling on a simple
poset:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">();</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x2), (3, x3)]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x3), (3, x2)]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">reduced</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in x1, x2, x3, spam, eggs over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x3), (3, x2)]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;wut&quot;</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in wut1, wut2, wut3, spam, eggs over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, wut1), (2, wut3), (3, wut2)]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">reduced</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b, spam, eggs over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x3), (3, x2)]</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="go">x3</span>
</pre></div>
</div>
<p>Illustrating the warning about facade:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">reduced</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b, spam, eggs over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">KeyError</span>: <span class="n">2</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">x3</span>
</pre></div>
</div>
<p>Another poset:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">SSTPoset</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">lext</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">lext</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;ohai&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, x5, x6, x7, x8, b, ohai over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[([[1, 1], [2]], x1), ([[1, 1], [3]], x2), ([[1, 2], [2]], x3), ([[1, 2], [3]], x4),</span>
<span class="go"> ([[1, 3], [2]], x5), ([[1, 3], [3]], x6), ([[2, 2], [3]], x7), ([[2, 3], [3]], x8)]</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion"><tt class="xref py py-meth docutils literal"><span class="pre">birational_rowmotion()</span></tt></a>, <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle"><tt class="xref py py-meth docutils literal"><span class="pre">birational_toggle()</span></tt></a> and
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles"><tt class="xref py py-meth docutils literal"><span class="pre">birational_toggles()</span></tt></a> for more substantial examples of what
one can do with the birational free labelling.</p>
<p>TESTS:</p>
<p>The <tt class="docutils literal"><span class="pre">linear_extension</span></tt> keyword does not have to be given an
actual linear extension:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">P</span>
<span class="go">Finite lattice containing 6 elements</span>
<span class="gp">sage: </span><span class="n">lex</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">lex</span><span class="p">,</span>
<span class="go">....:                                 prefix=&quot;u&quot;, reduced=True)</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in u1, u2, u3, u4, u5, u6 over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[((0, 0), u2),</span>
<span class="go"> ((0, 1), u4),</span>
<span class="go"> ((0, 2), u6),</span>
<span class="go"> ((1, 0), u1),</span>
<span class="go"> ((1, 1), u3),</span>
<span class="go"> ((1, 2), u5)]</span>
</pre></div>
</div>
<p>For comparison, the standard linear extension:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in u1, u2, u3, u4, u5, u6 over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[((0, 0), u1),</span>
<span class="go"> ((0, 1), u2),</span>
<span class="go"> ((0, 2), u3),</span>
<span class="go"> ((1, 0), u4),</span>
<span class="go"> ((1, 1), u5),</span>
<span class="go"> ((1, 2), u6)]</span>
</pre></div>
</div>
<p>If you want your linear extension to be tested for being a
linear extension, just call the <tt class="docutils literal"><span class="pre">linear_extension</span></tt> method
on the poset:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">lex</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">P</span><span class="o">.</span><span class="n">linear_extension</span><span class="p">(</span><span class="n">lex</span><span class="p">),</span>
<span class="go">....:                                 prefix=&quot;u&quot;, reduced=True)</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in u1, u2, u3, u4, u5, u6 over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[((0, 0), u1),</span>
<span class="go"> ((0, 1), u2),</span>
<span class="go"> ((0, 2), u5),</span>
<span class="go"> ((1, 0), u3),</span>
<span class="go"> ((1, 1), u4),</span>
<span class="go"> ((1, 2), u6)]</span>
</pre></div>
</div>
<p>Nonstandard base field:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">lex</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">lex</span><span class="p">,</span>
<span class="go">....:                                 prefix=&quot;aaa&quot;,</span>
<span class="go">....:                                 base_field=Zmod(13))</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, aaa1, aaa2, aaa3, aaa4, b over Ring of integers modulo 13,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span>
<span class="go">aaa3</span>
</pre></div>
</div>
<p>The empty poset:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">)</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, b, spam, eggs over Rational Field,</span>
<span class="go"> {},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">)</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in spam, eggs over Rational Field,</span>
<span class="go"> {},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(Multivariate Polynomial Ring in no variables over Rational Field,</span>
<span class="go"> {},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;zzz&quot;</span><span class="p">)</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, b over Rational Field,</span>
<span class="go"> {},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion">
<tt class="descname">birational_rowmotion</tt><big>(</big><em>labelling</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of applying birational rowmotion to the
<span class="math">\(\mathbf{K}\)</span>-labelling <tt class="docutils literal"><span class="pre">labelling</span></tt> of the poset <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>See the documentation of <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><tt class="xref py py-meth docutils literal"><span class="pre">birational_free_labelling()</span></tt></a>
for a definition of birational rowmotion and
<span class="math">\(\mathbf{K}\)</span>-labellings and for an explanation of how
<span class="math">\(\mathbf{K}\)</span>-labellings are to be encoded to be understood
by Sage. This implementation allows <span class="math">\(\mathbf{K}\)</span> to be a
semifield, not just a field. Birational rowmotion is only a
rational map, so an exception (most likely, <tt class="docutils literal"><span class="pre">ZeroDivisionError</span></tt>)
will be thrown if the denominator is zero.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">labelling</span></tt> &#8211; a <span class="math">\(\mathbf{K}\)</span>-labelling of <tt class="docutils literal"><span class="pre">self</span></tt> in the
sense as defined in the documentation of
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><tt class="xref py py-meth docutils literal"><span class="pre">birational_free_labelling()</span></tt></a></li>
</ul>
<p>OUTPUT:</p>
<p>The image of the <span class="math">\(\mathbf{K}\)</span>-labelling <span class="math">\(f\)</span> under birational
rowmotion.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">lex</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">lex</span><span class="p">);</span> <span class="n">t</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x2), (3, x3), (4, x4)]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_rowmotion</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="n">t</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, a*b/x4), (2, (x1*x2*b + x1*x3*b)/(x2*x4)),</span>
<span class="go"> (3, (x1*x2*b + x1*x3*b)/(x3*x4)), (4, (x2*b + x3*b)/x4)]</span>
</pre></div>
</div>
<p>A result of <a class="reference internal" href="#gr13" id="id5">[GR13]</a> states that applying birational rowmotion
<span class="math">\(n+m\)</span> times to a <span class="math">\(\mathbf{K}\)</span>-labelling <span class="math">\(f\)</span> of the poset
<span class="math">\([n] \times [m]\)</span> gives back <span class="math">\(f\)</span>. Let us check this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_rectangle_periodicity</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="go">....:     P = Posets.ChainPoset(n).product(Posets.ChainPoset(m))</span>
<span class="go">....:     t0 = P.birational_free_labelling(P)</span>
<span class="go">....:     t = t0</span>
<span class="go">....:     for i in range(k):</span>
<span class="go">....:         t = P.birational_rowmotion(t)</span>
<span class="go">....:     return t == t0</span>
<span class="gp">sage: </span><span class="n">test_rectangle_periodicity</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_rectangle_periodicity</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">test_rectangle_periodicity</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>While computations with the birational free labelling quickly
run out of memory due to the complexity of the rational
functions involved, it is computationally cheap to check
properties of birational rowmotion on examples in the tropical
semiring:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_rectangle_periodicity_tropical</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="go">....:     P = Posets.ChainPoset(n).product(Posets.ChainPoset(m))</span>
<span class="go">....:     TT = TropicalSemiring(ZZ)</span>
<span class="go">....:     t0 = (TT, {v: TT(floor(random()*100)) for v in P}, TT(0), TT(124))</span>
<span class="go">....:     t = t0</span>
<span class="go">....:     for i in range(k):</span>
<span class="go">....:         t = P.birational_rowmotion(t)</span>
<span class="go">....:     return t == t0</span>
<span class="gp">sage: </span><span class="n">test_rectangle_periodicity_tropical</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Tropicalization is also what relates birational rowmotion to
classical rowmotion on order ideals. In fact, if <span class="math">\(T\)</span> denotes
the <a class="reference external" href="../../../semirings/sage/rings/semirings/tropical_semiring.html#sage.rings.semirings.tropical_semiring.TropicalSemiring" title="(in Sage Reference Manual: Standard Semirings v7.1)"><tt class="xref py py-class docutils literal"><span class="pre">tropical</span> <span class="pre">semiring</span></tt></a> of
<span class="math">\(\ZZ\)</span> and <span class="math">\(P\)</span> is a finite poset, then we can define an embedding
<span class="math">\(\phi\)</span> from the set <span class="math">\(J(P)\)</span> of all order ideals of <span class="math">\(P\)</span> into the
set <span class="math">\(T^{\widehat{P}}\)</span> of all <span class="math">\(T\)</span>-labellings of <span class="math">\(P\)</span> by sending
every <span class="math">\(I \in J(P)\)</span> to the indicator function of <span class="math">\(I\)</span> extended by
the value <span class="math">\(1\)</span> at the element <span class="math">\(0\)</span> and the value <span class="math">\(0\)</span> at the
element <span class="math">\(1\)</span>. This map <span class="math">\(\phi\)</span> has the property that
<span class="math">\(R \circ \phi = \phi \circ r\)</span>, where <span class="math">\(R\)</span> denotes birational
rowmotion, and <span class="math">\(r\)</span> denotes <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><tt class="xref py py-meth docutils literal"><span class="pre">classical</span> <span class="pre">rowmotion</span></tt></a>
on <span class="math">\(J(P)\)</span>. An example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">IntegerPartitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">TT</span> <span class="o">=</span> <span class="n">TropicalSemiring</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">indicator_labelling</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
<span class="go">....:     # send order ideal `I` to a `T`-labelling of `P`.</span>
<span class="go">....:     dct = {v: TT(v in I) for v in P}</span>
<span class="go">....:     return (TT, dct, TT(1), TT(0))</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">indicator_labelling</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion</span><span class="p">(</span><span class="n">I</span><span class="p">))</span>
<span class="go">....:     == P.birational_rowmotion(indicator_labelling(I))</span>
<span class="go">....:     for I in P.order_ideals_lattice(facade=True))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Facade set to false works:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lex</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">lex</span><span class="p">);</span> <span class="n">t</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_rowmotion</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="n">t</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">(x1*x2*b + x1*x3*b)/(x2*x4)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_rowmotion</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">a*b/x3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle">
<tt class="descname">birational_toggle</tt><big>(</big><em>v</em>, <em>labelling</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of applying the birational <span class="math">\(v\)</span>-toggle <span class="math">\(T_v\)</span>
to the <span class="math">\(\mathbf{K}\)</span>-labelling <tt class="docutils literal"><span class="pre">labelling</span></tt> of the poset <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>See the documentation of <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><tt class="xref py py-meth docutils literal"><span class="pre">birational_free_labelling()</span></tt></a>
for a definition of this toggle and of <span class="math">\(\mathbf{K}\)</span>-labellings as
well as an explanation of how <span class="math">\(\mathbf{K}\)</span>-labellings are to be
encoded to be understood by Sage. This implementation allows
<span class="math">\(\mathbf{K}\)</span> to be a semifield, not just a field. The birational
<span class="math">\(v\)</span>-toggle is only a rational map, so an exception (most
likely, <tt class="docutils literal"><span class="pre">ZeroDivisionError</span></tt>) will be thrown if the
denominator is zero.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">v</span></tt> &#8211; an element of <tt class="docutils literal"><span class="pre">self</span></tt> (must have <tt class="docutils literal"><span class="pre">self</span></tt> as
parent if <tt class="docutils literal"><span class="pre">self</span></tt> is a <tt class="docutils literal"><span class="pre">facade=False</span></tt> poset)</li>
<li><tt class="docutils literal"><span class="pre">labelling</span></tt> &#8211; a <span class="math">\(\mathbf{K}\)</span>-labelling of <tt class="docutils literal"><span class="pre">self</span></tt> in the
sense as defined in the documentation of
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><tt class="xref py py-meth docutils literal"><span class="pre">birational_free_labelling()</span></tt></a></li>
</ul>
<p>OUTPUT:</p>
<p>The <span class="math">\(\mathbf{K}\)</span>-labelling <span class="math">\(T_v f\)</span> of <tt class="docutils literal"><span class="pre">self</span></tt>, where <span class="math">\(f\)</span> is
<tt class="docutils literal"><span class="pre">labelling</span></tt>.</p>
<p>EXAMPLES:</p>
<p>Let us start with the birational free labelling of the
&#8220;V&#8221;-poset (the three-element poset with Hasse diagram looking
like a &#8220;V&#8221;):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">();</span> <span class="n">s</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x2), (3, x3)]</span>
</pre></div>
</div>
<p>The image of <span class="math">\(s\)</span> under the <span class="math">\(1\)</span>-toggle <span class="math">\(T_1\)</span> is:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="n">s1</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, a*x2*x3/(x1*x2 + x1*x3)), (2, x2), (3, x3)]</span>
</pre></div>
</div>
<p>Now let us apply the <span class="math">\(2\)</span>-toggle <span class="math">\(T_2\)</span> (to the old <tt class="docutils literal"><span class="pre">s</span></tt>):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s2</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="n">s2</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x1*b/x2), (3, x3)]</span>
</pre></div>
</div>
<p>On the other hand, we can also apply <span class="math">\(T_2\)</span> to the image of <span class="math">\(s\)</span>
under <span class="math">\(T_1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s12</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">s1</span><span class="p">);</span> <span class="n">s12</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s12</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, a*x2*x3/(x1*x2 + x1*x3)), (2, a*x3*b/(x1*x2 + x1*x3)), (3, x3)]</span>
</pre></div>
</div>
<p>Each toggle is an involution:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="o">==</span> <span class="n">s</span>
<span class="go">....:      for i in V )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can also start with a less generic labelling:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">(Rational Field, {...}, 2, 10)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 28/13), (2, 6), (3, 7)]</span>
<span class="gp">sage: </span><span class="n">t13</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span> <span class="n">t13</span>
<span class="go">(Rational Field, {...}, 2, 10)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t13</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 28/13), (2, 6), (3, 40/13)]</span>
</pre></div>
</div>
<p>However, labellings have to be sufficiently generic, lest
denominators vanish:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">rational division by zero</span>
</pre></div>
</div>
<p>We don&#8217;t get into zero-division issues in the tropical
semiring (unless the zero of the tropical semiring appears
in the labelling):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">TT</span> <span class="o">=</span> <span class="n">TropicalSemiring</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">)},</span> <span class="n">TT</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">TT</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 6, 0)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 8), (2, 4), (3, 1)]</span>
<span class="gp">sage: </span><span class="n">t12</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span> <span class="n">t12</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 6, 0)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t12</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 8), (2, 4), (3, 1)]</span>
<span class="gp">sage: </span><span class="n">t123</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">t12</span><span class="p">);</span> <span class="n">t123</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 6, 0)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t123</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 8), (2, 4), (3, 7)]</span>
</pre></div>
</div>
<p>We turn to more interesting posets. Here is the <span class="math">\(6\)</span>-element
poset arising from the weak order on <span class="math">\(S_3\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">SymmetricGroupWeakOrderPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">))</span>
<span class="go">[&#39;123&#39;, &#39;132&#39;, &#39;213&#39;, &#39;231&#39;, &#39;312&#39;, &#39;321&#39;]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;123&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="s1">&#39;132&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;213&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;231&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;321&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;312&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">)},</span> <span class="n">TT</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 7, 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;123&#39;, 6), (&#39;132&#39;, 2), (&#39;213&#39;, 3), (&#39;231&#39;, 1), (&#39;312&#39;, 2), (&#39;321&#39;, 1)]</span>
<span class="gp">sage: </span><span class="n">t13</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="s1">&#39;213&#39;</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span> <span class="n">t13</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 7, 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t13</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;123&#39;, 6), (&#39;132&#39;, 2), (&#39;213&#39;, 4), (&#39;231&#39;, 1), (&#39;312&#39;, 2), (&#39;321&#39;, 1)]</span>
</pre></div>
</div>
<p>Let us verify on this example some basic properties of
toggles. First of all, again let us check that <span class="math">\(T_v\)</span> is an
involution for every <span class="math">\(v\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span> <span class="o">==</span> <span class="n">t</span>
<span class="go">....:      for v in P )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Furthermore, two toggles <span class="math">\(T_v\)</span> and <span class="math">\(T_w\)</span> commute unless
one of <span class="math">\(v\)</span> or <span class="math">\(w\)</span> covers the other:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">or</span> <span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="go">....:      or P.birational_toggle(v, P.birational_toggle(w, t))</span>
<span class="go">....:         == P.birational_toggle(w, P.birational_toggle(v, t))</span>
<span class="go">....:      for v in P for w in P )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Setting <tt class="docutils literal"><span class="pre">facade</span></tt> to <tt class="docutils literal"><span class="pre">False</span></tt> does not break
<tt class="docutils literal"><span class="pre">birational_toggle</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">],</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lex</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">lex</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span> <span class="o">==</span> <span class="n">t</span>
<span class="go">....:      for v in P )</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">t4</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">),</span> <span class="n">t</span><span class="p">);</span> <span class="n">t4</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="n">t4</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)]</span>
<span class="go">x1</span>
<span class="gp">sage: </span><span class="n">t4</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)]</span>
<span class="go">x2</span>
<span class="gp">sage: </span><span class="n">t4</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)]</span>
<span class="go">x3</span>
<span class="gp">sage: </span><span class="n">t4</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)]</span>
<span class="go">(x2*b + x3*b)/x4</span>
</pre></div>
</div>
<p>The one-element poset:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">8</span><span class="p">:</span> <span class="p">[]})</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t8</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="n">t8</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="n">t8</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span>
<span class="go">a*b/x1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles">
<tt class="descname">birational_toggles</tt><big>(</big><em>vs</em>, <em>labelling</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of applying a sequence of birational
toggles (specified by <tt class="docutils literal"><span class="pre">vs</span></tt>) to the <span class="math">\(\mathbf{K}\)</span>-labelling
<tt class="docutils literal"><span class="pre">labelling</span></tt> of the poset <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>See the documentation of <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><tt class="xref py py-meth docutils literal"><span class="pre">birational_free_labelling()</span></tt></a>
for a definition of birational toggles and <span class="math">\(\mathbf{K}\)</span>-labellings
and for an explanation of how <span class="math">\(\mathbf{K}\)</span>-labellings are to be
encoded to be understood by Sage. This implementation allows
<span class="math">\(\mathbf{K}\)</span> to be a semifield, not just a field. The birational
<span class="math">\(v\)</span>-toggle is only a rational map, so an exception (most
likely, <tt class="docutils literal"><span class="pre">ZeroDivisionError</span></tt>) will be thrown if the
denominator is zero.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">vs</span></tt> &#8211; an iterable comprising elements of <tt class="docutils literal"><span class="pre">self</span></tt>
(which must have <tt class="docutils literal"><span class="pre">self</span></tt> as parent if <tt class="docutils literal"><span class="pre">self</span></tt> is a
<tt class="docutils literal"><span class="pre">facade=False</span></tt> poset)</li>
<li><tt class="docutils literal"><span class="pre">labelling</span></tt> &#8211; a <span class="math">\(\mathbf{K}\)</span>-labelling of <tt class="docutils literal"><span class="pre">self</span></tt> in the
sense as defined in the documentation of
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><tt class="xref py py-meth docutils literal"><span class="pre">birational_free_labelling()</span></tt></a></li>
</ul>
<p>OUTPUT:</p>
<p>The <span class="math">\(\mathbf{K}\)</span>-labelling <span class="math">\(T_{v_n} T_{v_{n-1}} \cdots T_{v_1} f\)</span>
of <tt class="docutils literal"><span class="pre">self</span></tt>, where <span class="math">\(f\)</span> is <tt class="docutils literal"><span class="pre">labelling</span></tt> and
<span class="math">\((v_1, v_2, \ldots, v_n)\)</span> is <tt class="docutils literal"><span class="pre">vs</span></tt> (written as list).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">SymmetricGroupBruhatOrderPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">))</span>
<span class="go">[&#39;123&#39;, &#39;132&#39;, &#39;213&#39;, &#39;231&#39;, &#39;312&#39;, &#39;321&#39;]</span>
<span class="gp">sage: </span><span class="n">TT</span> <span class="o">=</span> <span class="n">TropicalSemiring</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;123&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="s1">&#39;132&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;213&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;231&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;321&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;312&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">)},</span> <span class="n">TT</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">tA</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">([</span><span class="s1">&#39;123&#39;</span><span class="p">,</span> <span class="s1">&#39;231&#39;</span><span class="p">,</span> <span class="s1">&#39;312&#39;</span><span class="p">],</span> <span class="n">t</span><span class="p">);</span> <span class="n">tA</span>
<span class="go">(Tropical semiring over Integer Ring, {...}, 7, 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">tA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;123&#39;, 6), (&#39;132&#39;, 2), (&#39;213&#39;, 3), (&#39;231&#39;, 2), (&#39;312&#39;, 1), (&#39;321&#39;, 1)]</span>
<span class="gp">sage: </span><span class="n">tAB</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">([</span><span class="s1">&#39;132&#39;</span><span class="p">,</span> <span class="s1">&#39;213&#39;</span><span class="p">,</span> <span class="s1">&#39;321&#39;</span><span class="p">],</span> <span class="n">tA</span><span class="p">);</span> <span class="n">tAB</span>
<span class="go">(Tropical semiring over Integer Ring, {...}, 7, 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">tAB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;123&#39;, 6), (&#39;132&#39;, 6), (&#39;213&#39;, 5), (&#39;231&#39;, 2), (&#39;312&#39;, 1), (&#39;321&#39;, 1)]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Qx</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">Qx</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">Qx</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)),</span> <span class="n">t</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">(Fraction Field of Univariate Polynomial Ring in x over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, (x^2 + x)/(x^2 + x + 1)), (2, (x^3 + x^2)/(x^2 + x + 1)), (3, x^4/(x^2 + x + 1)), (4, 1)]</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)),</span> <span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 1/x^2), (2, (x^2 + x + 1)/x^4), (3, (x^2 + x + 1)/(x^3 + x^2)), (4, (x^2 + x + 1)/x^3)]</span>
</pre></div>
</div>
<p>Facade set to <tt class="docutils literal"><span class="pre">False</span></tt> works:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">],</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lex</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">lex</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">([</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">P</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)],</span> <span class="n">t</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(x, a*x2*x3/(x1*x2 + x1*x3)), (y, a*x3*x4/(x1*x2 + x1*x3)), (w, x3), (z, x4)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.directed_subsets">
<tt class="descname">directed_subsets</tt><big>(</big><em>direction</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.directed_subsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order filters (resp. order ideals) of <tt class="docutils literal"><span class="pre">self</span></tt>, as lists.</p>
<p>If <tt class="docutils literal"><span class="pre">direction</span></tt> is &#8216;up&#8217;, returns the order filters (upper sets).</p>
<p>If <tt class="docutils literal"><span class="pre">direction</span></tt> is &#8216;down&#8217;, returns the order ideals (lower sets).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">direction</span></tt> &#8211; &#8216;up&#8217; or &#8216;down&#8217;</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">directed_subsets</span><span class="p">(</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="go">[[], [1, 2, 4, 3, 6, 12], [2, 4, 3, 6, 12], [2, 4, 6, 12], [3, 6, 12], [4, 3, 6, 12], [4, 6, 12], [4, 12], [6, 12], [12]]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Poset</span><span class="p">()</span><span class="o">.</span><span class="n">directed_subsets</span><span class="p">(</span><span class="s1">&#39;up&#39;</span><span class="p">))</span>
<span class="go">[[]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_lattice">
<tt class="descname">is_lattice</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether this poset is both a meet and a join semilattice.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lattice</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism">
<tt class="descname">is_poset_isomorphism</tt><big>(</big><em>f</em>, <em>codomain</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <span class="math">\(f\)</span> is an isomorphism of posets from
<tt class="docutils literal"><span class="pre">self</span></tt> to <tt class="docutils literal"><span class="pre">codomain</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> &#8211; a function from <tt class="docutils literal"><span class="pre">self</span></tt> to <tt class="docutils literal"><span class="pre">codomain</span></tt></li>
<li><tt class="docutils literal"><span class="pre">codomain</span></tt> &#8211; a poset</li>
</ul>
<p>EXAMPLES:</p>
<p>We build the poset <span class="math">\(D\)</span> of divisors of 30, and check that
it is isomorphic to the boolean lattice <span class="math">\(B\)</span> of the subsets
of <span class="math">\(\{2,3,5\}\)</span> ordered by inclusion, via the reverse
function <span class="math">\(f: B \to D, b \mapsto \prod_{x\in b} x\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])],</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">D</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_isomorphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>On the other hand, <span class="math">\(f\)</span> is not an isomorphism to the chain
of divisors of 30, ordered by usual comparison:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">P</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_isomorphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A non surjective case:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])],</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">D</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_isomorphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A non injective case:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])],</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">D</span><span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_isomorphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">since <tt class="docutils literal"><span class="pre">D</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> are not facade posets, <tt class="docutils literal"><span class="pre">f</span></tt> is
responsible for the conversions between integers and subsets to
elements of <tt class="docutils literal"><span class="pre">D</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> and back.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="finite_lattice_posets.html#sage.categories.finite_lattice_posets.FiniteLatticePosets.ParentMethods.is_lattice_morphism" title="sage.categories.finite_lattice_posets.FiniteLatticePosets.ParentMethods.is_lattice_morphism"><tt class="xref py py-meth docutils literal"><span class="pre">FiniteLatticePosets.ParentMethods.is_lattice_morphism()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_morphism">
<tt class="descname">is_poset_morphism</tt><big>(</big><em>f</em>, <em>codomain</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_morphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <span class="math">\(f\)</span> is a morphism of posets from <tt class="docutils literal"><span class="pre">self</span></tt>
to <tt class="docutils literal"><span class="pre">codomain</span></tt>, that is</p>
<div class="math">
\[x\leq y \Longrightarrow f(x) \leq f(y)\]</div>
<p>for all <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> &#8211; a function from <tt class="docutils literal"><span class="pre">self</span></tt> to <tt class="docutils literal"><span class="pre">codomain</span></tt></li>
<li><tt class="docutils literal"><span class="pre">codomain</span></tt> &#8211; a poset</li>
</ul>
<p>EXAMPLES:</p>
<p>We build the boolean lattice of the subsets of
<span class="math">\(\{2,3,5,6\}\)</span> and the lattice of divisors of <span class="math">\(30\)</span>, and
check that the map <span class="math">\(b \mapsto \gcd(\prod_{x\in b} x, 30)\)</span>
is a morphism of posets:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])],</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">D</span><span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">since <tt class="docutils literal"><span class="pre">D</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> are not facade posets, <tt class="docutils literal"><span class="pre">f</span></tt> is responsible
for the conversions between integers and subsets to elements of
<tt class="docutils literal"><span class="pre">D</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> and back.</p>
</div>
<p><span class="math">\(f\)</span> is also a morphism of posets to the chain of divisors
of 30, ordered by usual comparison:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">P</span><span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>FIXME: should this be <tt class="docutils literal"><span class="pre">is_order_preserving_morphism</span></tt>?</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism" title="sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism"><tt class="xref py py-meth docutils literal"><span class="pre">is_poset_isomorphism()</span></tt></a></p>
</div>
<p>TESTS:</p>
<p>Base cases:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">AntichainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="o">-</span><span class="n">x</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_poset_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_poset_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_poset_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">is_poset_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">();</span> <span class="n">P</span>
<span class="go">Finite poset containing 0 elements</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_poset_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_selfdual">
<tt class="descname">is_selfdual</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_selfdual" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether this poset is <em>self-dual</em>, that is
isomorphic to its dual poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]),</span><span class="n">cover_relations</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_selfdual</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span><span class="n">cover_relations</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_selfdual</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_selfdual</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.order_filter_generators">
<tt class="descname">order_filter_generators</tt><big>(</big><em>filter</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_filter_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Generators for an order filter</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">filter</span></tt> &#8211; an order filter of <tt class="docutils literal"><span class="pre">self</span></tt>, as a list (or iterable)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">Subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_filter</span><span class="p">([</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">])]);</span> <span class="n">I</span>
<span class="go">[{2, 3}, {1}, {1, 2}, {1, 3}, {1, 2, 3}]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_filter_generators</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">{{2, 3}, {1}}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators" title="sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators"><tt class="xref py py-meth docutils literal"><span class="pre">order_ideal_generators()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_complement_generators">
<tt class="descname">order_ideal_complement_generators</tt><big>(</big><em>antichain</em>, <em>direction='up'</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_complement_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Panyushev complement of the antichain
<tt class="docutils literal"><span class="pre">antichain</span></tt>.</p>
<p>Given an antichain <span class="math">\(A\)</span> of a poset <span class="math">\(P\)</span>, the Panyushev
complement of <span class="math">\(A\)</span> is defined to be the antichain consisting
of the minimal elements of the order filter <span class="math">\(B\)</span>, where <span class="math">\(B\)</span>
is the (set-theoretic) complement of the order ideal of
<span class="math">\(P\)</span> generated by <span class="math">\(A\)</span>.</p>
<p>Setting the optional keyword variable <tt class="docutils literal"><span class="pre">direction</span></tt> to
<tt class="docutils literal"><span class="pre">'down'</span></tt> leads to the inverse Panyushev complement being
computed instead of the Panyushev complement. The inverse
Panyushev complement of an antichain <span class="math">\(A\)</span> is the antichain
whose Panyushev complement is <span class="math">\(A\)</span>. It can be found as the
antichain consisting of the maximal elements of the order
ideal <span class="math">\(C\)</span>, where <span class="math">\(C\)</span> is the (set-theoretic) complement of
the order filter of <span class="math">\(P\)</span> generated by <span class="math">\(A\)</span>.</p>
<p><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><tt class="xref py py-meth docutils literal"><span class="pre">panyushev_complement()</span></tt></a> is an alias for this method.</p>
<p>Panyushev complementation is related (actually, isomorphic)
to rowmotion (<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><tt class="xref py py-meth docutils literal"><span class="pre">rowmotion()</span></tt></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">antichain</span></tt> &#8211; an antichain of <tt class="docutils literal"><span class="pre">self</span></tt>, as a list (or
iterable), or, more generally, generators of an order ideal
(resp. order filter)</li>
<li><tt class="docutils literal"><span class="pre">direction</span></tt> &#8211; &#8216;up&#8217; or &#8216;down&#8217; (default: &#8216;up&#8217;)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the generating antichain of the complement order filter
(resp. order ideal) of the order ideal (resp. order filter)
generated by the antichain <tt class="docutils literal"><span class="pre">antichain</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">{3}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">set()</span>

<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">{1, 2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">set()</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is a brute force implementation, building the
order ideal generated by the antichain, and searching
for order filter generators of its complement</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators">
<tt class="descname">order_ideal_generators</tt><big>(</big><em>ideal</em>, <em>direction='down'</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the antichain of (minimal) generators of the order
ideal (resp. order filter) <tt class="docutils literal"><span class="pre">ideal</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ideal</span></tt> &#8211; an order ideal <span class="math">\(I\)</span> (resp. order filter)
of <tt class="docutils literal"><span class="pre">self</span></tt>, as a list (or iterable); this should be
an order ideal if <tt class="docutils literal"><span class="pre">direction</span></tt> is set to <tt class="docutils literal"><span class="pre">'down'</span></tt>,
and an order filter if <tt class="docutils literal"><span class="pre">direction</span></tt> is set to
<tt class="docutils literal"><span class="pre">'up'</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">direction</span></tt> &#8211; <tt class="docutils literal"><span class="pre">'up'</span></tt> or <tt class="docutils literal"><span class="pre">'down'</span></tt> (default:
<tt class="docutils literal"><span class="pre">'down'</span></tt>).</li>
</ul>
<p>The antichain of (minimal) generators of an order ideal
<span class="math">\(I\)</span> in a poset <span class="math">\(P\)</span> is the set of all minimal elements of
<span class="math">\(P\)</span>. In the case of an order filter, the definition is
similar, but with &#8220;maximal&#8221; used instead of &#8220;minimal&#8221;.</p>
<p>EXAMPLES:</p>
<p>We build the boolean lattice of all subsets of <span class="math">\(\{1,2,3\}\)</span>
ordered by inclusion, and compute an order ideal there:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">Subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideal</span><span class="p">([</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">])]);</span> <span class="n">I</span>
<span class="go">[{}, {3}, {2}, {2, 3}, {1}, {1, 2}]</span>
</pre></div>
</div>
<p>Then, we retrieve the generators of this ideal:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_generators</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">{{1, 2}, {2, 3}}</span>
</pre></div>
</div>
<p>If <tt class="docutils literal"><span class="pre">direction</span></tt> is &#8216;up&#8217;, then this instead computes
the minimal generators for an order filter:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_filter</span><span class="p">([</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">])]);</span> <span class="n">I</span>
<span class="go">[{2, 3}, {1}, {1, 2}, {1, 3}, {1, 2, 3}]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_generators</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>
<span class="go">{{2, 3}, {1}}</span>
</pre></div>
</div>
<p>Complexity: <span class="math">\(O(n+m)\)</span> where <span class="math">\(n\)</span> is the cardinality of <span class="math">\(I\)</span>,
and <span class="math">\(m\)</span> the number of upper covers of elements of <span class="math">\(I\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideals_lattice">
<tt class="descname">order_ideals_lattice</tt><big>(</big><em>as_ideals=True</em>, <em>facade=None</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideals_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the lattice of order ideals of a poset <tt class="docutils literal"><span class="pre">self</span></tt>,
ordered by inclusion.</p>
<p>The lattice of order ideals of a poset <span class="math">\(P\)</span> is usually
denoted by <span class="math">\(J(P)\)</span>. Its underlying set is the set of order
ideals of <span class="math">\(P\)</span>, and its partial order is given by
inclusion.</p>
<p>The order ideals of <span class="math">\(P\)</span> are in a canonical bijection
with the antichains of <span class="math">\(P\)</span>. The bijection maps every
order ideal to the antichain formed by its maximal
elements. By setting the <tt class="docutils literal"><span class="pre">as_ideals</span></tt> keyword variable to
<tt class="docutils literal"><span class="pre">False</span></tt>, one can make this method apply this bijection
before returning the lattice.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">as_ideals</span></tt> &#8211; Boolean, if <tt class="docutils literal"><span class="pre">True</span></tt> (default) returns
a poset on the set of order ideals, otherwise on the set
of antichains</li>
<li><tt class="docutils literal"><span class="pre">facade</span></tt> &#8211; Boolean or <tt class="docutils literal"><span class="pre">None</span></tt> (default). Whether to
return a facade lattice or not. By default return facade
lattice if the poset is a facade poset.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 2], [1, 4], [2, 3], [3, 4]]</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideals_lattice</span><span class="p">();</span> <span class="n">J</span>
<span class="go">Finite lattice containing 8 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
<span class="go">[{}, {0}, {0, 2}, {0, 2, 3}, {0, 1}, {0, 1, 2}, {0, 1, 2, 3}, {0, 1, 2, 3, 4}]</span>
</pre></div>
</div>
<p>As a lattice on antichains:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">J2</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideals_lattice</span><span class="p">(</span><span class="bp">False</span><span class="p">);</span> <span class="n">J2</span>
<span class="go">Finite lattice containing 8 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">J2</span><span class="p">)</span>
<span class="go">[(0,), (1, 2), (1, 3), (1,), (2,), (3,), (4,), ()]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">DiamondPoset</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">facade</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">order_ideals_lattice</span><span class="p">();</span> <span class="n">J</span>
<span class="go">Finite lattice containing 6 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
<span class="go">[{}, {0}, {0, 2}, {0, 1}, {0, 1, 2}, {0, 1, 2, 3}]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[{}, {0}], [{0}, {0, 2}], [{0}, {0, 1}], [{0, 2}, {0, 1, 2}], [{0, 1}, {0, 1, 2}], [{0, 1, 2}, {0, 1, 2, 3}]]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">J_facade</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideals_lattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">J_nonfacade</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideals_lattice</span><span class="p">(</span><span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">J_facade</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">J_nonfacade</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement">
<tt class="descname">panyushev_complement</tt><big>(</big><em>antichain</em>, <em>direction='up'</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Panyushev complement of the antichain
<tt class="docutils literal"><span class="pre">antichain</span></tt>.</p>
<p>Given an antichain <span class="math">\(A\)</span> of a poset <span class="math">\(P\)</span>, the Panyushev
complement of <span class="math">\(A\)</span> is defined to be the antichain consisting
of the minimal elements of the order filter <span class="math">\(B\)</span>, where <span class="math">\(B\)</span>
is the (set-theoretic) complement of the order ideal of
<span class="math">\(P\)</span> generated by <span class="math">\(A\)</span>.</p>
<p>Setting the optional keyword variable <tt class="docutils literal"><span class="pre">direction</span></tt> to
<tt class="docutils literal"><span class="pre">'down'</span></tt> leads to the inverse Panyushev complement being
computed instead of the Panyushev complement. The inverse
Panyushev complement of an antichain <span class="math">\(A\)</span> is the antichain
whose Panyushev complement is <span class="math">\(A\)</span>. It can be found as the
antichain consisting of the maximal elements of the order
ideal <span class="math">\(C\)</span>, where <span class="math">\(C\)</span> is the (set-theoretic) complement of
the order filter of <span class="math">\(P\)</span> generated by <span class="math">\(A\)</span>.</p>
<p><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><tt class="xref py py-meth docutils literal"><span class="pre">panyushev_complement()</span></tt></a> is an alias for this method.</p>
<p>Panyushev complementation is related (actually, isomorphic)
to rowmotion (<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><tt class="xref py py-meth docutils literal"><span class="pre">rowmotion()</span></tt></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">antichain</span></tt> &#8211; an antichain of <tt class="docutils literal"><span class="pre">self</span></tt>, as a list (or
iterable), or, more generally, generators of an order ideal
(resp. order filter)</li>
<li><tt class="docutils literal"><span class="pre">direction</span></tt> &#8211; &#8216;up&#8217; or &#8216;down&#8217; (default: &#8216;up&#8217;)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the generating antichain of the complement order filter
(resp. order ideal) of the order ideal (resp. order filter)
generated by the antichain <tt class="docutils literal"><span class="pre">antichain</span></tt></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">{3}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">set()</span>

<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">{1, 2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">set()</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is a brute force implementation, building the
order ideal generated by the antichain, and searching
for order filter generators of its complement</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbit_iter">
<tt class="descname">panyushev_orbit_iter</tt><big>(</big><em>antichain</em>, <em>element_constructor=&lt;type 'set'&gt;</em>, <em>stop=True</em>, <em>check=True</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbit_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the Panyushev orbit of an antichain
<tt class="docutils literal"><span class="pre">antichain</span></tt> of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The Panyushev orbit of an antichain is its orbit under
Panyushev complementation (see
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><tt class="xref py py-meth docutils literal"><span class="pre">panyushev_complement()</span></tt></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">antichain</span></tt> &#8211; an antichain of <tt class="docutils literal"><span class="pre">self</span></tt>, given as an
iterable.</li>
<li><tt class="docutils literal"><span class="pre">element_constructor</span></tt> (defaults to <tt class="docutils literal"><span class="pre">set</span></tt>) &#8211; a type
constructor (<tt class="docutils literal"><span class="pre">set</span></tt>, <tt class="docutils literal"><span class="pre">tuple</span></tt>, <tt class="docutils literal"><span class="pre">list</span></tt>, <tt class="docutils literal"><span class="pre">frozenset</span></tt>,
<tt class="docutils literal"><span class="pre">iter</span></tt>, etc.) which is to be applied to the antichains
before they are yielded.</li>
<li><tt class="docutils literal"><span class="pre">stop</span></tt> &#8211; a Boolean (default: <tt class="docutils literal"><span class="pre">True</span></tt>) determining
whether the iterator should stop once it completes its
cycle (this happens when it is set to <tt class="docutils literal"><span class="pre">True</span></tt>) or go on
forever (this happens when it is set to <tt class="docutils literal"><span class="pre">False</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">check</span></tt> &#8211; a Boolean (default: <tt class="docutils literal"><span class="pre">True</span></tt>) determining
whether <tt class="docutils literal"><span class="pre">antichain</span></tt> should be checked for being an
antichain.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an iterator over the orbit of the antichain <tt class="docutils literal"><span class="pre">antichain</span></tt>
under Panyushev complementation. This iterator <span class="math">\(I\)</span> has the
property that <tt class="docutils literal"><span class="pre">I[0]</span> <span class="pre">==</span> <span class="pre">antichain</span></tt> and each <span class="math">\(i\)</span> satisfies
<tt class="docutils literal"><span class="pre">self.order_ideal_complement_generators(I[i])</span> <span class="pre">==</span> <span class="pre">I[i+1]</span></tt>,
where <tt class="docutils literal"><span class="pre">I[i+1]</span></tt> has to be understood as <tt class="docutils literal"><span class="pre">I[0]</span></tt> if it is
undefined.
The entries <tt class="docutils literal"><span class="pre">I[i]</span></tt> are sets by default, but depending on
the optional keyword variable <tt class="docutils literal"><span class="pre">element_constructors</span></tt>
they can also be tuples, lists etc.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}, {3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[{1, 2}, {3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">[{1, 2}, {3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[1, 2], [3], []]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">))</span>
<span class="go">[frozenset({1, 2}), frozenset({3}), frozenset()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[(1, 2), (3,), ()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">([]))</span>
<span class="go">[set()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">Piter</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">([</span><span class="mi">2</span><span class="p">],</span> <span class="n">stop</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{3}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbits">
<tt class="descname">panyushev_orbits</tt><big>(</big><em>element_constructor=&lt;type 'set'&gt;</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Panyushev orbits of antichains in <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The Panyushev orbit of an antichain is its orbit under
Panyushev complementation (see
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><tt class="xref py py-meth docutils literal"><span class="pre">panyushev_complement()</span></tt></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">element_constructor</span></tt> (defaults to <tt class="docutils literal"><span class="pre">set</span></tt>) &#8211; a type
constructor (<tt class="docutils literal"><span class="pre">set</span></tt>, <tt class="docutils literal"><span class="pre">tuple</span></tt>, <tt class="docutils literal"><span class="pre">list</span></tt>, <tt class="docutils literal"><span class="pre">frozenset</span></tt>,
<tt class="docutils literal"><span class="pre">iter</span></tt>, etc.) which is to be applied to the antichains
before they are returned.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the partition of the set of all antichains of <tt class="docutils literal"><span class="pre">self</span></tt> into
orbits under Panyushev complementation. This is returned as
a list of lists <tt class="docutils literal"><span class="pre">L</span></tt> such that for each <tt class="docutils literal"><span class="pre">L</span></tt> and <tt class="docutils literal"><span class="pre">i</span></tt>,
cyclically:
<tt class="docutils literal"><span class="pre">self.order_ideal_complement_generators(L[i])</span> <span class="pre">==</span> <span class="pre">L[i+1]</span></tt>.
The entries <tt class="docutils literal"><span class="pre">L[i]</span></tt> are sets by default, but depending on
the optional keyword variable <tt class="docutils literal"><span class="pre">element_constructors</span></tt>
they can also be tuples, lists etc.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">()</span>
<span class="go">[[{2}, {1}], [set(), {1, 2}, {3}]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
<span class="go">[[[2], [1]], [[], [1, 2], [3]]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">)</span>
<span class="go">[[frozenset({2}), frozenset({1})],</span>
<span class="go"> [frozenset(), frozenset({1, 2}), frozenset({3})]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">)</span>
<span class="go">[[(2,), (1,)], [(), (1, 2), (3,)]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">()</span>
<span class="go">[[set()]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion">
<tt class="descname">rowmotion</tt><big>(</big><em>order_ideal</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="Permalink to this definition">¶</a></dt>
<dd><p>The image of the order ideal <tt class="docutils literal"><span class="pre">order_ideal</span></tt> under rowmotion
in <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Rowmotion on a finite poset <span class="math">\(P\)</span> is an automorphism of the set
<span class="math">\(J(P)\)</span> of all order ideals of <span class="math">\(P\)</span>. One way to define it is as
follows: Given an order ideal <span class="math">\(I \in J(P)\)</span>, we let <span class="math">\(F\)</span> be the
set-theoretic complement of <span class="math">\(I\)</span> in <span class="math">\(P\)</span>. Furthermore we let
<span class="math">\(A\)</span> be the antichain consisting of all minimal elements of
<span class="math">\(F\)</span>. Then, the rowmotion of <span class="math">\(I\)</span> is defined to be the order
ideal of <span class="math">\(P\)</span> generated by the antichain <span class="math">\(A\)</span> (that is, the
order ideal consisting of each element of <span class="math">\(P\)</span> which has some
element of <span class="math">\(A\)</span> above it).</p>
<p>Rowmotion is related (actually, isomorphic) to Panyushev
complementation (<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><tt class="xref py py-meth docutils literal"><span class="pre">panyushev_complement()</span></tt></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">order_ideal</span></tt> &#8211; an order ideal of <tt class="docutils literal"><span class="pre">self</span></tt>, as a set</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the image of <tt class="docutils literal"><span class="pre">order_ideal</span></tt> under rowmotion, as a set again</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">8</span><span class="p">:</span> <span class="p">[]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Set</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">{1, 3, 4, 5, 6, 7}</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Set</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">Set of elements of {}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbit_iter">
<tt class="descname">rowmotion_orbit_iter</tt><big>(</big><em>oideal</em>, <em>element_constructor=&lt;type 'set'&gt;</em>, <em>stop=True</em>, <em>check=True</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbit_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the rowmotion orbit of an order ideal
<tt class="docutils literal"><span class="pre">oideal</span></tt> of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The rowmotion orbit of an order ideal is its orbit under
rowmotion (see <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><tt class="xref py py-meth docutils literal"><span class="pre">rowmotion()</span></tt></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">oideal</span></tt> &#8211; an order ideal of <tt class="docutils literal"><span class="pre">self</span></tt>, given as an
iterable.</li>
<li><tt class="docutils literal"><span class="pre">element_constructor</span></tt> (defaults to <tt class="docutils literal"><span class="pre">set</span></tt>) &#8211; a type
constructor (<tt class="docutils literal"><span class="pre">set</span></tt>, <tt class="docutils literal"><span class="pre">tuple</span></tt>, <tt class="docutils literal"><span class="pre">list</span></tt>, <tt class="docutils literal"><span class="pre">frozenset</span></tt>,
<tt class="docutils literal"><span class="pre">iter</span></tt>, etc.) which is to be applied to the order
ideals before they are yielded.</li>
<li><tt class="docutils literal"><span class="pre">stop</span></tt> &#8211; a Boolean (default: <tt class="docutils literal"><span class="pre">True</span></tt>) determining
whether the iterator should stop once it completes its
cycle (this happens when it is set to <tt class="docutils literal"><span class="pre">True</span></tt>) or go on
forever (this happens when it is set to <tt class="docutils literal"><span class="pre">False</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">check</span></tt> &#8211; a Boolean (default: <tt class="docutils literal"><span class="pre">True</span></tt>) determining
whether <tt class="docutils literal"><span class="pre">oideal</span></tt> should be checked for being an
order ideal.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an iterator over the orbit of the order ideal <tt class="docutils literal"><span class="pre">oideal</span></tt>
under rowmotion. This iterator <span class="math">\(I\)</span> has the property that
<tt class="docutils literal"><span class="pre">I[0]</span> <span class="pre">==</span> <span class="pre">oideal</span></tt> and that every <span class="math">\(i\)</span> satisfies
<tt class="docutils literal"><span class="pre">self.rowmotion(I[i])</span> <span class="pre">==</span> <span class="pre">I[i+1]</span></tt>, where <tt class="docutils literal"><span class="pre">I[i+1]</span></tt> has
to be understood as <tt class="docutils literal"><span class="pre">I[0]</span></tt> if it is undefined.
The entries <tt class="docutils literal"><span class="pre">I[i]</span></tt> are sets by default, but depending on
the optional keyword variable <tt class="docutils literal"><span class="pre">element_constructors</span></tt>
they can also be tuples, lists etc.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}, {1, 2, 3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[{1, 2}, {1, 2, 3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">[{1, 2}, {1, 2, 3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[1, 2], [1, 2, 3], []]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">))</span>
<span class="go">[frozenset({1, 2}), frozenset({1, 2, 3}), frozenset()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 2, 3), ()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([]))</span>
<span class="go">[set()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">Piter</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">stop</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3, 4}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3}</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[1, 2], [1, 2, 3, 4], [2, 3, 5], [1], [2, 3], [1, 2, 3, 5], [1, 2, 4], [3]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbits">
<tt class="descname">rowmotion_orbits</tt><big>(</big><em>element_constructor=&lt;type 'set'&gt;</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the rowmotion orbits of order ideals in <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>The rowmotion orbit of an order ideal is its orbit under
rowmotion (see <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><tt class="xref py py-meth docutils literal"><span class="pre">rowmotion()</span></tt></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">element_constructor</span></tt> (defaults to <tt class="docutils literal"><span class="pre">set</span></tt>) &#8211; a type
constructor (<tt class="docutils literal"><span class="pre">set</span></tt>, <tt class="docutils literal"><span class="pre">tuple</span></tt>, <tt class="docutils literal"><span class="pre">list</span></tt>, <tt class="docutils literal"><span class="pre">frozenset</span></tt>,
<tt class="docutils literal"><span class="pre">iter</span></tt>, etc.) which is to be applied to the antichains
before they are returned.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the partition of the set of all order ideals of <tt class="docutils literal"><span class="pre">self</span></tt>
into orbits under rowmotion. This is returned as
a list of lists <tt class="docutils literal"><span class="pre">L</span></tt> such that for each <tt class="docutils literal"><span class="pre">L</span></tt> and <tt class="docutils literal"><span class="pre">i</span></tt>,
cyclically: <tt class="docutils literal"><span class="pre">self.rowmotion(L[i])</span> <span class="pre">==</span> <span class="pre">L[i+1]</span></tt>.
The entries <tt class="docutils literal"><span class="pre">L[i]</span></tt> are sets by default, but depending on
the optional keyword variable <tt class="docutils literal"><span class="pre">element_constructors</span></tt>
they can also be tuples, lists etc.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits</span><span class="p">())</span>
<span class="go">[3, 5]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[[1, 3], [4], [1], [4, 1, 3], [4, 1, 2]], [[4, 1], [4, 1, 2, 3], []]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[[(1, 3), (4,), (1,), (4, 1, 3), (4, 1, 2)], [(4, 1), (4, 1, 2, 3), ()]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[[()]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbit_iter">
<tt class="descname">toggling_orbit_iter</tt><big>(</big><em>vs</em>, <em>oideal</em>, <em>element_constructor=&lt;type 'set'&gt;</em>, <em>stop=True</em>, <em>check=True</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbit_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the orbit of an order ideal <tt class="docutils literal"><span class="pre">oideal</span></tt> of
<tt class="docutils literal"><span class="pre">self</span></tt> under the operation of toggling the vertices
<tt class="docutils literal"><span class="pre">vs[0],</span> <span class="pre">vs[1],</span> <span class="pre">...</span></tt> in this order.</p>
<p>See <tt class="xref py py-meth docutils literal"><span class="pre">order_ideal_toggle()</span></tt> for a definition of toggling.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The orbit is that under the composition of toggles,
<em>not</em> under the single toggles themselves. Thus, for
example, if <tt class="docutils literal"><span class="pre">vs</span> <span class="pre">==</span> <span class="pre">[1,2]</span></tt>, then the orbit has the
form <span class="math">\((I, T_2 T_1 I, T_2 T_1 T_2 T_1 I, \ldots)\)</span>
(where <span class="math">\(I\)</span> denotes <tt class="docutils literal"><span class="pre">oideal</span></tt> and <span class="math">\(T_i\)</span> means
toggling at <span class="math">\(i\)</span>) rather than
<span class="math">\((I, T_1 I, T_2 T_1 I, T_1 T_2 T_1 I, \ldots)\)</span>.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">vs</span></tt>: a list (or other iterable) of elements of <tt class="docutils literal"><span class="pre">self</span></tt>
(but since the output depends on the order, sets should
not be used as <tt class="docutils literal"><span class="pre">vs</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">oideal</span></tt> &#8211; an order ideal of <tt class="docutils literal"><span class="pre">self</span></tt>, given as an
iterable.</li>
<li><tt class="docutils literal"><span class="pre">element_constructor</span></tt> (defaults to <tt class="docutils literal"><span class="pre">set</span></tt>) &#8211; a type
constructor (<tt class="docutils literal"><span class="pre">set</span></tt>, <tt class="docutils literal"><span class="pre">tuple</span></tt>, <tt class="docutils literal"><span class="pre">list</span></tt>, <tt class="docutils literal"><span class="pre">frozenset</span></tt>,
<tt class="docutils literal"><span class="pre">iter</span></tt>, etc.) which is to be applied to the order
ideals before they are yielded.</li>
<li><tt class="docutils literal"><span class="pre">stop</span></tt> &#8211; a Boolean (default: <tt class="docutils literal"><span class="pre">True</span></tt>) determining
whether the iterator should stop once it completes its
cycle (this happens when it is set to <tt class="docutils literal"><span class="pre">True</span></tt>) or go on
forever (this happens when it is set to <tt class="docutils literal"><span class="pre">False</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">check</span></tt> &#8211; a Boolean (default: <tt class="docutils literal"><span class="pre">True</span></tt>) determining
whether <tt class="docutils literal"><span class="pre">oideal</span></tt> should be checked for being an
order ideal.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an iterator over the orbit of the order ideal <tt class="docutils literal"><span class="pre">oideal</span></tt>
under toggling the vertices in the list <tt class="docutils literal"><span class="pre">vs</span></tt> in this
order. This iterator <span class="math">\(I\)</span> has the property that
<tt class="docutils literal"><span class="pre">I[0]</span> <span class="pre">==</span> <span class="pre">oideal</span></tt> and that every <span class="math">\(i\)</span> satisfies
<tt class="docutils literal"><span class="pre">self.order_ideal_toggles(I[i],</span> <span class="pre">vs)</span> <span class="pre">==</span> <span class="pre">I[i+1]</span></tt>, where
<tt class="docutils literal"><span class="pre">I[i+1]</span></tt> has to be understood as <tt class="docutils literal"><span class="pre">I[0]</span></tt> if it is
undefined.
The entries <tt class="docutils literal"><span class="pre">I[i]</span></tt> are sets by default, but depending on
the optional keyword variable <tt class="docutils literal"><span class="pre">element_constructors</span></tt>
they can also be tuples, lists etc.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}, set(), {1, 2, 3}]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}, {1, 2, 3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[1, 2], [1, 2, 3], []]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">))</span>
<span class="go">[frozenset({1, 2}), frozenset({1, 2, 3}), frozenset()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 2, 3), ()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 2, 3), ()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([],</span> <span class="p">[]))</span>
<span class="go">[set()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">Piter</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">stop</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits">
<tt class="descname">toggling_orbits</tt><big>(</big><em>vs</em>, <em>element_constructor=&lt;type 'set'&gt;</em><big>)</big><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the orbits of order ideals in <tt class="docutils literal"><span class="pre">self</span></tt> under the
operation of toggling the vertices <tt class="docutils literal"><span class="pre">vs[0],</span> <span class="pre">vs[1],</span> <span class="pre">...</span></tt>
in this order.</p>
<p>See <tt class="xref py py-meth docutils literal"><span class="pre">order_ideal_toggle()</span></tt> for a definition of toggling.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The orbits are those under the composition of toggles,
<em>not</em> under the single toggles themselves. Thus, for
example, if <tt class="docutils literal"><span class="pre">vs</span> <span class="pre">==</span> <span class="pre">[1,2]</span></tt>, then the orbits have the
form <span class="math">\((I, T_2 T_1 I, T_2 T_1 T_2 T_1 I, \ldots)\)</span>
(where <span class="math">\(I\)</span> denotes an order ideal and <span class="math">\(T_i\)</span> means
toggling at <span class="math">\(i\)</span>) rather than
<span class="math">\((I, T_1 I, T_2 T_1 I, T_1 T_2 T_1 I, \ldots)\)</span>.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">vs</span></tt>: a list (or other iterable) of elements of <tt class="docutils literal"><span class="pre">self</span></tt>
(but since the output depends on the order, sets should
not be used as <tt class="docutils literal"><span class="pre">vs</span></tt>).</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a partition of the order ideals of <tt class="docutils literal"><span class="pre">self</span></tt>, as a list of
sets <tt class="docutils literal"><span class="pre">L</span></tt> such that for each <tt class="docutils literal"><span class="pre">L</span></tt> and <tt class="docutils literal"><span class="pre">i</span></tt>, cyclically:
<tt class="docutils literal"><span class="pre">self.order_ideal_toggles(L[i],</span> <span class="pre">vs)</span> <span class="pre">==</span> <span class="pre">L[i+1]</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">toggling_orbits</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[2, 3, 3]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">toggling_orbits</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
<span class="go">[3, 3]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="finite_permutation_groups.html"
                                  title="previous chapter">Finite Permutation Groups</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="finite_semigroups.html"
                                  title="next chapter">Finite semigroups</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/categories/finite_posets.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="finite_semigroups.html" title="Finite semigroups"
             >next</a> |</li>
        <li class="right" >
          <a href="finite_permutation_groups.html" title="Finite Permutation Groups"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Category Framework</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>