<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=600, initial-scale=1">
    <title>PARI C-library interface &mdash; Sage Reference Manual v7.3: C/C++ Library Interfaces</title>
    
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '7.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v7.3: C/C++ Library Interfaces" href="../../../index.html" />
    <link rel="next" title="Convert Python functions to PARI closures" href="closure.html" />
    <link rel="prev" title="Sage class for PARI’s GEN type" href="gen.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="closure.html" title="Convert Python functions to PARI closures"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="gen.html" title="Sage class for PARI’s GEN type"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">C/C++ Library Interfaces</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="pari-c-library-interface">
<span id="sage-libs-pari-pari-instance"></span><h1>PARI C-library interface<a class="headerlink" href="#pari-c-library-interface" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.libs.pari.pari_instance"></span><p>AUTHORS:</p>
<ul class="simple">
<li>William Stein (2006-03-01): updated to work with PARI 2.2.12-beta</li>
<li>William Stein (2006-03-06): added newtonpoly</li>
<li>Justin Walker: contributed some of the function definitions</li>
<li>Gonzalo Tornaria: improvements to conversions; much better error
handling.</li>
<li>Robert Bradshaw, Jeroen Demeyer, William Stein (2010-08-15):
Upgrade to PARI 2.4.3 (<a class="reference external" href="https://trac.sagemath.org/9343">trac ticket #9343</a>)</li>
<li>Jeroen Demeyer (2011-11-12): rewrite various conversion routines
(<a class="reference external" href="https://trac.sagemath.org/11611">trac ticket #11611</a>, <a class="reference external" href="https://trac.sagemath.org/11854">trac ticket #11854</a>, <a class="reference external" href="https://trac.sagemath.org/11952">trac ticket #11952</a>)</li>
<li>Peter Bruin (2013-11-17): split off this file from gen.pyx
(<a class="reference external" href="https://trac.sagemath.org/15185">trac ticket #15185</a>)</li>
<li>Jeroen Demeyer (2014-02-09): upgrade to PARI 2.7 (<a class="reference external" href="https://trac.sagemath.org/15767">trac ticket #15767</a>)</li>
<li>Jeroen Demeyer (2014-09-19): upgrade to PARI 2.8 (<a class="reference external" href="https://trac.sagemath.org/16997">trac ticket #16997</a>)</li>
<li>Jeroen Demeyer (2015-03-17): automatically generate methods from
<code class="docutils literal"><span class="pre">pari.desc</span></code> (<a class="reference external" href="https://trac.sagemath.org/17631">trac ticket #17631</a> and <a class="reference external" href="https://trac.sagemath.org/17860">trac ticket #17860</a>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;5! + 10/x&#39;</span><span class="p">)</span>
<span class="go">(120*x + 10)/x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;intnum(x=0,13,sin(x)+sin(x^2) + x)&#39;</span><span class="p">)</span>
<span class="go">83.8179442684285  # 32-bit</span>
<span class="go">84.1818153922297  # 64-bit</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^3-1&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">factor</span><span class="p">();</span> <span class="n">v</span>
<span class="go">[x - 1, 1; x^2 + x + 1, 1]</span>
<span class="gp">sage: </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="c1"># indexing is 0-based unlike in GP.</span>
<span class="go">[x - 1, x^2 + x + 1]~</span>
<span class="gp">sage: </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[1, 1]~</span>
</pre></div>
</div>
<p>Arithmetic obeys the usual coercion rules:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">&lt;type &#39;sage.libs.pari.gen.gen&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">&lt;type &#39;sage.libs.pari.gen.gen&#39;&gt;</span>
</pre></div>
</div>
<p>GUIDE TO REAL PRECISION AND THE PARI LIBRARY</p>
<p>The default real precision in communicating with the PARI library
is the same as the default Sage real precision, which is 53 bits.
Inexact Pari objects are therefore printed by default to 15 decimal
digits (even if they are actually more precise).</p>
<p>Default precision example (53 bits, 15 significant decimals):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mf">1.23</span><span class="p">);</span> <span class="n">a</span>
<span class="go">1.23000000000000</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">sin</span><span class="p">()</span>
<span class="go">0.942488801931698</span>
</pre></div>
</div>
<p>Example with custom precision of 200 bits (60 significant
decimals):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RealField</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mf">1.23</span><span class="p">));</span> <span class="n">a</span>   <span class="c1"># only 15 significant digits printed</span>
<span class="go">1.23000000000000</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>         <span class="c1"># but the number is known to precision of 200 bits</span>
<span class="go">1.2300000000000000000000000000000000000000000000000000000000</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">sin</span><span class="p">()</span>      <span class="c1"># only 15 significant digits printed</span>
<span class="go">0.942488801931698</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">sin</span><span class="p">())</span>   <span class="c1"># but the number is known to precision of 200 bits</span>
<span class="go">0.94248880193169751002382356538924454146128740562765030213504</span>
</pre></div>
</div>
<p>It is possible to change the number of printed decimals:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RealField</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>    <span class="c1"># 200 bits of precision in computations</span>
<span class="gp">sage: </span><span class="n">old_prec</span> <span class="o">=</span> <span class="n">pari</span><span class="o">.</span><span class="n">set_real_precision</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>  <span class="c1"># 60 decimals printed</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mf">1.23</span><span class="p">));</span> <span class="n">a</span>
<span class="go">1.23000000000000000000000000000000000000000000000000000000000</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">sin</span><span class="p">()</span>
<span class="go">0.942488801931697510023823565389244541461287405627650302135038</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">set_real_precision</span><span class="p">(</span><span class="n">old_prec</span><span class="p">)</span>  <span class="c1"># restore the default printing behavior</span>
<span class="go">60</span>
</pre></div>
</div>
<p>Unless otherwise indicated in the docstring, most Pari functions
that return inexact objects use the precision of their arguments to
decide the precision of the computation. However, if some of these
arguments happen to be exact numbers (integers, rationals, etc.),
an optional parameter indicates the precision (in bits) to which
these arguments should be converted before the computation. If this
precision parameter is missing, the default precision of 53 bits is
used. The following first converts 2 into a real with 53-bit
precision:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RealField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">(</span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sin</span><span class="p">())</span>
<span class="go">0.909297426825682</span>
</pre></div>
</div>
<p>We can ask for a better precision using the optional parameter:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RealField</span><span class="p">(</span><span class="mi">150</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">(</span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">150</span><span class="p">))</span>
<span class="go">0.90929742682568169539601986591174484270225497</span>
</pre></div>
</div>
<p>Warning regarding conversions Sage - Pari - Sage: Some care must be
taken when juggling inexact types back and forth between Sage and
Pari. In theory, calling p=pari(s) creates a Pari object p with the
same precision as s; in practice, the Pari library&#8217;s precision is
word-based, so it will go up to the next word. For example, a
default 53-bit Sage real s will be bumped up to 64 bits by adding
bogus 11 bits. The function p.python() returns a Sage object with
exactly the same precision as the Pari object p. So
pari(s).python() is definitely not equal to s, since it has 64 bits
of precision, including the bogus 11 bits. The correct way of
avoiding this is to coerce pari(s).python() back into a domain with
the right precision. This has to be done by the user (or by Sage
functions that use Pari library functions in gen.pyx). For
instance, if we want to use the Pari library to compute sqrt(pi)
with a precision of 100 bits:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RealField</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">pi</span><span class="p">);</span> <span class="n">s</span>
<span class="go">3.1415926535897932384626433833</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">x</span>  <span class="c1"># wow, more digits than I expected!</span>
<span class="go">1.7724538509055160272981674833410973484</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">prec</span><span class="p">()</span>           <span class="c1"># has precision &#39;improved&#39; from 100 to 128?</span>
<span class="go">128</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">==</span> <span class="n">RealField</span><span class="p">(</span><span class="mi">128</span><span class="p">)(</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>  <span class="c1"># sadly, no!</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>               <span class="c1"># x should be brought back to precision 100</span>
<span class="go">1.7724538509055160272981674833</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Elliptic curves and precision: If you are working with elliptic
curves, you should set the precision for each method:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">82</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">eta1</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">elleta</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">100</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">eta1</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">3.6054636014326520859158205642077267748</span>
<span class="gp">sage: </span><span class="n">eta1</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">elleta</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">180</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">eta1</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">3.60546360143265208591582056420772677481026899659802474544</span>
</pre></div>
</div>
<p>Number fields and precision: TODO</p>
<p>TESTS:</p>
<p>Check that output from PARI&#8217;s print command is actually seen by
Sage (<a class="reference external" href="https://trac.sagemath.org/9636">trac ticket #9636</a>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;print(&quot;test&quot;)&#39;</span><span class="p">)</span>
<span class="go">test</span>
</pre></div>
</div>
<p>Check that <code class="docutils literal"><span class="pre">default()</span></code> works properly:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">67</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">IFAC: cracking composite</span>
<span class="go">        49191317529892137643</span>
<span class="go">IFAC: factor 6713103182899</span>
<span class="go">        is prime</span>
<span class="go">IFAC: factor 7327657</span>
<span class="go">        is prime</span>
<span class="go">IFAC: prime 7327657</span>
<span class="go">        appears with exponent = 1</span>
<span class="go">IFAC: prime 6713103182899</span>
<span class="go">        appears with exponent = 1</span>
<span class="go">IFAC: found 2 large prime (power) factors.</span>
<span class="go">[3, 1; 7327657, 1; 6713103182899, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">67</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[3, 1; 7327657, 1; 6713103182899, 1]</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.libs.pari.pari_instance.PariInstance">
<em class="property">class </em><code class="descclassname">sage.libs.pari.pari_instance.</code><code class="descname">PariInstance</code><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.libs.pari.pari_instance.PariInstance_auto" title="sage.libs.pari.pari_instance.PariInstance_auto"><code class="xref py py-class docutils literal"><span class="pre">sage.libs.pari.pari_instance.PariInstance_auto</span></code></a></p>
<p>Initialize the PARI system.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">size</span></code> &#8211; long, the number of bytes for the initial
PARI stack (see note below)</li>
<li><code class="docutils literal"><span class="pre">maxprime</span></code> &#8211; unsigned long, upper limit on a
precomputed prime number table (default: 500000)</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In Sage, the PARI stack is different than in GP or the
PARI C library. In Sage, instead of the PARI stack
holding the results of all computations, it <em>only</em> holds
the results of an individual computation. Each time a new
Python/PARI object is computed, it it copied to its own
space in the Python heap, and the memory it occupied on the
PARI stack is freed. Thus it is not necessary to make the
stack very large. Also, unlike in PARI, if the stack does
overflow, in most cases the PARI stack is automatically
increased and the relevant step of the computation rerun.</p>
<p class="last">This design obviously involves some performance penalties
over the way PARI works, but it scales much better and is
far more robust for large projects.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you do not want prime numbers, put <code class="docutils literal"><span class="pre">maxprime=2</span></code>, but be
careful because many PARI functions require this table. If
you get the error message &#8220;not enough precomputed primes&#8221;,
increase this parameter.</p>
</div>
<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.List">
<code class="descname">List</code><span class="sig-paren">(</span><em>x=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.List" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an empty list or convert <span class="math">\(x\)</span> to a list.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">List([0, 1, 2, 3, 4])</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">pari</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span>
<span class="go">List([])</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">listput</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">sage: </span><span class="n">L</span>
<span class="go">List([42])</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">listinsert</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">24</span>
<span class="gp">sage: </span><span class="n">L</span>
<span class="go">List([24, 42])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.libs.pari.pari_instance.PariInstance.PARI_ONE">
<code class="descname">PARI_ONE</code><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.PARI_ONE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="sage.libs.pari.pari_instance.PariInstance.PARI_TWO">
<code class="descname">PARI_TWO</code><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.PARI_TWO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="sage.libs.pari.pari_instance.PariInstance.PARI_ZERO">
<code class="descname">PARI_ZERO</code><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.PARI_ZERO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.allocatemem">
<code class="descname">allocatemem</code><span class="sig-paren">(</span><em>s=0</em>, <em>sizemax=0</em>, <em>silent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.allocatemem" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the PARI stack space to the given size <code class="docutils literal"><span class="pre">s</span></code> (or double
the current size if <code class="docutils literal"><span class="pre">s</span></code> is <span class="math">\(0\)</span>) and change the maximum stack
size to <code class="docutils literal"><span class="pre">sizemax</span></code>.</p>
<p>PARI tries to use only its current stack (the size which is set
by <code class="docutils literal"><span class="pre">s</span></code>), but it will increase its stack if needed up to the
maximum size which is set by <code class="docutils literal"><span class="pre">sizemax</span></code>.</p>
<p>The PARI stack is never automatically shrunk.  You can use the
command <code class="docutils literal"><span class="pre">pari.allocatemem(10^6)</span></code> to reset the size to <span class="math">\(10^6\)</span>,
which is the default size at startup.  Note that the results of
computations using Sage&#8217;s PARI interface are copied to the
Python heap, so they take up no space in the PARI stack.
The PARI stack is cleared after every computation.</p>
<p>It does no real harm to set this to a small value as the PARI
stack will be automatically doubled when we run out of memory.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">s</span></code> - an integer (default: 0).  A non-zero argument is the
size in bytes of the new PARI stack.  If <span class="math">\(s\)</span> is zero, double
the current stack size.</li>
<li><code class="docutils literal"><span class="pre">sizemax</span></code> - an integer (default: 0).  A non-zero argument
is the maximum size in bytes of the PARI stack.  If
<code class="docutils literal"><span class="pre">sizemax</span></code> is 0, the maximum of the current maximum and
<code class="docutils literal"><span class="pre">s</span></code> is taken.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">allocatemem</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">7</span><span class="p">)</span>
<span class="go">PARI stack size set to 10000000 bytes, maximum size set to 67108864</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">allocatemem</span><span class="p">()</span>  <span class="c1"># Double the current size</span>
<span class="go">PARI stack size set to 20000000 bytes, maximum size set to 67108864</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">stacksize</span><span class="p">()</span>
<span class="go">20000000</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">allocatemem</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">6</span><span class="p">)</span>
<span class="go">PARI stack size set to 1000000 bytes, maximum size set to 67108864</span>
</pre></div>
</div>
<p>The following computation will automatically increase the PARI
stack size:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;2^100000000&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">a</span></code> is now a Python variable on the Python heap and does not
take up any space on the PARI stack.  The PARI stack is still
large because of the computation of <code class="docutils literal"><span class="pre">a</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">stacksize</span><span class="p">()</span>
<span class="go">16000000</span>
</pre></div>
</div>
<p>Setting a small maximum size makes this fail:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">allocatemem</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="o">^</span><span class="mi">22</span><span class="p">)</span>
<span class="go">PARI stack size set to 1000000 bytes, maximum size set to 4194304</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;2^100000000&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">_^s: the PARI stack overflows (current size: 1000000; maximum size: 4194304)</span>
<span class="go">You can use pari.allocatemem() to change the stack size and try again</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Do the same without using the string interface and starting
from a very small stack size:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">allocatemem</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">^</span><span class="mi">26</span><span class="p">)</span>
<span class="go">PARI stack size set to 1024 bytes, maximum size set to 67108864</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">100000000</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">stacksize</span><span class="p">()</span>
<span class="go">16777216</span>
</pre></div>
</div>
<p>We do not allow <code class="docutils literal"><span class="pre">sizemax</span></code> less than <code class="docutils literal"><span class="pre">s</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">allocatemem</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="o">^</span><span class="mi">6</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">the maximum size (10000000) should be at least the stack size (1000000)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.complex">
<code class="descname">complex</code><span class="sig-paren">(</span><em>re</em>, <em>im</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new complex number, initialized from re and im.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.debugstack">
<code class="descname">debugstack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.debugstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the internal PARI variables <code class="docutils literal"><span class="pre">top</span></code> (top of stack), <code class="docutils literal"><span class="pre">avma</span></code>
(available memory address, think of this as the stack pointer),
<code class="docutils literal"><span class="pre">bot</span></code> (bottom of stack).</p>
<p>EXAMPLE:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">debugstack</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">top =  0x60b2c60</span>
<span class="go">avma = 0x5875c38</span>
<span class="go">bot =  0x57295e0</span>
<span class="go">size = 1000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.double_to_gen">
<code class="descname">double_to_gen</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.double_to_gen" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.euler">
<code class="descname">euler</code><span class="sig-paren">(</span><em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.euler" title="Permalink to this definition">¶</a></dt>
<dd><p>Euler&#8217;s constant <span class="math">\(\gamma = 0.57721...\)</span>. Note that
<code class="docutils literal"><span class="pre">Euler</span></code> is one of the few reserved names which cannot be used for
user variables.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.factorial">
<code class="descname">factorial</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.factorial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the factorial of the integer n as a PARI gen.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">120</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>
<span class="go">15511210043330985984000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.genus2red">
<code class="descname">genus2red</code><span class="sig-paren">(</span><em>P</em>, <em>P0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.genus2red" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(P\)</span> be a polynomial with integer coefficients.
Determines the reduction of the (proper, smooth) genus 2
curve <span class="math">\(C/\QQ\)</span>, defined by the hyperelliptic equation <span class="math">\(y^2 = P\)</span>.
The special syntax <code class="docutils literal"><span class="pre">genus2red([P,Q])</span></code> is also allowed, where
the polynomials <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> have integer coefficients, to
represent the model <span class="math">\(y^2 + Q(x)y = P(x)\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">genus2red</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">5</span><span class="p">,</span> <span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[1416875, [2, -1; 5, 4; 2267, 1], x^6 - 240*x^4 - 2550*x^3 - 11400*x^2 - 24100*x - 19855, [[2, [2, [Mod(1, 2)]], []], [5, [1, []], [&quot;[V] page 156&quot;, [3]]], [2267, [2, [Mod(432, 2267)]], [&quot;[I{1-0-0}] page 170&quot;, []]]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.get_debug_level">
<code class="descname">get_debug_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.get_debug_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the debug PARI C library variable.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.get_real_precision">
<code class="descname">get_real_precision</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.get_real_precision" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current PARI default real precision.</p>
<p>This is used both for creation of new objects from strings and for
printing. It is the number of digits <em>IN DECIMAL</em> in which real
numbers are printed. It also determines the precision of objects
created by parsing strings (e.g. pari(&#8216;1.2&#8217;)), which is <em>not</em> the
normal way of creating new pari objects in Sage. It has <em>no</em>
effect on the precision of computations within the pari library.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">get_real_precision</span><span class="p">()</span>
<span class="go">15</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.get_series_precision">
<code class="descname">get_series_precision</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.get_series_precision" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.init_primes">
<code class="descname">init_primes</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.init_primes" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute the primes table including at least all primes up to M
(but possibly more).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">init_primes</span><span class="p">(</span><span class="mi">200000</span><span class="p">)</span>
</pre></div>
</div>
<p>We make sure that ticket <a class="reference external" href="https://trac.sagemath.org/11741">trac ticket #11741</a> has been fixed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">init_primes</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">30</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Cannot compute primes beyond 436273290</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.matrix">
<code class="descname">matrix</code><span class="sig-paren">(</span><em>m</em>, <em>n</em>, <em>entries=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>matrix(long m, long n, entries=None): Create and return the m x n
PARI matrix with given list of entries.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.new_with_bits_prec">
<code class="descname">new_with_bits_prec</code><span class="sig-paren">(</span><em>s</em>, <em>precision</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.new_with_bits_prec" title="Permalink to this definition">¶</a></dt>
<dd><p>pari.new_with_bits_prec(self, s, precision) creates s as a PARI
gen with (at most) precision <em>bits</em> of precision.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.nth_prime">
<code class="descname">nth_prime</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.nth_prime" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <code class="xref py py-meth docutils literal"><span class="pre">prime()</span></code> instead.
See <a class="reference external" href="https://trac.sagemath.org/20216">trac ticket #20216</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.one">
<code class="descname">one</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.one" title="Permalink to this definition">¶</a></dt>
<dd><p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.pari_version">
<code class="descname">pari_version</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.pari_version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.pi">
<code class="descname">pi</code><span class="sig-paren">(</span><em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.pi" title="Permalink to this definition">¶</a></dt>
<dd><p>The constant <span class="math">\(\Pi\)</span> (<span class="math">\(3.14159...\)</span>). Note that <code class="docutils literal"><span class="pre">Pi</span></code> is one of the few
reserved names which cannot be used for user variables.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.polchebyshev">
<code class="descname">polchebyshev</code><span class="sig-paren">(</span><em>n</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.polchebyshev" title="Permalink to this definition">¶</a></dt>
<dd><p>Chebyshev polynomial of the first kind of degree <span class="math">\(n\)</span>,
in the variable <span class="math">\(v\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">polchebyshev</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">64*x^7 - 112*x^5 + 56*x^3 - 7*x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">polchebyshev</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="go">64*z^7 - 112*z^5 + 56*z^3 - 7*z</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">polchebyshev</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.polcyclo_eval">
<code class="descname">polcyclo_eval</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.polcyclo_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <code class="xref py py-meth docutils literal"><span class="pre">polcyclo()</span></code> instead.
See <a class="reference external" href="https://trac.sagemath.org/20217">trac ticket #20217</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.polsubcyclo">
<code class="descname">polsubcyclo</code><span class="sig-paren">(</span><em>n</em>, <em>d</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.polsubcyclo" title="Permalink to this definition">¶</a></dt>
<dd><p>polsubcyclo(n, d, v=x): return the pari list of polynomial(s)
defining the sub-abelian extensions of degree <span class="math">\(d\)</span> of the
cyclotomic field <span class="math">\(\QQ(\zeta_n)\)</span>, where <span class="math">\(d\)</span>
divides <span class="math">\(\phi(n)\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">polsubcyclo</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">[x^4 + 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">polsubcyclo</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="go">[z^2 + 2, z^2 - 2, z^2 + 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">polsubcyclo</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[x - 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">polsubcyclo</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.poltchebi">
<code class="descname">poltchebi</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.poltchebi" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.libs.pari.pari_instance.PariInstance.polchebyshev" title="sage.libs.pari.pari_instance.PariInstance.polchebyshev"><code class="xref py py-meth docutils literal"><span class="pre">polchebyshev()</span></code></a> instead.
See <a class="reference external" href="https://trac.sagemath.org/18203">trac ticket #18203</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.prime_list">
<code class="descname">prime_list</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.prime_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.libs.pari.pari_instance.PariInstance.primes" title="sage.libs.pari.pari_instance.PariInstance.primes"><code class="xref py py-meth docutils literal"><span class="pre">primes()</span></code></a> instead.
See <a class="reference external" href="https://trac.sagemath.org/20216">trac ticket #20216</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.primes">
<code class="descname">primes</code><span class="sig-paren">(</span><em>n=None</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.primes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pari vector containing the first <span class="math">\(n\)</span> primes, the primes
in the interval <span class="math">\([n, end]\)</span>, or the primes up to <span class="math">\(end\)</span>.</p>
<p>INPUT:</p>
<p>Either</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">n</span></code> &#8211; integer</li>
</ul>
<p>or</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">n</span></code> &#8211; list or tuple <span class="math">\([a, b]\)</span> defining an interval of primes</li>
</ul>
<p>or</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">n,</span> <span class="pre">end</span></code> &#8211; start and end point of an interval of primes</li>
</ul>
<p>or</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">end</span></code> &#8211; end point for the list of primes</li>
</ul>
<p>OUTPUT: a PARI list of prime numbers</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">primes</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[2, 3, 5]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">primes</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">primes</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">pari</span><span class="o">.</span><span class="n">primes</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>
<span class="go">1000</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">primes</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">29</span><span class="p">)</span>
<span class="go">[11, 13, 17, 19, 23, 29]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">primes</span><span class="p">((</span><span class="mi">11</span><span class="p">,</span><span class="mi">29</span><span class="p">))</span>
<span class="go">[11, 13, 17, 19, 23, 29]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">primes</span><span class="p">(</span><span class="n">end</span><span class="o">=</span><span class="mi">29</span><span class="p">)</span>
<span class="go">[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">primes</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">30</span><span class="p">,</span> <span class="mi">10</span><span class="o">^</span><span class="mi">30</span> <span class="o">+</span> <span class="mi">100</span><span class="p">)</span>
<span class="go">[1000000000000000000000000000057, 1000000000000000000000000000099]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">primes</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">primes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">primes</span><span class="p">(</span><span class="n">end</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">primes</span><span class="p">(</span><span class="n">end</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">primes</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.primes_up_to_n">
<code class="descname">primes_up_to_n</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.primes_up_to_n" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.set_debug_level">
<code class="descname">set_debug_level</code><span class="sig-paren">(</span><em>level</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.set_debug_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the debug PARI C library variable.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.set_real_precision">
<code class="descname">set_real_precision</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.set_real_precision" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the PARI default real precision in decimal digits.</p>
<p>This is used both for creation of new objects from strings and for
printing. It is the number of digits <em>IN DECIMAL</em> in which real
numbers are printed. It also determines the precision of objects
created by parsing strings (e.g. pari(&#8216;1.2&#8217;)), which is <em>not</em> the
normal way of creating new pari objects in Sage. It has <em>no</em>
effect on the precision of computations within the pari library.</p>
<p>Returns the previous PARI real precision.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">set_real_precision</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1.2&#39;</span><span class="p">)</span>
<span class="go">1.20000000000000000000000000000000000000000000000000000000000</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">set_real_precision</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="go">60</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.set_series_precision">
<code class="descname">set_series_precision</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.set_series_precision" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.setrand">
<code class="descname">setrand</code><span class="sig-paren">(</span><em>seed</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.setrand" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets PARI&#8217;s current random number seed.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">seed</span></code> &#8211; either a strictly positive integer or a GEN of
type <code class="docutils literal"><span class="pre">t_VECSMALL</span></code> as output by <code class="docutils literal"><span class="pre">getrand()</span></code></li>
</ul>
<p>This should not be called directly; instead, use Sage&#8217;s global
random number seed handling in <code class="docutils literal"><span class="pre">sage.misc.randstate</span></code>
and call <code class="docutils literal"><span class="pre">current_randstate().set_seed_pari()</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">setrand</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="o">.</span><span class="n">getrand</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">setrand</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">==</span> <span class="n">pari</span><span class="o">.</span><span class="n">getrand</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Check that invalid inputs are handled properly (<a class="reference external" href="https://trac.sagemath.org/11825">trac ticket #11825</a>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">setrand</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">incorrect type in setrand (t_POL)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.stacksize">
<code class="descname">stacksize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.stacksize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current size of the PARI stack, which is <span class="math">\(10^6\)</span>
by default.  However, the stack size is automatically doubled
when needed up to some maximum.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.libs.pari.pari_instance.PariInstance.stacksizemax" title="sage.libs.pari.pari_instance.PariInstance.stacksizemax"><code class="xref py py-meth docutils literal"><span class="pre">stacksizemax()</span></code></a> to get the maximum stack size</li>
<li><a class="reference internal" href="#sage.libs.pari.pari_instance.PariInstance.allocatemem" title="sage.libs.pari.pari_instance.PariInstance.allocatemem"><code class="xref py py-meth docutils literal"><span class="pre">allocatemem()</span></code></a> to change the current or maximum
stack size</li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">stacksize</span><span class="p">()</span>
<span class="go">1000000</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">allocatemem</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">18</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">stacksize</span><span class="p">()</span>
<span class="go">262144</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.stacksizemax">
<code class="descname">stacksizemax</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.stacksizemax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum size of the PARI stack, which is determined
at startup in terms of available memory. Usually, the PARI
stack size is (much) smaller than this maximum but the stack
will be increased up to this maximum if needed.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#sage.libs.pari.pari_instance.PariInstance.stacksize" title="sage.libs.pari.pari_instance.PariInstance.stacksize"><code class="xref py py-meth docutils literal"><span class="pre">stacksize()</span></code></a> to get the current stack size</li>
<li><a class="reference internal" href="#sage.libs.pari.pari_instance.PariInstance.allocatemem" title="sage.libs.pari.pari_instance.PariInstance.allocatemem"><code class="xref py py-meth docutils literal"><span class="pre">allocatemem()</span></code></a> to change the current or maximum
stack size</li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">allocatemem</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">18</span><span class="p">,</span> <span class="mi">2</span><span class="o">^</span><span class="mi">26</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">stacksizemax</span><span class="p">()</span>
<span class="go">67108864</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.vector">
<code class="descname">vector</code><span class="sig-paren">(</span><em>n</em>, <em>entries=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.vector" title="Permalink to this definition">¶</a></dt>
<dd><p>vector(long n, entries=None): Create and return the length n PARI
vector with given list of entries.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">vector</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[1, 2, 5, 4, 3]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">vector</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[x, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">vector</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">length of entries (=3) must equal n (=2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance.zero">
<code class="descname">zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance.zero" title="Permalink to this definition">¶</a></dt>
<dd><p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto">
<em class="property">class </em><code class="descclassname">sage.libs.pari.pari_instance.</code><code class="descname">PariInstance_auto</code><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/parent_base.html#sage.structure.parent_base.ParentWithBase" title="(in Sage Reference Manual: Basic Structures v7.3)"><code class="xref py py-class docutils literal"><span class="pre">sage.structure.parent_base.ParentWithBase</span></code></a></p>
<p>Part of the <a class="reference internal" href="#sage.libs.pari.pari_instance.PariInstance" title="sage.libs.pari.pari_instance.PariInstance"><code class="xref py py-class docutils literal"><span class="pre">PariInstance</span></code></a> class containing auto-generated functions.</p>
<p>You must never use this class directly (in fact, Sage may crash if
you do), use the derived class <a class="reference internal" href="#sage.libs.pari.pari_instance.PariInstance" title="sage.libs.pari.pari_instance.PariInstance"><code class="xref py py-class docutils literal"><span class="pre">PariInstance</span></code></a> instead.</p>
<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.Catalan">
<code class="descname">Catalan</code><span class="sig-paren">(</span><em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.Catalan" title="Permalink to this definition">¶</a></dt>
<dd><p>Catalan&#8217;s constant <span class="math">\(G = \sum_{n &gt;= 0}((-1)^n)/((2n+1)^2) = 0.91596...\)</span>.
Note that <code class="docutils literal"><span class="pre">Catalan</span></code> is one of the few reserved names which cannot be
used for user variables.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.Euler">
<code class="descname">Euler</code><span class="sig-paren">(</span><em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.Euler" title="Permalink to this definition">¶</a></dt>
<dd><p>Euler&#8217;s constant <span class="math">\(\gamma = 0.57721...\)</span>. Note that
<code class="docutils literal"><span class="pre">Euler</span></code> is one of the few reserved names which cannot be used for
user variables.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.I">
<code class="descname">I</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.I" title="Permalink to this definition">¶</a></dt>
<dd><p>The complex number <span class="math">\(\sqrt{-1}\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.Pi">
<code class="descname">Pi</code><span class="sig-paren">(</span><em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.Pi" title="Permalink to this definition">¶</a></dt>
<dd><p>The constant <span class="math">\(\Pi\)</span> (<span class="math">\(3.14159...\)</span>). Note that <code class="docutils literal"><span class="pre">Pi</span></code> is one of the few
reserved names which cannot be used for user variables.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.addhelp">
<code class="descname">addhelp</code><span class="sig-paren">(</span><em>sym</em>, <em>str</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.addhelp" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the help message for the symbol <code class="docutils literal"><span class="pre">sym</span></code>. The string <em>str</em>
is expanded on the spot and stored as the online help for <code class="docutils literal"><span class="pre">sym</span></code>. It is
recommended to document global variables and user functions in this way,
although <code class="docutils literal"><span class="pre">gp</span></code> will not protest if you don&#8217;t.</p>
<p>You can attach a help text to an alias, but it will never be
shown: aliases are expanded by the <code class="docutils literal"><span class="pre">?</span></code> help operator and we get the help
of the symbol the alias points to. Nothing prevents you from modifying the
help of built-in PARI functions. But if you do, we would like to hear why you
needed it!</p>
<p>Without <code class="docutils literal"><span class="pre">addhelp</span></code>, the standard help for user functions consists of its
name and definition.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>gp&gt; f(x) = x^2;
gp&gt; ?f
f =
 (x)-&gt;x^2
</pre></div>
</div>
<p>Once addhelp is applied to <span class="math">\(f\)</span>, the function code is no
longer included. It can still be consulted by typing the function name:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>gp&gt; addhelp(f, &quot;Square&quot;)
gp&gt; ?f
Square

gp&gt; f
%2 = (x)-&gt;x^2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.bernfrac">
<code class="descname">bernfrac</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.bernfrac" title="Permalink to this definition">¶</a></dt>
<dd><p>Bernoulli number <span class="math">\(B_x\)</span>,
where <span class="math">\(B_0 = 1\)</span>, <span class="math">\(B_1 = -1/2\)</span>, <span class="math">\(B_2 = 1/6\)</span>,..., expressed as a rational number.
The argument <span class="math">\(x\)</span> should be of type integer.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.bernpol">
<code class="descname">bernpol</code><span class="sig-paren">(</span><em>n</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.bernpol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bernoulli polynomial <span class="math">\(B_n\)</span> in variable <span class="math">\(v\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? bernpol(1)
%1 = x - 1/2
? bernpol(3)
%2 = x^3 - 3/2*x^2 + 1/2*x
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.bernreal">
<code class="descname">bernreal</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.bernreal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bernoulli number
<span class="math">\(B_x\)</span>, as <code class="docutils literal"><span class="pre">bernfrac</span></code>, but <span class="math">\(B_x\)</span> is returned as a real number
(with the current precision).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.bernvec">
<code class="descname">bernvec</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.bernvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a vector containing, as rational numbers,
the Bernoulli numbers <span class="math">\(B_0\)</span>, <span class="math">\(B_2\)</span>,..., <span class="math">\(B_{2x}\)</span>.
This routine is obsolete. Use <code class="docutils literal"><span class="pre">bernfrac</span></code> instead each time you need a
Bernoulli number in exact form.</p>
<p><strong>Note.</strong> This routine is implemented using repeated independent
calls to <code class="docutils literal"><span class="pre">bernfrac</span></code>, which is faster than the standard recursion in exact
arithmetic. It is only kept for backward compatibility: it is not faster than
individual calls to <code class="docutils literal"><span class="pre">bernfrac</span></code>, its output uses a lot of memory space,
and coping with the index shift is awkward.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.default">
<code class="descname">default</code><span class="sig-paren">(</span><em>key=None</em>, <em>val=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.default" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default corresponding to keyword <em>key</em>. If <em>val</em> is
present, sets the default to <em>val</em> first (which is subject to string
expansion first). Typing <code class="docutils literal"><span class="pre">default()</span></code> (or <code class="docutils literal"><span class="pre">\d</span></code>) yields the complete
default list as well as their current values. See <code class="docutils literal"><span class="pre">defaults</span></code> (in the PARI manual) for an
introduction to GP defaults, <code class="docutils literal"><span class="pre">gp_defaults</span></code> (in the PARI manual) for a
list of available defaults, and <code class="docutils literal"><span class="pre">meta</span></code> (in the PARI manual) for some shortcut
alternatives. Note that the shortcuts are meant for interactive use and
usually display more information than <code class="docutils literal"><span class="pre">default</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.ellmodulareqn">
<code class="descname">ellmodulareqn</code><span class="sig-paren">(</span><em>N</em>, <em>x=None</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.ellmodulareqn" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vector [<code class="docutils literal"><span class="pre">eqn</span></code>,:math:<span class="math">\(t\)</span>] where <code class="docutils literal"><span class="pre">eqn</span></code> is a modular equation of
level <span class="math">\(N\)</span>, i.e.&nbsp;a bivariate polynomial with integer coefficients; <span class="math">\(t\)</span>
indicates the type of this equation: either <em>canonical</em> (<span class="math">\(t = 0\)</span>) or
<em>Atkin</em> (<span class="math">\(t = 1\)</span>). This function currently requires the package
<code class="docutils literal"><span class="pre">seadata</span></code> to be installed and is limited to <span class="math">\(N &lt; 500\)</span>, <span class="math">\(N\)</span> prime.</p>
<p>Let <span class="math">\(j\)</span> be the <span class="math">\(j\)</span>-invariant function. The polynomial <code class="docutils literal"><span class="pre">eqn</span></code> satisfies
the following functional equation, which allows to compute the values of the
classical modular polynomial <span class="math">\(\Phi_N\)</span> of prime level <span class="math">\(N\)</span>, such that
<span class="math">\(\Phi_N(j(\tau), j(N\tau)) = 0\)</span>, while being much smaller than the latter:</p>
<ul class="simple">
<li>for canonical type:
<span class="math">\(P(f(\tau),j(\tau)) = P(N^s/f(\tau),j(N \tau)) = 0\)</span>,
where <span class="math">\(s = 12/\mathrm{gcd}(12,N-1)\)</span>;</li>
<li>for Atkin type:
<span class="math">\(P(f(\tau),j(\tau)) = P(f(\tau),j(N \tau)) = 0\)</span>.</li>
</ul>
<p>In both cases, <span class="math">\(f\)</span> is a suitable modular function (see below).</p>
<p>The following GP function returns values of the classical modular polynomial
by eliminating <span class="math">\(f(\tau)\)</span> in the above two equations, for <span class="math">\(N &lt;= 31\)</span> or
<span class="math">\(N belongs to {41,47,59,71}\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">classicaleqn</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="s1">&#39;X, Y=&#39;</span><span class="n">Y</span><span class="p">)</span><span class="o">=</span>
<span class="p">{</span>
 <span class="n">my</span><span class="p">(</span><span class="n">E</span><span class="o">=</span><span class="n">ellmodulareqn</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">P</span><span class="o">=</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="o">=</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
 <span class="k">if</span><span class="p">(</span><span class="n">poldegree</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;y)&gt;2,error(&quot;level unavailable in classicaleqn&quot;));</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
 <span class="n">my</span><span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="mi">12</span><span class="o">/</span><span class="n">gcd</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
 <span class="n">Q</span> <span class="o">=</span> <span class="s1">&#39;x^(N+1) * substvec(P,[&#39;</span><span class="n">x</span><span class="p">,</span><span class="s1">&#39;y],[N^s/&#39;</span><span class="n">x</span><span class="p">,</span><span class="n">Y</span><span class="p">]);</span>
 <span class="n">d</span> <span class="o">=</span> <span class="n">N</span><span class="o">^</span><span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
 <span class="p">,</span>
 <span class="n">Q</span> <span class="o">=</span> <span class="n">subst</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;y,Y);</span>
 <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="o">-</span><span class="n">Y</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
 <span class="n">polresultant</span><span class="p">(</span><span class="n">subst</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="s1">&#39;y,X), Q) / d;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>More precisely, let <span class="math">\(W_N(\tau) = ({-1})/({N \tau})\)</span> be the Atkin-Lehner
involution; we have <span class="math">\(j(W_N(\tau)) = j(N \tau)\)</span> and the function <span class="math">\(f\)</span> also
satisfies:</p>
<ul class="simple">
<li>for canonical type:
<span class="math">\(f(W_N(\tau)) = N^s/f(\tau)\)</span>;</li>
<li>for Atkin type:
<span class="math">\(f(W_N(\tau)) = f(\tau)\)</span>.</li>
</ul>
<p>Furthermore, for an equation of canonical type, <span class="math">\(f\)</span> is the standard
<span class="math">\(\eta\)</span>-quotient</p>
<div class="math">
\[f(\tau) = N^s (\eta(N \tau) / \eta(\tau) )^{2 s},\]</div>
<p>where <span class="math">\(\eta\)</span> is Dedekind&#8217;s eta function, which is invariant under
<span class="math">\(\Gamma_0(N)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.extern">
<code class="descname">extern</code><span class="sig-paren">(</span><em>str</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.extern" title="Permalink to this definition">¶</a></dt>
<dd><p>The string <em>str</em> is the name of an external command (i.e.&nbsp;one you
would type from your UNIX shell prompt). This command is immediately run and
its output fed into <code class="docutils literal"><span class="pre">gp</span></code>, just as if read from a file.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.externstr">
<code class="descname">externstr</code><span class="sig-paren">(</span><em>str</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.externstr" title="Permalink to this definition">¶</a></dt>
<dd><p>The string <em>str</em> is the name of an external command (i.e.&nbsp;one you
would type from your UNIX shell prompt). This command is immediately run and
its output is returned as a vector of GP strings, one component per output
line.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.factorial">
<code class="descname">factorial</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.factorial" title="Permalink to this definition">¶</a></dt>
<dd><p>Factorial of <span class="math">\(x\)</span>. The expression <span class="math">\(x!\)</span> gives a result which is an integer,
while <span class="math">\(factorial(x)\)</span> gives a real number.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.fibonacci">
<code class="descname">fibonacci</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.fibonacci" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x-th\)</span> Fibonacci number.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.galoisgetpol">
<code class="descname">galoisgetpol</code><span class="sig-paren">(</span><em>a</em>, <em>b=0</em>, <em>s=1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.galoisgetpol" title="Permalink to this definition">¶</a></dt>
<dd><p>Query the galpol package for a polynomial with Galois group isomorphic to
GAP4(a,b), totally real if <span class="math">\(s = 1\)</span> (default) and totally complex if <span class="math">\(s = 2\)</span>. The
output is a vector [<code class="docutils literal"><span class="pre">pol</span></code>, <code class="docutils literal"><span class="pre">den</span></code>] where</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">pol</span></code> is the polynomial of degree <span class="math">\(a\)</span></li>
<li><code class="docutils literal"><span class="pre">den</span></code> is the denominator of <code class="docutils literal"><span class="pre">nfgaloisconj(pol)</span></code>.
Pass it as an optional argument to <code class="docutils literal"><span class="pre">galoisinit</span></code> or <code class="docutils literal"><span class="pre">nfgaloisconj</span></code> to
speed them up:</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? [pol,den] = galoisgetpol(64,4,1);
? G = galoisinit(pol);
time = 352ms
? galoisinit(pol, den); \\ passing &#39;den&#39; speeds up the computation
time = 264ms
? % == %`
%4 = 1 \\ same answer
</pre></div>
</div>
<p>If <span class="math">\(b\)</span> and <span class="math">\(s\)</span> are omitted, return the number of isomorphism classes of
groups of order <span class="math">\(a\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.getabstime">
<code class="descname">getabstime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.getabstime" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the CPU time (in milliseconds) elapsed since <code class="docutils literal"><span class="pre">gp</span></code> startup.
This provides a reentrant version of <code class="docutils literal"><span class="pre">gettime</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">my</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">getabstime</span><span class="p">());</span>
<span class="o">...</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time: &quot;</span><span class="p">,</span> <span class="n">getabstime</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">);</span>
</pre></div>
</div>
<p>For a version giving wall-clock time, see <code class="docutils literal"><span class="pre">getwalltime</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.getenv">
<code class="descname">getenv</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.getenv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of the environment variable <code class="docutils literal"><span class="pre">s</span></code> if it is defined, otherwise return 0.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.getheap">
<code class="descname">getheap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.getheap" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a two-component row vector giving the
number of objects on the heap and the amount of memory they occupy in long
words. Useful mainly for debugging purposes.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.getrand">
<code class="descname">getrand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.getrand" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current value of the seed used by the
pseudo-random number generator <code class="docutils literal"><span class="pre">random</span></code>. Useful mainly for debugging
purposes, to reproduce a specific chain of computations. The returned value
is technical (reproduces an internal state array), and can only be used as an
argument to <code class="docutils literal"><span class="pre">setrand</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.getstack">
<code class="descname">getstack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.getstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current value of <span class="math">\(top-avma\)</span>, i.e.&nbsp;the number of
bytes used up to now on the stack. Useful mainly for debugging purposes.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.gettime">
<code class="descname">gettime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.gettime" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the CPU time (in milliseconds) used since either the last call to
<code class="docutils literal"><span class="pre">gettime</span></code>, or to the beginning of the containing GP instruction (if
inside <code class="docutils literal"><span class="pre">gp</span></code>), whichever came last.</p>
<p>For a reentrant version, see <code class="docutils literal"><span class="pre">getabstime</span></code>.</p>
<p>For a version giving wall-clock time, see <code class="docutils literal"><span class="pre">getwalltime</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.getwalltime">
<code class="descname">getwalltime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.getwalltime" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the time (in milliseconds) elapsed since the UNIX Epoch
(1970-01-01 00:00:00 (UTC)).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">my</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">getwalltime</span><span class="p">());</span>
<span class="o">...</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time: &quot;</span><span class="p">,</span> <span class="n">getwalltime</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.input">
<code class="descname">input</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.input" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a string, interpreted as a GP expression,
from the input file, usually standard input (i.e.&nbsp;the keyboard). If a
sequence of expressions is given, the result is the result of the last
expression of the sequence. When using this instruction, it is useful to
prompt for the string by using the <code class="docutils literal"><span class="pre">print1</span></code> function. Note that in the
present version 2.19 of <code class="docutils literal"><span class="pre">pari.el</span></code>, when using <code class="docutils literal"><span class="pre">gp</span></code> under GNU Emacs (see
<code class="docutils literal"><span class="pre">emacs</span></code> (in the PARI manual)) one <em>must</em> prompt for the string, with a string
which ends with the same prompt as any of the previous ones (a <code class="docutils literal"><span class="pre">&quot;?</span> <span class="pre">&quot;</span></code>
will do for instance).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.install">
<code class="descname">install</code><span class="sig-paren">(</span><em>name</em>, <em>code</em>, <em>gpname=None</em>, <em>lib=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.install" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads from dynamic library <em>lib</em> the function <em>name</em>. Assigns to it
the name <em>gpname</em> in this <code class="docutils literal"><span class="pre">gp</span></code> session, with <em>prototype</em>
<em>code</em> (see below). If <em>gpname</em> is omitted, uses <em>name</em>.
If <em>lib</em> is omitted, all symbols known to <code class="docutils literal"><span class="pre">gp</span></code> are available: this
includes the whole of <code class="docutils literal"><span class="pre">libpari.so</span></code> and possibly others (such as
<code class="docutils literal"><span class="pre">libc.so</span></code>).</p>
<p>Most importantly, <code class="docutils literal"><span class="pre">install</span></code> gives you access to all non-static functions
defined in the PARI library. For instance, the function \kbd{GEN addii(GEN
x, GEN y)} adds two PARI integers, and is not directly accessible under
<code class="docutils literal"><span class="pre">gp</span></code> (it is eventually called by the <code class="docutils literal"><span class="pre">+</span></code> operator of course):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? install(&quot;addii&quot;, &quot;GG&quot;)
? addii(1, 2)
%1 = 3
</pre></div>
</div>
<p>It also allows to add external functions to the <code class="docutils literal"><span class="pre">gp</span></code> interpreter.
For instance, it makes the function <code class="docutils literal"><span class="pre">system</span></code> obsolete:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? install(system, vs, sys,/*omitted*/)
? sys(&quot;ls gp*&quot;)
gp.c gp.h gp_rl.c
</pre></div>
</div>
<p>This works because <code class="docutils literal"><span class="pre">system</span></code> is part of <code class="docutils literal"><span class="pre">libc.so</span></code>,
which is linked to <code class="docutils literal"><span class="pre">gp</span></code>. It is also possible to compile a shared library
yourself and provide it to gp in this way: use <code class="docutils literal"><span class="pre">gp2c</span></code>, or do it manually
(see the <code class="docutils literal"><span class="pre">modules_build</span></code> variable in <code class="docutils literal"><span class="pre">pari.cfg</span></code> for hints).</p>
<p>Re-installing a function will print a warning and update the prototype code
if needed. However, it will not reload a symbol from the library, even if the
latter has been recompiled.</p>
<p><strong>Prototype.</strong> We only give a simplified description here, covering
most functions, but there are many more possibilities. The full documentation
is available in <code class="docutils literal"><span class="pre">libpari.dvi</span></code>, see</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>??prototype
</pre></div>
</div>
<ul class="simple">
<li>First character <code class="docutils literal"><span class="pre">i</span></code>, <code class="docutils literal"><span class="pre">l</span></code>, <code class="docutils literal"><span class="pre">v</span></code> : return type int / long /
void. (Default: <code class="docutils literal"><span class="pre">GEN</span></code>)</li>
<li>One letter for each mandatory argument, in the same order as they appear
in the argument list: <code class="docutils literal"><span class="pre">G</span></code> (<code class="docutils literal"><span class="pre">GEN</span></code>), <code class="docutils literal"><span class="pre">&amp;</span></code>
(<code class="docutils literal"><span class="pre">GEN*</span></code>), <code class="docutils literal"><span class="pre">L</span></code> (<code class="docutils literal"><span class="pre">long</span></code>), <code class="docutils literal"><span class="pre">s</span></code> (<code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></code>), <code class="docutils literal"><span class="pre">n</span></code>
(variable).</li>
<li><code class="docutils literal"><span class="pre">p</span></code> to supply <code class="docutils literal"><span class="pre">realprecision</span></code> (usually <code class="docutils literal"><span class="pre">long</span> <span class="pre">prec</span></code> in the
argument list), <code class="docutils literal"><span class="pre">P</span></code> to supply <code class="docutils literal"><span class="pre">seriesprecision</span></code> (usually kbd{long
precdl}).</li>
</ul>
<p>We also have special constructs for optional arguments and default
values:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">DG</span></code> (optional <code class="docutils literal"><span class="pre">GEN</span></code>, <code class="docutils literal"><span class="pre">NULL</span></code> if omitted),</li>
<li><code class="docutils literal"><span class="pre">D&amp;</span></code> (optional <code class="docutils literal"><span class="pre">GEN*</span></code>, <code class="docutils literal"><span class="pre">NULL</span></code> if omitted),</li>
<li><code class="docutils literal"><span class="pre">Dn</span></code> (optional variable, <span class="math">\(-1\)</span> if omitted),</li>
</ul>
<p>For instance the prototype corresponding to</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">long</span> <span class="n">issquareall</span><span class="p">(</span><span class="n">GEN</span> <span class="n">x</span><span class="p">,</span> <span class="n">GEN</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">)</span>
</pre></div>
</div>
<p>is <code class="docutils literal"><span class="pre">lGD&amp;</span></code>.</p>
<p><strong>Caution.</strong> This function may not work on all systems, especially
when <code class="docutils literal"><span class="pre">gp</span></code> has been compiled statically. In that case, the first use of an
installed function will provoke a Segmentation Fault (this should never
happen with a dynamically linked executable). If you intend to use this
function, please check first on some harmless example such as the one above
that it works properly on your machine.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.intnumgaussinit">
<code class="descname">intnumgaussinit</code><span class="sig-paren">(</span><em>n=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.intnumgaussinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize tables for <span class="math">\(n\)</span>-point Gauss-Legendre integration of
a smooth function <span class="math">\(f\)</span> lon a compact
interval <span class="math">\([a,b]\)</span> at current <code class="docutils literal"><span class="pre">realprecision</span></code>. If <span class="math">\(n\)</span> is omitted, make a
default choice <span class="math">\(n ~ realprecision\)</span>, suitable for analytic
functions on <span class="math">\([-1,1]\)</span>. The error is bounded by</p>
<div class="math">
\[((b-a)^{2n+1} (n!)^4)/((2n+1)[(2n)!]^3) f^{(2n)} (\xi) ,
a &lt; \xi &lt; b\]</div>
<p>so, if the interval length increases, <span class="math">\(n\)</span> should be increased as well.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? T = intnumgaussinit();
? intnumgauss(t=-1,1,exp(t), T) - exp(1)+exp(-1)
%1 = -5.877471754111437540 E-39
? intnumgauss(t=-10,10,exp(t), T) - exp(10)+exp(-10)
%2 = -8.358367809712546836 E-35
? intnumgauss(t=-1,1,1/(1+t^2), T) - Pi/2
%3 = -9.490148553624725335 E-22

? T = intnumgaussinit(50);
? intnumgauss(t=-1,1,1/(1+t^2), T) - Pi/2
%5 = -1.1754943508222875080 E-38
? intnumgauss(t=-5,5,1/(1+t^2), T) - 2*atan(5)
%6 = -1.2[...]E-8
</pre></div>
</div>
<p>On the other hand, we recommend to split the integral and change variables
rather than increasing <span class="math">\(n\)</span> too much, see <code class="docutils literal"><span class="pre">intnumgauss</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.kill">
<code class="descname">kill</code><span class="sig-paren">(</span><em>sym</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.kill" title="Permalink to this definition">¶</a></dt>
<dd><p>Restores the symbol <code class="docutils literal"><span class="pre">sym</span></code> to its &#8220;undefined&#8221; status, and deletes any
help messages associated to <code class="docutils literal"><span class="pre">sym</span></code> using <code class="docutils literal"><span class="pre">addhelp</span></code>. Variable names
remain known to the interpreter and keep their former priority: you cannot
make a variable &#8220;less important&#8221; by killing it!</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? z = y = 1; y
%1 = 1
? kill(y)
? y \\ restored to ``undefined&#39;&#39; status
%2 = y
? variable()
%3 = [x, y, z] \\ but the variable name y is still known, with y &gt; z !
</pre></div>
</div>
<p>For the same reason, killing a user function (which is an ordinary
variable holding a <code class="docutils literal"><span class="pre">t_CLOSURE</span></code>) does not remove its name from the list of
variable names.</p>
<p>If the symbol is associated to a variable &#8212; user functions being an
important special case &#8212;, one may use the quote operator
<code class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">'a</span></code> to reset variables to their starting values. However, this
will not delete a help message associated to <code class="docutils literal"><span class="pre">a</span></code>, and is also slightly
slower than <code class="docutils literal"><span class="pre">kill(a)</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? x = 1; addhelp(x, &quot;foo&quot;); x
%1 = 1
? x = &#39;x; x \\ same as &#39;kill&#39;, except we don&#39;t delete help.
%2 = x
? ?x
foo
</pre></div>
</div>
<p>On the other hand, <code class="docutils literal"><span class="pre">kill</span></code> is the only way to remove aliases and installed
functions.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? alias(fun, sin);
? kill(fun);

? install(addii, GG);
? kill(addii);
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.localbitprec">
<code class="descname">localbitprec</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.localbitprec" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the real precision to <span class="math">\(p\)</span> bits in the dynamic scope. All computations
are performed as if <code class="docutils literal"><span class="pre">realbitprecision</span></code> was <span class="math">\(p\)</span>:
transcendental constants (e.g.&nbsp;<code class="docutils literal"><span class="pre">Pi</span></code>) and
conversions from exact to floating point inexact data use <span class="math">\(p\)</span> bits, as well as
iterative routines implicitly using a floating point
accuracy as a termination criterion (e.g.&nbsp;<code class="docutils literal"><span class="pre">solve</span></code> or <code class="docutils literal"><span class="pre">intnum</span></code>).
But <code class="docutils literal"><span class="pre">realbitprecision</span></code> itself is unaffected
and is &#8220;unmasked&#8221; when we exit the dynamic (<em>not</em> lexical) scope.
In effect, this is similar to</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">my</span><span class="p">(</span><span class="n">bit</span> <span class="o">=</span> <span class="n">default</span><span class="p">(</span><span class="n">realbitprecision</span><span class="p">));</span>
<span class="n">default</span><span class="p">(</span><span class="n">realbitprecision</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
<span class="o">...</span>
<span class="n">default</span><span class="p">(</span><span class="n">realbitprecision</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
</pre></div>
</div>
<p>but is both less cumbersome, cleaner (no need to manipulate
a global variable, which in fact never changes and is only temporarily masked)
and more robust: if the above computation is interrupted or an exception
occurs, <code class="docutils literal"><span class="pre">realbitprecision</span></code> will not be restored as intended.</p>
<p>Such <code class="docutils literal"><span class="pre">localbitprec</span></code> statements can be nested, the innermost one taking
precedence as expected. Beware that <code class="docutils literal"><span class="pre">localbitprec</span></code> follows the semantic of
<code class="docutils literal"><span class="pre">local</span></code>, not <code class="docutils literal"><span class="pre">my</span></code>: a subroutine called from <code class="docutils literal"><span class="pre">localbitprec</span></code> scope
uses the local accuracy:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? f()=bitprecision(1.0);
? f()
%2 = 128
? localbitprec(1000); f()
%3 = 1024
</pre></div>
</div>
<p>Note that the bit precision of <em>data</em> (<code class="docutils literal"><span class="pre">1.0</span></code> in the
above example) increases by steps of 64 (32 on a 32-bit machine) so we get
<span class="math">\(1024\)</span> instead of the expected <span class="math">\(1000\)</span>; <code class="docutils literal"><span class="pre">localbitprec</span></code> bounds the
relative error exactly as specified in functions that support that
granularity (e.g.&nbsp;<code class="docutils literal"><span class="pre">lfun</span></code>), and rounded to the next multiple of 64
(resp.&nbsp;32) everywhere else.</p>
<p><strong>Warning.</strong> Changing <code class="docutils literal"><span class="pre">realbitprecision</span></code> or <code class="docutils literal"><span class="pre">realprecision</span></code>
in programs is deprecated in favor of <code class="docutils literal"><span class="pre">localbitprec</span></code> and
<code class="docutils literal"><span class="pre">localprec</span></code>. Think about the <code class="docutils literal"><span class="pre">realprecision</span></code> and
<code class="docutils literal"><span class="pre">realbitprecision</span></code> defaults as interactive commands for the <code class="docutils literal"><span class="pre">gp</span></code>
interpreter, best left out of GP programs. Indeed, the above rules imply that
mixing both constructs yields surprising results:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \p38
? localprec(19); default(realprecision,1000); Pi
%1 = 3.141592653589793239
? \p
 realprecision = 1001 significant digits (1000 digits displayed)
</pre></div>
</div>
<p>Indeed, <code class="docutils literal"><span class="pre">realprecision</span></code> itself is ignored within
<code class="docutils literal"><span class="pre">localprec</span></code> scope, so <code class="docutils literal"><span class="pre">Pi</span></code> is computed to a low accuracy. And when
we leave the <code class="docutils literal"><span class="pre">localprec</span></code> scope, <code class="docutils literal"><span class="pre">realprecision</span></code> only regains precedence,
it is not &#8220;restored&#8221; to the original value.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.localprec">
<code class="descname">localprec</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.localprec" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the real precision to <span class="math">\(p\)</span> in the dynamic scope. All computations
are performed as if <code class="docutils literal"><span class="pre">realprecision</span></code> was <span class="math">\(p\)</span>:
transcendental constants (e.g.&nbsp;<code class="docutils literal"><span class="pre">Pi</span></code>) and
conversions from exact to floating point inexact data use <span class="math">\(p\)</span> decimal
digits, as well as iterative routines implicitly using a floating point
accuracy as a termination criterion (e.g.&nbsp;<code class="docutils literal"><span class="pre">solve</span></code> or <code class="docutils literal"><span class="pre">intnum</span></code>).
But <code class="docutils literal"><span class="pre">realprecision</span></code> itself is unaffected
and is &#8220;unmasked&#8221; when we exit the dynamic (<em>not</em> lexical) scope.
In effect, this is similar to</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">my</span><span class="p">(</span><span class="n">prec</span> <span class="o">=</span> <span class="n">default</span><span class="p">(</span><span class="n">realprecision</span><span class="p">));</span>
<span class="n">default</span><span class="p">(</span><span class="n">realprecision</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
<span class="o">...</span>
<span class="n">default</span><span class="p">(</span><span class="n">realprecision</span><span class="p">,</span> <span class="n">prec</span><span class="p">);</span>
</pre></div>
</div>
<p>but is both less cumbersome, cleaner (no need to manipulate
a global variable, which in fact never changes and is only temporarily masked)
and more robust: if the above computation is interrupted or an exception
occurs, <code class="docutils literal"><span class="pre">realprecision</span></code> will not be restored as intended.</p>
<p>Such <code class="docutils literal"><span class="pre">localprec</span></code> statements can be nested, the innermost one taking
precedence as expected. Beware that <code class="docutils literal"><span class="pre">localprec</span></code> follows the semantic of
<code class="docutils literal"><span class="pre">local</span></code>, not <code class="docutils literal"><span class="pre">my</span></code>: a subroutine called from <code class="docutils literal"><span class="pre">localprec</span></code> scope
uses the local accuracy:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? f()=precision(1.);
? f()
%2 = 38
? localprec(19); f()
%3 = 19
</pre></div>
</div>
<p><strong>Warning.</strong> Changing <code class="docutils literal"><span class="pre">realprecision</span></code> itself in programs is
now deprecated in favor of <code class="docutils literal"><span class="pre">localprec</span></code>. Think about the
<code class="docutils literal"><span class="pre">realprecision</span></code> default as an interactive command for the <code class="docutils literal"><span class="pre">gp</span></code>
interpreter, best left out of GP programs. Indeed, the above rules
imply that mixing both constructs yields surprising results:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \p38
? localprec(19); default(realprecision,100); Pi
%1 = 3.141592653589793239
? \p
 realprecision = 115 significant digits (100 digits displayed)
</pre></div>
</div>
<p>Indeed, <code class="docutils literal"><span class="pre">realprecision</span></code> itself is ignored within
<code class="docutils literal"><span class="pre">localprec</span></code> scope, so <code class="docutils literal"><span class="pre">Pi</span></code> is computed to a low accuracy. And when
we leave <code class="docutils literal"><span class="pre">localprec</span></code> scope, <code class="docutils literal"><span class="pre">realprecision</span></code> only regains precedence,
it is not &#8220;restored&#8221; to the original value.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.mathilbert">
<code class="descname">mathilbert</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.mathilbert" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> being a <code class="docutils literal"><span class="pre">long</span></code>, creates the
Hilbert matrixof order <span class="math">\(x\)</span>, i.e.&nbsp;the matrix whose coefficient
(<span class="math">\(i\)</span>,:math:<span class="math">\(j\)</span>) is <span class="math">\(1/ (i+j-1)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.matid">
<code class="descname">matid</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.matid" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the <span class="math">\(n x n\)</span> identity matrix.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.matpascal">
<code class="descname">matpascal</code><span class="sig-paren">(</span><em>n</em>, <em>q=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.matpascal" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates as a matrix the lower triangular
Pascal triangle of order <span class="math">\(x+1\)</span> (i.e.&nbsp;with binomial coefficients
up to <span class="math">\(x\)</span>). If <span class="math">\(q\)</span> is given, compute the <span class="math">\(q\)</span>-Pascal triangle (i.e.&nbsp;using
<span class="math">\(q\)</span>-binomial coefficients).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.numtoperm">
<code class="descname">numtoperm</code><span class="sig-paren">(</span><em>n</em>, <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.numtoperm" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the <span class="math">\(k\)</span>-th permutation (as a row vector of length <span class="math">\(n\)</span>) of the
numbers <span class="math">\(1\)</span> to <span class="math">\(n\)</span>. The number <span class="math">\(k\)</span> is taken modulo <span class="math">\(n!\)</span>, i.e.&nbsp;inverse
function of <code class="docutils literal"><span class="pre">permtonum</span></code>. The numbering used is the standard lexicographic
ordering, starting at <span class="math">\(0\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.oo">
<code class="descname">oo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.oo" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an object meaning <span class="math">\(+ oo\)</span>, for use in functions such as
<code class="docutils literal"><span class="pre">intnum</span></code>. It can be negated (<code class="docutils literal"><span class="pre">-oo</span></code> represents <span class="math">\(- oo\)</span>), and
compared to real numbers (<code class="docutils literal"><span class="pre">t_INT</span></code>, <code class="docutils literal"><span class="pre">t_FRAC</span></code>, <code class="docutils literal"><span class="pre">t_REAL</span></code>), with the
expected meaning: <span class="math">\(+ oo\)</span> is greater than any real number and <span class="math">\(- oo\)</span> is
smaller.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.partitions">
<code class="descname">partitions</code><span class="sig-paren">(</span><em>k</em>, <em>a=None</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.partitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vector of partitions of the integer <span class="math">\(k\)</span> as a sum of positive
integers (parts); for <span class="math">\(k &lt; 0\)</span>, it returns the empty set <code class="docutils literal"><span class="pre">[]</span></code>, and for <span class="math">\(k
= 0\)</span> the trivial partition (no parts). A partition is given by a
<code class="docutils literal"><span class="pre">t_VECSMALL</span></code>, where parts are sorted in nondecreasing order:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? partitions(3)
%1 = [Vecsmall([3]), Vecsmall([1, 2]), Vecsmall([1, 1, 1])]
</pre></div>
</div>
<p>correspond to <span class="math">\(3\)</span>, <span class="math">\(1+2\)</span> and <span class="math">\(1+1+1\)</span>. The number
of (unrestricted) partitions of <span class="math">\(k\)</span> is given
by <code class="docutils literal"><span class="pre">numbpart</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? #partitions(50)
%1 = 204226
? numbpart(50)
%2 = 204226
</pre></div>
</div>
<p>Optional parameters <span class="math">\(n\)</span> and <span class="math">\(a\)</span> are as follows:</p>
<ul class="simple">
<li><span class="math">\(n = nmax\)</span> (resp. <span class="math">\(n = [nmin,nmax]\)</span>) restricts
partitions to length less than <span class="math">\(nmax\)</span> (resp. length between
<span class="math">\(nmin\)</span> and <span class="math">\(nmax\)</span>), where the <em>length</em> is the number of nonzero
entries.</li>
<li><span class="math">\(a = amax\)</span> (resp. <span class="math">\(a = [amin,amax]\)</span>) restricts the parts
to integers less than <span class="math">\(amax\)</span> (resp. between <span class="math">\(amin\)</span> and
<span class="math">\(amax\)</span>).</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? partitions(4, 2) \\ parts bounded by 2
%1 = [Vecsmall([2, 2]), Vecsmall([1, 1, 2]), Vecsmall([1, 1, 1, 1])]
? partitions(4,, 2) \\ at most 2 parts
%2 = [Vecsmall([4]), Vecsmall([1, 3]), Vecsmall([2, 2])]
? partitions(4,[0,3], 2) \\ at most 2 parts
%3 = [Vecsmall([4]), Vecsmall([1, 3]), Vecsmall([2, 2])]
</pre></div>
</div>
<p>By default, parts are positive and we remove zero entries unless
<span class="math">\(amin &lt;= 0\)</span>, in which case <span class="math">\(nmin\)</span> is ignored and <span class="math">\(X\)</span> is of constant length
<span class="math">\(nmax\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? partitions(4, [0,3]) \\ parts between 0 and 3
%1 = [Vecsmall([0, 0, 1, 3]), Vecsmall([0, 0, 2, 2]),\
 Vecsmall([0, 1, 1, 2]), Vecsmall([1, 1, 1, 1])]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.polchebyshev">
<code class="descname">polchebyshev</code><span class="sig-paren">(</span><em>n</em>, <em>flag=1</em>, <em>a=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.polchebyshev" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <span class="math">\(n-th\)</span>
Chebyshev polynomial of the first kind <span class="math">\(T_n\)</span> (<span class="math">\(flag = 1\)</span>) or the second
kind <span class="math">\(U_n\)</span> (<span class="math">\(flag = 2\)</span>), evaluated at <span class="math">\(a\)</span> (<code class="docutils literal"><span class="pre">'x</span></code> by default). Both series of
polynomials satisfy the 3-term relation</p>
<div class="math">
\[P_{n+1} = 2xP_n - P_{n-1},\]</div>
<p>and are determined by the initial conditions <span class="math">\(U_0 = T_0 = 1\)</span>, <span class="math">\(T_1 = x\)</span>,
<span class="math">\(U_1 = 2x\)</span>. In fact <span class="math">\(T_n' = n U_{n-1}\)</span> and, for all complex numbers <span class="math">\(z\)</span>, we
have <span class="math">\(T_n(\cos z) = \cos (nz)\)</span> and <span class="math">\(U_{n-1}(\cos z) = \sin(nz)/\sin z\)</span>.
If <span class="math">\(n &gt;= 0\)</span>, then these polynomials have degree <span class="math">\(n\)</span>. For <span class="math">\(n &lt; 0\)</span>,
<span class="math">\(T_n\)</span> is equal to <span class="math">\(T_{-n}\)</span> and <span class="math">\(U_n\)</span> is equal to <span class="math">\(-U_{-2-n}\)</span>.
In particular, <span class="math">\(U_{-1} = 0\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.polcyclo">
<code class="descname">polcyclo</code><span class="sig-paren">(</span><em>n</em>, <em>a=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.polcyclo" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(n\)</span>-th cyclotomic polynomial, evaluated at <span class="math">\(a\)</span> (<code class="docutils literal"><span class="pre">'x</span></code> by default). The
integer <span class="math">\(n\)</span> must be positive.</p>
<p>Algorithm used: reduce to the case where <span class="math">\(n\)</span> is squarefree; to compute the
cyclotomic polynomial, use <span class="math">\(\Phi_{np}(x) = \Phi_n(x^p)/\Phi(x)\)</span>; to compute
it evaluated, use <span class="math">\(\Phi_n(x) = \prod_{d \| n} (x^d-1)^{\mu(n/d)}\)</span>. In the
evaluated case, the algorithm assumes that <span class="math">\(a^d - 1\)</span> is either <span class="math">\(0\)</span> or
invertible, for all <span class="math">\(d \| n\)</span>. If this is not the case (the base ring has
zero divisors), use <code class="docutils literal"><span class="pre">subst(polcyclo(n),x,a)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.polhermite">
<code class="descname">polhermite</code><span class="sig-paren">(</span><em>n</em>, <em>a=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.polhermite" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(n-th\)</span> Hermite polynomial <span class="math">\(H_n\)</span> evaluated at <span class="math">\(a\)</span>
(<code class="docutils literal"><span class="pre">'x</span></code> by default), i.e.</p>
<div class="math">
\[H_n(x) = (-1)^n e^{x^2} (d^n)/(dx^n)e^{-x^2}.\]</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.pollegendre">
<code class="descname">pollegendre</code><span class="sig-paren">(</span><em>n</em>, <em>a=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.pollegendre" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(n-th\)</span> Legendre polynomial evaluated at <span class="math">\(a\)</span> (<code class="docutils literal"><span class="pre">'x</span></code> by
default).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.polmodular">
<code class="descname">polmodular</code><span class="sig-paren">(</span><em>L</em>, <em>inv=0</em>, <em>x=None</em>, <em>y=None</em>, <em>derivs=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.polmodular" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the modular polynomial of level <span class="math">\(L\)</span> in variables <span class="math">\(x\)</span> and <span class="math">\(y\)</span>
for the modular function specified by <code class="docutils literal"><span class="pre">inv</span></code>. If <code class="docutils literal"><span class="pre">inv</span></code> is 0 (the
default), use the modular <span class="math">\(j\)</span> function, if <code class="docutils literal"><span class="pre">inv</span></code> is 1 use the
Weber-<span class="math">\(f\)</span> function, and if <code class="docutils literal"><span class="pre">inv</span></code> is 5 use <span class="math">\(\gamma_2 = 
\sqrt[3]{j}\)</span>. If <span class="math">\(x\)</span> is given as <code class="docutils literal"><span class="pre">Mod(j,</span> <span class="pre">p)</span></code> or an element <span class="math">\(j\)</span> of
a finite field (as a <code class="docutils literal"><span class="pre">t_FFELT</span></code>), then return the modular polynomial of
level <span class="math">\(L\)</span> evaluated at <span class="math">\(j\)</span>. If <span class="math">\(j\)</span> is from a finite field and
<code class="docutils literal"><span class="pre">derivs</span></code> is non-zero, then return a triple where the
last two elements are the first and second derivatives of the modular
polynomial evaluated at <span class="math">\(j\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? polmodular(3)
%1 = x^4 + (-y^3 + 2232*y^2 - 1069956*y + 36864000)*x^3 + ...
? polmodular(7, 1, , &#39;J)
%2 = x^8 - J^7*x^7 + 7*J^4*x^4 - 8*J*x + J^8
? polmodular(7, 5, 7*ffgen(19)^0, &#39;j)
%3 = j^8 + 4*j^7 + 4*j^6 + 8*j^5 + j^4 + 12*j^2 + 18*j + 18
? polmodular(7, 5, Mod(7,19), &#39;j)
%4 = Mod(1, 19)*j^8 + Mod(4, 19)*j^7 + Mod(4, 19)*j^6 + ...

? u = ffgen(5)^0; T = polmodular(3,0,,&#39;j)*u;
? polmodular(3, 0, u,&#39;j,1)
%6 = [j^4 + 3*j^2 + 4*j + 1, 3*j^2 + 2*j + 4, 3*j^3 + 4*j^2 + 4*j + 2]
? subst(T,x,u)
%7 = j^4 + 3*j^2 + 4*j + 1
? subst(T&#39;,x,u)
%8 = 3*j^2 + 2*j + 4
? subst(T&#39;&#39;,x,u)
%9 = 3*j^3 + 4*j^2 + 4*j + 2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.polsubcyclo">
<code class="descname">polsubcyclo</code><span class="sig-paren">(</span><em>n</em>, <em>d</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.polsubcyclo" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives polynomials (in variable <span class="math">\(v\)</span>) defining the sub-Abelian extensions
of degree <span class="math">\(d\)</span> of the cyclotomic field <span class="math">\(\mathbb{Q}(\zeta_n)\)</span>, where <span class="math">\(d \| \phi(n)\)</span>.</p>
<p>If there is exactly one such extension the output is a polynomial, else it is
a vector of polynomials, possibly empty. To get a vector in all cases,
use <code class="docutils literal"><span class="pre">concat([],</span> <span class="pre">polsubcyclo(n,d))</span></code>.</p>
<p>The function <code class="docutils literal"><span class="pre">galoissubcyclo</span></code> allows to specify exactly which
sub-Abelian extension should be computed.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.poltchebi">
<code class="descname">poltchebi</code><span class="sig-paren">(</span><em>n</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.poltchebi" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated alias for <code class="docutils literal"><span class="pre">polchebyshev</span></code></p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.polylog">
<code class="descname">polylog</code><span class="sig-paren">(</span><em>m</em>, <em>x</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.polylog" title="Permalink to this definition">¶</a></dt>
<dd><p>One of the different polylogarithms, depending on <em>flag</em>:</p>
<p>If <span class="math">\(flag = 0\)</span> or is omitted: <span class="math">\(m-th\)</span> polylogarithm of <span class="math">\(x\)</span>, i.e.&nbsp;analytic
continuation of the power series <span class="math">\({Li}_m(x) = \sum_{n &gt;= 1}x^n/n^m\)</span>
(<span class="math">\(x &lt; 1\)</span>). Uses the functional equation linking the values at <span class="math">\(x\)</span> and <span class="math">\(1/x\)</span>
to restrict to the case <span class="math">\(\|x\| &lt;= 1\)</span>, then the power series when
<span class="math">\(\|x\|^2 &lt;= 1/2\)</span>, and the power series expansion in <span class="math">\(\log(x)\)</span> otherwise.</p>
<p>Using <span class="math">\(flag\)</span>, computes a modified <span class="math">\(m-th\)</span> polylogarithm of <span class="math">\(x\)</span>.
We use Zagier&#8217;s notations; let <span class="math">\(\Re_m\)</span> denote <span class="math">\(\Re\)</span> or <span class="math">\(\Im\)</span> depending
on whether <span class="math">\(m\)</span> is odd or even:</p>
<p>If <span class="math">\(flag = 1\)</span>: compute <span class="math">\(~ D_m(x)\)</span>, defined for <span class="math">\(\|x\| &lt;= 1\)</span> by</p>
<div class="math">
\[\Re_m(\sum_{k = 0}^{m-1} ((-\log\|x\|)^k)/(k!){Li}_{m-k}(x)
+((-\log\|x\|)^{m-1})/(m!)\log\|1-x\|).\]</div>
<p>If <span class="math">\(flag = 2\)</span>: compute <span class="math">\(D_m(x)\)</span>, defined for <span class="math">\(\|x\| &lt;= 1\)</span> by</p>
<div class="math">
\[\Re_m(\sum_{k = 0}^{m-1}((-\log\|x\|)^k)/(k!){Li}_{m-k}(x)
-(1)/(2)((-\log\|x\|)^m)/(m!)).\]</div>
<p>If <span class="math">\(flag = 3\)</span>: compute <span class="math">\(P_m(x)\)</span>, defined for <span class="math">\(\|x\| &lt;= 1\)</span> by</p>
<div class="math">
\[\Re_m(\sum_{k = 0}^{m-1}(2^kB_k)/(k!)(\log\|x\|)^k{Li}_{m-k}(x)
-(2^{m-1}B_m)/(m!)(\log\|x\|)^m).\]</div>
<p>These three functions satisfy the functional equation
<span class="math">\(f_m(1/x) = (-1)^{m-1}f_m(x)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.polzagier">
<code class="descname">polzagier</code><span class="sig-paren">(</span><em>n</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.polzagier" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates Zagier&#8217;s polynomial <span class="math">\(P_n^{(m)}\)</span> used in
the functions <code class="docutils literal"><span class="pre">sumalt</span></code> and <code class="docutils literal"><span class="pre">sumpos</span></code> (with <span class="math">\(flag = 1\)</span>), see
&#8220;Convergence acceleration of alternating series&#8221;, Cohen et al.,
<em>Experiment.&nbsp;Math.</em>, vol.&nbsp;9, 2000, pp.&nbsp;3&#8211;12.</p>
<p>If <span class="math">\(m &lt; 0\)</span> or <span class="math">\(m &gt;= n\)</span>, <span class="math">\(P_n^{(m)} = 0\)</span>.
We have
<span class="math">\(P_n := P_n^{(0)}\)</span> is <span class="math">\(T_n(2x-1)\)</span>, where <span class="math">\(T_n\)</span> is the Legendre polynomial of
the second kind. For <span class="math">\(n &gt; m &gt; 0\)</span>, <span class="math">\(P_n^{(m)}\)</span> is the <span class="math">\(m\)</span>-th difference with
step <span class="math">\(2\)</span> of the sequence <span class="math">\(n^{m+1}P_n\)</span>; in this case, it satisfies</p>
<div class="math">
\[2 P_n^{(m)}(sin^2 t) = (d^{m+1})/(dt^{m+1})(\sin(2t)^m \sin(2(n-m)t)).\]</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.prime">
<code class="descname">prime</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.prime" title="Permalink to this definition">¶</a></dt>
<dd><p>The <span class="math">\(n-th\)</span> prime number</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? prime(10^9)
%1 = 22801763489
</pre></div>
</div>
<p>Uses checkpointing and a naive <span class="math">\(O(n)\)</span> algorithm.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads in the file
<em>filename</em> (subject to string expansion). If <em>filename</em> is
omitted, re-reads the last file that was fed into <code class="docutils literal"><span class="pre">gp</span></code>. The return
value is the result of the last expression evaluated.</p>
<p>If a GP <code class="docutils literal"><span class="pre">binary</span> <span class="pre">file</span></code> is read using this command (see
<code class="docutils literal"><span class="pre">writebin</span></code> (in the PARI manual)), the file is loaded and the last object in the file
is returned.</p>
<p>In case the file you read in contains an <code class="docutils literal"><span class="pre">allocatemem</span></code> statement (to be
generally avoided), you should leave <code class="docutils literal"><span class="pre">read</span></code> instructions by themselves,
and not part of larger instruction sequences.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.readstr">
<code class="descname">readstr</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.readstr" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads in the file <em>filename</em> and return a vector of GP strings,
each component containing one line from the file. If <em>filename</em> is
omitted, re-reads the last file that was fed into <code class="docutils literal"><span class="pre">gp</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.readvec">
<code class="descname">readvec</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.readvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads in the file
<em>filename</em> (subject to string expansion). If <em>filename</em> is
omitted, re-reads the last file that was fed into <code class="docutils literal"><span class="pre">gp</span></code>. The return
value is a vector whose components are the evaluation of all sequences
of instructions contained in the file. For instance, if <em>file</em> contains</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
</pre></div>
</div>
<p>then we will get:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \r a
%1 = 1
%2 = 2
%3 = 3
? read(a)
%4 = 3
? readvec(a)
%5 = [1, 2, 3]
</pre></div>
</div>
<p>In general a sequence is just a single line, but as usual braces and
<code class="docutils literal"><span class="pre">\</span></code> may be used to enter multiline sequences.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.stirling">
<code class="descname">stirling</code><span class="sig-paren">(</span><em>n</em>, <em>k</em>, <em>flag=1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.stirling" title="Permalink to this definition">¶</a></dt>
<dd><p>Stirling number of the first kind <span class="math">\(s(n,k)\)</span> (<span class="math">\(flag = 1\)</span>, default) or
of the second kind <span class="math">\(S(n,k)\)</span> (<em>flag</em> = 2), where <span class="math">\(n\)</span>, <span class="math">\(k\)</span> are non-negative
integers. The former is <span class="math">\((-1)^{n-k}\)</span> times the
number of permutations of <span class="math">\(n\)</span> symbols with exactly <span class="math">\(k\)</span> cycles; the latter is
the number of ways of partitioning a set of <span class="math">\(n\)</span> elements into <span class="math">\(k\)</span> non-empty
subsets. Note that if all <span class="math">\(s(n,k)\)</span> are needed, it is much faster to compute</p>
<div class="math">
\[\sum_k s(n,k) x^k = x(x-1)...(x-n+1).\]</div>
<p>Similarly, if a large number of <span class="math">\(S(n,k)\)</span> are needed for the same <span class="math">\(k\)</span>,
one should use</p>
<div class="math">
\[\sum_n S(n,k) x^n = (x^k)/((1-x)...(1-kx)).\]</div>
<p>(Should be implemented using a divide and conquer product.) Here are
simple variants for <span class="math">\(n\)</span> fixed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">s</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="n">k</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">.</span><span class="n">n</span> <span class="o">*/</span>
<span class="n">vecstirling</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vec</span><span class="p">(</span> <span class="n">factorback</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="o">*</span><span class="s1">&#39;x)) )</span>

<span class="o">/*</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">S</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="n">k</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">.</span><span class="n">n</span> <span class="o">*/</span>
<span class="n">vecstirling2</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span>
<span class="p">{</span> <span class="n">my</span><span class="p">(</span><span class="n">Q</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">t</span><span class="p">);</span>
 <span class="n">vector</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">divrem</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="n">i</span><span class="p">);</span> <span class="n">Q</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">simplify</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.system">
<code class="descname">system</code><span class="sig-paren">(</span><em>str</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.system" title="Permalink to this definition">¶</a></dt>
<dd><p><em>str</em> is a string representing a system command. This command is
executed, its output written to the standard output (this won&#8217;t get into your
logfile), and control returns to the PARI system. This simply calls the C
<code class="docutils literal"><span class="pre">system</span></code> command.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.varhigher">
<code class="descname">varhigher</code><span class="sig-paren">(</span><em>name</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.varhigher" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a variable <em>name</em> whose priority is higher
than the priority of <span class="math">\(v\)</span> (of all existing variables if <span class="math">\(v\)</span> is omitted).
This is a counterpart to <code class="docutils literal"><span class="pre">varlower</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? Pol([x,x], t)
 *** at top-level: Pol([x,x],t)
 *** ^------------
 *** Pol: incorrect priority in gtopoly: variable x &lt;= t
? t = varhigher(&quot;t&quot;, x);
? Pol([x,x], t)
%3 = x*t + x
</pre></div>
</div>
<p>This routine is useful since new GP variables directly
created by the interpreter always have lower priority than existing
GP variables. When some basic objects already exist in a variable
that is incompatible with some function requirement, you can now
create a new variable with a suitable priority instead of changing variables
in existing objects:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(x^2+1);
? rnfequation(K,y^2-2)
 *** at top-level: rnfequation(K,y^2-2)
 *** ^--------------------
 *** rnfequation: incorrect priority in rnfequation: variable y &gt;= x
? y = varhigher(&quot;y&quot;, x);
? rnfequation(K, y^2-2)
%3 = y^4 - 2*y^2 + 9
</pre></div>
</div>
<p><strong>Caution 1.</strong>
The <em>name</em> is an arbitrary character string, only used for display
purposes and need not be related to the GP variable holding the result, nor
to be a valid variable name. In particular the <em>name</em> can
not be used to retrieve the variable, it is not even present in the parser&#8217;s
hash tables.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? x = varhigher(&quot;#&quot;);
? x^2
%2 = #^2
</pre></div>
</div>
<p><strong>Caution 2.</strong> There are a limited number of variables and if no
existing variable with the given display name has the requested
priority, the call to <code class="docutils literal"><span class="pre">varhigher</span></code> uses up one such slot. Do not create
new variables in this way unless it&#8217;s absolutely necessary,
reuse existing names instead and choose sensible priority requirements:
if you only need a variable with higher priority than <span class="math">\(x\)</span>, state so
rather than creating a new variable with highest priority.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>\\ quickly use up all variables
? n = 0; while(1,varhigher(&quot;tmp&quot;); n++)
 *** at top-level: n=0;while(1,varhigher(&quot;tmp&quot;);n++)
 *** ^-------------------
 *** varhigher: no more variables available.
 *** Break loop: type &#39;break&#39; to go back to GP prompt
break&gt; n
65510
\\ infinite loop: here we reuse the same &#39;tmp&#39;
? n = 0; while(1,varhigher(&quot;tmp&quot;, x); n++)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.varlower">
<code class="descname">varlower</code><span class="sig-paren">(</span><em>name</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.varlower" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a variable <em>name</em> whose priority is lower
than the priority of <span class="math">\(v\)</span> (of all existing variables if <span class="math">\(v\)</span> is omitted).
This is a counterpart to <code class="docutils literal"><span class="pre">varhigher</span></code>.</p>
<p>New GP variables directly created by the interpreter always
have lower priority than existing GP variables, but it is not easy
to check whether an identifier is currently unused, so that the
corresponding variable has the expected priority when it&#8217;s created!
Thus, depending on the session history, the same command may fail or succeed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? t; z; \\ now t &gt; z
? rnfequation(t^2+1,z^2-t)
 *** at top-level: rnfequation(t^2+1,z^
 *** ^--------------------
 *** rnfequation: incorrect priority in rnfequation: variable t &gt;= t
</pre></div>
</div>
<p>Restart and retry:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? z; t; \\ now z &gt; t
? rnfequation(t^2+1,z^2-t)
%2 = z^4 + 1
</pre></div>
</div>
<p>It is quite annoying for package authors, when trying to
define a base ring, to notice that the package may fail for some users
depending on their session history. The safe way to do this is as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? z; t; \\ In new session: now z &gt; t
...
? t = varlower(&quot;t&quot;, &#39;z);
? rnfequation(t^2+1,z^2-2)
%2 = z^4 - 2*z^2 + 9
? variable()
%3 = [x, y, z, t]
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>? t; z; \\ In new session: now t &gt; z
...
? t = varlower(&quot;t&quot;, &#39;z); \\ create a new variable, still printed &quot;t&quot;
? rnfequation(t^2+1,z^2-2)
%2 = z^4 - 2*z^2 + 9
? variable()
%3 = [x, y, t, z, t]
</pre></div>
</div>
<p>Now both constructions succeed. Note that in the
first case, <code class="docutils literal"><span class="pre">varlower</span></code> is essentially a no-op, the existing variable <span class="math">\(t\)</span>
has correct priority. While in the second case, two different variables are
displayed as <code class="docutils literal"><span class="pre">t</span></code>, one with higher priority than <span class="math">\(z\)</span> (created in the first
line) and another one with lower priority (created by <code class="docutils literal"><span class="pre">varlower</span></code>).</p>
<p><strong>Caution 1.</strong>
The <em>name</em> is an arbitrary character string, only used for display
purposes and need not be related to the GP variable holding the result, nor
to be a valid variable name. In particular the <em>name</em> can
not be used to retrieve the variable, it is not even present in the parser&#8217;s
hash tables.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? x = varlower(&quot;#&quot;);
? x^2
%2 = #^2
</pre></div>
</div>
<p><strong>Caution 2.</strong> There are a limited number of variables and if no
existing variable with the given display name has the requested
priority, the call to <code class="docutils literal"><span class="pre">varlower</span></code> uses up one such slot. Do not create
new variables in this way unless it&#8217;s absolutely necessary,
reuse existing names instead and choose sensible priority requirements:
if you only need a variable with higher priority than <span class="math">\(x\)</span>, state so
rather than creating a new variable with highest priority.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>\\ quickly use up all variables
? n = 0; while(1,varlower(&quot;x&quot;); n++)
 *** at top-level: n=0;while(1,varlower(&quot;x&quot;);n++)
 *** ^-------------------
 *** varlower: no more variables available.
 *** Break loop: type &#39;break&#39; to go back to GP prompt
break&gt; n
65510
\\ infinite loop: here we reuse the same &#39;tmp&#39;
? n = 0; while(1,varlower(&quot;tmp&quot;, x); n++)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.pari_instance.PariInstance_auto.version">
<code class="descname">version</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.PariInstance_auto.version" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current version number as a <code class="docutils literal"><span class="pre">t_VEC</span></code> with three integer
components (major version number, minor version number and patchlevel);
if your sources were obtained through our version control system, this will
be followed by further more precise arguments, including
e.g.&nbsp;a&nbsp;<code class="docutils literal"><span class="pre">git</span></code> <em>commit hash</em>.</p>
<p>This function is present in all versions of PARI following releases 2.3.4
(stable) and 2.4.3 (testing).</p>
<p>Unless you are working with multiple development versions, you probably only
care about the 3 first numeric components. In any case, the <code class="docutils literal"><span class="pre">lex</span></code> function
offers a clever way to check against a particular version number, since it will
compare each successive vector entry, numerically or as strings, and will not
mind if the vectors it compares have different lengths:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="n">version</span><span class="p">(),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span>
\\ <span class="n">code</span> <span class="n">to</span> <span class="n">be</span> <span class="n">executed</span> <span class="k">if</span> <span class="n">we</span> <span class="n">are</span> <span class="n">running</span> <span class="mf">2.3</span><span class="o">.</span><span class="mi">5</span> <span class="ow">or</span> <span class="n">more</span> <span class="n">recent</span><span class="o">.</span>
<span class="p">,</span>
\\ <span class="n">compatibility</span> <span class="n">code</span>
<span class="p">);</span>
</pre></div>
</div>
<p>On a number of different machines, <code class="docutils literal"><span class="pre">version()</span></code> could return either of</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">%</span><span class="mi">1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> \\ <span class="n">released</span> <span class="n">version</span><span class="p">,</span> <span class="n">stable</span> <span class="n">branch</span>
<span class="o">%</span><span class="mi">1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> \\ <span class="n">released</span> <span class="n">version</span><span class="p">,</span> <span class="n">testing</span> <span class="n">branch</span>
<span class="o">%</span><span class="mi">1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15174</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="mi">505</span><span class="n">ab9b</span><span class="s2">&quot;] </span><span class="se">\\</span><span class="s2"> development</span>
</pre></div>
</div>
<p>In particular, if you are only working with released versions, the first
line of the gp introductory message can be emulated by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">M</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">version</span><span class="p">();</span>
<span class="n">printf</span><span class="p">(</span><span class="s2">&quot;GP/PARI CALCULATOR Version </span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
</pre></div>
</div>
<p>If you <em>are</em> working with many development versions of
PARI/GP, the 4th and/or 5th components can be profitably included in the
name of your logfiles, for instance.</p>
<p><strong>Technical note.</strong> For development versions obtained via <code class="docutils literal"><span class="pre">git</span></code>,
the 4th and 5th components are liable to change eventually, but we document
their current meaning for completeness. The 4th component counts the number
of reachable commits in the branch (analogous to <code class="docutils literal"><span class="pre">svn</span></code>&#8216;s revision
number), and the 5th is the <code class="docutils literal"><span class="pre">git</span></code> commit hash. In particular, <code class="docutils literal"><span class="pre">lex</span></code>
comparison still orders correctly development versions with respect to each
others or to released versions (provided we stay within a given branch,
e.g. <code class="docutils literal"><span class="pre">master</span></code>)!</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.libs.pari.pari_instance.default_bitprec">
<code class="descclassname">sage.libs.pari.pari_instance.</code><code class="descname">default_bitprec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.default_bitprec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default precision in bits.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.libs.pari.pari_instance</span> <span class="kn">import</span> <span class="n">default_bitprec</span>
<span class="gp">sage: </span><span class="n">default_bitprec</span><span class="p">()</span>
<span class="go">64</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.libs.pari.pari_instance.prec_bits_to_dec">
<code class="descclassname">sage.libs.pari.pari_instance.</code><code class="descname">prec_bits_to_dec</code><span class="sig-paren">(</span><em>prec_in_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.prec_bits_to_dec" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from precision expressed in bits to precision expressed in
decimal.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.libs.pari.pari_instance</span> <span class="kn">import</span> <span class="n">prec_bits_to_dec</span>
<span class="gp">sage: </span><span class="n">prec_bits_to_dec</span><span class="p">(</span><span class="mi">53</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="mi">32</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">prec_bits_to_dec</span><span class="p">(</span><span class="mi">32</span><span class="o">*</span><span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)]</span>
<span class="go">[(32, 9),</span>
<span class="go">(64, 19),</span>
<span class="go">(96, 28),</span>
<span class="go">(128, 38),</span>
<span class="go">(160, 48),</span>
<span class="go">(192, 57),</span>
<span class="go">(224, 67),</span>
<span class="go">(256, 77)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.libs.pari.pari_instance.prec_bits_to_words">
<code class="descclassname">sage.libs.pari.pari_instance.</code><code class="descname">prec_bits_to_words</code><span class="sig-paren">(</span><em>prec_in_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.prec_bits_to_words" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from precision expressed in bits to pari real precision
expressed in words. Note: this rounds up to the nearest word,
adjusts for the two codewords of a pari real, and is
architecture-dependent.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.libs.pari.pari_instance</span> <span class="kn">import</span> <span class="n">prec_bits_to_words</span>
<span class="gp">sage: </span><span class="n">prec_bits_to_words</span><span class="p">(</span><span class="mi">70</span><span class="p">)</span>
<span class="go">5   # 32-bit</span>
<span class="go">4   # 64-bit</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[(</span><span class="mi">32</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">prec_bits_to_words</span><span class="p">(</span><span class="mi">32</span><span class="o">*</span><span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)]</span>
<span class="go">[(32, 3), (64, 4), (96, 5), (128, 6), (160, 7), (192, 8), (224, 9), (256, 10)] # 32-bit</span>
<span class="go">[(32, 3), (64, 3), (96, 4), (128, 4), (160, 5), (192, 5), (224, 6), (256, 6)] # 64-bit</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.libs.pari.pari_instance.prec_dec_to_bits">
<code class="descclassname">sage.libs.pari.pari_instance.</code><code class="descname">prec_dec_to_bits</code><span class="sig-paren">(</span><em>prec_in_dec</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.prec_dec_to_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from precision expressed in decimal to precision expressed
in bits.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.libs.pari.pari_instance</span> <span class="kn">import</span> <span class="n">prec_dec_to_bits</span>
<span class="gp">sage: </span><span class="n">prec_dec_to_bits</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="go">49</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">prec_dec_to_bits</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
<span class="go">[(10, 33),</span>
<span class="go">(20, 66),</span>
<span class="go">(30, 99),</span>
<span class="go">(40, 132),</span>
<span class="go">(50, 166),</span>
<span class="go">(60, 199),</span>
<span class="go">(70, 232),</span>
<span class="go">(80, 265),</span>
<span class="go">(90, 298)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.libs.pari.pari_instance.prec_dec_to_words">
<code class="descclassname">sage.libs.pari.pari_instance.</code><code class="descname">prec_dec_to_words</code><span class="sig-paren">(</span><em>prec_in_dec</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.prec_dec_to_words" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from precision expressed in decimal to precision expressed
in words. Note: this rounds up to the nearest word, adjusts for the
two codewords of a pari real, and is architecture-dependent.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.libs.pari.pari_instance</span> <span class="kn">import</span> <span class="n">prec_dec_to_words</span>
<span class="gp">sage: </span><span class="n">prec_dec_to_words</span><span class="p">(</span><span class="mi">38</span><span class="p">)</span>
<span class="go">6   # 32-bit</span>
<span class="go">4   # 64-bit</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">prec_dec_to_words</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
<span class="go">[(10, 4), (20, 5), (30, 6), (40, 7), (50, 8), (60, 9), (70, 10), (80, 11)] # 32-bit</span>
<span class="go">[(10, 3), (20, 4), (30, 4), (40, 5), (50, 5), (60, 6), (70, 6), (80, 7)] # 64-bit</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.libs.pari.pari_instance.prec_words_to_bits">
<code class="descclassname">sage.libs.pari.pari_instance.</code><code class="descname">prec_words_to_bits</code><span class="sig-paren">(</span><em>prec_in_words</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.prec_words_to_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from pari real precision expressed in words to precision
expressed in bits. Note: this adjusts for the two codewords of a
pari real, and is architecture-dependent.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.libs.pari.pari_instance</span> <span class="kn">import</span> <span class="n">prec_words_to_bits</span>
<span class="gp">sage: </span><span class="n">prec_words_to_bits</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">256   # 32-bit</span>
<span class="go">512   # 64-bit</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">prec_words_to_bits</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
<span class="go">[(3, 32), (4, 64), (5, 96), (6, 128), (7, 160), (8, 192), (9, 224)]  # 32-bit</span>
<span class="go">[(3, 64), (4, 128), (5, 192), (6, 256), (7, 320), (8, 384), (9, 448)] # 64-bit</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.libs.pari.pari_instance.prec_words_to_dec">
<code class="descclassname">sage.libs.pari.pari_instance.</code><code class="descname">prec_words_to_dec</code><span class="sig-paren">(</span><em>prec_in_words</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.pari_instance.prec_words_to_dec" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from precision expressed in words to precision expressed in
decimal. Note: this adjusts for the two codewords of a pari real,
and is architecture-dependent.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.libs.pari.pari_instance</span> <span class="kn">import</span> <span class="n">prec_words_to_dec</span>
<span class="gp">sage: </span><span class="n">prec_words_to_dec</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">28   # 32-bit</span>
<span class="go">57   # 64-bit</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">prec_words_to_dec</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
<span class="go">[(3, 9), (4, 19), (5, 28), (6, 38), (7, 48), (8, 57), (9, 67)] # 32-bit</span>
<span class="go">[(3, 19), (4, 38), (5, 57), (6, 77), (7, 96), (8, 115), (9, 134)] # 64-bit</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="gen.html"
                                  title="previous chapter">Sage class for PARI&#8217;s GEN type</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="closure.html"
                                  title="next chapter">Convert Python functions to PARI closures</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../../_sources/sage/libs/pari/pari_instance.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="closure.html" title="Convert Python functions to PARI closures"
             >next</a> |</li>
        <li class="right" >
          <a href="gen.html" title="Sage class for PARI’s GEN type"
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">C/C++ Library Interfaces</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.4.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>