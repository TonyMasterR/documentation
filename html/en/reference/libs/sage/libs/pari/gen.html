<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Sage class for PARI’s GEN type &mdash; Sage Reference Manual v6.8: C/C++ Library Interfaces</title>
    
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '6.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v6.8: C/C++ Library Interfaces" href="../../../index.html" />
    <link rel="next" title="PARI C-library interface" href="pari_instance.html" />
    <link rel="prev" title="Pari objects" href="gen_py.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pari_instance.html" title="PARI C-library interface"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="gen_py.html" title="Pari objects"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">C/C++ Library Interfaces</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="sage-class-for-pari-s-gen-type">
<span id="sage-libs-pari-gen"></span><h1>Sage class for PARI&#8217;s GEN type<a class="headerlink" href="#sage-class-for-pari-s-gen-type" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.libs.pari.gen"></span><p>See the <tt class="docutils literal"><span class="pre">PariInstance</span></tt> class for documentation and examples.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li>William Stein (2006-03-01): updated to work with PARI 2.2.12-beta</li>
<li>William Stein (2006-03-06): added newtonpoly</li>
<li>Justin Walker: contributed some of the function definitions</li>
<li>Gonzalo Tornaria: improvements to conversions; much better error
handling.</li>
<li>Robert Bradshaw, Jeroen Demeyer, William Stein (2010-08-15):
Upgrade to PARI 2.4.3 (<a class="reference external" href="http://trac.sagemath.org/9343">trac ticket #9343</a>)</li>
<li>Jeroen Demeyer (2011-11-12): rewrite various conversion routines
(<a class="reference external" href="http://trac.sagemath.org/11611">trac ticket #11611</a>, <a class="reference external" href="http://trac.sagemath.org/11854">trac ticket #11854</a>, <a class="reference external" href="http://trac.sagemath.org/11952">trac ticket #11952</a>)</li>
<li>Peter Bruin (2013-11-17): move PariInstance to a separate file
(<a class="reference external" href="http://trac.sagemath.org/15185">trac ticket #15185</a>)</li>
<li>Jeroen Demeyer (2014-02-09): upgrade to PARI 2.7 (<a class="reference external" href="http://trac.sagemath.org/15767">trac ticket #15767</a>)</li>
<li>Martin von Gagern (2014-12-17): Added some Galois functions (<a class="reference external" href="http://trac.sagemath.org/17519">trac ticket #17519</a>)</li>
<li>Jeroen Demeyer (2015-01-12): upgrade to PARI 2.8 (<a class="reference external" href="http://trac.sagemath.org/16997">trac ticket #16997</a>)</li>
<li>Jeroen Demeyer (2015-03-17): automatically generate methods from
<tt class="docutils literal"><span class="pre">pari.desc</span></tt> (<a class="reference external" href="http://trac.sagemath.org/17631">trac ticket #17631</a> and <a class="reference external" href="http://trac.sagemath.org/17860">trac ticket #17860</a>)</li>
</ul>
<dl class="class">
<dt id="sage.libs.pari.gen.gen">
<em class="property">class </em><tt class="descclassname">sage.libs.pari.gen.</tt><tt class="descname">gen</tt><a class="headerlink" href="#sage.libs.pari.gen.gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.libs.pari.gen.gen_auto" title="sage.libs.pari.gen.gen_auto"><tt class="xref py py-class docutils literal"><span class="pre">sage.libs.pari.gen.gen_auto</span></tt></a></p>
<p>Cython extension class that models the PARI GEN type.</p>
<dl class="method">
<dt id="sage.libs.pari.gen.gen.Col">
<tt class="descname">Col</tt><big>(</big><em>x</em>, <em>n=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the object <span class="math">\(x\)</span> into a column vector with minimal size <span class="math">\(|n|\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; gen</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; Make the column vector of minimal length <span class="math">\(|n|\)</span>. If <span class="math">\(n &gt; 0\)</span>,
append zeros; if <span class="math">\(n &lt; 0\)</span>, prepend zeros.</li>
</ul>
<p>OUTPUT:</p>
<p>A PARI column vector (type <tt class="docutils literal"><span class="pre">t_COL</span></tt>)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span><span class="o">.</span><span class="n">Col</span><span class="p">()</span>
<span class="go">[1.50000000000000]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Col</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2; 3,4]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Col</span><span class="p">()</span>
<span class="go">[[1, 2], [3, 4]]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;&quot;Sage&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Col</span><span class="p">()</span>
<span class="go">[&quot;S&quot;, &quot;a&quot;, &quot;g&quot;, &quot;e&quot;]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x + 3*x^3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Col</span><span class="p">()</span>
<span class="go">[3, 0, 1, 0]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x + 3*x^3 + O(x^5)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Col</span><span class="p">()</span>
<span class="go">[1, 0, 3, 0]~</span>
</pre></div>
</div>
<p>We demonstate the <span class="math">\(n\)</span> argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Col</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Col</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Col</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4, 0, 0]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Col</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[0, 0, 1, 2, 3, 4]~</span>
</pre></div>
</div>
<p>See also <a class="reference internal" href="#sage.libs.pari.gen.gen.Vec" title="sage.libs.pari.gen.gen.Vec"><tt class="xref py py-meth docutils literal"><span class="pre">Vec()</span></tt></a> (create a row vector) for more examples
and <a class="reference internal" href="#sage.libs.pari.gen.gen.Colrev" title="sage.libs.pari.gen.gen.Colrev"><tt class="xref py py-meth docutils literal"><span class="pre">Colrev()</span></tt></a> (create a column in reversed order).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Colrev">
<tt class="descname">Colrev</tt><big>(</big><em>x</em>, <em>n=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Colrev" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the object <span class="math">\(x\)</span> into a column vector with minimal size <span class="math">\(|n|\)</span>.
The order of the resulting vector is reversed compared to <a class="reference internal" href="#sage.libs.pari.gen.gen.Col" title="sage.libs.pari.gen.gen.Col"><tt class="xref py py-meth docutils literal"><span class="pre">Col()</span></tt></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; gen</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; Make the vector of minimal length <span class="math">\(|n|\)</span>. If <span class="math">\(n &gt; 0\)</span>,
prepend zeros; if <span class="math">\(n &lt; 0\)</span>, append zeros.</li>
</ul>
<p>OUTPUT:</p>
<p>A PARI column vector (type <tt class="docutils literal"><span class="pre">t_COL</span></tt>)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span><span class="o">.</span><span class="n">Colrev</span><span class="p">()</span>
<span class="go">[1.50000000000000]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Colrev</span><span class="p">()</span>
<span class="go">[4, 3, 2, 1]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2; 3,4]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Colrev</span><span class="p">()</span>
<span class="go">[[3, 4], [1, 2]]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x + 3*x^3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Colrev</span><span class="p">()</span>
<span class="go">[0, 1, 0, 3]~</span>
</pre></div>
</div>
<p>We demonstate the <span class="math">\(n\)</span> argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Colrev</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[4, 3, 2, 1]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Colrev</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[4, 3, 2, 1]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Colrev</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[0, 0, 4, 3, 2, 1]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Colrev</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[4, 3, 2, 1, 0, 0]~</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.List">
<tt class="descname">List</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.List" title="Permalink to this definition">¶</a></dt>
<dd><p>List(x): transforms the PARI vector or list x into a list.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">v</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_VEC&#39;</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w</span>
<span class="go">List([1, 2, 3])</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_LIST&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Mat">
<tt class="descname">Mat</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Mat(x): Returns the matrix defined by x.</p>
<ul class="simple">
<li>If x is already a matrix, a copy of x is created and returned.</li>
<li>If x is not a vector or a matrix, this function returns a 1x1
matrix.</li>
<li>If x is a row (resp. column) vector, this functions returns
a 1-row (resp. 1-column) matrix, <em>unless</em> all elements are
column (resp. row) vectors of the same length, in which case
the vectors are concatenated sideways and the associated big
matrix is returned.</li>
</ul>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - a PARI matrix</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_INT&#39;</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">y</span>
<span class="go">Mat(5)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_MAT&#39;</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2;3,4]&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_MAT&#39;</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2,3,4]&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_VEC&#39;</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">y</span>
<span class="go">Mat([1, 2, 3, 4])</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_MAT&#39;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2;3,4]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">();</span> <span class="n">v</span>
<span class="go">[[1, 3]~, [2, 4]~]</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span>
<span class="go">[1, 2; 3, 4]</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2;3,4]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Col</span><span class="p">();</span> <span class="n">v</span>
<span class="go">[[1, 2], [3, 4]]~</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span>
<span class="go">[1, 2; 3, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Mod">
<tt class="descname">Mod</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Mod(x, y): Returns the object x modulo y, denoted Mod(x, y).</p>
<p>The input y must be a an integer or a polynomial:</p>
<ul class="simple">
<li>If y is an INTEGER, x must also be an integer, a rational
number, or a p-adic number compatible with the modulus y.</li>
<li>If y is a POLYNOMIAL, x must be a scalar (which is not a
polmod), a polynomial, a rational function, or a power
series.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function is not the same as <tt class="docutils literal"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></tt> which is an
integer or a polynomial.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
<li><tt class="docutils literal"><span class="pre">y</span></tt> - integer or polynomial</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - intmod or polmod</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">Mod</span><span class="p">(</span><span class="n">pari</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">Mod(3, 7)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">^</span><span class="mi">2</span>
<span class="go">Mod(2, 7)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">^</span><span class="mi">100</span>
<span class="go">Mod(4, 7)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_INTMOD&#39;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;x^2 + x + 1&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">Mod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span>
<span class="go">Mod(x, x^2 + x + 1)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">*</span><span class="n">a</span>
<span class="go">Mod(-x - 1, x^2 + x + 1)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_POLMOD&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Pol">
<tt class="descname">Pol</tt><big>(</big><em>v=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Pol" title="Permalink to this definition">¶</a></dt>
<dd><p>Pol(x, v): convert x into a polynomial with main variable v and
return the result.</p>
<ul class="simple">
<li>If x is a scalar, returns a constant polynomial.</li>
<li>If x is a power series, the effect is identical to
<tt class="docutils literal"><span class="pre">truncate</span></tt>, i.e. it chops off the <span class="math">\(O(X^k)\)</span>.</li>
<li>If x is a vector, this function creates the polynomial whose
coefficients are given in x, with x[0] being the leading
coefficient (which can be zero).</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>This is <em>not</em> a substitution function. It will not
transform an object containing variables of higher priority
than v:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x+y&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Pol</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">incorrect priority in gtopoly: variable x &lt; y</span>
</pre></div>
</div>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
<li><tt class="docutils literal"><span class="pre">v</span></tt> - (optional) which variable, defaults to &#8216;x&#8217;</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - a polynomial</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;[1,2,3,4]&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">Pol</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">x^3 + 2*x^2 + 3*x + 4</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">*</span><span class="n">f</span>
<span class="go">x^6 + 4*x^5 + 10*x^4 + 20*x^3 + 25*x^2 + 24*x + 16</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;[1,2;3,4]&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">Pol</span><span class="p">()</span>
<span class="go">[1, 3]~*x + [2, 4]~</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Polrev">
<tt class="descname">Polrev</tt><big>(</big><em>v=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Polrev" title="Permalink to this definition">¶</a></dt>
<dd><p>Polrev(x, v): Convert x into a polynomial with main variable v and
return the result. This is the reverse of Pol if x is a vector,
otherwise it is identical to Pol. By &#8220;reverse&#8221; we mean that the
coefficients are reversed.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - a polynomial</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;[1,2,3,4]&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">Polrev</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">4*x^3 + 3*x^2 + 2*x + 1</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">Pol</span><span class="p">()</span>
<span class="go">x^3 + 2*x^2 + 3*x + 4</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">Polrev</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
<span class="go">4*y^3 + 3*y^2 + 2*y + 1</span>
</pre></div>
</div>
<p>Note that Polrev does <em>not</em> reverse the coefficients of a
polynomial!</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span>
<span class="go">4*x^3 + 3*x^2 + 2*x + 1</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">Polrev</span><span class="p">()</span>
<span class="go">4*x^3 + 3*x^2 + 2*x + 1</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;[1,2;3,4]&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">Polrev</span><span class="p">()</span>
<span class="go">[2, 4]~*x + [1, 3]~</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Qfb">
<tt class="descname">Qfb</tt><big>(</big><em>a</em>, <em>b</em>, <em>c</em>, <em>D=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Qfb" title="Permalink to this definition">¶</a></dt>
<dd><p>Qfb(a,b,c,D=0.): Returns the binary quadratic form</p>
<div class="math">
\[ax^2 + bxy + cy^2.\]</div>
<p>The optional D is 0 by default and initializes Shank&#8217;s distance if
<span class="math">\(b^2 - 4ac &gt; 0\)</span>.  The discriminant of the quadratic form must not
be a perfect square.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Negative definite forms are not implemented, so use their
positive definite counterparts instead. (I.e., if f is a
negative definite quadratic form, then -f is positive
definite.)</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span></tt> - gen</li>
<li><tt class="docutils literal"><span class="pre">b</span></tt> - gen</li>
<li><tt class="docutils literal"><span class="pre">c</span></tt> - gen</li>
<li><tt class="docutils literal"><span class="pre">D</span></tt> - gen (optional, defaults to 0)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - binary quadratic form</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">Qfb</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Qfb(3, 7, 1, 0.E-19)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">Qfb</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c"># discriminant is 25</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">domain error in Qfb: issquare(disc) = 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Ser">
<tt class="descname">Ser</tt><big>(</big><em>f</em>, <em>v=-1</em>, <em>precision=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Ser" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a power series or Laurent series in the variable <span class="math">\(v\)</span>
constructed from the object <span class="math">\(f\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> &#8211; PARI gen</li>
<li><tt class="docutils literal"><span class="pre">v</span></tt> &#8211; PARI variable (default: <span class="math">\(x\)</span>)</li>
<li><tt class="docutils literal"><span class="pre">precision</span></tt> &#8211; the desired relative precision (default:
the value returned by <tt class="docutils literal"><span class="pre">pari.get_series_precision()</span></tt>).
This is the absolute precision minus the <span class="math">\(v\)</span>-adic valuation.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>PARI object of type <tt class="docutils literal"><span class="pre">t_SER</span></tt></li>
</ul>
<p>The series is constructed from <span class="math">\(f\)</span> in the following way:</p>
<ul class="simple">
<li>If <span class="math">\(f\)</span> is a scalar, a constant power series is returned.</li>
<li>If <span class="math">\(f\)</span> is a polynomial, it is converted into a power series
in the obvious way.</li>
<li>If <span class="math">\(f\)</span> is a rational function, it will be expanded in a
Laurent series around <span class="math">\(v = 0\)</span>.</li>
<li>If <span class="math">\(f\)</span> is a vector, its coefficients become the coefficients
of the power series, starting from the constant term.  This
is the convention used by the function <tt class="docutils literal"><span class="pre">Polrev()</span></tt>, and the
reverse of that used by <tt class="docutils literal"><span class="pre">Pol()</span></tt>.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function will not transform objects containing
variables of higher priority than <span class="math">\(v\)</span>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">Ser</span><span class="p">()</span>
<span class="go">2 + O(x^16)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">Mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span><span class="o">.</span><span class="n">Ser</span><span class="p">()</span>
<span class="go">Mod(0, 7)*x^15 + O(x^16)</span>

<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">Ser</span><span class="p">()</span>
<span class="go">1 + 2*x + 3*x^2 + 4*x^3 + 5*x^4 + O(x^16)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">Ser</span><span class="p">(</span><span class="s">&#39;v&#39;</span><span class="p">);</span> <span class="k">print</span> <span class="n">f</span>
<span class="go">1 + 2*v + 3*v^2 + 4*v^3 + 5*v^4 + O(v^16)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">f</span>
<span class="go">1 - 2*v + v^2 + 6*v^5 - 17*v^6 + 16*v^7 - 5*v^8 + 36*v^10 - 132*v^11 + 181*v^12 - 110*v^13 + 25*v^14 + 216*v^15 + O(v^16)</span>

<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^5&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Ser</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="go">x^5 + O(x^25)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1/x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Ser</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">x^-1 + O(x^0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Set">
<tt class="descname">Set</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set(x): convert x into a set, i.e. a row vector of strings in
increasing lexicographic order.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - a vector of strings in increasing
lexicographic order.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">Set</span><span class="p">()</span>
<span class="go">[1, 2, 5]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([])</span><span class="o">.</span><span class="n">Set</span><span class="p">()</span>     <span class="c"># the empty set</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">Set</span><span class="p">()</span>
<span class="go">[-1, 1, 3]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Set</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1/(x*y)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Set</span><span class="p">()</span>
<span class="go">[1/(y*x)]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[&quot;bc&quot;,&quot;ab&quot;,&quot;bc&quot;]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Set</span><span class="p">()</span>
<span class="go">[&quot;ab&quot;, &quot;bc&quot;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Str">
<tt class="descname">Str</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Str" title="Permalink to this definition">¶</a></dt>
<dd><p>Str(self): Return the print representation of self as a PARI
object.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> - gen</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - a PARI gen of type t_STR, i.e., a PARI
string</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="s">&#39;abc&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">Str</span><span class="p">()</span>
<span class="go">&quot;[1, 2, [abc, 1]]&quot;</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.54</span><span class="p">])</span><span class="o">.</span><span class="n">Str</span><span class="p">()</span>
<span class="go">&quot;[1, 1, 1.54000000000000]&quot;</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Str</span><span class="p">()</span>       <span class="c"># 1 is automatically converted to string rep</span>
<span class="go">&quot;1&quot;</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>       <span class="c"># PARI variable &quot;x&quot;</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">Str</span><span class="p">()</span>             <span class="c"># is converted to string rep.</span>
<span class="go">&quot;x&quot;</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">Str</span><span class="p">()</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_STR&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Strchr">
<tt class="descname">Strchr</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Strchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Strchr(x): converts x to a string, translating each integer into a
character (in ASCII).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><a class="reference internal" href="#sage.libs.pari.gen.gen.Vecsmall" title="sage.libs.pari.gen.gen.Vecsmall"><tt class="xref py py-meth docutils literal"><span class="pre">Vecsmall()</span></tt></a> is (essentially) the inverse to <a class="reference internal" href="#sage.libs.pari.gen.gen.Strchr" title="sage.libs.pari.gen.gen.Strchr"><tt class="xref py py-meth docutils literal"><span class="pre">Strchr()</span></tt></a>.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - PARI vector of integers</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - a PARI string</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">65</span><span class="p">,</span><span class="mi">66</span><span class="p">,</span><span class="mi">123</span><span class="p">])</span><span class="o">.</span><span class="n">Strchr</span><span class="p">()</span>
<span class="go">&quot;AB{&quot;</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;&quot;Sage&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">()</span>   <span class="c"># pari(&#39;&quot;Sage&quot;&#39;) --&gt; PARI t_STR</span>
<span class="go">Vecsmall([83, 97, 103, 101])</span>
<span class="gp">sage: </span><span class="n">_</span><span class="o">.</span><span class="n">Strchr</span><span class="p">()</span>
<span class="go">&quot;Sage&quot;</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">83</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">103</span><span class="p">,</span> <span class="mi">101</span><span class="p">])</span><span class="o">.</span><span class="n">Strchr</span><span class="p">()</span>
<span class="go">&quot;Sage&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Strexpand">
<tt class="descname">Strexpand</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Strexpand" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate the entries of the vector <span class="math">\(x\)</span> into a single string,
then perform tilde expansion and environment variable expansion
similar to shells.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; PARI gen. Either a vector or an element which is then
treated like <span class="math">\([x]\)</span>.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>PARI string (type <tt class="docutils literal"><span class="pre">t_STR</span></tt>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;&quot;~/subdir&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Strexpand</span><span class="p">()</span>     <span class="c"># random</span>
<span class="go">&quot;/home/johndoe/subdir&quot;</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;&quot;$SAGE_LOCAL&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Strexpand</span><span class="p">()</span>  <span class="c"># random</span>
<span class="go">&quot;/usr/local/sage/local&quot;</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;&quot;$HOME&quot;&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">Strexpand</span><span class="p">()</span> <span class="o">!=</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Strtex">
<tt class="descname">Strtex</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Strtex" title="Permalink to this definition">¶</a></dt>
<dd><p>Strtex(x): Translates the vector x of PARI gens to TeX format and
returns the resulting concatenated strings as a PARI t_STR.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; PARI gen. Either a vector or an element which is then
treated like <span class="math">\([x]\)</span>.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>PARI string (type <tt class="docutils literal"><span class="pre">t_STR</span></tt>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">v</span><span class="o">=</span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^2&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">Strtex</span><span class="p">()</span>
<span class="go">&quot;x^2&quot;</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">=</span><span class="n">pari</span><span class="p">([</span><span class="s">&#39;1/x^2&#39;</span><span class="p">,</span><span class="s">&#39;x&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">Strtex</span><span class="p">()</span>
<span class="go">&quot;\\frac{1}{x^2}x&quot;</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">=</span><span class="n">pari</span><span class="p">([</span><span class="s">&#39;1 + 1/x + 1/(y+1)&#39;</span><span class="p">,</span><span class="s">&#39;x-1&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">Strtex</span><span class="p">()</span>
<span class="go">&quot;\\frac{ \\left(y\n + 2\\right) \\*x\n + \\left(y\n + 1\\right) }{ \\left(y\n + 1\\right) \\*x}x\n - 1&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Vec">
<tt class="descname">Vec</tt><big>(</big><em>x</em>, <em>n=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the object <span class="math">\(x\)</span> into a vector with minimal size <span class="math">\(|n|\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; gen</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; Make the vector of minimal length <span class="math">\(|n|\)</span>. If <span class="math">\(n &gt; 0\)</span>,
append zeros; if <span class="math">\(n &lt; 0\)</span>, prepend zeros.</li>
</ul>
<p>OUTPUT:</p>
<p>A PARI vector (type <tt class="docutils literal"><span class="pre">t_VEC</span></tt>)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[1, 0, 0, 0]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^3 + 3*x - 2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[1, 0, 3, -2]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1, 2; 3, 4]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[[1, 3]~, [2, 4]~]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;&quot;Sage&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[&quot;S&quot;, &quot;a&quot;, &quot;g&quot;, &quot;e&quot;]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;2*x^2 + 3*x^3 + O(x^5)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[2, 3, 0]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;2*x^-2 + 3*x^3 + O(x^5)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[2, 0, 0, 0, 0, 3, 0]</span>
</pre></div>
</div>
<p>Note the different term ordering for polynomials and series:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1 + x + 3*x^3 + O(x^5)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[1, 1, 0, 3, 0]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1 + x + 3*x^3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[3, 0, 1, 1]</span>
</pre></div>
</div>
<p>We demonstate the <span class="math">\(n\)</span> argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Vec</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Vec</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Vec</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4, 0, 0]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Vec</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[0, 0, 1, 2, 3, 4]</span>
</pre></div>
</div>
<p>See also <a class="reference internal" href="#sage.libs.pari.gen.gen.Col" title="sage.libs.pari.gen.gen.Col"><tt class="xref py py-meth docutils literal"><span class="pre">Col()</span></tt></a> (create a column vector) and <a class="reference internal" href="#sage.libs.pari.gen.gen.Vecrev" title="sage.libs.pari.gen.gen.Vecrev"><tt class="xref py py-meth docutils literal"><span class="pre">Vecrev()</span></tt></a>
(create a vector in reversed order).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Vecrev">
<tt class="descname">Vecrev</tt><big>(</big><em>x</em>, <em>n=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Vecrev" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the object <span class="math">\(x\)</span> into a vector with minimal size <span class="math">\(|n|\)</span>.
The order of the resulting vector is reversed compared to <a class="reference internal" href="#sage.libs.pari.gen.gen.Vec" title="sage.libs.pari.gen.gen.Vec"><tt class="xref py py-meth docutils literal"><span class="pre">Vec()</span></tt></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; gen</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; Make the vector of minimal length <span class="math">\(|n|\)</span>. If <span class="math">\(n &gt; 0\)</span>,
prepend zeros; if <span class="math">\(n &lt; 0\)</span>, append zeros.</li>
</ul>
<p>OUTPUT:</p>
<p>A PARI vector (type <tt class="docutils literal"><span class="pre">t_VEC</span></tt>)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">()</span>
<span class="go">[0, 0, 0, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^3 + 3*x - 2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">()</span>
<span class="go">[-2, 3, 0, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">()</span>
<span class="go">[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;Col([1, 2, 3])&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">()</span>
<span class="go">[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1, 2; 3, 4]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">()</span>
<span class="go">[[2, 4]~, [1, 3]~]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;&quot;Sage&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">()</span>
<span class="go">[&quot;e&quot;, &quot;g&quot;, &quot;a&quot;, &quot;S&quot;]</span>
</pre></div>
</div>
<p>We demonstate the <span class="math">\(n\)</span> argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[4, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[4, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[0, 0, 4, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[4, 3, 2, 1, 0, 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Vecsmall">
<tt class="descname">Vecsmall</tt><big>(</big><em>x</em>, <em>n=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Vecsmall" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the object <span class="math">\(x\)</span> into a <tt class="docutils literal"><span class="pre">t_VECSMALL</span></tt> with minimal size <span class="math">\(|n|\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; gen</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; Make the vector of minimal length <span class="math">\(|n|\)</span>. If <span class="math">\(n &gt; 0\)</span>,
append zeros; if <span class="math">\(n &lt; 0\)</span>, prepend zeros.</li>
</ul>
<p>OUTPUT:</p>
<p>A PARI vector of small integers (type <tt class="docutils literal"><span class="pre">t_VECSMALL</span></tt>)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">()</span>
<span class="go">Vecsmall([1, 2, 3])</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;&quot;Sage&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">()</span>
<span class="go">Vecsmall([83, 97, 103, 101])</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">()</span>
<span class="go">Vecsmall([1234])</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^2 + 2*x + 3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">()</span>
<span class="go">Vecsmall([1, 2, 3])</span>
</pre></div>
</div>
<p>We demonstate the <span class="math">\(n\)</span> argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Vecsmall([1, 2, 3])</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Vecsmall([1, 2, 3])</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">Vecsmall([1, 2, 3, 0, 0, 0])</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">)</span>
<span class="go">Vecsmall([0, 0, 0, 1, 2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Zn_issquare">
<tt class="descname">Zn_issquare</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Zn_issquare" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">self</span></tt> is a square modulo <span class="math">\(n\)</span>, <tt class="docutils literal"><span class="pre">False</span></tt>
if not.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; integer</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; integer or factorisation matrix</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">Zn_issquare</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">Zn_issquare</span><span class="p">(</span><span class="mf">30.</span><span class="n">factor</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Zn_sqrt">
<tt class="descname">Zn_sqrt</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.Zn_sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a square root of <tt class="docutils literal"><span class="pre">self</span></tt> modulo <span class="math">\(n\)</span>, if such a square
root exists; otherwise, raise a <tt class="docutils literal"><span class="pre">ValueError</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; integer</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; integer or factorisation matrix</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">Zn_sqrt</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">3 is not a square modulo 4</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">Zn_sqrt</span><span class="p">(</span><span class="mf">30.</span><span class="n">factor</span><span class="p">())</span>
<span class="go">22</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.abs">
<tt class="descname">abs</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the absolute value of x (its modulus, if x is complex).
Rational functions are not allowed. Contrary to most transcendental
functions, an exact argument is not converted to a real number
before applying abs and an exact result is returned if possible.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;-27.1&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
<span class="go">27.1000000000000</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1 + I&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">1.4142135623730950488016887242096980786</span>
</pre></div>
</div>
<p>If x is a polynomial, returns -x if the leading coefficient is real
and negative else returns x. For a power series, the constant
coefficient is considered instead.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x-1.2*x^2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
<span class="go">1.20000000000000*x^2 - x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;-2 + t + O(t^2)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
<span class="go">2 - t + O(t^2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.acos">
<tt class="descname">acos</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.acos" title="Permalink to this definition">¶</a></dt>
<dd><p>The principal branch of <span class="math">\(\cos^{-1}(x)\)</span>, so that
<span class="math">\(\RR e(\mathrm{acos}(x))\)</span> belongs to <span class="math">\([0,Pi]\)</span>. If <span class="math">\(x\)</span>
is real and <span class="math">\(|x| &gt; 1\)</span>, then <span class="math">\(\mathrm{acos}(x)\)</span> is complex.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">acos</span><span class="p">()</span>
<span class="go">1.04719755119660</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">acos</span><span class="p">()</span>
<span class="go">1.04719755119660</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">1.1</span><span class="p">)</span><span class="o">.</span><span class="n">acos</span><span class="p">()</span>
<span class="go">0.443568254385115*I</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">1.1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">acos</span><span class="p">()</span>
<span class="go">0.849343054245252 - 1.09770986682533*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.acosh">
<tt class="descname">acosh</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.acosh" title="Permalink to this definition">¶</a></dt>
<dd><p>The principal branch of <span class="math">\(\cosh^{-1}(x)\)</span>, so that
<span class="math">\(\Im(\mathrm{acosh}(x))\)</span> belongs to <span class="math">\([0,Pi]\)</span>. If
<span class="math">\(x\)</span> is real and <span class="math">\(x &lt; 1\)</span>, then
<span class="math">\(\mathrm{acosh}(x)\)</span> is complex.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">acosh</span><span class="p">()</span>
<span class="go">1.31695789692482</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">acosh</span><span class="p">()</span>
<span class="go">1.57079632679490*I</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">acosh</span><span class="p">()</span>
<span class="go">0.881373587019543 + 1.57079632679490*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.agm">
<tt class="descname">agm</tt><big>(</big><em>x</em>, <em>y</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.agm" title="Permalink to this definition">¶</a></dt>
<dd><p>The arithmetic-geometric mean of x and y. In the case of complex or
negative numbers, the principal square root is always chosen.
p-adic or power series arguments are also allowed. Note that a
p-adic AGM exists only if x/y is congruent to 1 modulo p (modulo 16
for p=2). x and y cannot both be vectors or matrices.</p>
<p>If any of <span class="math">\(x\)</span> or <span class="math">\(y\)</span> is an exact argument, it is
first converted to a real or complex number using the optional
parameter precision (in bits). If the arguments are inexact (e.g.
real), the smallest of their two precisions is used in the
computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">agm</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2.00000000000000</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">agm</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">agm</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1.45679103104691</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">agm</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">-0.964731722290876 + 1.15700282952632*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.algdep">
<tt class="descname">algdep</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.algdep" title="Permalink to this definition">¶</a></dt>
<dd><p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">pari</span><span class="o">.</span><span class="n">set_real_precision</span><span class="p">(</span><span class="mi">210</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w1</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;z1=2-sqrt(26); (z1+I)/(z1-I)&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">w1</span><span class="o">.</span><span class="n">algdep</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span> <span class="n">f</span>
<span class="go">545*x^11 - 297*x^10 - 281*x^9 + 48*x^8 - 168*x^7 + 690*x^6 - 168*x^5 + 48*x^4 - 281*x^3 - 297*x^2 + 545*x</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">w1</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1.0e-200</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[x, 1; x + 1, 2; x^2 + 1, 1; x^2 + x + 1, 1; 545*x^4 - 1932*x^3 + 2790*x^2 - 1932*x + 545, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">set_real_precision</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">210</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.arg">
<tt class="descname">arg</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.arg" title="Permalink to this definition">¶</a></dt>
<dd><p>arg(x): argument of x,such that <span class="math">\(-\pi &lt; \arg(x) \leq \pi\)</span>.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">arg</span><span class="p">()</span>
<span class="go">0.463647609000806</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.asin">
<tt class="descname">asin</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.asin" title="Permalink to this definition">¶</a></dt>
<dd><p>The principal branch of <span class="math">\(\sin^{-1}(x)\)</span>, so that
<span class="math">\(\RR e(\mathrm{asin}(x))\)</span> belongs to <span class="math">\([-\pi/2,\pi/2]\)</span>. If
<span class="math">\(x\)</span> is real and <span class="math">\(|x| &gt; 1\)</span> then <span class="math">\(\mathrm{asin}(x)\)</span>
is complex.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">pari</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">sin</span><span class="p">())</span><span class="o">.</span><span class="n">asin</span><span class="p">()</span>
<span class="go">0.500000000000000</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">asin</span><span class="p">()</span>
<span class="go">1.57079632679490 - 1.31695789692482*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.asinh">
<tt class="descname">asinh</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.asinh" title="Permalink to this definition">¶</a></dt>
<dd><p>The principal branch of <span class="math">\(\sinh^{-1}(x)\)</span>, so that
<span class="math">\(\Im(\mathrm{asinh}(x))\)</span> belongs to <span class="math">\([-\pi/2,\pi/2]\)</span>.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">asinh</span><span class="p">()</span>
<span class="go">1.44363547517881</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">asinh</span><span class="p">()</span>
<span class="go">1.52857091948100 + 0.427078586392476*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.atan">
<tt class="descname">atan</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.atan" title="Permalink to this definition">¶</a></dt>
<dd><p>The principal branch of <span class="math">\(\tan^{-1}(x)\)</span>, so that
<span class="math">\(\RR e(\mathrm{atan}(x))\)</span> belongs to <span class="math">\(]-\pi/2, \pi/2[\)</span>.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">atan</span><span class="p">()</span>
<span class="go">0.785398163397448</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">1.5</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">atan</span><span class="p">()</span>
<span class="go">1.10714871779409 + 0.255412811882995*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.atanh">
<tt class="descname">atanh</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.atanh" title="Permalink to this definition">¶</a></dt>
<dd><p>The principal branch of <span class="math">\(\tanh^{-1}(x)\)</span>, so that
<span class="math">\(\Im(\mathrm{atanh}(x))\)</span> belongs to <span class="math">\(]-\pi/2,\pi/2]\)</span>. If
<span class="math">\(x\)</span> is real and <span class="math">\(|x| &gt; 1\)</span> then <span class="math">\(\mathrm{atanh}(x)\)</span>
is complex.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">atanh</span><span class="p">()</span>
<span class="go">0.E-19</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">atanh</span><span class="p">()</span>
<span class="go">0.549306144334055 - 1.57079632679490*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bernfrac">
<tt class="descname">bernfrac</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bernfrac" title="Permalink to this definition">¶</a></dt>
<dd><p>The Bernoulli number <span class="math">\(B_x\)</span>, where <span class="math">\(B_0 = 1\)</span>,
<span class="math">\(B_1 = -1/2\)</span>, <span class="math">\(B_2 = 1/6,\ldots,\)</span> expressed as a
rational number. The argument <span class="math">\(x\)</span> should be of type
integer.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">bernfrac</span><span class="p">()</span>
<span class="go">43867/798</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">pari</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">bernfrac</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[1, -1/2, 1/6, 0, -1/30, 0, 1/42, 0, -1/30, 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bernreal">
<tt class="descname">bernreal</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bernreal" title="Permalink to this definition">¶</a></dt>
<dd><p>The Bernoulli number <span class="math">\(B_x\)</span>, as for the function bernfrac,
but <span class="math">\(B_x\)</span> is returned as a real number (with the current
precision).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">bernreal</span><span class="p">()</span>
<span class="go">54.9711779448622</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">bernreal</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">192</span><span class="p">)</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">54.9711779448621553884711779448621553884711779448621553885</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bernvec">
<tt class="descname">bernvec</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bernvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a vector containing, as rational numbers, the Bernoulli
numbers <span class="math">\(B_0, B_2,\ldots, B_{2x}\)</span>. This routine is
obsolete. Use bernfrac instead each time you need a Bernoulli
number in exact form.</p>
<p>Note: this routine is implemented using repeated independent calls
to bernfrac, which is faster than the standard recursion in exact
arithmetic.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">bernvec</span><span class="p">()</span>
<span class="go">doctest:...: DeprecationWarning: bernvec() is deprecated, use repeated calls to bernfrac() instead</span>
<span class="go">See http://trac.sagemath.org/15767 for details.</span>
<span class="go">[1, 1/6, -1/30, 1/42, -1/30, 5/66, -691/2730, 7/6, -3617/510]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">bernfrac</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)]</span>
<span class="go">[1, 1/6, -1/30, 1/42, -1/30, 5/66, -691/2730, 7/6, -3617/510]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.besselh1">
<tt class="descname">besselh1</tt><big>(</big><em>nu</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.besselh1" title="Permalink to this definition">¶</a></dt>
<dd><p>The <span class="math">\(H^1\)</span>-Bessel function of index <span class="math">\(\nu\)</span> and
argument <span class="math">\(x\)</span>.</p>
<p>If <span class="math">\(nu\)</span> or <span class="math">\(x\)</span> is an exact argument, it is first
converted to a real or complex number using the optional parameter
precision (in bits). If the arguments are inexact (e.g. real), the
smallest of their precisions is used in the computation, and the
parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">besselh1</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0.486091260585891 - 0.160400393484924*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.besselh2">
<tt class="descname">besselh2</tt><big>(</big><em>nu</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.besselh2" title="Permalink to this definition">¶</a></dt>
<dd><p>The <span class="math">\(H^2\)</span>-Bessel function of index <span class="math">\(\nu\)</span> and
argument <span class="math">\(x\)</span>.</p>
<p>If <span class="math">\(nu\)</span> or <span class="math">\(x\)</span> is an exact argument, it is first
converted to a real or complex number using the optional parameter
precision (in bits). If the arguments are inexact (e.g. real), the
smallest of their precisions is used in the computation, and the
parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">besselh2</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0.486091260585891 + 0.160400393484924*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.besseli">
<tt class="descname">besseli</tt><big>(</big><em>nu</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.besseli" title="Permalink to this definition">¶</a></dt>
<dd><p>Bessel I function (Bessel function of the second kind), with index
<span class="math">\(\nu\)</span> and argument <span class="math">\(x\)</span>. If <span class="math">\(x\)</span> converts to
a power series, the initial factor
<span class="math">\((x/2)^{\nu}/\Gamma(\nu+1)\)</span> is omitted (since it cannot be
represented in PARI when <span class="math">\(\nu\)</span> is not integral).</p>
<p>If <span class="math">\(nu\)</span> or <span class="math">\(x\)</span> is an exact argument, it is first
converted to a real or complex number using the optional parameter
precision (in bits). If the arguments are inexact (e.g. real), the
smallest of their precisions is used in the computation, and the
parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">besseli</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">2.24521244092995</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">besseli</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>
<span class="go">1.12539407613913 + 2.08313822670661*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.besselj">
<tt class="descname">besselj</tt><big>(</big><em>nu</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.besselj" title="Permalink to this definition">¶</a></dt>
<dd><p>Bessel J function (Bessel function of the first kind), with index
<span class="math">\(\nu\)</span> and argument <span class="math">\(x\)</span>. If <span class="math">\(x\)</span> converts to
a power series, the initial factor
<span class="math">\((x/2)^{\nu}/\Gamma(\nu+1)\)</span> is omitted (since it cannot be
represented in PARI when <span class="math">\(\nu\)</span> is not integral).</p>
<p>If <span class="math">\(nu\)</span> or <span class="math">\(x\)</span> is an exact argument, it is first
converted to a real or complex number using the optional parameter
precision (in bits). If the arguments are inexact (e.g. real), the
smallest of their precisions is used in the computation, and the
parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">besselj</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0.486091260585891</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.besseljh">
<tt class="descname">besseljh</tt><big>(</big><em>nu</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.besseljh" title="Permalink to this definition">¶</a></dt>
<dd><p>J-Bessel function of half integral index (Spherical Bessel
function of the first kind). More precisely, besseljh(n,x) computes
<span class="math">\(J_{n+1/2}(x)\)</span> where n must an integer, and x is any
complex value. In the current implementation (PARI, version
2.2.11), this function is not very accurate when <span class="math">\(x\)</span> is
small.</p>
<p>If <span class="math">\(nu\)</span> or <span class="math">\(x\)</span> is an exact argument, it is first
converted to a real or complex number using the optional parameter
precision (in bits). If the arguments are inexact (e.g. real), the
smallest of their precisions is used in the computation, and the
parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">besseljh</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0.412710032209716</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.besselk">
<tt class="descname">besselk</tt><big>(</big><em>nu</em>, <em>x</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.besselk" title="Permalink to this definition">¶</a></dt>
<dd><p>nu.besselk(x, flag=0): K-Bessel function (modified Bessel function
of the second kind) of index nu, which can be complex, and argument
x.</p>
<p>If <span class="math">\(nu\)</span> or <span class="math">\(x\)</span> is an exact argument, it is first
converted to a real or complex number using the optional parameter
precision (in bits). If the arguments are inexact (e.g. real), the
smallest of their precisions is used in the computation, and the
parameter precision is ignored.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">nu</span></tt> - a complex number</li>
<li><tt class="docutils literal"><span class="pre">x</span></tt> - real number (positive or negative)</li>
<li><tt class="docutils literal"><span class="pre">flag</span></tt> - default: 0 or 1: use hyperu (hyperu is
much slower for small x, and doesn&#8217;t work for negative x).</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">besselk</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0.0455907718407551 + 0.0289192946582081*I</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">besselk</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">-4.34870874986752 - 5.38744882697109*I</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">besselk</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3.74224603319728 E-132 + 2.49071062641525 E-134*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.besseln">
<tt class="descname">besseln</tt><big>(</big><em>nu</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.besseln" title="Permalink to this definition">¶</a></dt>
<dd><p>nu.besseln(x): Bessel N function (Spherical Bessel function of the
second kind) of index nu and argument x.</p>
<p>If <span class="math">\(nu\)</span> or <span class="math">\(x\)</span> is an exact argument, it is first
converted to a real or complex number using the optional parameter
precision (in bits). If the arguments are inexact (e.g. real), the
smallest of their precisions is used in the computation, and the
parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">besseln</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">-0.280775566958244 - 0.486708533223726*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bezout">
<tt class="descname">bezout</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bezout" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bezoutres">
<tt class="descname">bezoutres</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bezoutres" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <tt class="xref py py-meth docutils literal"><span class="pre">polresultantext()</span></tt> instead.
See <a class="reference external" href="http://trac.sagemath.org/18203">trac ticket #18203</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bid_get_cyc">
<tt class="descname">bid_get_cyc</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bid_get_cyc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the structure of the group <span class="math">\((O_K/I)^*\)</span>, where <span class="math">\(I\)</span> is the
ideal represented by <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>NOTE: <tt class="docutils literal"><span class="pre">self</span></tt> must be a &#8220;big ideal&#8221; (<tt class="docutils literal"><span class="pre">bid</span></tt>) as returned by
<tt class="docutils literal"><span class="pre">idealstar</span></tt> for example.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealstar</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">bid_get_cyc</span><span class="p">()</span>
<span class="go">[4, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bid_get_gen">
<tt class="descname">bid_get_gen</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bid_get_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of generators of the group <span class="math">\((O_K/I)^*\)</span>, where
<span class="math">\(I\)</span> is the ideal represented by <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>NOTE: <tt class="docutils literal"><span class="pre">self</span></tt> must be a &#8220;big ideal&#8221; (<tt class="docutils literal"><span class="pre">bid</span></tt>) with generators,
as returned by <tt class="docutils literal"><span class="pre">idealstar</span></tt> with <tt class="docutils literal"><span class="pre">flag</span></tt> = 2.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealstar</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">bid_get_gen</span><span class="p">()</span>
<span class="go">[7, [-2, -1]~]</span>
</pre></div>
</div>
<p>We get an exception if we do not supply <tt class="docutils literal"><span class="pre">flag</span> <span class="pre">=</span> <span class="pre">2</span></tt> to
<tt class="docutils literal"><span class="pre">idealstar</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealstar</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">bid_get_gen</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">missing bid generators. Use idealstar(,,2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.binary">
<tt class="descname">binary</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.binary" title="Permalink to this definition">¶</a></dt>
<dd><p>binary(x): gives the vector formed by the binary digits of abs(x),
where x is of type t_INT.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen of type t_INT</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - of type t_VEC</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">binary</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">binary</span><span class="p">()</span>
<span class="go">[1, 0, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">binary</span><span class="p">()</span>
<span class="go">[1, 0, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2005</span><span class="p">)</span><span class="o">.</span><span class="n">binary</span><span class="p">()</span>
<span class="go">[1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;&quot;2&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">binary</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">x (=&quot;2&quot;) must be of type t_INT, but is of type t_STR.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.binomial">
<tt class="descname">binomial</tt><big>(</big><em>x</em>, <em>k</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.binomial" title="Permalink to this definition">¶</a></dt>
<dd><p>binomial(x, k): return the binomial coefficient &#8220;x choose k&#8221;.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - any PARI object (gen)</li>
<li><tt class="docutils literal"><span class="pre">k</span></tt> - integer</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x+1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1/6*x^3 - 1/6*x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;2+x+O(x^2)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1/3*x + O(x^2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bitand">
<tt class="descname">bitand</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bitand" title="Permalink to this definition">¶</a></dt>
<dd><p>bitand(x,y): Bitwise and of two integers x and y. Negative numbers
behave as if modulo some large power of 2.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen (of type t_INT)</li>
<li><tt class="docutils literal"><span class="pre">y</span></tt> - coercible to gen (of type t_INT)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - of type type t_INT</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">bitand</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">bitand</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">binary</span><span class="p">()</span>
<span class="go">[1, 1, 0]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">binary</span><span class="p">()</span>
<span class="go">[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">bitand</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span><span class="o">.</span><span class="n">bitand</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">19</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">bitand</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">-1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bitneg">
<tt class="descname">bitneg</tt><big>(</big><em>x</em>, <em>n=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bitneg" title="Permalink to this definition">¶</a></dt>
<dd><p>bitneg(x,n=-1): Bitwise negation of the integer x truncated to n
bits. n=-1 (the default) represents an infinite sequence of the bit
1. Negative numbers behave as if modulo some large power of 2.</p>
<p>With n=-1, this function returns -n-1. With n = 0, it returns a
number a such that <span class="math">\(a\cong -n-1 \pmod{2^n}\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen (t_INT)</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> - long, default = -1</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - t_INT</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">bitneg</span><span class="p">()</span>
<span class="go">-11</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">bitneg</span><span class="p">()</span>
<span class="go">-2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">bitneg</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">bitneg</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">569</span><span class="p">)</span><span class="o">.</span><span class="n">bitneg</span><span class="p">()</span>
<span class="go">-570</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">569</span><span class="p">)</span><span class="o">.</span><span class="n">bitneg</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">454</span>
<span class="gp">sage: </span><span class="mi">454</span> <span class="o">%</span> <span class="mi">2</span><span class="o">^</span><span class="mi">10</span>
<span class="go">454</span>
<span class="gp">sage: </span><span class="o">-</span><span class="mi">570</span> <span class="o">%</span> <span class="mi">2</span><span class="o">^</span><span class="mi">10</span>
<span class="go">454</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bitnegimply">
<tt class="descname">bitnegimply</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bitnegimply" title="Permalink to this definition">¶</a></dt>
<dd><p>bitnegimply(x,y): Bitwise negated imply of two integers x and y, in
other words, x BITAND BITNEG(y). Negative numbers behave as if
modulo big power of 2.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen (of type t_INT)</li>
<li><tt class="docutils literal"><span class="pre">y</span></tt> - coercible to gen (of type t_INT)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - of type type t_INT</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span><span class="o">.</span><span class="n">bitnegimply</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">14</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">bitnegimply</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">8</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">bitnegimply</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bitor">
<tt class="descname">bitor</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bitor" title="Permalink to this definition">¶</a></dt>
<dd><p>bitor(x,y): Bitwise or of two integers x and y. Negative numbers
behave as if modulo big power of 2.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen (of type t_INT)</li>
<li><tt class="docutils literal"><span class="pre">y</span></tt> - coercible to gen (of type t_INT)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - of type type t_INT</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span><span class="o">.</span><span class="n">bitor</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">14</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">bitor</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">12</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">bitor</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">13</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span><span class="o">.</span><span class="n">bitor</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">13</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bittest">
<tt class="descname">bittest</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bittest" title="Permalink to this definition">¶</a></dt>
<dd><p>bittest(x, long n): Returns bit number n (coefficient of
<span class="math">\(2^n\)</span> in binary) of the integer x. Negative numbers behave
as if modulo a big power of 2.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen (pari integer)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">bool</span></tt> - a Python bool</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">bittest</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">bittest</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">bittest</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">bittest</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">bittest</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">bittest</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">bittest</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[True, False, True, True, True, True, True, True, True, True]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bitxor">
<tt class="descname">bitxor</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bitxor" title="Permalink to this definition">¶</a></dt>
<dd><p>bitxor(x,y): Bitwise exclusive or of two integers x and y. Negative
numbers behave as if modulo big power of 2.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen (of type t_INT)</li>
<li><tt class="docutils literal"><span class="pre">y</span></tt> - coercible to gen (of type t_INT)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - of type type t_INT</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">bitxor</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">bitxor</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">bitxor</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bnf_get_cyc">
<tt class="descname">bnf_get_cyc</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bnf_get_cyc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the structure of the class group of this number field as
a vector of SNF invariants.</p>
<p>NOTE: <tt class="docutils literal"><span class="pre">self</span></tt> must be a &#8220;big number field&#8221; (<tt class="docutils literal"><span class="pre">bnf</span></tt>).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">65</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">pari_bnf</span><span class="p">()</span><span class="o">.</span><span class="n">bnf_get_cyc</span><span class="p">()</span>
<span class="go">[4, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bnf_get_gen">
<tt class="descname">bnf_get_gen</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bnf_get_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of generators of the class group of this
number field.</p>
<p>NOTE: <tt class="docutils literal"><span class="pre">self</span></tt> must be a &#8220;big number field&#8221; (<tt class="docutils literal"><span class="pre">bnf</span></tt>).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">65</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">pari_bnf</span><span class="p">()</span><span class="o">.</span><span class="n">bnf_get_gen</span><span class="p">();</span> <span class="n">G</span>
<span class="go">[[3, 2; 0, 1], [2, 1; 0, 1]]</span>
<span class="gp">sage: </span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">J</span><span class="p">:</span> <span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">G</span><span class="p">)</span>
<span class="go">[Fractional ideal (3, a + 2), Fractional ideal (2, a + 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bnf_get_no">
<tt class="descname">bnf_get_no</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bnf_get_no" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the class number of <tt class="docutils literal"><span class="pre">self</span></tt>, a &#8220;big number field&#8221; (<tt class="docutils literal"><span class="pre">bnf</span></tt>).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">65</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">pari_bnf</span><span class="p">()</span><span class="o">.</span><span class="n">bnf_get_no</span><span class="p">()</span>
<span class="go">8</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bnf_get_reg">
<tt class="descname">bnf_get_reg</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bnf_get_reg" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the regulator of this number field.</p>
<p>NOTE: <tt class="docutils literal"><span class="pre">self</span></tt> must be a &#8220;big number field&#8221; (<tt class="docutils literal"><span class="pre">bnf</span></tt>).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">pari_bnf</span><span class="p">()</span><span class="o">.</span><span class="n">bnf_get_reg</span><span class="p">()</span>
<span class="go">2.66089858019037...</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bnfcertify">
<tt class="descname">bnfcertify</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bnfcertify" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">bnf</span></tt> being as output by <tt class="docutils literal"><span class="pre">bnfinit</span></tt>, checks whether the result is
correct, i.e. whether the calculation of the contents of <tt class="docutils literal"><span class="pre">self</span></tt>
are correct without assuming the Generalized Riemann Hypothesis.
If it is correct, the answer is 1. If not, the program may output
some error message or loop indefinitely.</p>
<p>For more information about PARI and the Generalized Riemann
Hypothesis, see [PariUsers], page 120.</p>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="pariusers" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[PariUsers]</td><td>User&#8217;s Guide to PARI/GP,
<a class="reference external" href="http://pari.math.u-bordeaux.fr/pub/pari/manuals/2.7.0/users.pdf">http://pari.math.u-bordeaux.fr/pub/pari/manuals/2.7.0/users.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bnfunit">
<tt class="descname">bnfunit</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bnfunit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bnrclassno">
<tt class="descname">bnrclassno</tt><big>(</big><em>I</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.bnrclassno" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order of the ray class group of self modulo <tt class="docutils literal"><span class="pre">I</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt>: a pari &#8220;BNF&#8221; object representing a number field</li>
<li><tt class="docutils literal"><span class="pre">I</span></tt>: a pari &#8220;BID&#8221; object representing an ideal of self</li>
</ul>
<p>OUTPUT: integer</p>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">z</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">23</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">primes_above</span><span class="p">(</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">pari_bnf</span><span class="p">()</span><span class="o">.</span><span class="n">bnrclassno</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">_pari_bid_</span><span class="p">())</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ceil">
<tt class="descname">ceil</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>For real x: return the smallest integer = x. For rational
functions: the quotient of numerator by denominator. For lists:
apply componentwise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - depends on type of x</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">1.4</span><span class="p">)</span><span class="o">.</span><span class="n">ceil</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mf">1.4</span><span class="p">)</span><span class="o">.</span><span class="n">ceil</span><span class="p">()</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">ceil</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">ceil</span><span class="p">()</span>
<span class="go">x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">((</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">ceil</span><span class="p">()</span>
<span class="go">x + 1</span>
</pre></div>
</div>
<p>This may be unexpected: but it is correct, treating the argument as
a rational function in RR(x).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mf">2.5</span><span class="p">)</span><span class="o">.</span><span class="n">ceil</span><span class="p">()</span>
<span class="go">x^2 + 5*x + 2.50000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.centerlift">
<tt class="descname">centerlift</tt><big>(</big><em>x</em>, <em>v=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.centerlift" title="Permalink to this definition">¶</a></dt>
<dd><p>centerlift(x,v): Centered lift of x. This function returns exactly
the same thing as lift, except if x is an integer mod.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
<li><tt class="docutils literal"><span class="pre">v</span></tt> - var (default: x)</li>
</ul>
<p>OUTPUT: gen</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">Mod</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">centerlift</span><span class="p">()</span>
<span class="go">-2</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">lift</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;x-1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Mod</span><span class="p">(</span><span class="s">&#39;x^2 + 1&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">centerlift</span><span class="p">()</span>
<span class="go">x - 1</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">lift</span><span class="p">()</span>
<span class="go">x - 1</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;x-y&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Mod</span><span class="p">(</span><span class="s">&#39;x^2+1&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">Mod(x - y, x^2 + 1)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">centerlift</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="go">x - y</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">centerlift</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
<span class="go">Mod(x - y, x^2 + 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.change_variable_name">
<tt class="descname">change_variable_name</tt><big>(</big><em>var</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.change_variable_name" title="Permalink to this definition">¶</a></dt>
<dd><p>In <tt class="docutils literal"><span class="pre">self</span></tt>, which must be a <tt class="docutils literal"><span class="pre">t_POL</span></tt> or <tt class="docutils literal"><span class="pre">t_SER</span></tt>, set the
variable to <tt class="docutils literal"><span class="pre">var</span></tt>.  If the variable of <tt class="docutils literal"><span class="pre">self</span></tt> is already
<tt class="docutils literal"><span class="pre">var</span></tt>, then return <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">You should be careful with variable priorities when
applying this on a polynomial or series of which the
coefficients have polynomial components.  To be safe, only
use this function on polynomials with integer or rational
coefficients.  For a safer alternative, use <a class="reference internal" href="#sage.libs.pari.gen.gen.subst" title="sage.libs.pari.gen.gen.subst"><tt class="xref py py-meth docutils literal"><span class="pre">subst()</span></tt></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^3 + 17*x + 3&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">change_variable_name</span><span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">)</span>
<span class="go">y^3 + 17*y + 3</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;1 + 2*y + O(y^10)&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">change_variable_name</span><span class="p">(</span><span class="s">&quot;q&quot;</span><span class="p">)</span>
<span class="go">1 + 2*q + O(q^10)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">change_variable_name</span><span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="n">f</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In PARI, <tt class="docutils literal"><span class="pre">I</span></tt> refers to the square root of -1, so it cannot be
used as variable name.  Note the difference with <a class="reference internal" href="#sage.libs.pari.gen.gen.subst" title="sage.libs.pari.gen.gen.subst"><tt class="xref py py-meth docutils literal"><span class="pre">subst()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^2 + 1&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">change_variable_name</span><span class="p">(</span><span class="s">&quot;I&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">I already exists with incompatible valence</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="s">&quot;I&quot;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.component">
<tt class="descname">component</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.component" title="Permalink to this definition">¶</a></dt>
<dd><p>component(x, long n): Return n&#8217;th component of the internal
representation of x. This function is 1-based instead of 0-based.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For vectors or matrices, it is simpler to use x[n-1]. For
list objects such as is output by nfinit, it is easier to
use member functions.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> - C long (coercible to)</li>
</ul>
<p>OUTPUT: gen</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^3 + 2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^3 + 2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^3 + 2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">non-existent component: index &lt; 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.conj">
<tt class="descname">conj</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>conj(x): Return the algebraic conjugate of x.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
</ul>
<p>OUTPUT: gen</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x+1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
<span class="go">x + 1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x+I&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
<span class="go">x - I</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1/(2*x+3*I)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
<span class="go">1/(2*x - 3*I)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;2-I&#39;</span><span class="p">,</span><span class="s">&#39;Mod(x,x^2+1)&#39;</span><span class="p">,</span> <span class="s">&#39;Mod(x,x^2-2)&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
<span class="go">[1, 2, 2 + I, Mod(-x, x^2 + 1), Mod(-x, x^2 - 2)]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;Mod(x,x^2-2)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
<span class="go">Mod(-x, x^2 - 2)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;Mod(x,x^3-3)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">incorrect type in gconj (t_POLMOD)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.conjvec">
<tt class="descname">conjvec</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.conjvec" title="Permalink to this definition">¶</a></dt>
<dd><p>conjvec(x): Returns the vector of all conjugates of the algebraic
number x. An algebraic number is a polynomial over Q modulo an
irreducible polynomial.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
</ul>
<p>OUTPUT: gen</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;Mod(1+x,x^2-2)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">conjvec</span><span class="p">()</span>
<span class="go">[-0.414213562373095, 2.41421356237310]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;Mod(x,x^3-3)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">conjvec</span><span class="p">()</span>
<span class="go">[1.44224957030741, -0.721124785153704 - 1.24902476648341*I, -0.721124785153704 + 1.24902476648341*I]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;Mod(1+x,x^2-2)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">conjvec</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">192</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">-0.414213562373095048801688724209698078569671875376948073177</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.content">
<tt class="descname">content</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.content" title="Permalink to this definition">¶</a></dt>
<dd><p>Greatest common divisor of all the components of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">content</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&quot;4*x^3 - 2*x/3 + 2/5&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">content</span><span class="p">()</span>
<span class="go">2/15</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.cos">
<tt class="descname">cos</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.cos" title="Permalink to this definition">¶</a></dt>
<dd><p>The cosine function.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span><span class="o">.</span><span class="n">cos</span><span class="p">()</span>
<span class="go">0.0707372016677029</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">cos</span><span class="p">()</span>
<span class="go">0.833730025131149 - 0.988897705762865*I</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x+O(x^8)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cos</span><span class="p">()</span>
<span class="go">1 - 1/2*x^2 + 1/24*x^4 - 1/720*x^6 + 1/40320*x^8 + O(x^9)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.cosh">
<tt class="descname">cosh</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.cosh" title="Permalink to this definition">¶</a></dt>
<dd><p>The hyperbolic cosine function.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span><span class="o">.</span><span class="n">cosh</span><span class="p">()</span>
<span class="go">2.35240961524325</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">cosh</span><span class="p">()</span>
<span class="go">0.833730025131149 + 0.988897705762865*I</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x+O(x^8)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cosh</span><span class="p">()</span>
<span class="go">1 + 1/2*x^2 + 1/24*x^4 + 1/720*x^6 + O(x^8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.cotan">
<tt class="descname">cotan</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.cotan" title="Permalink to this definition">¶</a></dt>
<dd><p>The cotangent of x.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">cotan</span><span class="p">()</span>
<span class="go">-0.295812915532746</span>
</pre></div>
</div>
<p>Computing the cotangent of <span class="math">\(\pi\)</span> doesn&#8217;t raise an error,
but instead just returns a very large (positive or negative)
number.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">RR</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">cotan</span><span class="p">()</span>         <span class="c"># random</span>
<span class="go">-8.17674825 E15</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.debug">
<tt class="descname">debug</tt><big>(</big><em>depth=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.debug" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the internal structure of self (like the <tt class="docutils literal"><span class="pre">\x</span></tt> command in gp).</p>
<p>EXAMPLE:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1/2, 1.0*I]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">debug</span><span class="p">()</span>  <span class="c"># random addresses</span>
<span class="go">[&amp;=0000000004c5f010] VEC(lg=3):2200000000000003 0000000004c5eff8 0000000004c5efb0</span>
<span class="go">  1st component = [&amp;=0000000004c5eff8] FRAC(lg=3):0800000000000003 0000000004c5efe0 0000000004c5efc8</span>
<span class="go">    num = [&amp;=0000000004c5efe0] INT(lg=3):0200000000000003 (+,lgefint=3):4000000000000003 0000000000000001</span>
<span class="go">    den = [&amp;=0000000004c5efc8] INT(lg=3):0200000000000003 (+,lgefint=3):4000000000000003 0000000000000002</span>
<span class="go">  2nd component = [&amp;=0000000004c5efb0] COMPLEX(lg=3):0c00000000000003 00007fae8a2eb840 0000000004c5ef90</span>
<span class="go">    real = gen_0</span>
<span class="go">    imag = [&amp;=0000000004c5ef90] REAL(lg=4):0400000000000004 (+,expo=0):6000000000000000 8000000000000000 0000000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.denominator">
<tt class="descname">denominator</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.denominator" title="Permalink to this definition">¶</a></dt>
<dd><p>denominator(x): Return the denominator of x. When x is a vector,
this is the least common multiple of the denominators of the
components of x.</p>
<p>what about poly? INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
</ul>
<p>OUTPUT: gen</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;5/9&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span>
<span class="go">9</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;(x+1)/(x-2)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span>
<span class="go">x - 2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;2/3 + 5/8*x + 7/3*x^2 + 1/5*y&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;2/3*x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[2/3, 5/8, 7/3, 1/5]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span>
<span class="go">120</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.dilog">
<tt class="descname">dilog</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.dilog" title="Permalink to this definition">¶</a></dt>
<dd><p>The principal branch of the dilogarithm of <span class="math">\(x\)</span>, i.e. the
analytic continuation of the power series
<span class="math">\(\log_2(x) = \sum_{n&gt;=1} x^n/n^2\)</span>.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dilog</span><span class="p">()</span>
<span class="go">1.64493406684823</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">dilog</span><span class="p">()</span>
<span class="go">0.616850275068085 + 1.46036211675312*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.disc">
<tt class="descname">disc</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.disc" title="Permalink to this definition">¶</a></dt>
<dd><p>e.disc(): return the discriminant of the elliptic curve e.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">disc</span><span class="p">()</span>
<span class="go">-161051</span>
<span class="gp">sage: </span><span class="n">_</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[-1, 1; 11, 5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.eint1">
<tt class="descname">eint1</tt><big>(</big><em>x</em>, <em>n=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.eint1" title="Permalink to this definition">¶</a></dt>
<dd><p>x.eint1(n): exponential integral E1(x):</p>
<div class="math">
\[\int_{x}^{\infty} \frac{e^{-t}}{t} dt\]</div>
<p>If n is present, output the vector [eint1(x), eint1(2*x), ...,
eint1(n*x)]. This is faster than repeatedly calling eint1(i*x).</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>REFERENCE:</p>
<ul class="simple">
<li>See page 262, Prop 5.6.12, of Cohen&#8217;s book &#8220;A Course in
Computational Algebraic Number Theory&#8221;.</li>
</ul>
<p>EXAMPLES:</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.elementval">
<tt class="descname">elementval</tt><big>(</big><em>x</em>, <em>p</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.elementval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.elladd">
<tt class="descname">elladd</tt><big>(</big><em>z0</em>, <em>z1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.elladd" title="Permalink to this definition">¶</a></dt>
<dd><p>e.elladd(z0, z1): return the sum of the points z0 and z1 on this
elliptic curve.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> - elliptic curve E</li>
<li><tt class="docutils literal"><span class="pre">z0</span></tt> - point on E</li>
<li><tt class="docutils literal"><span class="pre">z1</span></tt> - point on E</li>
</ul>
<p>OUTPUT: point on E</p>
<p>EXAMPLES:</p>
<p>First we create an elliptic curve:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
</pre></div>
</div>
<p>Next we add two points on the elliptic curve. Notice that the
Python lists are automatically converted to PARI objects so you
don&#8217;t have to do that explicitly in your code.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elladd</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[-3/4, -15/8]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellak">
<tt class="descname">ellak</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellak" title="Permalink to this definition">¶</a></dt>
<dd><p>e.ellak(n): Returns the coefficient <span class="math">\(a_n\)</span> of the
<span class="math">\(L\)</span>-function of the elliptic curve e, i.e. the
<span class="math">\(n\)</span>-th Fourier coefficient of the weight 2 newform
associated to e (according to Shimura-Taniyama).</p>
<blockquote>
<div>The curve <span class="math">\(e\)</span> <em>must</em> be a medium or long vector of the type
given by ellinit. For this function to work for every n and not
just those prime to the conductor, e must be a minimal Weierstrass
equation. If this is not the case, use the function ellminimalmodel
first before using ellak (or you will get INCORRECT RESULTS!)</div></blockquote>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> - a PARI elliptic curve.</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> - integer.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellak</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellak</span><span class="p">(</span><span class="mi">2005</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellak</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellak</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellan">
<tt class="descname">ellan</tt><big>(</big><em>n</em>, <em>python_ints=False</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellan" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the first <span class="math">\(n\)</span> Fourier coefficients of the modular
form attached to this elliptic curve. See ellak for more details.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">n</span></tt> - a long integer</li>
<li><tt class="docutils literal"><span class="pre">python_ints</span></tt> - bool (default is False); if True,
return a list of Python ints instead of a PARI gen wrapper.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellan</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[1, -2, -1]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellan</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">[1, -2, -1, 2, 1, 2, -2, 0, -2, -2, 1, -2, 4, 4, -1, -4, -2, 4, 0, 2]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellan</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">ellan</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">python_ints</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">v</span>
<span class="go">[1, -2, -1, 2, 1, 2, -2, 0, -2, -2]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellanalyticrank">
<tt class="descname">ellanalyticrank</tt><big>(</big><em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellanalyticrank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 2-component vector with the order of vanishing at
<span class="math">\(s = 1\)</span> of the L-function of the elliptic curve and the value
of the first non-zero derivative.</p>
<p>EXAMPLE:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s">&#39;389a1&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">ellanalyticrank</span><span class="p">()</span>
<span class="go">[2, 1.51863300057685]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellap">
<tt class="descname">ellap</tt><big>(</big><em>p</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellap" title="Permalink to this definition">¶</a></dt>
<dd><p>e.ellap(p): Returns the prime-indexed coefficient <span class="math">\(a_p\)</span> of the
<span class="math">\(L\)</span>-function of the elliptic curve <span class="math">\(e\)</span>, i.e. the <span class="math">\(p\)</span>-th Fourier
coefficient of the newform attached to e.</p>
<p>The computation uses the Shanks&#8211;Mestre method, or the SEA
algorithm.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For this function to work for every n and not just those prime
to the conductor, e must be a minimal Weierstrass equation.
If this is not the case, use the function ellminimalmodel first
before using ellap (or you will get INCORRECT RESULTS!)</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> - a PARI elliptic curve.</li>
<li><tt class="docutils literal"><span class="pre">p</span></tt> - prime integer</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellap</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-2</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellap</span><span class="p">(</span><span class="mi">2003</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellak</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellaplist">
<tt class="descname">ellaplist</tt><big>(</big><em>n</em>, <em>python_ints=False</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellaplist" title="Permalink to this definition">¶</a></dt>
<dd><p>e.ellaplist(n): Returns a PARI list of all the prime-indexed
coefficients <span class="math">\(a_p\)</span> (up to n) of the <span class="math">\(L\)</span>-function
of the elliptic curve <span class="math">\(e\)</span>, i.e. the Fourier coefficients of
the newform attached to <span class="math">\(e\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; an elliptic curve</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; a long integer</li>
<li><tt class="docutils literal"><span class="pre">python_ints</span></tt> &#8211; bool (default is False); if True,
return a list of Python ints instead of a PARI gen wrapper.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The curve e must be a medium or long vector of the type given by
ellinit. For this function to work for every n and not just those
prime to the conductor, e must be a minimal Weierstrass equation.
If this is not the case, use the function ellminimalmodel first
before using ellaplist (or you will get INCORRECT RESULTS!)</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">ellaplist</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="n">v</span>
<span class="go">[-2, -1, 1, -2]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">&lt;type &#39;sage.libs.pari.gen.gen&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_VEC&#39;</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellan</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">[1, -2, -1, 2, 1, 2, -2, 0, -2, -2]</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">ellaplist</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">python_ints</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">v</span>
<span class="go">[-2, -1, 1, -2]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">ellaplist</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="n">v</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">[] &lt;type &#39;sage.libs.pari.gen.gen&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">ellaplist</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">python_ints</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="n">v</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">[] &lt;type &#39;list&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellbil">
<tt class="descname">ellbil</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellbil" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.libs.pari.gen.gen.ellheight" title="sage.libs.pari.gen.gen.ellheight"><tt class="xref py py-meth docutils literal"><span class="pre">ellheight()</span></tt></a> instead.
See <a class="reference external" href="http://trac.sagemath.org/18203">trac ticket #18203</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellchangecurve">
<tt class="descname">ellchangecurve</tt><big>(</big><em>ch</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellchangecurve" title="Permalink to this definition">¶</a></dt>
<dd><p>e.ellchangecurve(ch): return the new model (equation) for the
elliptic curve e given by the change of coordinates ch.</p>
<p>The change of coordinates is specified by a vector ch=[u,r,s,t]; if
<span class="math">\(x'\)</span> and <span class="math">\(y'\)</span> are the new coordinates, then
<span class="math">\(x = u^2 x' + r\)</span> and <span class="math">\(y = u^3 y' + su^2 x' + t\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> - elliptic curve</li>
<li><tt class="docutils literal"><span class="pre">ch</span></tt> - change of coordinates vector with 4
entries</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellglobalred</span><span class="p">()</span>
<span class="go">[10351, [1, -1, 0, -1], 1, [11, 1; 941, 1], [[1, 5, 0, 1], [1, 5, 0, 1]]]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">ellchangecurve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[1, -1, 0, 4, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellchangepoint">
<tt class="descname">ellchangepoint</tt><big>(</big><em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellchangepoint" title="Permalink to this definition">¶</a></dt>
<dd><p>self.ellchangepoint(y): change data on point or vector of points
self on an elliptic curve according to y=[u,r,s,t]</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellisoncurve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellisoncurve</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">ellchangecurve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>   <span class="c"># show only first five entries</span>
<span class="go">[6, -2, -1, 17, 8]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">ellchangepoint</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[-1, 4]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">ellisoncurve</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.elleisnum">
<tt class="descname">elleisnum</tt><big>(</big><em>k</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.elleisnum" title="Permalink to this definition">¶</a></dt>
<dd><p>om.elleisnum(k, flag=0): om=[om1,om2] being a 2-component vector
giving a basis of a lattice L and k an even positive integer,
computes the numerical value of the Eisenstein series of weight k.
When flag is non-zero and k=4 or 6, this gives g2 or g3 with the
correct normalization.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">om</span></tt> - gen, 2-component vector giving a basis of a
lattice L</li>
<li><tt class="docutils literal"><span class="pre">k</span></tt> - int (even positive)</li>
<li><tt class="docutils literal"><span class="pre">flag</span></tt> - int (default 0)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - numerical value of E_k</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">om</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">om</span>
<span class="go">[2.49021256085506, -1.97173770155165*I]</span>
<span class="gp">sage: </span><span class="n">om</span><span class="o">.</span><span class="n">elleisnum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">10.0672605281120</span>
<span class="gp">sage: </span><span class="n">om</span><span class="o">.</span><span class="n">elleisnum</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">112.000000000000</span>
<span class="gp">sage: </span><span class="n">om</span><span class="o">.</span><span class="n">elleisnum</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="go">2.15314248576078 E50</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.elleta">
<tt class="descname">elleta</tt><big>(</big><em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.elleta" title="Permalink to this definition">¶</a></dt>
<dd><p>e.elleta(): return the vector [eta1,eta2] of quasi-periods
associated with the period lattice e.omega() of the elliptic curve
e.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">82</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elleta</span><span class="p">()</span>
<span class="go">[3.60546360143265, 3.60546360143265*I]</span>
<span class="gp">sage: </span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">eta1</span><span class="p">,</span> <span class="n">eta2</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">elleta</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w1</span><span class="o">*</span><span class="n">eta2</span> <span class="o">-</span> <span class="n">w2</span><span class="o">*</span><span class="n">eta1</span>
<span class="go">6.28318530717959*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellglobalred">
<tt class="descname">ellglobalred</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellglobalred" title="Permalink to this definition">¶</a></dt>
<dd><p>Return information related to the global minimal model of the
elliptic curve e.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> &#8211; elliptic curve (returned by ellinit)</li>
</ul>
<p>OUTPUT: A vector [N, [u,r,s,t], c, faN, L] with</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">N</span></tt> - the (arithmetic) conductor of <span class="math">\(e\)</span></p>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">[u,r,s,t]</span></tt> - a vector giving the coordinate change over</dt>
<dd><p class="first last">Q from e to its minimal integral model (see also ellminimalmodel)</p>
</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">c</span></tt> - the product of the local Tamagawa numbers of <span class="math">\(e\)</span>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">faN</span></tt> is the factorization of <span class="math">\(N\)</span></p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">L[i]</span></tt> is <tt class="docutils literal"><span class="pre">elllocalred(E,</span> <span class="pre">faN[i,1])</span></tt></p>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellglobalred</span><span class="p">()</span>
<span class="go">[20144, [1, -2, 0, -1], 1, [2, 4; 1259, 1], [[4, 2, 0, 1], [1, 5, 0, 1]]]</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s">&#39;17a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">a_invariants</span><span class="p">())</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellglobalred</span><span class="p">()</span>
<span class="go">[17, [1, 0, 0, 0], 4, Mat([17, 1]), [[1, 8, 0, 4]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellheight">
<tt class="descname">ellheight</tt><big>(</big><em>a</em>, <em>b=None</em>, <em>flag=-1</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellheight" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonical height of point <tt class="docutils literal"><span class="pre">a</span></tt> on elliptic curve <tt class="docutils literal"><span class="pre">self</span></tt>,
resp. the value of the associated bilinear form at <tt class="docutils literal"><span class="pre">(a,b)</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt>&#8211; an elliptic curve over <span class="math">\(\QQ\)</span>.</li>
<li><tt class="docutils literal"><span class="pre">a</span></tt> &#8211; rational point on <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">b</span></tt> &#8211; (optional) rational point on <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">precision</span> <span class="pre">(optional)</span></tt> &#8211; the precision of the
result, in bits.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellheight</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">0.476711659343740</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellheight</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">precision</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">0.47671165934373953737948605888465305945902294218            # 32-bit</span>
<span class="go">0.476711659343739537379486058884653059459022942211150879336  # 64-bit</span>
</pre></div>
</div>
<p>Computing the bilinear form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellheight</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">0.418188984498861</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellheightmatrix">
<tt class="descname">ellheightmatrix</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellheightmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>e.ellheightmatrix(x): return the height matrix for the vector x of
points on the elliptic curve e.</p>
<p>In other words, it returns the Gram matrix of x with respect to the
height bilinear form on e (see ellbil).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> - elliptic curve over <span class="math">\(\QQ\)</span>,
assumed to be in a standard minimal integral model (as given by
ellminimalmodel)</li>
<li><tt class="docutils literal"><span class="pre">x</span></tt> - vector of rational points on e</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span><span class="o">.</span><span class="n">ellminimalmodel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellheightmatrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="go">[0.476711659343740, 0.418188984498861; 0.418188984498861, 0.686667083305587]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellinit">
<tt class="descname">ellinit</tt><big>(</big><em>flag=-1</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the PARI elliptic curve object with Weierstrass coefficients
given by self, a list with 5 elements.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; a list of 5 coefficients</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">flag</span></tt> &#8211; ignored (for backwards compatibility)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">precision</span> <span class="pre">(optional,</span> <span class="pre">default:</span> <span class="pre">0)</span></tt> - the real
precision to be used in the computation of the components of the
PARI (s)ell structure; if 0, use the default 64 bits.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The parameter <tt class="docutils literal"><span class="pre">precision</span></tt> in <tt class="docutils literal"><span class="pre">ellinit</span></tt> controls not
only the real precision of the resulting (s)ell structure,
but in some cases also the precision of most subsequent
computations with this elliptic curve (if those rely on
the precomputations done by <tt class="docutils literal"><span class="pre">ellinit</span></tt>).  You should
therefore set the precision from the start to the value
you require.</p>
</div>
</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> &#8211; a PARI ell structure.</li>
</ul>
<p>EXAMPLES:</p>
<p>An elliptic curve with integer coefficients:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">();</span> <span class="n">e</span>
<span class="go">[0, 1, 0, 1, 0, 4, 2, 0, -1, -32, 224, -48, 2048/3, Vecsmall([1]), [Vecsmall([64, -1])], [0, 0, 0, 0, 0, 0, 0, 0]]</span>
</pre></div>
</div>
<p>The coefficients can be any ring elements that convert to PARI:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="go">[0, 1/2, 0, -3/4, 0, 2, -3/2, 0, -9/16, 40, -116, 117/4, 256000/117, Vecsmall([1]), [Vecsmall([64, 1])], [0, 0, 0, 0, 0, 0, 0, 0]]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">0.75</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="go">[0, 0.500000000000000, 0, -0.750000000000000, 0, 2.00000000000000, -1.50000000000000, 0, -0.562500000000000, 40.0000000000000, -116.000000000000, 29.2500000000000, 2188.03418803419, Vecsmall([0]), [Vecsmall([64, 1])], [0, 0, 0, 0]]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="go">[0, I, 0, 1, 0, 4*I, 2, 0, -1, -64, 352*I, -80, 16384/5, Vecsmall([0]), [Vecsmall([64, 0])], [0, 0, 0, 0]]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="go">[0, x, 0, 2*x, 1, 4*x, 4*x, 4, -4*x^2 + 4*x, 16*x^2 - 96*x, -64*x^3 + 576*x^2 - 864, 64*x^4 - 576*x^3 + 576*x^2 - 432, (256*x^6 - 4608*x^5 + 27648*x^4 - 55296*x^3)/(4*x^4 - 36*x^3 + 36*x^2 - 27), Vecsmall([0]), [Vecsmall([64, 0])], [0, 0, 0, 0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellisoncurve">
<tt class="descname">ellisoncurve</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellisoncurve" title="Permalink to this definition">¶</a></dt>
<dd><p>e.ellisoncurve(x): return True if the point x is on the elliptic
curve e, False otherwise.</p>
<p>If the point or the curve have inexact coefficients, an attempt is
made to take this into account.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellisoncurve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellisoncurve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellisoncurve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.00000000000000001</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellisoncurve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.000000000000000001</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellisoncurve</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellj">
<tt class="descname">ellj</tt><big>(</big><em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellj" title="Permalink to this definition">¶</a></dt>
<dd><p>Elliptic <span class="math">\(j\)</span>-invariant of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">ellj</span><span class="p">()</span>
<span class="go">1728.00000000000</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">ellj</span><span class="p">()</span>
<span class="go">153553679.396729</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;quadgen(-3)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ellj</span><span class="p">()</span>
<span class="go">0.E-54</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;quadgen(-7)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ellj</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">-3375.000000000000000000000000000000000000000000000000000000000000000000000000</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">ellj</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">domain error in modular function: Im(argument) &lt;= 0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.elllocalred">
<tt class="descname">elllocalred</tt><big>(</big><em>p</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.elllocalred" title="Permalink to this definition">¶</a></dt>
<dd><p>e.elllocalred(p): computes the data of local reduction at the prime
p on the elliptic curve e</p>
<p>For more details on local reduction and Kodaira types, see IV.8 and
IV.9 in J. Silverman&#8217;s book &#8220;Advanced topics in the arithmetic of
elliptic curves&#8221;.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> - elliptic curve with coefficients in <span class="math">\(\ZZ\)</span></li>
<li><tt class="docutils literal"><span class="pre">p</span></tt> - prime number</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - the exponent of p in the arithmetic
conductor of e</li>
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - the Kodaira type of e at p, encoded as an
integer:</li>
<li><tt class="docutils literal"><span class="pre">1</span></tt> - type <span class="math">\(I_0\)</span>: good reduction,
nonsingular curve of genus 1</li>
<li><tt class="docutils literal"><span class="pre">2</span></tt> - type <span class="math">\(II\)</span>: rational curve with a
cusp</li>
<li><tt class="docutils literal"><span class="pre">3</span></tt> - type <span class="math">\(III\)</span>: two nonsingular rational
curves intersecting tangentially at one point</li>
<li><tt class="docutils literal"><span class="pre">4</span></tt> - type <span class="math">\(IV\)</span>: three nonsingular
rational curves intersecting at one point</li>
<li><tt class="docutils literal"><span class="pre">5</span></tt> - type <span class="math">\(I_1\)</span>: rational curve with a
node</li>
<li><tt class="docutils literal"><span class="pre">6</span> <span class="pre">or</span> <span class="pre">larger</span></tt> - think of it as <span class="math">\(4+v\)</span>, then
it is type <span class="math">\(I_v\)</span>: <span class="math">\(v\)</span> nonsingular rational curves
arranged as a <span class="math">\(v\)</span>-gon</li>
<li><tt class="docutils literal"><span class="pre">-1</span></tt> - type <span class="math">\(I_0^*\)</span>: nonsingular rational
curve of multiplicity two with four nonsingular rational curves of
multiplicity one attached</li>
<li><tt class="docutils literal"><span class="pre">-2</span></tt> - type <span class="math">\(II^*\)</span>: nine nonsingular
rational curves in a special configuration</li>
<li><tt class="docutils literal"><span class="pre">-3</span></tt> - type <span class="math">\(III^*\)</span>: eight nonsingular
rational curves in a special configuration</li>
<li><tt class="docutils literal"><span class="pre">-4</span></tt> - type <span class="math">\(IV^*\)</span>: seven nonsingular
rational curves in a special configuration</li>
<li><tt class="docutils literal"><span class="pre">-5</span> <span class="pre">or</span> <span class="pre">smaller</span></tt> - think of it as <span class="math">\(-4-v\)</span>,
then it is type <span class="math">\(I_v^*\)</span>: chain of <span class="math">\(v+1\)</span>
nonsingular rational curves of multiplicity two, with two
nonsingular rational curves of multiplicity one attached at either
end</li>
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - a vector with 4 components, giving the
coordinate changes done during the local reduction; if the first
component is 1, then the equation for e was already minimal at p</li>
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - the local Tamagawa number <span class="math">\(c_p\)</span></li>
</ul>
<p>EXAMPLES:</p>
<p>Type <span class="math">\(I_0\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllocalred</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">[0, 1, [1, 0, 0, 0], 1]</span>
</pre></div>
</div>
<p>Type <span class="math">\(II\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s">&#39;27a3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">a_invariants</span><span class="p">())</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllocalred</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[3, 2, [1, -1, 0, 1], 1]</span>
</pre></div>
</div>
<p>Type <span class="math">\(III\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s">&#39;24a4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">a_invariants</span><span class="p">())</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllocalred</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[3, 3, [1, 1, 0, 1], 2]</span>
</pre></div>
</div>
<p>Type <span class="math">\(IV\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s">&#39;20a2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">a_invariants</span><span class="p">())</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllocalred</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2, 4, [1, 1, 0, 1], 3]</span>
</pre></div>
</div>
<p>Type <span class="math">\(I_1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s">&#39;11a2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">a_invariants</span><span class="p">())</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllocalred</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="go">[1, 5, [1, 0, 0, 0], 1]</span>
</pre></div>
</div>
<p>Type <span class="math">\(I_2\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s">&#39;14a4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">a_invariants</span><span class="p">())</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllocalred</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[1, 6, [1, 0, 0, 0], 2]</span>
</pre></div>
</div>
<p>Type <span class="math">\(I_6\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s">&#39;14a1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">a_invariants</span><span class="p">())</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllocalred</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[1, 10, [1, 0, 0, 0], 2]</span>
</pre></div>
</div>
<p>Type <span class="math">\(I_0^*\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s">&#39;32a3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">a_invariants</span><span class="p">())</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllocalred</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[5, -1, [1, 1, 1, 0], 1]</span>
</pre></div>
</div>
<p>Type <span class="math">\(II^*\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s">&#39;24a5&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">a_invariants</span><span class="p">())</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllocalred</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[3, -2, [1, 2, 1, 4], 1]</span>
</pre></div>
</div>
<p>Type <span class="math">\(III^*\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s">&#39;24a2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">a_invariants</span><span class="p">())</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllocalred</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[3, -3, [1, 2, 1, 4], 2]</span>
</pre></div>
</div>
<p>Type <span class="math">\(IV^*\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s">&#39;20a1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">a_invariants</span><span class="p">())</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllocalred</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2, -4, [1, 0, 1, 2], 3]</span>
</pre></div>
</div>
<p>Type <span class="math">\(I_1^*\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s">&#39;24a1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">a_invariants</span><span class="p">())</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllocalred</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[3, -5, [1, 0, 1, 2], 4]</span>
</pre></div>
</div>
<p>Type <span class="math">\(I_6^*\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s">&#39;90c2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">a_invariants</span><span class="p">())</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllocalred</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[2, -10, [1, 96, 1, 316], 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.elllseries">
<tt class="descname">elllseries</tt><big>(</big><em>s</em>, <em>A=1</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.elllseries" title="Permalink to this definition">¶</a></dt>
<dd><p>e.elllseries(s, A=1): return the value of the <span class="math">\(L\)</span>-series of
the elliptic curve e at the complex number s.</p>
<p>This uses an <span class="math">\(O(N^{1/2})\)</span> algorithm in the conductor N of
e, so it is impractical for large conductors (say greater than
<span class="math">\(10^{12}\)</span>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> - elliptic curve defined over <span class="math">\(\QQ\)</span></li>
<li><tt class="docutils literal"><span class="pre">s</span></tt> - complex number</li>
<li><tt class="docutils literal"><span class="pre">A</span> <span class="pre">(optional)</span></tt> - cutoff point for the integral,
which must be chosen close to 1 for best speed.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllseries</span><span class="p">(</span><span class="mf">2.1</span><span class="p">)</span>
<span class="go">0.402838047956645</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllseries</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
<span class="go">2.98766720445395 E-38</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllseries</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span>
<span class="go">5.48956813891054 E-77</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllseries</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elllseries</span><span class="p">(</span><span class="mf">2.1</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="mf">1.1</span><span class="p">)</span>
<span class="go">0.402838047956645</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellminimalmodel">
<tt class="descname">ellminimalmodel</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellminimalmodel" title="Permalink to this definition">¶</a></dt>
<dd><p>ellminimalmodel(e): return the standard minimal integral model of
the rational elliptic curve e and the corresponding change of
variables. INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> - gen (that defines an elliptic curve)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - minimal model</li>
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - change of coordinates</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">,</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">ellminimalmodel</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[1, -1, 0, 4, 3]</span>
<span class="gp">sage: </span><span class="n">ch</span>
<span class="go">[1, -1, 0, -1]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellchangecurve</span><span class="p">(</span><span class="n">ch</span><span class="p">)[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[1, -1, 0, 4, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellmul">
<tt class="descname">ellmul</tt><big>(</big><em>z</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <span class="math">\(n\)</span> times the point <span class="math">\(z\)</span> on the elliptic curve <span class="math">\(e\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> - elliptic curve</li>
<li><tt class="docutils literal"><span class="pre">z</span></tt> - point on <span class="math">\(e\)</span></li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> - integer, or a complex quadratic integer of complex
multiplication for <span class="math">\(e\)</span>. Complex multiplication currently
only works if <span class="math">\(e\)</span> is defined over <span class="math">\(Q\)</span>.</li>
</ul>
<p>EXAMPLES: We consider a curve with CM by <span class="math">\(Z[i]\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>  <span class="c"># Point of infinite order</span>
</pre></div>
</div>
<p>Multiplication by two:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellmul</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellmul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[1/4, -7/8]</span>
</pre></div>
</div>
<p>Complex multiplication:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">ellmul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">I</span><span class="p">);</span> <span class="n">q</span>
<span class="go">[-2*I, 1 + I]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellmul</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">I</span><span class="p">)</span>
<span class="go">[1/4, -7/8]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">for</span> <span class="n">D</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="o">-</span><span class="mi">19</span><span class="p">,</span> <span class="o">-</span><span class="mi">27</span><span class="p">,</span> <span class="o">-</span><span class="mi">28</span><span class="p">]:</span>  <span class="c"># long time (1s)</span>
<span class="go">....:     hcpol = hilbert_class_polynomial(D)</span>
<span class="go">....:     j = hcpol.roots(multiplicities=False)[0]</span>
<span class="go">....:     t = (1728-j)/(27*j)</span>
<span class="go">....:     E = EllipticCurve([4*t,16*t^2])</span>
<span class="go">....:     P = E.point([0, 4*t])</span>
<span class="go">....:     assert(E.j_invariant() == j)</span>
<span class="go">....:     #</span>
<span class="go">....:     # Compute some CM number and its minimal polynomial</span>
<span class="go">....:     #</span>
<span class="go">....:     cm = pari(&#39;cm = (3*quadgen(%s)+2)&#39;%D)</span>
<span class="go">....:     cm_minpoly = pari(&#39;minpoly(cm)&#39;)</span>
<span class="go">....:     #</span>
<span class="go">....:     # Evaluate cm_minpoly(cm)(P), which should be zero</span>
<span class="go">....:     #</span>
<span class="go">....:     e = pari(E)  # Convert E to PARI</span>
<span class="go">....:     P2 = e.ellmul(P, cm_minpoly[2]*cm + cm_minpoly[1])</span>
<span class="go">....:     P0 = e.elladd(e.ellmul(P, cm_minpoly[0]), e.ellmul(P2, cm))</span>
<span class="go">....:     assert(P0 == E(0))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellorder">
<tt class="descname">ellorder</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellorder" title="Permalink to this definition">¶</a></dt>
<dd><p>e.ellorder(x): return the order of the point x on the elliptic
curve e (return 0 if x is not a torsion point)</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> - elliptic curve defined over <span class="math">\(\QQ\)</span></li>
<li><tt class="docutils literal"><span class="pre">x</span></tt> - point on e</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s">&#39;65a1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">a_invariants</span><span class="p">())</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
</pre></div>
</div>
<p>A point of order two:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellorder</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">2</span>
</pre></div>
</div>
<p>And a point of infinite order:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellorder</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellordinate">
<tt class="descname">ellordinate</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellordinate" title="Permalink to this definition">¶</a></dt>
<dd><p>e.ellordinate(x): return the <span class="math">\(y\)</span>-coordinates of the points
on the elliptic curve e having x as <span class="math">\(x\)</span>-coordinate.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> - elliptic curve</li>
<li><tt class="docutils literal"><span class="pre">x</span></tt> - x-coordinate (can be a complex or p-adic
number, or a more complicated object like a power series)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellordinate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[0, -1]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellordinate</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">[0.582203589721741 - 1.38606082464177*I, -1.58220358972174 + 1.38606082464177*I]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellordinate</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">128</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">0.58220358972174117723338947874993600727 - 1.3860608246417697185311834209833653345*I</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellordinate</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="mi">5</span><span class="o">^</span><span class="mi">1</span><span class="o">+</span><span class="n">O</span><span class="p">(</span><span class="mi">5</span><span class="o">^</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[4*5 + 5^2 + O(5^3), 4 + 3*5^2 + O(5^3)]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellordinate</span><span class="p">(</span><span class="s">&#39;z+2*z^2+O(z^4)&#39;</span><span class="p">)</span>
<span class="go">[-2*z - 7*z^2 - 23*z^3 + O(z^4), -1 + 2*z + 7*z^2 + 23*z^3 + O(z^4)]</span>
</pre></div>
</div>
<p>The field in which PARI looks for the point depends on the
input field:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellordinate</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellordinate</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span>
<span class="go">[11.3427192823270, -12.3427192823270]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellpointtoz">
<tt class="descname">ellpointtoz</tt><big>(</big><em>pt</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellpointtoz" title="Permalink to this definition">¶</a></dt>
<dd><p>e.ellpointtoz(pt): return the complex number (in the fundamental
parallelogram) corresponding to the point <tt class="docutils literal"><span class="pre">pt</span></tt> on the elliptic curve
e, under the complex uniformization of e given by the Weierstrass
p-function.</p>
<p>The complex number z returned by this function lies in the
parallelogram formed by the real and complex periods of e, as given
by e.omega().</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellpointtoz</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">1.85407467730137</span>
</pre></div>
</div>
<p>The point at infinity is sent to the complex number 0:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellpointtoz</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellpow">
<tt class="descname">ellpow</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.libs.pari.gen.gen.ellmul" title="sage.libs.pari.gen.gen.ellmul"><tt class="xref py py-meth docutils literal"><span class="pre">ellmul()</span></tt></a> instead.
See <a class="reference external" href="http://trac.sagemath.org/18203">trac ticket #18203</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellrootno">
<tt class="descname">ellrootno</tt><big>(</big><em>p=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellrootno" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the root number for the L-function of the elliptic curve
E/Q at a prime p (including 0, for the infinite place); return
the global root number if p is omitted.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> - elliptic curve over <span class="math">\(\QQ\)</span></li>
<li><tt class="docutils literal"><span class="pre">p</span></tt> - a prime number or <tt class="docutils literal"><span class="pre">None</span></tt>.</li>
</ul>
<p>OUTPUT: 1 or -1</p>
<p>EXAMPLES: Here is a curve of rank 3:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">82</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellrootno</span><span class="p">()</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellrootno</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellrootno</span><span class="p">(</span><span class="mi">1009</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellsigma">
<tt class="descname">ellsigma</tt><big>(</big><em>z</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellsigma" title="Permalink to this definition">¶</a></dt>
<dd><p>e.ellsigma(z, flag=0): return the value at the complex point z of
the Weierstrass <span class="math">\(\sigma\)</span> function associated to the
elliptic curve e.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellsigma</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>
<span class="go">1.43490215804166 + 1.80307856719256*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellsub">
<tt class="descname">ellsub</tt><big>(</big><em>z0</em>, <em>z1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellsub" title="Permalink to this definition">¶</a></dt>
<dd><p>e.ellsub(z0, z1): return z0-z1 on this elliptic curve.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> - elliptic curve E</li>
<li><tt class="docutils literal"><span class="pre">z0</span></tt> - point on E</li>
<li><tt class="docutils literal"><span class="pre">z1</span></tt> - point on E</li>
</ul>
<p>OUTPUT: point on E</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellsub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[0, 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.elltaniyama">
<tt class="descname">elltaniyama</tt><big>(</big><em>n=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.elltaniyama" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.elltors">
<tt class="descname">elltors</tt><big>(</big><em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.elltors" title="Permalink to this definition">¶</a></dt>
<dd><p>e.elltors(flag = 0): return information about the torsion subgroup
of the elliptic curve e</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> - elliptic curve over <span class="math">\(\QQ\)</span></li>
<li><tt class="docutils literal"><span class="pre">flag</span> <span class="pre">(optional)</span></tt> - specify which algorithm to
use:</li>
<li><tt class="docutils literal"><span class="pre">0</span> <span class="pre">(default)</span></tt> - use Doud&#8217;s algorithm: bound
torsion by computing the cardinality of e(GF(p)) for small primes
of good reduction, then look for torsion points using Weierstrass
parametrization and Mazur&#8217;s classification</li>
<li><tt class="docutils literal"><span class="pre">1</span></tt> - use algorithm given by the Nagell-Lutz
theorem (this is much slower)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - the order of the torsion subgroup, a.k.a.
the number of points of finite order</li>
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - vector giving the structure of the torsion
subgroup as a product of cyclic groups, sorted in non-increasing
order</li>
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - vector giving points on e generating these
cyclic groups</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="mi">26</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elltors</span><span class="p">()</span>
<span class="go">[12, [6, 2], [[1, 2], [3, -2]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellwp">
<tt class="descname">ellwp</tt><big>(</big><em>z='z'</em>, <em>n=20</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellwp" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value or the series expansion of the Weierstrass
<span class="math">\(P\)</span>-function at <span class="math">\(z\)</span> on the lattice <span class="math">\(self\)</span> (or the lattice
defined by the elliptic curve <span class="math">\(self\)</span>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; an elliptic curve created using <tt class="docutils literal"><span class="pre">ellinit</span></tt> or a
list <tt class="docutils literal"><span class="pre">[om1,</span> <span class="pre">om2]</span></tt> representing generators for a lattice.</li>
<li><tt class="docutils literal"><span class="pre">z</span></tt> &#8211; (default: &#8216;z&#8217;) a complex number or a variable name
(as string or PARI variable).</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; (default: 20) if &#8216;z&#8217; is a variable, compute the
series expansion up to at least <span class="math">\(O(z^n)\)</span>.</li>
<li><tt class="docutils literal"><span class="pre">flag</span></tt> &#8211; (default = 0): If <tt class="docutils literal"><span class="pre">flag</span></tt> is 0, compute only
<span class="math">\(P(z)\)</span>.  If <tt class="docutils literal"><span class="pre">flag</span></tt> is 1, compute <span class="math">\([P(z), P'(z)]\)</span>.</li>
</ul>
<p>OUTPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><span class="math">\(P(z)\)</span> (if <tt class="docutils literal"><span class="pre">flag</span></tt> is 0) or <span class="math">\([P(z), P'(z)]\)</span> (if <tt class="docutils literal"><span class="pre">flag</span></tt> is 1).</dt>
<dd><p class="first last">numbers</p>
</dd>
</dl>
</li>
</ul>
<p>EXAMPLES:</p>
<p>We first define the elliptic curve X_0(11):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
</pre></div>
</div>
<p>Compute P(1):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">ellwp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">13.9658695257485</span>
</pre></div>
</div>
<p>Compute P(1+i), where i = sqrt(-1):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">ellwp</span><span class="p">(</span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">))</span>
<span class="go">-1.11510682565555 + 2.33419052307470*I</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">ellwp</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>
<span class="go">-1.11510682565555 + 2.33419052307470*I</span>
</pre></div>
</div>
<p>The series expansion, to the default <span class="math">\(O(z^20)\)</span> precision:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">ellwp</span><span class="p">()</span>
<span class="go">z^-2 + 31/15*z^2 + 2501/756*z^4 + 961/675*z^6 + 77531/41580*z^8 + 1202285717/928746000*z^10 + 2403461/2806650*z^12 + 30211462703/43418875500*z^14 + 3539374016033/7723451736000*z^16 + 413306031683977/1289540602350000*z^18 + O(z^20)</span>
</pre></div>
</div>
<p>Compute the series for wp to lower precision:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">ellwp</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">z^-2 + 31/15*z^2 + O(z^4)</span>
</pre></div>
</div>
<p>Next we use the version where the input is generators for a
lattice:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mf">1.2692</span><span class="p">,</span> <span class="mf">0.63</span> <span class="o">+</span> <span class="mf">1.45</span><span class="o">*</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">ellwp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">13.9656146936689 + 0.000644829272810...*I</span>
</pre></div>
</div>
<p>With flag=1, compute the pair P(z) and P&#8217;(z):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">ellwp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[13.9658695257485, 50.5619300880073]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellzeta">
<tt class="descname">ellzeta</tt><big>(</big><em>z</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellzeta" title="Permalink to this definition">¶</a></dt>
<dd><p>e.ellzeta(z): return the value at the complex point z of the
Weierstrass <span class="math">\(\zeta\)</span> function associated with the elliptic
curve e.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function has infinitely many poles (one of which is at
z=0); attempting to evaluate it too close to one of the
poles will result in a PariError.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> - elliptic curve</li>
<li><tt class="docutils literal"><span class="pre">z</span></tt> - complex number</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellzeta</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1.06479841295883</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellzeta</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">-0.350122658523049 - 0.350122658523049*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellztopoint">
<tt class="descname">ellztopoint</tt><big>(</big><em>z</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ellztopoint" title="Permalink to this definition">¶</a></dt>
<dd><p>e.ellztopoint(z): return the point on the elliptic curve e
corresponding to the complex number z, under the usual complex
uniformization of e by the Weierstrass p-function.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">e</span></tt> - elliptic curve</li>
<li><tt class="docutils literal"><span class="pre">z</span></tt> - complex number</li>
</ul>
<p>OUTPUT point on e</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellztopoint</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>
<span class="go">[0.E-... - 1.02152286795670*I, -0.149072813701096 - 0.149072813701096*I]</span>
</pre></div>
</div>
<p>Complex numbers belonging to the period lattice of e are of course
sent to the point at infinity on e:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellztopoint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.erfc">
<tt class="descname">erfc</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.erfc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complementary error function:</p>
<div class="math">
\[(2/\sqrt{\pi}) \int_{x}^{\infty} e^{-t^2} dt.\]</div>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">erfc</span><span class="p">()</span>
<span class="go">0.157299207050285</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.eta">
<tt class="descname">eta</tt><big>(</big><em>x</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.eta" title="Permalink to this definition">¶</a></dt>
<dd><p>x.eta(flag=0): if flag=0, <span class="math">\(\eta\)</span> function without the
<span class="math">\(q^{1/24}\)</span>; otherwise <span class="math">\(\eta\)</span> of the complex number
<span class="math">\(x\)</span> in the upper half plane intelligently computed using
<span class="math">\(\mathrm{SL}(2,\ZZ)\)</span> transformations.</p>
<p>DETAILS: This functions computes the following. If the input
<span class="math">\(x\)</span> is a complex number with positive imaginary part, the
result is <span class="math">\(\prod_{n=1}^{\infty} (q-1^n)\)</span>, where
<span class="math">\(q=e^{2 i \pi x}\)</span>. If <span class="math">\(x\)</span> is a power series
(or can be converted to a power series) with positive valuation,
the result is <span class="math">\(\prod_{n=1}^{\infty} (1-x^n)\)</span>.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">eta</span><span class="p">()</span>
<span class="go">0.998129069925959</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.eval">
<tt class="descname">eval</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate <tt class="docutils literal"><span class="pre">self</span></tt> with the given arguments.</p>
<p>This is currently implemented in 3 cases:</p>
<ul class="simple">
<li>univariate polynomials, rational functions, power series and
Laurent series (using a single unnamed argument or keyword
arguments),</li>
<li>any PARI object supporting the PARI function <tt class="docutils literal"><span class="pre">substvec</span></tt>
(in particular, multivariate polynomials) using keyword
arguments,</li>
<li>objects of type <tt class="docutils literal"><span class="pre">t_CLOSURE</span></tt> (functions in GP bytecode form)
using unnamed arguments.</li>
</ul>
<p>In no case is mixing unnamed and keyword arguments allowed.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^2 + 1&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_POL&#39;</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1/2</span>
</pre></div>
</div>
<p>The notation <tt class="docutils literal"><span class="pre">f(x)</span></tt> is an alternative for <tt class="docutils literal"><span class="pre">f.eval(x)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Evaluating power series:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;1 + x + x^3 + O(x^7)&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1 + 2*y^2 + 8*y^6 + O(y^14)</span>
</pre></div>
</div>
<p>Substituting zero is sometimes possible, and trying to do so
in illegal cases can raise various errors:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1 + O(x^3)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1/x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">impossible inverse in gdiv: 0</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1/x + O(x^2)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">substituting 0 in Laurent series with negative valuation</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1/x + O(x^2)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;O(x^3)&#39;</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">impossible inverse in gdiv: O(x^3)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;O(x^0)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">domain error in polcoeff: t_SER = O(x^0)</span>
</pre></div>
</div>
<p>Evaluating multivariate polynomials:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;y^2 + x^3&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>    <span class="c"># Dangerous, depends on PARI variable ordering</span>
<span class="go">y^2 + 1</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># Safe</span>
<span class="go">y^2 + 1</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">x^3 + 1</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">evaluating PARI t_POL takes exactly 1 argument (2 given)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s">&#39;2*y&#39;</span><span class="p">)</span>
<span class="go">x^2 + 8*y^3</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">()</span>
<span class="go">x^3 + y^2</span>
</pre></div>
</div>
<p>It&#8217;s not an error to substitute variables which do not appear:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="mi">37</span><span class="p">)</span>
<span class="go">x^3 + y^2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">42</span>
</pre></div>
</div>
<p>We can define and evaluate closures as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;n -&gt; n + 2&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_CLOSURE&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">5</span>

<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;() -&gt; 42&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">()</span>
<span class="go">42</span>

<span class="gp">sage: </span><span class="n">pr</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;s -&gt; print(s)&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pr</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s">&#39;&quot;hello world&quot;&#39;</span><span class="p">)</span>
<span class="go">hello world</span>

<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;myfunc(x,y) = x*y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">30</span>
</pre></div>
</div>
<p>Default arguments work, missing arguments are treated as zero
(like in GP):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;(x, y, z=1.0) -&gt; [x, y, z]&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[1, 2, 1.00000000000000]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[1, 0, 1.00000000000000]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">()</span>
<span class="go">[0, 0, 1.00000000000000]</span>
</pre></div>
</div>
<p>Variadic closures are supported as well (<a class="reference external" href="http://trac.sagemath.org/18623">trac ticket #18623</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;(v[..])-&gt;length(v)&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;(x,y,z[..])-&gt;[x,y,z]&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">(),</span> <span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">([0, 0, []], [1, 0, []], [1, 2, []], [1, 2, [3]], [1, 2, [3, 4]])</span>
</pre></div>
</div>
<p>Using keyword arguments, we can substitute in more complicated
objects, for example a number field:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">nf</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">nf</span>
<span class="go">[y^2 + 1, [0, 1], -4, 1, [Mat([1, 0.E-38 + 1.00000000000000*I]), [1, 1.00000000000000; 1, -1.00000000000000], [1, 1; 1, -1], [2, 0; 0, -2], [2, 0; 0, 2], [1, 0; 0, -1], [1, [0, -1; 1, 0]], []], [0.E-38 + 1.00000000000000*I], [1, y], [1, 0; 0, 1], [1, 0, 0, -1; 0, 1, 1, 0]]</span>
<span class="gp">sage: </span><span class="n">nf</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="go">[x^2 + 1, [0, 1], -4, 1, [Mat([1, 0.E-38 + 1.00000000000000*I]), [1, 1.00000000000000; 1, -1.00000000000000], [1, 1; 1, -1], [2, 0; 0, -2], [2, 0; 0, 2], [1, 0; 0, -1], [1, [0, -1; 1, 0]], []], [0.E-38 + 1.00000000000000*I], [1, x], [1, 0; 0, 1], [1, 0, 0, -1; 0, 1, 1, 0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.exp">
<tt class="descname">exp</tt><big>(</big><em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>x.exp(): exponential of x.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">1.00000000000000</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">2.71828182845905</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x+O(x^8)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">1 + x + 1/2*x^2 + 1/6*x^3 + 1/24*x^4 + 1/120*x^5 + 1/720*x^6 + 1/5040*x^7 + O(x^8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.factor">
<tt class="descname">factor</tt><big>(</big><em>limit=-1</em>, <em>proof=1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the factorization of x.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">limit</span></tt> &#8211; (default: -1) is optional and can be set
whenever x is of (possibly recursive) rational type. If limit is
set return partial factorization, using primes up to limit (up to
primelimit if limit=0).</li>
<li><tt class="docutils literal"><span class="pre">proof</span></tt> &#8211; (default: True) optional. If False (not the default),
returned factors larger than <span class="math">\(2^{64}\)</span> may only be pseudoprimes.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the standard PARI/GP interpreter and C-library the
factor command <em>always</em> has proof=False, so beware!</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^10-1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[x - 1, 1; x + 1, 1; x^4 - x^3 + x^2 - x + 1, 1; x^4 + x^3 + x^2 + x + 1, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">100</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[3, 1; 5, 3; 11, 1; 31, 1; 41, 1; 101, 1; 251, 1; 601, 1; 1801, 1; 4051, 1; 8101, 1; 268501, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">100</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">(</span><span class="n">proof</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">[3, 1; 5, 3; 11, 1; 31, 1; 41, 1; 101, 1; 251, 1; 601, 1; 1801, 1; 4051, 1; 8101, 1; 268501, 1]</span>
</pre></div>
</div>
<p>We illustrate setting a limit:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">next_prime</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">50</span><span class="p">)</span><span class="o">*</span><span class="n">next_prime</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">60</span><span class="p">)</span><span class="o">*</span><span class="n">next_prime</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">factor</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[10007, 1; 100000000000000000000000000000000000000000000000151000000000700000000000000000000000000000000000000000000001057, 1]</span>
</pre></div>
</div>
<p>PARI doesn&#8217;t have an algorithm for factoring multivariate
polynomials:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^3 - y^3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">sorry, factor for general polynomials is not yet implemented</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.factornf">
<tt class="descname">factornf</tt><big>(</big><em>t</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.factornf" title="Permalink to this definition">¶</a></dt>
<dd><p>Factorization of the polynomial <tt class="docutils literal"><span class="pre">self</span></tt> over the number field
defined by the polynomial <tt class="docutils literal"><span class="pre">t</span></tt>.  This does not require that <span class="math">\(t\)</span>
is integral, nor that the discriminant of the number field can be
factored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">factornf</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">pari_polynomial</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">))</span>
<span class="go">[x + Mod(-4*a, 8*a^2 - 1), 1; x + Mod(4*a, 8*a^2 - 1), 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.factorpadic">
<tt class="descname">factorpadic</tt><big>(</big><em>p</em>, <em>r=20</em>, <em>flag=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.factorpadic" title="Permalink to this definition">¶</a></dt>
<dd><p>p-adic factorization of the polynomial <tt class="docutils literal"><span class="pre">pol</span></tt> to precision <tt class="docutils literal"><span class="pre">r</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pol</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">pol</span><span class="p">)</span><span class="o">.</span><span class="n">factorpadic</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[(1 + O(5^20))*x + (1 + O(5^20)), 2; (1 + O(5^20))*x + (4 + 4*5 + 4*5^2 + 4*5^3 + 4*5^4 + 4*5^5 + 4*5^6 + 4*5^7 + 4*5^8 + 4*5^9 + 4*5^10 + 4*5^11 + 4*5^12 + 4*5^13 + 4*5^14 + 4*5^15 + 4*5^16 + 4*5^17 + 4*5^18 + 4*5^19 + O(5^20)), 2]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">pol</span><span class="p">)</span><span class="o">.</span><span class="n">factorpadic</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[(1 + O(5^3))*x + (1 + O(5^3)), 2; (1 + O(5^3))*x + (4 + 4*5 + 4*5^2 + O(5^3)), 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ffgen">
<tt class="descname">ffgen</tt><big>(</big><em>T</em>, <em>v=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ffgen" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the generator <span class="math">\(g=x \bmod T\)</span> of the finite field defined
by the polynomial <span class="math">\(T\)</span>.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">T</span></tt> &#8211; a gen of type t_POL with coefficients of type t_INTMOD:</dt>
<dd><p class="first last">a polynomial over a prime finite field</p>
</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">v</span></tt> &#8211; string: a variable name or -1 (optional)</p>
</li>
</ul>
<p>If <span class="math">\(v\)</span> is a string, then <span class="math">\(g\)</span> will be a polynomial in <span class="math">\(v\)</span>, else the
variable of the polynomial <span class="math">\(T\)</span> is used.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="s">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">ffgen</span><span class="p">()</span>
<span class="go">x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">ffgen</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="go">a</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ffinit">
<tt class="descname">ffinit</tt><big>(</big><em>p</em>, <em>n</em>, <em>v=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ffinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a monic irreducible polynomial <span class="math">\(g\)</span> of degree <span class="math">\(n\)</span> over the
finite field of <span class="math">\(p\)</span> elements.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">p</span></tt> &#8211; a gen of type t_INT: a prime number</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; integer: the degree of the polynomial</li>
<li><tt class="docutils literal"><span class="pre">v</span></tt> &#8211; string: a variable name or -1 (optional)</li>
</ul>
<p>If <span class="math">\(v \geq 0', then `g\)</span> will be a polynomial in <span class="math">\(v\)</span>, else the
variable <span class="math">\(x\)</span> is used.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">ffinit</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="go">Mod(1, 7)*x^11 + Mod(1, 7)*x^10 + Mod(4, 7)*x^9 + Mod(5, 7)*x^8 + Mod(1, 7)*x^7 + Mod(1, 7)*x^2 + Mod(1, 7)*x + Mod(6, 7)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2003</span><span class="p">)</span><span class="o">.</span><span class="n">ffinit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Mod(1, 2003)*x^3 + Mod(1, 2003)*x^2 + Mod(1993, 2003)*x + Mod(1995, 2003)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.fflog">
<tt class="descname">fflog</tt><big>(</big><em>g</em>, <em>o=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.fflog" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the discrete logarithm of the finite field element
<tt class="docutils literal"><span class="pre">self</span></tt> in base <span class="math">\(g\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; a PARI finite field element (<tt class="docutils literal"><span class="pre">FFELT</span></tt>) in the
multiplicative group generated by <span class="math">\(g\)</span>.</li>
<li><tt class="docutils literal"><span class="pre">g</span></tt> &#8211; the base of the logarithm as a PARI finite field
element (<tt class="docutils literal"><span class="pre">FFELT</span></tt>). If <span class="math">\(o\)</span> is <tt class="docutils literal"><span class="pre">None</span></tt>, this must be a
generator of the parent finite field.</li>
<li><tt class="docutils literal"><span class="pre">o</span></tt> &#8211; either <tt class="docutils literal"><span class="pre">None</span></tt> (then <span class="math">\(g\)</span> must a primitive root)
or the order of <span class="math">\(g\)</span> or a tuple <tt class="docutils literal"><span class="pre">(o,</span> <span class="pre">o.factor())</span></tt>.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>An integer <span class="math">\(n\)</span> such that <tt class="docutils literal"><span class="pre">self</span> <span class="pre">=</span> <span class="pre">g^n</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">k</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">ffprimroot</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">g</span><span class="o">^</span><span class="mi">1234</span><span class="p">)</span><span class="o">.</span><span class="n">fflog</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">1234</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">k</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">fflog</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>This element does not generate the full multiplicative group:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">g</span><span class="o">^</span><span class="mi">5</span>
<span class="gp">sage: </span><span class="nb">ord</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">fforder</span><span class="p">();</span> <span class="nb">ord</span>
<span class="go">819</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">b</span><span class="o">^</span><span class="mi">555</span><span class="p">)</span><span class="o">.</span><span class="n">fflog</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">ord</span><span class="p">)</span>
<span class="go">555</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">b</span><span class="o">^</span><span class="mi">555</span><span class="p">)</span><span class="o">.</span><span class="n">fflog</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="nb">ord</span><span class="p">,</span> <span class="nb">ord</span><span class="o">.</span><span class="n">factor</span><span class="p">())</span> <span class="p">)</span>
<span class="go">555</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.fforder">
<tt class="descname">fforder</tt><big>(</big><em>o=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.fforder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the multiplicative order of the finite field element
<tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; a PARI finite field element (<tt class="docutils literal"><span class="pre">FFELT</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">o</span></tt> &#8211; either <tt class="docutils literal"><span class="pre">None</span></tt> or a multiple of the order of <span class="math">\(o\)</span>
or a tuple <tt class="docutils literal"><span class="pre">(o,</span> <span class="pre">o.factor())</span></tt>.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>The smallest positive integer <span class="math">\(n\)</span> such that <tt class="docutils literal"><span class="pre">self^n</span> <span class="pre">=</span> <span class="pre">1</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">k</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="o">^</span><span class="mi">80</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">ffprimroot</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">fforder</span><span class="p">()</span>
<span class="go">82718061255302767487140869206996285356581211090087890624</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">fforder</span><span class="p">(</span> <span class="p">(</span><span class="mi">5</span><span class="o">^</span><span class="mi">80</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">factor</span><span class="p">(</span><span class="mi">5</span><span class="o">^</span><span class="mi">80</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">)</span>
<span class="go">82718061255302767487140869206996285356581211090087890624</span>
<span class="gp">sage: </span><span class="n">k</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span><span class="o">.</span><span class="n">fforder</span><span class="p">(</span><span class="n">o</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ffprimroot">
<tt class="descname">ffprimroot</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ffprimroot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a primitive root of the multiplicative group of the
definition field of the given finite field element.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; a PARI finite field element (<tt class="docutils literal"><span class="pre">FFELT</span></tt>)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>A generator of the multiplicative group of the finite field
generated by <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">k</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">ffprimroot</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span>  <span class="c"># random</span>
<span class="go">a + 1</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">fforder</span><span class="p">()</span>
<span class="go">8</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.fibonacci">
<tt class="descname">fibonacci</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.fibonacci" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Fibonacci number of index x.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">fibonacci</span><span class="p">()</span>
<span class="go">2584</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">pari</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">fibonacci</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.floor">
<tt class="descname">floor</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>For real x: return the largest integer = x. For rational functions:
the quotient of numerator by denominator. For lists: apply
componentwise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
</ul>
<p>OUTPUT: gen</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">floor</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">11</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">floor</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">1.17</span><span class="p">)</span><span class="o">.</span><span class="n">floor</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.3</span><span class="p">,</span><span class="mf">4.99</span><span class="p">])</span><span class="o">.</span><span class="n">floor</span><span class="p">()</span>
<span class="go">[1, 2, 4]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([[</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">2.2</span><span class="p">],[</span><span class="mf">3.3</span><span class="p">,</span><span class="mf">4.4</span><span class="p">]])</span><span class="o">.</span><span class="n">floor</span><span class="p">()</span>
<span class="go">[[1, 2], [3, 4]]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">floor</span><span class="p">()</span>
<span class="go">x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">((</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">floor</span><span class="p">()</span>
<span class="go">x + 1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mf">2.5</span><span class="p">)</span><span class="o">.</span><span class="n">floor</span><span class="p">()</span>
<span class="go">x^2 + 5*x + 2.50000000000000</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;&quot;hello world&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">floor</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">incorrect type in gfloor (t_STR)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.frac">
<tt class="descname">frac</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.frac" title="Permalink to this definition">¶</a></dt>
<dd><p>frac(x): Return the fractional part of x, which is x - floor(x).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
</ul>
<p>OUTPUT: gen</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">1.75</span><span class="p">)</span><span class="o">.</span><span class="n">frac</span><span class="p">()</span>
<span class="go">0.750000000000000</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">frac</span><span class="p">()</span>
<span class="go">0.414213562373095</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;sqrt(-2)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">frac</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">incorrect type in gfloor (t_COMPLEX)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.galoisfixedfield">
<tt class="descname">galoisfixedfield</tt><big>(</big><em>perm</em>, <em>flag=0</em>, <em>v=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.galoisfixedfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the fixed field of the Galois group <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This wraps the <a class="reference external" href="http://pari.math.u-bordeaux.fr/dochtml/html.stable/Functions_related_to_general_number_fields.html#galoisfixedfield">galoisfixedfield</a> function from PARI.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; A Galois group as generated by <a class="reference internal" href="#sage.libs.pari.gen.gen.galoisinit" title="sage.libs.pari.gen.gen.galoisinit"><tt class="xref py py-meth docutils literal"><span class="pre">galoisinit()</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">perm</span></tt> &#8211; An element of a Galois group, a vector of such
elements, or a subgroup generated by <a class="reference internal" href="#sage.libs.pari.gen.gen.galoissubgroups" title="sage.libs.pari.gen.gen.galoissubgroups"><tt class="xref py py-meth docutils literal"><span class="pre">galoissubgroups()</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">flag</span></tt> &#8211; Amount of data to include in output (see below).</li>
<li><tt class="docutils literal"><span class="pre">v</span></tt> &#8211; Name of the second variable to use (default: <tt class="docutils literal"><span class="pre">'y'</span></tt>).</li>
</ul>
<p>OUTPUT:</p>
<p>This depends on the value of <tt class="docutils literal"><span class="pre">flag</span></tt>:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">flag</span> <span class="pre">=</span> <span class="pre">0</span></tt> &#8211; A two-element tuple consisting of the defining
polynomial of the fixed field and a description of its roots
modulo the primes used in the group.</li>
<li><tt class="docutils literal"><span class="pre">flag</span> <span class="pre">=</span> <span class="pre">1</span></tt> &#8211; Just the polynomial.</li>
<li><tt class="docutils literal"><span class="pre">flag</span> <span class="pre">=</span> <span class="pre">2</span></tt> &#8211; A third tuple element will describe the
factorization of the original polynomial, using the variable
indicated by <tt class="docutils literal"><span class="pre">v</span></tt> to stand for a root of the polynomial
from the first tuple element.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">galoisinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">galoisfixedfield</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">flag</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[x^2 + 4, Mod(2*x^2, x^4 + 1), [x^2 - 1/2*y, x^2 + 1/2*y]]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">galoisfixedfield</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">5</span><span class="p">:</span><span class="mi">7</span><span class="p">])</span>
<span class="go">[x^4 + 1, Mod(x, x^4 + 1)]</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">galoissubgroups</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">galoisfixedfield</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">flag</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="s">&#39;z&#39;</span><span class="p">)</span>
<span class="go">[x^2 + 2, Mod(x^3 + x, x^4 + 1), [x^2 - z*x - 1, x^2 + z*x - 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.galoisinit">
<tt class="descname">galoisinit</tt><big>(</big><em>den=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.galoisinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Galois group of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This wraps the <a class="reference external" href="http://pari.math.u-bordeaux.fr/dochtml/html.stable/Functions_related_to_general_number_fields.html#galoisinit">galoisinit</a> function from PARI.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; A number field or a polynomial.</li>
<li><tt class="docutils literal"><span class="pre">den</span></tt> &#8211; If set, this must be a multiple of the least
common denominator of the automorphisms, expressed as
polynomials in a root of the defining polynomial.</li>
</ul>
<p>OUTPUT:</p>
<p>An eight-tuple, represented as a GEN object,
with details about the Galois group of the number field.
For details see <a class="reference external" href="http://pari.math.u-bordeaux.fr/dochtml/html.stable/Functions_related_to_general_number_fields.html#galoisinit">the PARI manual</a>.
Note that the element indices in Sage and PARI are
0-based and 1-based, respectively.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">108</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">galoisinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">==</span> <span class="n">prod</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.galoisisabelian">
<tt class="descname">galoisisabelian</tt><big>(</big><em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.galoisisabelian" title="Permalink to this definition">¶</a></dt>
<dd><p>Decide whether <tt class="docutils literal"><span class="pre">self</span></tt> is an abelian group.</p>
<p>This wraps the <a class="reference external" href="http://pari.math.u-bordeaux.fr/dochtml/html.stable/Functions_related_to_general_number_fields.html#galoisisabelian">galoisisabelian</a> function from PARI.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; A Galois group as generated by <a class="reference internal" href="#sage.libs.pari.gen.gen.galoisinit" title="sage.libs.pari.gen.gen.galoisinit"><tt class="xref py py-meth docutils literal"><span class="pre">galoisinit()</span></tt></a>,
or a subgroup thereof as returned by <a class="reference internal" href="#sage.libs.pari.gen.gen.galoissubgroups" title="sage.libs.pari.gen.gen.galoissubgroups"><tt class="xref py py-meth docutils literal"><span class="pre">galoissubgroups()</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">flag</span></tt> &#8211; Controls the details contained in the returned result.</li>
</ul>
<p>OUTPUT:</p>
<p>This returns 0 if <tt class="docutils literal"><span class="pre">self</span></tt> is not an abelian group. If it is,
then the output depends on <tt class="docutils literal"><span class="pre">flag</span></tt>:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">flag</span> <span class="pre">=</span> <span class="pre">0</span></tt> &#8211; The HNF matrix of <tt class="docutils literal"><span class="pre">self</span></tt> over its generators
is returned.</li>
<li><tt class="docutils literal"><span class="pre">flag</span> <span class="pre">=</span> <span class="pre">1</span></tt> &#8211; The return value is simply 1.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">108</span><span class="p">)</span><span class="o">.</span><span class="n">galoisinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">galoisisabelian</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">galoissubgroups</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">galoisisabelian</span><span class="p">()</span>
<span class="go">Mat(2)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">galoisisabelian</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.galoisisnormal">
<tt class="descname">galoisisnormal</tt><big>(</big><em>subgrp</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.galoisisnormal" title="Permalink to this definition">¶</a></dt>
<dd><p>Decide whether <tt class="docutils literal"><span class="pre">subgrp</span></tt> is a normal subgroup of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This wraps the <a class="reference external" href="http://pari.math.u-bordeaux.fr/dochtml/html.stable/Functions_related_to_general_number_fields.html#galoisisnormal">galoisisnormal</a> function from PARI.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; A Galois group as generated by <a class="reference internal" href="#sage.libs.pari.gen.gen.galoisinit" title="sage.libs.pari.gen.gen.galoisinit"><tt class="xref py py-meth docutils literal"><span class="pre">galoisinit()</span></tt></a>,
or a subgroup thereof as returned by <a class="reference internal" href="#sage.libs.pari.gen.gen.galoissubgroups" title="sage.libs.pari.gen.gen.galoissubgroups"><tt class="xref py py-meth docutils literal"><span class="pre">galoissubgroups()</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">subgrp</span></tt> &#8211; A subgroup of <tt class="docutils literal"><span class="pre">self</span></tt> as returned by
<a class="reference internal" href="#sage.libs.pari.gen.gen.galoissubgroups" title="sage.libs.pari.gen.gen.galoissubgroups"><tt class="xref py py-meth docutils literal"><span class="pre">galoissubgroups()</span></tt></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>One if <tt class="docutils literal"><span class="pre">subgrp</span></tt> is a subgroup of <tt class="docutils literal"><span class="pre">self</span></tt>, zero otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">108</span><span class="p">)</span><span class="o">.</span><span class="n">galoisinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">galoissubgroups</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">galoisisnormal</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">galoisisnormal</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.galoispermtopol">
<tt class="descname">galoispermtopol</tt><big>(</big><em>perm</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.galoispermtopol" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the polynomial defining the Galois automorphism <tt class="docutils literal"><span class="pre">perm</span></tt>.</p>
<p>This wraps the <a class="reference external" href="http://pari.math.u-bordeaux.fr/dochtml/html.stable/Functions_related_to_general_number_fields.html#galoispermtopol">galoispermtopol</a> function from PARI.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; A Galois group as generated by <a class="reference internal" href="#sage.libs.pari.gen.gen.galoisinit" title="sage.libs.pari.gen.gen.galoisinit"><tt class="xref py py-meth docutils literal"><span class="pre">galoisinit()</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">perm</span></tt> &#8211; A permutation from that group,
or a vector or matrix of such permutations.</li>
</ul>
<p>OUTPUT:</p>
<p>The defining polynomial of the specified automorphism.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">108</span><span class="p">)</span><span class="o">.</span><span class="n">galoisinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">galoispermtopol</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
<span class="go">[x, 1/12*x^4 - 1/2*x, -1/12*x^4 - 1/2*x, 1/12*x^4 + 1/2*x, -1/12*x^4 + 1/2*x, -x]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">galoispermtopol</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1/12*x^4 - 1/2*x</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">galoispermtopol</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
<span class="go">[1/12*x^4 - 1/2*x, -1/12*x^4 - 1/2*x, 1/12*x^4 + 1/2*x]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.galoissubfields">
<tt class="descname">galoissubfields</tt><big>(</big><em>flag=0</em>, <em>v=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.galoissubfields" title="Permalink to this definition">¶</a></dt>
<dd><p>List all subfields of the Galois group <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This wraps the <a class="reference external" href="http://pari.math.u-bordeaux.fr/dochtml/html.stable/Functions_related_to_general_number_fields.html#galoissubfields">galoissubfields</a> function from PARI.</p>
<p>This method is essentially the same as applying
<a class="reference internal" href="#sage.libs.pari.gen.gen.galoisfixedfield" title="sage.libs.pari.gen.gen.galoisfixedfield"><tt class="xref py py-meth docutils literal"><span class="pre">galoisfixedfield()</span></tt></a> to each group returned by
<a class="reference internal" href="#sage.libs.pari.gen.gen.galoissubgroups" title="sage.libs.pari.gen.gen.galoissubgroups"><tt class="xref py py-meth docutils literal"><span class="pre">galoissubgroups()</span></tt></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; A Galois group as generated by <a class="reference internal" href="#sage.libs.pari.gen.gen.galoisinit" title="sage.libs.pari.gen.gen.galoisinit"><tt class="xref py py-meth docutils literal"><span class="pre">galoisinit()</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">flag</span></tt> &#8211; Has the same meaning as in <a class="reference internal" href="#sage.libs.pari.gen.gen.galoisfixedfield" title="sage.libs.pari.gen.gen.galoisfixedfield"><tt class="xref py py-meth docutils literal"><span class="pre">galoisfixedfield()</span></tt></a>.</li>
<li><tt class="docutils literal"><span class="pre">v</span></tt> &#8211; Has the same meaning as in <a class="reference internal" href="#sage.libs.pari.gen.gen.galoisfixedfield" title="sage.libs.pari.gen.gen.galoisfixedfield"><tt class="xref py py-meth docutils literal"><span class="pre">galoisfixedfield()</span></tt></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>A vector of all subfields of this group.  Each entry is as
described in the <a class="reference internal" href="#sage.libs.pari.gen.gen.galoisfixedfield" title="sage.libs.pari.gen.gen.galoisfixedfield"><tt class="xref py py-meth docutils literal"><span class="pre">galoisfixedfield()</span></tt></a> method.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">108</span><span class="p">)</span><span class="o">.</span><span class="n">galoisinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">galoissubfields</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[x, x^2 + 972, x^3 + 54, x^3 + 864, x^3 - 54, x^6 + 108]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">galoisinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">galoissubfields</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="s">&#39;z&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[x^2 + 2, Mod(x^3 + x, x^4 + 1), [x^2 - z*x - 1, x^2 + z*x - 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.galoissubgroups">
<tt class="descname">galoissubgroups</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.galoissubgroups" title="Permalink to this definition">¶</a></dt>
<dd><p>List all subgroups of the Galois group <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>This wraps the <a class="reference external" href="http://pari.math.u-bordeaux.fr/dochtml/html.stable/Functions_related_to_general_number_fields.html#galoissubgroups">galoissubgroups</a> function from PARI.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; A Galois group as generated by <a class="reference internal" href="#sage.libs.pari.gen.gen.galoisinit" title="sage.libs.pari.gen.gen.galoisinit"><tt class="xref py py-meth docutils literal"><span class="pre">galoisinit()</span></tt></a>,
or a subgroup thereof as returned by <a class="reference internal" href="#sage.libs.pari.gen.gen.galoissubgroups" title="sage.libs.pari.gen.gen.galoissubgroups"><tt class="xref py py-meth docutils literal"><span class="pre">galoissubgroups()</span></tt></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>A vector of all subgroups of this group.
Each subgroup is described as a two-tuple,
with the subgroup generators as first element
and the orders of these generators as second element.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">108</span><span class="p">)</span><span class="o">.</span><span class="n">galoisinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">galoissubgroups</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[3, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.gamma">
<tt class="descname">gamma</tt><big>(</big><em>s</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>s.gamma(precision): Gamma function at s.</p>
<p>If <span class="math">\(s\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(s\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">gamma</span><span class="p">()</span>
<span class="go">1.00000000000000</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">gamma</span><span class="p">()</span>
<span class="go">24.0000000000000</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">gamma</span><span class="p">()</span>
<span class="go">0.498015668118356 - 0.154949828301811*I</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">gamma</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">domain error in gamma: argument = non-positive integer</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.gammah">
<tt class="descname">gammah</tt><big>(</big><em>s</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.gammah" title="Permalink to this definition">¶</a></dt>
<dd><p>s.gammah(): Gamma function evaluated at the argument x+1/2.</p>
<p>If <span class="math">\(s\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(s\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">gammah</span><span class="p">()</span>
<span class="go">1.32934038817914</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">gammah</span><span class="p">()</span>
<span class="go">52.3427777845535</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">gammah</span><span class="p">()</span>
<span class="go">0.575315188063452 + 0.0882106775440939*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.gcd">
<tt class="descname">gcd</tt><big>(</big><em>x</em>, <em>y=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.gcd" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the greatest common divisor of <span class="math">\(x\)</span> and <span class="math">\(y\)</span>.</p>
<p>If <span class="math">\(y\)</span> is <tt class="docutils literal"><span class="pre">None</span></tt>, then <span class="math">\(x\)</span> must be a list or tuple, and the
greatest common divisor of its components is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">gcd</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">gcd</span><span class="p">()</span>
<span class="go">x</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.gequal">
<tt class="descname">gequal</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.gequal" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are equal using PARI&#8217;s <tt class="docutils literal"><span class="pre">gequal</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;&quot;some_string&quot;&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">gequal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">gequal</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">gequal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">gequal</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">gequal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>WARNING: this relation is not transitive:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[0]&#39;</span><span class="p">);</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[0,0]&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">gequal</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">gequal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">gequal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.gequal0">
<tt class="descname">gequal0</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.gequal0" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <span class="math">\(a\)</span> is equal to zero.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">gequal0</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">gequal0</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">1e-100</span><span class="p">)</span><span class="o">.</span><span class="n">gequal0</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&quot;0.0 + 0.0*I&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">gequal0</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="o">^</span><span class="mi">20</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">)(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">gequal0</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.gequal_long">
<tt class="descname">gequal_long</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.gequal_long" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <span class="math">\(a\)</span> is equal to the <tt class="docutils literal"><span class="pre">long</span> <span class="pre">int</span></tt> <span class="math">\(b\)</span> using PARI&#8217;s <tt class="docutils literal"><span class="pre">gequalsg</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mf">2.0</span><span class="p">);</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;3*matid(3)&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">gequal_long</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">gequal_long</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">gequal_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">gequal_long</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">gequal_long</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">gequal_long</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">gequal_long</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.getattr">
<tt class="descname">getattr</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.getattr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the PARI attribute with the given name.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;nfinit(x^2 - x - 1)&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">getattr</span><span class="p">(</span><span class="s">&quot;pol&quot;</span><span class="p">)</span>
<span class="go">x^2 - x - 1</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">getattr</span><span class="p">(</span><span class="s">&quot;disc&quot;</span><span class="p">)</span>
<span class="go">5</span>

<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">getattr</span><span class="p">(</span><span class="s">&quot;reg&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">_.reg: incorrect type in reg (t_VEC)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">getattr</span><span class="p">(</span><span class="s">&quot;zzz&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">not a function in function call</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.hyperu">
<tt class="descname">hyperu</tt><big>(</big><em>a</em>, <em>b</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.hyperu" title="Permalink to this definition">¶</a></dt>
<dd><p>a.hyperu(b,x): U-confluent hypergeometric function.</p>
<p>If <span class="math">\(a\)</span>, <span class="math">\(b\)</span>, or <span class="math">\(x\)</span> is an exact argument,
it is first converted to a real or complex number using the
optional parameter precision (in bits). If the arguments are
inexact (e.g. real), the smallest of their precisions is used in
the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">hyperu</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0.333333333333333</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.idealchinese">
<tt class="descname">idealchinese</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.idealchinese" title="Permalink to this definition">¶</a></dt>
<dd><p>Chinese Remainder Theorem over number fields.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; prime ideal factorization</li>
<li><tt class="docutils literal"><span class="pre">y</span></tt> &#8211; vector of elements</li>
</ul>
<p>OUTPUT:</p>
<p>An element b in the ambient number field <tt class="docutils literal"><span class="pre">self</span></tt> such that
<span class="math">\(v_p(b-y_p) \ge v_p(x)\)</span> for all prime ideals <span class="math">\(p\)</span> dividing <span class="math">\(x\)</span>,
and <span class="math">\(v_p(b) \ge 0\)</span> for all other <span class="math">\(p\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&#39;alpha&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">nf</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">gen</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">moduli</span> <span class="o">=</span> <span class="n">pari</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="n">P</span><span class="o">.</span><span class="n">pari_prime</span><span class="p">(),</span><span class="mi">4</span><span class="p">,</span><span class="n">Q</span><span class="o">.</span><span class="n">pari_prime</span><span class="p">(),</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">residues</span> <span class="o">=</span> <span class="n">pari</span><span class="o">.</span><span class="n">vector</span><span class="p">(</span><span class="mi">2</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">nf</span><span class="o">.</span><span class="n">idealchinese</span><span class="p">(</span><span class="n">moduli</span><span class="p">,</span><span class="n">residues</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">valuation</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">valuation</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.idealcoprime">
<tt class="descname">idealcoprime</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.idealcoprime" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two integral ideals x and y of a pari number field self,
return an element a of the field (expressed in the integral
basis of self) such that a*x is an integral ideal coprime to
y.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;alpha&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">nf</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1, -1, 2]~&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1, -1, 3]~&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">nf</span><span class="o">.</span><span class="n">idealcoprime</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[1, 0, 0]~</span>

<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[2, -2, 4]~&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">nf</span><span class="o">.</span><span class="n">idealcoprime</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[5/43, 9/43, -1/43]~</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.idealintersection">
<tt class="descname">idealintersection</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.idealintersection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ideallist">
<tt class="descname">ideallist</tt><big>(</big><em>bound</em>, <em>flag=4</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ideallist" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector of vectors <span class="math">\(L\)</span> of all idealstar of all ideals of <span class="math">\(norm &lt;= bound\)</span>.</p>
<p>The binary digits of flag mean:</p>
<blockquote>
<div><ul class="simple">
<li>1: give generators;</li>
<li>2: add units;</li>
<li>4: (default) give only the ideals and not the bid.</li>
</ul>
</div></blockquote>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">pari_nf</span><span class="p">()</span><span class="o">.</span><span class="n">ideallist</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we have our list <span class="math">\(L\)</span>. Entry <span class="math">\(L[n-1]\)</span> contains all ideals of
norm <span class="math">\(n\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="c"># One ideal of norm 1.</span>
<span class="go">[[1, 0; 0, 1]]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span>  <span class="c"># 4 ideals of norm 65.</span>
<span class="go">[[65, 8; 0, 1], [65, 47; 0, 1], [65, 18; 0, 1], [65, 57; 0, 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ideallog">
<tt class="descname">ideallog</tt><big>(</big><em>x</em>, <em>bid</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ideallog" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the discrete logarithm of the unit x in (ring of integers)/bid.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> - a pari number field</li>
<li><tt class="docutils literal"><span class="pre">bid</span></tt>  - a big ideal structure (corresponding to an ideal I
of self) output by idealstar</li>
<li><tt class="docutils literal"><span class="pre">x</span></tt>  - an element of self with valuation zero at all
primes dividing I</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the discrete logarithm of x on the generators given in bid[2]</li>
</ul>
<p>EXAMPLE:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;alpha&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">nf</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1, -1, 2]~&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bid</span> <span class="o">=</span> <span class="n">nf</span><span class="o">.</span><span class="n">idealstar</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;5&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">nf</span><span class="o">.</span><span class="n">ideallog</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bid</span><span class="p">)</span>
<span class="go">[25]~</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.idealprimedec">
<tt class="descname">idealprimedec</tt><big>(</big><em>nf</em>, <em>p</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.idealprimedec" title="Permalink to this definition">¶</a></dt>
<dd><p>Prime ideal decomposition of the prime number <span class="math">\(p\)</span> in the number
field <span class="math">\(nf\)</span> as a vector of 5 component vectors <span class="math">\([p,a,e,f,b]\)</span>
representing the prime ideals <span class="math">\(p O_K + a O_K\)</span>, <span class="math">\(e\)</span> ,`f` as usual,
<span class="math">\(a\)</span> as vector of components on the integral basis, <span class="math">\(b\)</span> Lenstra&#8217;s
constant.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealprimedec</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="n">F</span>
<span class="go">[[5, [-2, 1]~, 1, 1, [2, -1; 1, 2]], [5, [2, 1]~, 1, 1, [-2, -1; 1, -2]]]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_p</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.idealstar">
<tt class="descname">idealstar</tt><big>(</big><em>I</em>, <em>flag=1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.idealstar" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the big ideal (bid) structure of modulus I.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> - a pari number field</li>
<li><tt class="docutils literal"><span class="pre">I</span></tt> &#8211; an ideal of self, or a row vector whose first
component is an ideal and whose second component
is a row vector of r_1 0 or 1.</li>
<li><tt class="docutils literal"><span class="pre">flag</span></tt> - determines the amount of computation and the shape
of the output:<ul>
<li><tt class="docutils literal"><span class="pre">1</span></tt> (default): return a bid structure without
generators</li>
<li><tt class="docutils literal"><span class="pre">2</span></tt>: return a bid structure with generators (slower)</li>
<li><tt class="docutils literal"><span class="pre">0</span></tt> (deprecated): only outputs units of (ring of integers/I)
as an abelian group, i.e as a 3-component
vector [h,d,g]: h is the order, d is the vector
of SNF cyclic components and g the corresponding
generators. This flag is deprecated: it is in
fact slightly faster to compute a true bid
structure, which contains much more information.</li>
</ul>
</li>
</ul>
<p>EXAMPLE:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;alpha&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">nf</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1, -1, 2]~&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">nf</span><span class="o">.</span><span class="n">idealstar</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">[[[43, 9, 5; 0, 1, 0; 0, 0, 1], [0]], [42, [42]], Mat([[43, [9, 1, 0]~, 1, 1, [-5, 2, -18; -9, -5, 2; 1, -9, -5]], 1]), [[[[42], [3], [3], [Vecsmall([])], 1]], [[], [], []]], Mat(1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.idealval">
<tt class="descname">idealval</tt><big>(</big><em>x</em>, <em>p</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.idealval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.imag">
<tt class="descname">imag</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>imag(x): Return the imaginary part of x. This function also works
component-wise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
</ul>
<p>OUTPUT: gen</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1+2*I&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span>
<span class="go">1.41421356237310</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x+I&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x+2*I&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;(1+I)*x^2+2*I&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span>
<span class="go">x^2 + 2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2,3] + [4*I,5,6]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span>
<span class="go">[4, 0, 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.incgam">
<tt class="descname">incgam</tt><big>(</big><em>s</em>, <em>x</em>, <em>y=None</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.incgam" title="Permalink to this definition">¶</a></dt>
<dd><p>s.incgam(x, y, precision): incomplete gamma function. y is optional
and is the precomputed value of gamma(s).</p>
<p>If <span class="math">\(s\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(s\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">incgam</span><span class="p">(</span><span class="mi">3</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
<span class="go">-0.0458297859919946 + 0.0433696818726677*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.incgamc">
<tt class="descname">incgamc</tt><big>(</big><em>s</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.incgamc" title="Permalink to this definition">¶</a></dt>
<dd><p>s.incgamc(x): complementary incomplete gamma function.</p>
<p>The arguments <span class="math">\(x\)</span> and <span class="math">\(s\)</span> are complex numbers such
that <span class="math">\(s\)</span> is not a pole of <span class="math">\(\Gamma\)</span> and
<span class="math">\(|x|/(|s|+1)\)</span> is not much larger than <span class="math">\(1\)</span>
(otherwise, the convergence is very slow). The function returns the
value of the integral
<span class="math">\(\int_{0}^{x} e^{-t} t^{s-1} dt.\)</span></p>
<p>If <span class="math">\(s\)</span> or <span class="math">\(x\)</span> is an exact argument, it is first
converted to a real or complex number using the optional parameter
precision (in bits). If the arguments are inexact (e.g. real), the
smallest of their precisions is used in the computation, and the
parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">incgamc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.864664716763387</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ispower">
<tt class="descname">ispower</tt><big>(</big><em>k=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ispower" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether or not self is a perfect k-th power. If k is not
specified, find the largest k so that self is a k-th power.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">k</span></tt> - int (optional)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">power</span></tt> - int, what power it is</li>
<li><tt class="docutils literal"><span class="pre">g</span></tt> - what it is a power of</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">ispower</span><span class="p">()</span>
<span class="go">(2, 3)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">.</span><span class="n">ispower</span><span class="p">()</span>
<span class="go">(1, 17)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">.</span><span class="n">ispower</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(False, None)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">.</span><span class="n">ispower</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(1, 17)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">ispower</span><span class="p">()</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.isprime">
<tt class="descname">isprime</tt><big>(</big><em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.isprime" title="Permalink to this definition">¶</a></dt>
<dd><p>isprime(x, flag=0): Returns True if x is a PROVEN prime number, and
False otherwise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">flag</span></tt> - int 0 (default): use a combination of
algorithms. 1: certify primality using the Pocklington-Lehmer Test.
2: certify primality using the APRCL test.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">bool</span></tt> - True or False</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">isprime</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">.</span><span class="n">isprime</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">561</span><span class="p">)</span>    <span class="c"># smallest Carmichael number</span>
<span class="gp">sage: </span><span class="n">n</span><span class="o">.</span><span class="n">isprime</span><span class="p">()</span>      <span class="c"># not just a pseudo-primality test!</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">n</span><span class="o">.</span><span class="n">isprime</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">n</span><span class="o">.</span><span class="n">isprime</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">31</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">n</span><span class="o">.</span><span class="n">isprime</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(True, [2, 3, 1; 3, 5, 1; 7, 3, 1; 11, 3, 1; 31, 2, 1; 151, 3, 1; 331, 3, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.isprimepower">
<tt class="descname">isprimepower</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.isprimepower" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <tt class="docutils literal"><span class="pre">self</span></tt> is a prime power (with an exponent &gt;= 1).</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> - A PARI integer</li>
</ul>
<p>OUTPUT:</p>
<p>A tuple <tt class="docutils literal"><span class="pre">(k,</span> <span class="pre">p)</span></tt> where <span class="math">\(k\)</span> is a Python integer and <span class="math">\(p\)</span> a PARI
integer.</p>
<ul class="simple">
<li>If the input was a prime power, <span class="math">\(p\)</span> is the prime and <span class="math">\(k\)</span> the
power.</li>
<li>Otherwise, <span class="math">\(k = 0\)</span> and <span class="math">\(p\)</span> is <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">If you don&#8217;t need a proof that <span class="math">\(p\)</span> is prime, you can use
<a class="reference internal" href="#sage.libs.pari.gen.gen.ispseudoprimepower" title="sage.libs.pari.gen.gen.ispseudoprimepower"><tt class="xref py py-meth docutils literal"><span class="pre">ispseudoprimepower()</span></tt></a> instead.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">isprimepower</span><span class="p">()</span>
<span class="go">(2, 3)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">.</span><span class="n">isprimepower</span><span class="p">()</span>
<span class="go">(1, 17)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">isprimepower</span><span class="p">()</span>
<span class="go">(0, 18)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="o">^</span><span class="mi">12345</span><span class="p">)</span><span class="o">.</span><span class="n">isprimepower</span><span class="p">()</span>
<span class="go">(12345, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ispseudoprime">
<tt class="descname">ispseudoprime</tt><big>(</big><em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ispseudoprime" title="Permalink to this definition">¶</a></dt>
<dd><p>ispseudoprime(x, flag=0): Returns True if x is a pseudo-prime
number, and False otherwise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">flag</span></tt> - int 0 (default): checks whether x is a
Baillie-Pomerance-Selfridge-Wagstaff pseudo prime (strong
Rabin-Miller pseudo prime for base 2, followed by strong Lucas test
for the sequence (P,-1), P smallest positive integer such that
<span class="math">\(P^2 - 4\)</span> is not a square mod x). 0: checks whether x is a
strong Miller-Rabin pseudo prime for flag randomly chosen bases
(with end-matching to catch square roots of -1).</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">bool</span></tt> - True or False, or when flag=1, either False or a tuple
(True, cert) where <tt class="docutils literal"><span class="pre">cert</span></tt> is a primality certificate.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">ispseudoprime</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">.</span><span class="n">ispseudoprime</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">561</span><span class="p">)</span>     <span class="c"># smallest Carmichael number</span>
<span class="gp">sage: </span><span class="n">n</span><span class="o">.</span><span class="n">ispseudoprime</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ispseudoprimepower">
<tt class="descname">ispseudoprimepower</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ispseudoprimepower" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <tt class="docutils literal"><span class="pre">self</span></tt> is the power (with an exponent &gt;= 1) of
a pseudo-prime.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> - A PARI integer</li>
</ul>
<p>OUTPUT:</p>
<p>A tuple <tt class="docutils literal"><span class="pre">(k,</span> <span class="pre">p)</span></tt> where <span class="math">\(k\)</span> is a Python integer and <span class="math">\(p\)</span> a PARI
integer.</p>
<ul class="simple">
<li>If the input was a pseudoprime power, <span class="math">\(p\)</span> is the pseudoprime
and <span class="math">\(k\)</span> the power.</li>
<li>Otherwise, <span class="math">\(k = 0\)</span> and <span class="math">\(p\)</span> is <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="o">^</span><span class="mi">12345</span><span class="p">)</span><span class="o">.</span><span class="n">ispseudoprimepower</span><span class="p">()</span>
<span class="go">(12345, 3)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">1500</span> <span class="o">+</span> <span class="mi">1465</span><span class="p">)</span>         <span class="c"># next_prime(2^1500)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">p</span><span class="o">^</span><span class="mi">11</span><span class="p">)</span><span class="o">.</span><span class="n">ispseudoprimepower</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># very fast</span>
<span class="go">11</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.issquare">
<tt class="descname">issquare</tt><big>(</big><em>x</em>, <em>find_root=False</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.issquare" title="Permalink to this definition">¶</a></dt>
<dd><p>issquare(x,n): <tt class="docutils literal"><span class="pre">True</span></tt> if x is a square, <tt class="docutils literal"><span class="pre">False</span></tt> if not. If
<tt class="docutils literal"><span class="pre">find_root</span></tt> is given, also returns the exact square root.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.issquarefree">
<tt class="descname">issquarefree</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.issquarefree" title="Permalink to this definition">¶</a></dt>
<dd><p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">issquarefree</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">issquarefree</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.j">
<tt class="descname">j</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.j" title="Permalink to this definition">¶</a></dt>
<dd><p>e.j(): return the j-invariant of the elliptic curve e.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">j</span><span class="p">()</span>
<span class="go">-122023936/161051</span>
<span class="gp">sage: </span><span class="n">_</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[-1, 1; 2, 12; 11, -5; 31, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.lcm">
<tt class="descname">lcm</tt><big>(</big><em>x</em>, <em>y=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.lcm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the least common multiple of <span class="math">\(x\)</span> and <span class="math">\(y\)</span>.</p>
<p>If <span class="math">\(y\)</span> is <tt class="docutils literal"><span class="pre">None</span></tt>, then <span class="math">\(x\)</span> must be a list or tuple, and the
least common multiple of its components is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">lcm</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="go">30</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">lcm</span><span class="p">()</span>
<span class="go">5*y</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">lcm</span><span class="p">()</span>
<span class="go">10*x^2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.lift">
<tt class="descname">lift</tt><big>(</big><em>x</em>, <em>v=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.lift" title="Permalink to this definition">¶</a></dt>
<dd><p>lift(x,v): Returns the lift of an element of Z/nZ to Z or R[x]/(P)
to R[x] for a type R if v is omitted. If v is given, lift only
polymods with main variable v. If v does not occur in x, lift only
intmods.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
<li><tt class="docutils literal"><span class="pre">v</span></tt> - (optional) variable</li>
</ul>
<p>OUTPUT: gen</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">Mod</span><span class="p">(</span><span class="s">&#39;x^3 + 17*x + 3&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span>
<span class="go">Mod(x, x^3 + 17*x + 3)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">^</span><span class="mi">4</span><span class="p">;</span> <span class="n">b</span>
<span class="go">Mod(-17*x^2 - 3*x, x^3 + 17*x + 3)</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">lift</span><span class="p">()</span>
<span class="go">-17*x^2 - 3*x</span>
</pre></div>
</div>
<p>??? more examples</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.list">
<tt class="descname">list</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.list" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert self to a list of PARI gens.</p>
<p>EXAMPLES:</p>
<p>A PARI vector becomes a Sage list:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;vector(10,i,i^2)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span>
<span class="go">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;sage.libs.pari.gen.gen&#39;&gt;</span>
</pre></div>
</div>
<p>For polynomials, list() behaves as for ordinary Sage polynomials:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pol</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;x^3 + 5/3*x&quot;</span><span class="p">);</span> <span class="n">pol</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[0, 5/3, 0, 1]</span>
</pre></div>
</div>
<p>For power series or Laurent series, we get all coefficients starting
from the lowest degree term.  This includes trailing zeros:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">LaurentSeriesRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 0, 0, 0, 0, 0]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">x</span><span class="o">^-</span><span class="mi">2</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 0]</span>
</pre></div>
</div>
<p>For matrices, we get a list of columns:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">]);</span> <span class="n">M</span>
<span class="go">[1 4]</span>
<span class="go">[2 5]</span>
<span class="go">[3 6]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[1, 2, 3]~, [4, 5, 6]~]</span>
</pre></div>
</div>
<p>For &#8220;scalar&#8221; types, we get a 1-element list containing <tt class="docutils literal"><span class="pre">self</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[42]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.list_str">
<tt class="descname">list_str</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.list_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str that might correctly evaluate to a Python-list.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.listinsert">
<tt class="descname">listinsert</tt><big>(</big><em>obj</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.listinsert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.listput">
<tt class="descname">listput</tt><big>(</big><em>obj</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.listput" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.lllgram">
<tt class="descname">lllgram</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.lllgram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.lllgramint">
<tt class="descname">lllgramint</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.lllgramint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.lngamma">
<tt class="descname">lngamma</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.lngamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <a class="reference internal" href="#sage.libs.pari.gen.gen.log_gamma" title="sage.libs.pari.gen.gen.log_gamma"><tt class="xref py py-meth docutils literal"><span class="pre">log_gamma()</span></tt></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">lngamma</span><span class="p">()</span>
<span class="go">359.134205369575</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.log">
<tt class="descname">log</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.log" title="Permalink to this definition">¶</a></dt>
<dd><p>x.log(): natural logarithm of x.</p>
<p>This function returns the principal branch of the natural logarithm
of <span class="math">\(x\)</span>, i.e., the branch such that
<span class="math">\(\Im(\log(x)) \in ]-\pi, \pi].\)</span> The result is
complex (with imaginary part equal to <span class="math">\(\pi\)</span>) if
<span class="math">\(x\in \RR\)</span> and <span class="math">\(x&lt;0\)</span>. In general, the algorithm uses
the formula</p>
<div class="math">
\[\log(x) \simeq \frac{\pi}{2{\rm agm}(1,4/s)} - m\log(2),\]</div>
<p>if <span class="math">\(s=x 2^m\)</span> is large enough. (The result is exact to
<span class="math">\(B\)</span> bits provided that <span class="math">\(s&gt;2^{B/2}\)</span>.) At low
accuracies, this function computes <span class="math">\(\log\)</span> using the series
expansion near <span class="math">\(1\)</span>.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>Note that <span class="math">\(p\)</span>-adic arguments can also be given as input,
with the convention that <span class="math">\(\log(p)=0\)</span>. Hence, in particular,
<span class="math">\(\exp(\log(x))/x\)</span> is not in general equal to <span class="math">\(1\)</span>
but instead to a <span class="math">\((p-1)\)</span>-st root of unity (or
<span class="math">\(\pm 1\)</span> if <span class="math">\(p=2\)</span>) times a power of <span class="math">\(p\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">log</span><span class="p">()</span>
<span class="go">1.60943791243410</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">log</span><span class="p">()</span>
<span class="go">0.E-19 + 1.57079632679490*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.log_gamma">
<tt class="descname">log_gamma</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.log_gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Logarithm of the gamma function of x.</p>
<p>This function returns the principal branch of the logarithm of the
gamma function of <span class="math">\(x\)</span>. The function
<span class="math">\(\log(\Gamma(x))\)</span> is analytic on the complex plane with
non-positive integers removed. This function can have much larger
inputs than <span class="math">\(\Gamma\)</span> itself.</p>
<p>The <span class="math">\(p\)</span>-adic analogue of this function is unfortunately not
implemented.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">log_gamma</span><span class="p">()</span>
<span class="go">359.134205369575</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.matadjoint">
<tt class="descname">matadjoint</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.matadjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>matadjoint(x): adjoint matrix of x.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2,3; 4,5,6;  7,8,9]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">matadjoint</span><span class="p">()</span>
<span class="go">[-3, 6, -3; 6, -12, 6; -3, 6, -3]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[a,b,c; d,e,f; g,h,i]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">matadjoint</span><span class="p">()</span>
<span class="go">[(i*e - h*f), (-i*b + h*c), (f*b - e*c); (-i*d + g*f), i*a - g*c, -f*a + d*c; (h*d - g*e), -h*a + g*b, e*a - d*b]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.matdet">
<tt class="descname">matdet</tt><big>(</big><em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.matdet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the determinant of this matrix.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">flag</span></tt> - (optional) flag 0: using Gauss-Bareiss.
1: use classical Gaussian elimination (slightly better for integer
entries)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2; 3,4]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">matdet</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">-2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2; 3,4]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">matdet</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">-2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.matfrobenius">
<tt class="descname">matfrobenius</tt><big>(</big><em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.matfrobenius" title="Permalink to this definition">¶</a></dt>
<dd><p>M.matfrobenius(flag=0): Return the Frobenius form of the square
matrix M. If flag is 1, return only the elementary divisors (a list
of polynomials). If flag is 2, return a two-components vector [F,B]
where F is the Frobenius form and B is the basis change so that
<span class="math">\(M=B^{-1} F B\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2;3,4]&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">matfrobenius</span><span class="p">()</span>
<span class="go">[0, 2; 1, 5]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">matfrobenius</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[x^2 - 5*x - 2]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">matfrobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[[0, 2; 1, 5], [1, -1/3; 0, 1/3]]</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">matfrobenius</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 2; 1, 5]</span>
<span class="gp">sage: </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[1, 2; 3, 4]</span>
</pre></div>
</div>
<p>We let t be the matrix of <span class="math">\(T_2\)</span> acting on modular symbols
of level 43, which was computed using
<tt class="docutils literal"><span class="pre">ModularSymbols(43,sign=1).T(2).matrix()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[3, -2, 0, 0; 0, -2, 0, 1; 0, -1, -2, 2; 0, -2, 0, 2]&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">matfrobenius</span><span class="p">()</span>
<span class="go">[0, 0, 0, -12; 1, 0, 0, -2; 0, 1, 0, 8; 0, 0, 1, 1]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">charpoly</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="go">x^4 - x^3 - 8*x^2 + 2*x + 12</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">matfrobenius</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[x^4 - x^3 - 8*x^2 + 2*x + 12]</span>
</pre></div>
</div>
<p>AUTHORS:</p>
<ul class="simple">
<li>Martin Albrect (2006-04-02)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.mathnf">
<tt class="descname">mathnf</tt><big>(</big><em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.mathnf" title="Permalink to this definition">¶</a></dt>
<dd><p>A.mathnf(flag=0): (upper triangular) Hermite normal form of A,
basis for the lattice formed by the columns of A.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">flag</span></tt> - optional, value range from 0 to 4 (0 if
omitted), meaning : 0: naive algorithm</li>
<li><tt class="docutils literal"><span class="pre">1:</span> <span class="pre">Use</span> <span class="pre">Batut's</span> <span class="pre">algorithm</span></tt> - output 2-component
vector [H,U] such that H is the HNF of A, and U is a unimodular
matrix such that xU=H. 3: Use Batut&#8217;s algorithm. Output [H,U,P]
where P is a permutation matrix such that P A U = H. 4: As 1, using
a heuristic variant of LLL reduction along the way.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2,3; 4,5,6;  7,8,9]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mathnf</span><span class="p">()</span>
<span class="go">[6, 1; 3, 1; 0, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.mathnfmod">
<tt class="descname">mathnfmod</tt><big>(</big><em>d</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.mathnfmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Hermite normal form if d is a multiple of the
determinant</p>
<p>Beware that PARI&#8217;s concept of a Hermite normal form is an upper
triangular matrix with the same column space as the input matrix.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">d</span></tt> - multiple of the determinant of self</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre>       sage: M=matrix([[1,2,3],[4,5,6],[7,8,11]])
sage: d=M.det()
sage: pari(M).mathnfmod(d)
       [6, 4, 3; 0, 1, 0; 0, 0, 1]
</pre></div>
</div>
<p>Note that d really needs to be a multiple of the discriminant, not
just of the exponent of the cokernel:</p>
<div class="highlight-python"><div class="highlight"><pre>       sage: M=matrix([[1,0,0],[0,2,0],[0,0,6]])
sage: pari(M).mathnfmod(6)
[1, 0, 0; 0, 1, 0; 0, 0, 6]
sage: pari(M).mathnfmod(12)
[1, 0, 0; 0, 2, 0; 0, 0, 6]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.mathnfmodid">
<tt class="descname">mathnfmodid</tt><big>(</big><em>d</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.mathnfmodid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Hermite Normal Form of M concatenated with d*Identity</p>
<p>Beware that PARI&#8217;s concept of a Hermite normal form is a maximal
rank upper triangular matrix with the same column space as the
input matrix.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">d</span></tt> - Determines</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre>       sage: M=matrix([[1,0,0],[0,2,0],[0,0,6]])
sage: pari(M).mathnfmodid(6)
       [1, 0, 0; 0, 2, 0; 0, 0, 6]
</pre></div>
</div>
<p>This routine is not completely equivalent to mathnfmod:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">mathnfmod</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[1, 0, 0; 0, 1, 0; 0, 0, 6]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.matker">
<tt class="descname">matker</tt><big>(</big><em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.matker" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a basis of the kernel of this matrix.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">flag</span></tt> - optional; may be set to 0: default;
non-zero: x is known to have integral entries.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2,3;4,5,6;7,8,9]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">matker</span><span class="p">()</span>
<span class="go">[1; -2; 1]</span>
</pre></div>
</div>
<p>With algorithm 1, even if the matrix has integer entries the kernel
need not be saturated (which is weird):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2,3;4,5,6;7,8,9]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">matker</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[3; -6; 3]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;matrix(3,3,i,j,i)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">matker</span><span class="p">()</span>
<span class="go">[-1, -1; 1, 0; 0, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2,3;4,5,6;7,8,9]*Mod(1,2)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">matker</span><span class="p">()</span>
<span class="go">[Mod(1, 2); Mod(0, 2); Mod(1, 2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.matkerint">
<tt class="descname">matkerint</tt><big>(</big><em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.matkerint" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the integer kernel of a matrix.</p>
<p>This is the LLL-reduced Z-basis of the kernel of the matrix x with
integral entries.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[2,1;2,1]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">matker</span><span class="p">()</span>
<span class="go">[-1/2; 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[2,1;2,1]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">matkerint</span><span class="p">()</span>
<span class="go">[1; -2]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[2,1;2,1]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">matkerint</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">doctest:...: DeprecationWarning: The flag argument to matkerint() is deprecated by PARI</span>
<span class="go">See http://trac.sagemath.org/18203 for details.</span>
<span class="go">[1; -2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.matsnf">
<tt class="descname">matsnf</tt><big>(</big><em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.matsnf" title="Permalink to this definition">¶</a></dt>
<dd><p>x.matsnf(flag=0): Smith normal form (i.e. elementary divisors) of
the matrix x, expressed as a vector d. Binary digits of flag mean
1: returns [u,v,d] where d=u*x*v, otherwise only the diagonal d
is returned, 2: allow polynomial entries, otherwise assume x is
integral, 4: removes all information corresponding to entries equal
to 1 in d.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2,3; 4,5,6;  7,8,9]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">matsnf</span><span class="p">()</span>
<span class="go">[0, 3, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.matsolve">
<tt class="descname">matsolve</tt><big>(</big><em>B</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.matsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>matsolve(B): Solve the linear system Mx=B for an invertible matrix
M</p>
<p>matsolve(B) uses Gaussian elimination to solve Mx=B, where M is
invertible and B is a column vector.</p>
<p>The corresponding pari library routine is gauss. The gp-interface
name matsolve has been given preference here.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">B</span></tt> - a column vector of the same dimension as the
square matrix self</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,1;1,-1]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">matsolve</span><span class="p">(</span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1;0]&#39;</span><span class="p">))</span>
<span class="go">[1/2; 1/2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.matsolvemod">
<tt class="descname">matsolvemod</tt><big>(</big><em>D</em>, <em>B</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.matsolvemod" title="Permalink to this definition">¶</a></dt>
<dd><p>For column vectors <span class="math">\(D=(d_i)\)</span> and <span class="math">\(B=(b_i)\)</span>, find a small integer
solution to the system of linear congruences</p>
<div class="math">
\[R_ix=b_i\text{ (mod }d_i),\]</div>
<p>where <span class="math">\(R_i\)</span> is the ith row of <tt class="docutils literal"><span class="pre">self</span></tt>. If <span class="math">\(d_i=0\)</span>, the equation is
considered over the integers. The entries of <tt class="docutils literal"><span class="pre">self</span></tt>, <tt class="docutils literal"><span class="pre">D</span></tt>, and
<tt class="docutils literal"><span class="pre">B</span></tt> should all be integers (those of <tt class="docutils literal"><span class="pre">D</span></tt> should also be
non-negative).</p>
<p>If <tt class="docutils literal"><span class="pre">flag</span></tt> is 1, the output is a two-component row vector whose first
component is a solution and whose second component is a matrix whose
columns form a basis of the solution set of the homogeneous system.</p>
<p>For either value of <tt class="docutils literal"><span class="pre">flag</span></tt>, the output is 0 if there is no solution.</p>
<p>Note that if <tt class="docutils literal"><span class="pre">D</span></tt> or <tt class="docutils literal"><span class="pre">B</span></tt> is an integer, then it will be considered
as a vector all of whose entries are that integer.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[3,4]~&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2]~&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2;3,4]&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">matsolvemod</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="go">[-2, 0]~</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">matsolvemod</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[-1, 1]~</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">matsolvemod</span><span class="p">(</span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[3,0]~&#39;</span><span class="p">),</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2]~&#39;</span><span class="p">))</span>
<span class="go">[6, -4]~</span>
<span class="gp">sage: </span><span class="n">M2</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,10;9,18]&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M2</span><span class="o">.</span><span class="n">matsolvemod</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[2,3]~&#39;</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[[0, -1]~, [-1, -2; 1, -1]]</span>
<span class="gp">sage: </span><span class="n">M2</span><span class="o">.</span><span class="n">matsolvemod</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[2,3]~&#39;</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">M2</span><span class="o">.</span><span class="n">matsolvemod</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[2,45]~&#39;</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[[1, 1]~, [-1, -4; 1, -5]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.mattranspose">
<tt class="descname">mattranspose</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.mattranspose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose of the matrix self.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2,3; 4,5,6; 7,8,9]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mattranspose</span><span class="p">()</span>
<span class="go">[1, 4, 7; 2, 5, 8; 3, 6, 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.mod">
<tt class="descname">mod</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an INTMOD or POLMOD <tt class="docutils literal"><span class="pre">Mod(a,m)</span></tt>, return the modulus <span class="math">\(m\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">Mod</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">mod</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&quot;Mod(x, x*y)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mod</span><span class="p">()</span>
<span class="go">y*x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&quot;[Mod(4,5)]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mod</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Not an INTMOD or POLMOD in mod()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ncols">
<tt class="descname">ncols</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.ncols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of columns of self.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;matrix(19,8)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ncols</span><span class="p">()</span>
<span class="go">8</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.newtonpoly">
<tt class="descname">newtonpoly</tt><big>(</big><em>p</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.newtonpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>x.newtonpoly(p): Newton polygon of polynomial x with respect to the
prime p.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;y^8+6*y^6-27*y^5+1/9*y^2-y+1&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">newtonpoly</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[1, 1, -1/3, -1/3, -1/3, -1/3, -1/3, -1/3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nextprime">
<tt class="descname">nextprime</tt><big>(</big><em>add_one=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nextprime" title="Permalink to this definition">¶</a></dt>
<dd><p>nextprime(x): smallest pseudoprime greater than or equal to <span class="math">\(x\)</span>.
If <tt class="docutils literal"><span class="pre">add_one</span></tt> is non-zero, return the smallest pseudoprime
strictly greater than <span class="math">\(x\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nextprime</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">nextprime</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">nextprime</span><span class="p">(</span><span class="n">add_one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">nextprime</span><span class="p">()</span>
<span class="go">1267650600228229401496703205653</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nf_get_diff">
<tt class="descname">nf_get_diff</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nf_get_diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the different of this number field as a PARI ideal.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; A PARI number field being the output of <tt class="docutils literal"><span class="pre">nfinit()</span></tt>,</dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">bnfinit()</span></tt> or <tt class="docutils literal"><span class="pre">bnrinit()</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">nf_get_diff</span><span class="p">()</span>
<span class="go">[12, 0, 0, 0; 0, 12, 8, 0; 0, 0, 4, 0; 0, 0, 0, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nf_get_pol">
<tt class="descname">nf_get_pol</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nf_get_pol" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the defining polynomial of this number field.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; A PARI number field being the output of <tt class="docutils literal"><span class="pre">nfinit()</span></tt>,</dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">bnfinit()</span></tt> or <tt class="docutils literal"><span class="pre">bnrinit()</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="go">y^4 - 4*y^2 + 1</span>
<span class="gp">sage: </span><span class="n">bnr</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;K = bnfinit(x^4 - 4*x^2 + 1); bnrinit(K, 2*x)&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bnr</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="go">x^4 - 4*x^2 + 1</span>
</pre></div>
</div>
<p>For relative number fields, this returns the relative
polynomial. However, beware that <tt class="docutils literal"><span class="pre">pari(L)</span></tt> returns an absolute
number field:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">L</span><span class="o">.&lt;</span><span class="n">b</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">extension</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>        <span class="c"># Absolute</span>
<span class="go">y^8 - 28*y^6 + 208*y^4 - 408*y^2 + 36</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">pari_rnf</span><span class="p">()</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>   <span class="c"># Relative</span>
<span class="go">x^2 - 5</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">pari_nf</span><span class="p">()</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="go">y^4 - 4*y^2 + 1</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">pari_bnf</span><span class="p">()</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="go">y^4 - 4*y^2 + 1</span>
</pre></div>
</div>
<p>An error is raised for invalid input:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&quot;[0]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">incorrect type in pol (t_VEC)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nf_get_sign">
<tt class="descname">nf_get_sign</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nf_get_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Python list <tt class="docutils literal"><span class="pre">[r1,</span> <span class="pre">r2]</span></tt>, where <tt class="docutils literal"><span class="pre">r1</span></tt> and <tt class="docutils literal"><span class="pre">r2</span></tt> are
Python ints representing the number of real embeddings and pairs
of complex embeddings of this number field, respectively.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; A PARI number field being the output of <tt class="docutils literal"><span class="pre">nfinit()</span></tt>,</dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">bnfinit()</span></tt> or <tt class="docutils literal"><span class="pre">bnrinit()</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">pari_nf</span><span class="p">()</span><span class="o">.</span><span class="n">nf_get_sign</span><span class="p">();</span> <span class="n">s</span>
<span class="go">[4, 0]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="o">.</span><span class="n">pari_nf</span><span class="p">()</span><span class="o">.</span><span class="n">nf_get_sign</span><span class="p">()</span>
<span class="go">[0, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nf_get_zk">
<tt class="descname">nf_get_zk</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nf_get_zk" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector with a <span class="math">\(\ZZ\)</span>-basis for the ring of integers of
this number field. The first element is always <span class="math">\(1\)</span>.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; A PARI number field being the output of <tt class="docutils literal"><span class="pre">nfinit()</span></tt>,</dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">bnfinit()</span></tt> or <tt class="docutils literal"><span class="pre">bnrinit()</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">nf_get_zk</span><span class="p">()</span>
<span class="go">[1, y, y^3 - 4*y, y^2 - 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nf_subst">
<tt class="descname">nf_subst</tt><big>(</big><em>z</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nf_subst" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a PARI number field <tt class="docutils literal"><span class="pre">self</span></tt>, return the same PARI
number field but in the variable <tt class="docutils literal"><span class="pre">z</span></tt>.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; A PARI number field being the output of <tt class="docutils literal"><span class="pre">nfinit()</span></tt>,</dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">bnfinit()</span></tt> or <tt class="docutils literal"><span class="pre">bnrinit()</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We can substitute in a PARI <tt class="docutils literal"><span class="pre">nf</span></tt> structure:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Kpari</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">pari_nf</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="go">y^2 + 5</span>
<span class="gp">sage: </span><span class="n">Lpari</span> <span class="o">=</span> <span class="n">Kpari</span><span class="o">.</span><span class="n">nf_subst</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Lpari</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="go">a^2 + 5</span>
</pre></div>
</div>
<p>We can also substitute in a PARI <tt class="docutils literal"><span class="pre">bnf</span></tt> structure:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">Kpari</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">pari_bnf</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="go">y^2 + 5</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">bnf_get_cyc</span><span class="p">()</span>  <span class="c"># Structure of class group</span>
<span class="go">[2]</span>
<span class="gp">sage: </span><span class="n">Lpari</span> <span class="o">=</span> <span class="n">Kpari</span><span class="o">.</span><span class="n">nf_subst</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Lpari</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="go">a^2 + 5</span>
<span class="gp">sage: </span><span class="n">Lpari</span><span class="o">.</span><span class="n">bnf_get_cyc</span><span class="p">()</span>  <span class="c"># We still have a bnf after substituting</span>
<span class="go">[2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfbasis">
<tt class="descname">nfbasis</tt><big>(</big><em>flag=0</em>, <em>fa=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nfbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Integral basis of the field <span class="math">\(\QQ[a]\)</span>, where <tt class="docutils literal"><span class="pre">a</span></tt> is a root of
the polynomial x.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">flag</span></tt>: if set to 1 and <tt class="docutils literal"><span class="pre">fa</span></tt> is not given: assume that no
square of a prime &gt; 500000 divides the discriminant of <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">fa</span></tt>: If present, encodes a subset of primes at which to
check for maximality. This must be one of the three following
things:</p>
<blockquote>
<div><ul class="simple">
<li>an integer: check all primes up to <tt class="docutils literal"><span class="pre">fa</span></tt> using trial
division.</li>
<li>a vector: a list of primes to check.</li>
<li>a matrix: a partial factorization of the discriminant
of <tt class="docutils literal"><span class="pre">x</span></tt>.</li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In earlier versions of Sage, other bits in <tt class="docutils literal"><span class="pre">flag</span></tt> were
defined but these are now simply ignored.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^3 - 17&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nfbasis</span><span class="p">()</span>
<span class="go">[1, x, 1/3*x^2 - 1/3*x + 1/3]</span>
</pre></div>
</div>
<p>We test <tt class="docutils literal"><span class="pre">flag</span></tt> = 1, noting it gives a wrong result when the
discriminant (-4 * <span class="math">\(p`^2 * `q\)</span> in the example below) has a big square
factor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">next_prime</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">10</span><span class="p">);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">next_prime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">);</span> <span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">p</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">nfbasis</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Wrong result</span>
<span class="go">[1, x]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">nfbasis</span><span class="p">()</span>    <span class="c"># Correct result</span>
<span class="go">[1, 1/10000000019*x]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">nfbasis</span><span class="p">(</span><span class="n">fa</span><span class="o">=</span><span class="mi">10</span><span class="o">^</span><span class="mi">6</span><span class="p">)</span>   <span class="c"># Check primes up to 10^6: wrong result</span>
<span class="go">[1, x]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">nfbasis</span><span class="p">(</span><span class="n">fa</span><span class="o">=</span><span class="s">&quot;[2,2; </span><span class="si">%s</span><span class="s">,2]&quot;</span><span class="o">%</span><span class="n">p</span><span class="p">)</span>    <span class="c"># Correct result and faster</span>
<span class="go">[1, 1/10000000019*x]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">nfbasis</span><span class="p">(</span><span class="n">fa</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">p</span><span class="p">])</span>              <span class="c"># Equivalent with the above</span>
<span class="go">[1, 1/10000000019*x]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfbasis_d">
<tt class="descname">nfbasis_d</tt><big>(</big><em>flag=0</em>, <em>fa=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nfbasis_d" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#sage.libs.pari.gen.gen.nfbasis" title="sage.libs.pari.gen.gen.nfbasis"><tt class="xref py py-meth docutils literal"><span class="pre">nfbasis()</span></tt></a>, but return a tuple <tt class="docutils literal"><span class="pre">(B,</span> <span class="pre">D)</span></tt> where <span class="math">\(B\)</span>
is the integral basis and <span class="math">\(D\)</span> the discriminant.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;alpha&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nfbasis_d</span><span class="p">()</span>
<span class="go">([1, y, y^2], -108)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">5</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span><span class="s">&#39;beta&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nfbasis_d</span><span class="p">()</span>
<span class="go">([1, y, y^2, y^3, y^4], 45753125)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">Polrev</span><span class="p">()</span><span class="o">.</span><span class="n">nfbasis_d</span><span class="p">()</span>
<span class="go">([1, x, x^2], -108)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfbasistoalg">
<tt class="descname">nfbasistoalg</tt><big>(</big><em>nf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nfbasistoalg" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the column vector <tt class="docutils literal"><span class="pre">x</span></tt> on the integral basis into an
algebraic number.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">nf</span></tt> &#8211; a number field</li>
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; a column of rational numbers of length equal to the
degree of <tt class="docutils literal"><span class="pre">nf</span></tt> or a single rational number</li>
</ul>
</div></blockquote>
<p>OUTPUT:</p>
<blockquote>
<div><ul class="simple">
<li>A POLMOD representing the element of <tt class="docutils literal"><span class="pre">nf</span></tt> whose coordinates
are <tt class="docutils literal"><span class="pre">x</span></tt> in the Z-basis of <tt class="docutils literal"><span class="pre">nf</span></tt>.</li>
</ul>
</div></blockquote>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">17</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Kpari</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">pari_nf</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">getattr</span><span class="p">(</span><span class="s">&#39;zk&#39;</span><span class="p">)</span>
<span class="go">[1, 1/3*y^2 - 1/3*y + 1/3, y]</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">nfbasistoalg</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">Mod(42, y^3 - 17)</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">nfbasistoalg</span><span class="p">(</span><span class="s">&quot;[3/2, -5, 0]~&quot;</span><span class="p">)</span>
<span class="go">Mod(-5/3*y^2 + 5/3*y - 1/6, y^3 - 17)</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">getattr</span><span class="p">(</span><span class="s">&#39;zk&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;[3/2, -5, 0]~&quot;</span><span class="p">)</span>
<span class="go">-5/3*y^2 + 5/3*y - 1/6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfbasistoalg_lift">
<tt class="descname">nfbasistoalg_lift</tt><big>(</big><em>nf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nfbasistoalg_lift" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the column vector <tt class="docutils literal"><span class="pre">x</span></tt> on the integral basis into a
polynomial representing the algebraic number.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">nf</span></tt> &#8211; a number field</li>
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; a column of rational numbers of length equal to the
degree of <tt class="docutils literal"><span class="pre">nf</span></tt> or a single rational number</li>
</ul>
</div></blockquote>
<p>OUTPUT:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">nf.nfbasistoalg(x).lift()</span></tt></li>
</ul>
</div></blockquote>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">17</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Kpari</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">pari_nf</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">getattr</span><span class="p">(</span><span class="s">&#39;zk&#39;</span><span class="p">)</span>
<span class="go">[1, 1/3*y^2 - 1/3*y + 1/3, y]</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">nfbasistoalg_lift</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">nfbasistoalg_lift</span><span class="p">(</span><span class="s">&quot;[3/2, -5, 0]~&quot;</span><span class="p">)</span>
<span class="go">-5/3*y^2 + 5/3*y - 1/6</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">getattr</span><span class="p">(</span><span class="s">&#39;zk&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;[3/2, -5, 0]~&quot;</span><span class="p">)</span>
<span class="go">-5/3*y^2 + 5/3*y - 1/6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfdisc">
<tt class="descname">nfdisc</tt><big>(</big><em>flag=-1</em>, <em>p=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nfdisc" title="Permalink to this definition">¶</a></dt>
<dd><p>nfdisc(x): Return the discriminant of the number field defined over
QQ by x.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;alpha&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nfdisc</span><span class="p">()</span>
<span class="go">-108</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">5</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span><span class="s">&#39;beta&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nfdisc</span><span class="p">()</span>
<span class="go">45753125</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span>
<span class="go">x^3 - 2</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span><span class="o">.</span><span class="n">nfdisc</span><span class="p">()</span>
<span class="go">-108</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfeltdiveuc">
<tt class="descname">nfeltdiveuc</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nfeltdiveuc" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in the number field <tt class="docutils literal"><span class="pre">self</span></tt>, return <span class="math">\(q\)</span> such
that <span class="math">\(x - q y\)</span> is &#8220;small&#8221;.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">k</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">nfeltdiveuc</span><span class="p">(</span><span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">pari</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="go">[2, -2]~</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfeltreduce">
<tt class="descname">nfeltreduce</tt><big>(</big><em>x</em>, <em>I</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nfeltreduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an ideal I in Hermite normal form and an element x of the pari
number field self, finds an element r in self such that x-r belongs
to the ideal and r is small.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">k</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">kp</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">kp</span><span class="o">.</span><span class="n">nfeltreduce</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">I</span><span class="o">.</span><span class="n">pari_hnf</span><span class="p">())</span>
<span class="go">[2, 0]~</span>
<span class="gp">sage: </span><span class="mi">12</span> <span class="o">-</span> <span class="n">k</span><span class="p">(</span><span class="n">kp</span><span class="o">.</span><span class="n">nfeltreduce</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">I</span><span class="o">.</span><span class="n">pari_hnf</span><span class="p">()))</span> <span class="ow">in</span> <span class="n">I</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfgaloisconj">
<tt class="descname">nfgaloisconj</tt><big>(</big><em>flag=0</em>, <em>denom=None</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nfgaloisconj" title="Permalink to this definition">¶</a></dt>
<dd><p>Edited from the pari documentation:</p>
<p>nfgaloisconj(nf): list of conjugates of a root of the
polynomial x=nf.pol in the same number field.</p>
<p>Uses a combination of Allombert&#8217;s algorithm and nfroots.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="mi">0</span><span class="p">;</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">nfinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">nf</span><span class="o">.</span><span class="n">nfgaloisconj</span><span class="p">()</span>
<span class="go">[-x, x]~</span>
<span class="gp">sage: </span><span class="n">nf</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">nfinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">nf</span><span class="o">.</span><span class="n">nfgaloisconj</span><span class="p">()</span>
<span class="go">[x]~</span>
<span class="gp">sage: </span><span class="n">nf</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">nfinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">nf</span><span class="o">.</span><span class="n">nfgaloisconj</span><span class="p">()</span>
<span class="go">[-x, x]~</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfgenerator">
<tt class="descname">nfgenerator</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nfgenerator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfhilbert">
<tt class="descname">nfhilbert</tt><big>(</big><em>a</em>, <em>b</em>, <em>p=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nfhilbert" title="Permalink to this definition">¶</a></dt>
<dd><p>nfhilbert(nf,a,b,{p}): if p is omitted, global Hilbert symbol (a,b)
in nf, that is 1 if X^2-aY^2-bZ^2 has a non-trivial solution (X,Y,Z)
in nf, -1 otherwise. Otherwise compute the local symbol modulo the
prime ideal p.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">nfhilbert</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="n">t</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">t</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>   <span class="c"># Prime ideal above 5</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">nfhilbert</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">pari_prime</span><span class="p">())</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="n">t</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c"># Prime ideal above 23, ramified</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">nfhilbert</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">pari_prime</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfhnf">
<tt class="descname">nfhnf</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nfhnf" title="Permalink to this definition">¶</a></dt>
<dd><p>nfhnf(nf,x) : given a pseudo-matrix (A, I) or an integral pseudo-matrix (A,I,J), finds a
pseudo-basis in Hermite normal form of the module it generates.</p>
<p>A pseudo-matrix is a 2-component row vector (A, I) where A is a relative m x n matrix and
I an ideal list of length n. An integral pseudo-matrix is a 3-component row vector (A, I, J).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The definition of a pseudo-basis (<a class="reference internal" href="#cohen" id="id1">[Cohen]</a>):
Let M be a finitely generated, torsion-free R-module, and set V = KM.  If <span class="math">\(\mathfrak{a}_i\)</span> are
fractional ideals of R and <span class="math">\(w_i\)</span> are elements of V, we say that
<span class="math">\((w_i, \mathfrak{a}_k)_{1 \leq i \leq k}\)</span>
is a pseudo-basis of M if
<span class="math">\(M = \mathfrak{a}_1 w_1 \oplus \cdots \oplus \mathfrak{a}_k w_k.\)</span></p>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="cohen" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[Cohen]</a></td><td>Cohen, &#8220;Advanced Topics in Computational Number Theory&#8221;</td></tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Fp</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">F</span><span class="p">,[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="o">+</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">F</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">F</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">Fp</span><span class="o">.</span><span class="n">nfhnf</span><span class="p">([</span><span class="n">pari</span><span class="p">(</span><span class="n">A</span><span class="p">),[</span><span class="n">pari</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">I</span><span class="p">]])</span>
<span class="go">[[1, [-969/5, -1/15]~, [15, -2]~, [-1938, -3]~; 0, 1, 0, 0; 0, 0, 1, 0; 0, 0, 0, 1], [[3997, 1911; 0, 7], [15, 6; 0, 3], 1, 1]]</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">b</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Kp</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">K</span><span class="p">,[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="o">*</span><span class="n">b</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">57</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">b</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">b</span><span class="o">^</span><span class="mi">2</span><span class="p">),</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">Kp</span><span class="o">.</span><span class="n">nfhnf</span><span class="p">([</span><span class="n">pari</span><span class="p">(</span><span class="n">A</span><span class="p">),[</span><span class="n">pari</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">I</span><span class="p">]])</span>
<span class="go">[[1, -225, 72, -31; 0, 1, [0, -1, 0]~, [0, 0, -1/2]~; 0, 0, 1, [0, 0, -1/2]~; 0, 0, 0, 1], [[1116, 756, 612; 0, 18, 0; 0, 0, 18], 2, 1, [2, 0, 0; 0, 1, 0; 0, 0, 1]]]</span>
</pre></div>
</div>
<p>An example where the ring of integers of the number field is not a PID:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">b</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Kp</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">K</span><span class="p">,[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="o">*</span><span class="n">b</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">57</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">b</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">b</span><span class="o">^</span><span class="mi">2</span><span class="p">),</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">Kp</span><span class="o">.</span><span class="n">nfhnf</span><span class="p">([</span><span class="n">pari</span><span class="p">(</span><span class="n">A</span><span class="p">),[</span><span class="n">pari</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">I</span><span class="p">]])</span>
<span class="go">[[1, [15, 6]~, [0, -54]~, [113, 72]~; 0, 1, [-4, -1]~, [0, -1]~; 0, 0, 1, 0; 0, 0, 0, 1], [[360, 180; 0, 180], [6, 4; 0, 2], 1, 1]]</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">K</span><span class="p">,[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="o">*</span><span class="n">b</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">57</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="o">-</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">b</span><span class="p">),</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">Kp</span><span class="o">.</span><span class="n">nfhnf</span><span class="p">([</span><span class="n">pari</span><span class="p">(</span><span class="n">A</span><span class="p">),[</span><span class="n">pari</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">I</span><span class="p">]])</span>
<span class="go">[[1, [7605, 4]~, [5610, 5]~, [7913, -6]~; 0, 1, 0, -1; 0, 0, 1, 0; 0, 0, 0, 1], [[19320, 13720; 0, 56], [2, 1; 0, 1], 1, 1]]</span>
</pre></div>
</div>
<p>AUTHORS:</p>
<ul class="simple">
<li>Aly Deines (2012-09-19)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfinit">
<tt class="descname">nfinit</tt><big>(</big><em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nfinit" title="Permalink to this definition">¶</a></dt>
<dd><p>nfinit(pol, {flag=0}): <tt class="docutils literal"><span class="pre">pol</span></tt> being a nonconstant irreducible
polynomial, gives a vector containing all the data necessary for PARI
to compute in this number field.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">flag</span></tt> is optional and can be set to:</dt>
<dd><ul class="first last">
<li><p class="first">0: default</p>
</li>
<li><p class="first">1: do not compute different</p>
</li>
<li><p class="first">2: first use polred to find a simpler polynomial</p>
</li>
<li><dl class="first docutils">
<dt>3: outputs a two-element vector [nf,Mod(a,P)], where nf is as in 2</dt>
<dd><p class="first last">and Mod(a,P) is a polmod equal to Mod(x,pol) and P=nf.pol</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^3 - 17&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nfinit</span><span class="p">()</span>
<span class="go">[x^3 - 17, [1, 1], -867, 3, [[1, 1.68006914259990, 2.57128159065824; 1, -0.340034571299952 - 2.65083754153991*I, -1.28564079532912 + 2.22679517779329*I], [1, 1.68006914259990, 2.57128159065824; 1, -2.99087211283986, 0.941154382464174; 1, 2.31080297023995, -3.51243597312241], [1, 2, 3; 1, -3, 1; 1, 2, -4], [3, 1, 0; 1, -11, 17; 0, 17, 0], [51, 0, 16; 0, 17, 3; 0, 0, 1], [17, 0, -1; 0, 0, 3; -1, 3, 2], [51, [-17, 6, -1; 0, -18, 3; 1, 0, -16]], [3, 17]], [2.57128159065824, -1.28564079532912 + 2.22679517779329*I], [1, 1/3*x^2 - 1/3*x + 1/3, x], [1, 0, -1; 0, 0, 3; 0, 1, 1], [1, 0, 0, 0, -4, 6, 0, 6, -1; 0, 1, 0, 1, 1, -1, 0, -1, 3; 0, 0, 1, 0, 2, 0, 1, 0, 1]]</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^2 + 10^100 + 1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nfinit</span><span class="p">()</span>
<span class="go">[...]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1.0&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nfinit</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">incorrect type in checknf [please apply nfinit()] (t_REAL)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfisisom">
<tt class="descname">nfisisom</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nfisisom" title="Permalink to this definition">¶</a></dt>
<dd><p>nfisisom(x, y): Determine if the number fields defined by x and y
are isomorphic. According to the PARI documentation, this is much
faster if at least one of x or y is a number field. If they are
isomorphic, it returns an embedding for the generators. If not,
returns 0.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;alpha&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;beta&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span><span class="o">.</span><span class="n">nfisisom</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">_pari_</span><span class="p">())</span>
<span class="go">[y]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">GG</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="s">&#39;gamma&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span><span class="o">.</span><span class="n">nfisisom</span><span class="p">(</span><span class="n">GG</span><span class="o">.</span><span class="n">_pari_</span><span class="p">())</span>
<span class="go">[1/2*y^2]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span><span class="o">.</span><span class="n">nfisisom</span><span class="p">(</span><span class="n">GG</span><span class="o">.</span><span class="n">pari_nf</span><span class="p">())</span>
<span class="go">[1/2*y^2]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">pari_nf</span><span class="p">()</span><span class="o">.</span><span class="n">nfisisom</span><span class="p">(</span><span class="n">GG</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[y^2]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;alpha&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span><span class="o">.</span><span class="n">nfisisom</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">_pari_</span><span class="p">())</span>
<span class="go">0</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>This method converts its second argument (<a class="reference external" href="http://trac.sagemath.org/18728">trac ticket #18728</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.&lt;</span><span class="n">b</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">nfisisom</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="go">[-1/2*y - 1/2, 1/2*y - 1/2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfroots">
<tt class="descname">nfroots</tt><big>(</big><em>poly</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nfroots" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the roots of <span class="math">\(poly\)</span> in the number field self without
multiplicity.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s">&#39;yy&#39;</span><span class="p">]</span><span class="o">.</span><span class="mi">0</span><span class="p">;</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="c"># pari has variable ordering rules</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s">&#39;zz&#39;</span><span class="p">]</span><span class="o">.</span><span class="mi">0</span><span class="p">;</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">nfinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">nf</span><span class="o">.</span><span class="n">nfroots</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[Mod(-zz, zz^2 + 2), Mod(zz, zz^2 + 2)]</span>
<span class="gp">sage: </span><span class="n">nf</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">nfinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">nf</span><span class="o">.</span><span class="n">nfroots</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[Mod(zz, zz^3 + 2)]</span>
<span class="gp">sage: </span><span class="n">nf</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">nfinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">nf</span><span class="o">.</span><span class="n">nfroots</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[Mod(-zz, zz^4 + 2), Mod(zz, zz^4 + 2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfrootsof1">
<tt class="descname">nfrootsof1</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nfrootsof1" title="Permalink to this definition">¶</a></dt>
<dd><p>nf.nfrootsof1()</p>
<p>number of roots of unity and primitive root of unity in the number
field nf.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">nf</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^2 + 1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nfinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">nf</span><span class="o">.</span><span class="n">nfrootsof1</span><span class="p">()</span>
<span class="go">[4, x]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfsubfields">
<tt class="descname">nfsubfields</tt><big>(</big><em>d=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nfsubfields" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all subfields of degree d of number field nf (all subfields if
d is null or omitted). Result is a vector of subfields, each being
given by [g,h], where g is an absolute equation and h expresses one
of the roots of g in terms of the root x of the polynomial defining
nf.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> - nf number field</li>
<li><tt class="docutils literal"><span class="pre">d</span></tt> - C long integer</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nrows">
<tt class="descname">nrows</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.nrows" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of rows of self.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;matrix(19,8)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span>
<span class="go">19</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.numbpart">
<tt class="descname">numbpart</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.numbpart" title="Permalink to this definition">¶</a></dt>
<dd><p>numbpart(x): returns the number of partitions of x.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">numbpart</span><span class="p">()</span>
<span class="go">627</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">numbpart</span><span class="p">()</span>
<span class="go">190569292</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.numdiv">
<tt class="descname">numdiv</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.numdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of divisors of the integer n.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">numdiv</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.omega">
<tt class="descname">omega</tt><big>(</big><em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.omega" title="Permalink to this definition">¶</a></dt>
<dd><p>e.omega(): return basis for the period lattice of the elliptic
curve e.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">[1.26920930427955, 0.634604652139777 - 1.45881661693850*I]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.order">
<tt class="descname">order</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.padicprec">
<tt class="descname">padicprec</tt><big>(</big><em>x</em>, <em>p</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.padicprec" title="Permalink to this definition">¶</a></dt>
<dd><p>padicprec(x,p): Return the absolute p-adic precision of the object
x.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
</ul>
<p>OUTPUT: int</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Qp</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="mi">11</span><span class="o">^-</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="mi">11</span><span class="o">^-</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">11</span><span class="o">^-</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">padicprec</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="go">-5</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">padicprec</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">inconsistent moduli in padicprec: 11 != 17</span>
</pre></div>
</div>
<p>This works for polynomials too:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">Zp</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">pol</span> <span class="o">=</span> <span class="n">R</span><span class="p">([</span><span class="n">O</span><span class="p">(</span><span class="mi">3</span><span class="o">^</span><span class="mi">4</span><span class="p">),</span> <span class="n">O</span><span class="p">(</span><span class="mi">3</span><span class="o">^</span><span class="mi">6</span><span class="p">),</span> <span class="n">O</span><span class="p">(</span><span class="mi">3</span><span class="o">^</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">pol</span><span class="p">)</span><span class="o">.</span><span class="n">padicprec</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.padicprime">
<tt class="descname">padicprime</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.padicprime" title="Permalink to this definition">¶</a></dt>
<dd><p>The uniformizer of the p-adic ring this element lies in, as a t_INT.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen, of type t_PADIC</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">p</span></tt> - gen, of type t_INT</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Qp</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="mi">11</span><span class="o">^-</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="mi">11</span><span class="o">^-</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">11</span><span class="o">^-</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">padicprime</span><span class="p">()</span>
<span class="go">11</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">padicprime</span><span class="p">()</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_INT&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.phi">
<tt class="descname">phi</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Euler phi function of n.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">phi</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.polcoeff">
<tt class="descname">polcoeff</tt><big>(</big><em>n</em>, <em>var=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.polcoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;x^2 + y^3 + x*y&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">x^2 + y*x + y^3</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">polcoeff</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">y</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">polcoeff</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">polcoeff</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;y&quot;</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">polcoeff</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;y&quot;</span><span class="p">)</span>
<span class="go">x</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.poldegree">
<tt class="descname">poldegree</tt><big>(</big><em>var=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.poldegree" title="Permalink to this definition">¶</a></dt>
<dd><p>f.poldegree(var=x): Return the degree of this polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.poldisc">
<tt class="descname">poldisc</tt><big>(</big><em>var=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.poldisc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the discriminant of this polynomial.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&quot;x^2 + 1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">poldisc</span><span class="p">()</span>
<span class="go">-4</span>
</pre></div>
</div>
<p>Before <a class="reference external" href="http://trac.sagemath.org/15654">trac ticket #15654</a>, this used to take a very long time.
Now it takes much less than a second:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">allocatemem</span><span class="p">(</span><span class="mi">200000</span><span class="p">)</span>
<span class="go">PARI stack size set to 200000 bytes</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZpFM</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">pol</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">50</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">pol</span><span class="p">)</span><span class="o">.</span><span class="n">poldisc</span><span class="p">()</span>
<span class="go">2*3 + 3^4 + 2*3^6 + 3^7 + 2*3^8 + 2*3^9 + O(3^10)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.polinterpolate">
<tt class="descname">polinterpolate</tt><big>(</big><em>ya</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.polinterpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>self.polinterpolate(ya,x,e): polynomial interpolation at x
according to data vectors self, ya (i.e. return P such that
P(self[i]) = ya[i] for all i). Also return an error estimate on the
returned value.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.polisirreducible">
<tt class="descname">polisirreducible</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.polisirreducible" title="Permalink to this definition">¶</a></dt>
<dd><p>f.polisirreducible(): Returns True if f is an irreducible
non-constant polynomial, or False if f is reducible or constant.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.polroots">
<tt class="descname">polroots</tt><big>(</big><em>flag=-1</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.polroots" title="Permalink to this definition">¶</a></dt>
<dd><p>Complex roots of the given polynomial using Schonhage&#8217;s method,
as modified by Gourdon.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.polrootspadicfast">
<tt class="descname">polrootspadicfast</tt><big>(</big><em>p</em>, <em>r=20</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.polrootspadicfast" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.polsturm_full">
<tt class="descname">polsturm_full</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.polsturm_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <tt class="xref py py-meth docutils literal"><span class="pre">polsturm()</span></tt> instead.
See <a class="reference external" href="http://trac.sagemath.org/18203">trac ticket #18203</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.polylog">
<tt class="descname">polylog</tt><big>(</big><em>x</em>, <em>m</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.polylog" title="Permalink to this definition">¶</a></dt>
<dd><p>x.polylog(m,flag=0): m-th polylogarithm of x. flag is optional, and
can be 0: default, 1: D_m -modified m-th polylog of x, 2:
D_m-modified m-th polylog of x, 3: P_m-modified m-th polylog of
x.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>TODO: Add more explanation, copied from the PARI manual.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">polylog</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">5.64181141475134 - 8.32820207698027*I</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">polylog</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">5.64181141475134 - 8.32820207698027*I</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">polylog</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0.523778453502411</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">polylog</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-0.400459056163451</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.pr_get_e">
<tt class="descname">pr_get_e</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.pr_get_e" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the ramification index (over <span class="math">\(\QQ\)</span>) of this prime ideal.</p>
<p>NOTE: <tt class="docutils literal"><span class="pre">self</span></tt> must be a PARI prime ideal (as returned by
<tt class="docutils literal"><span class="pre">idealfactor</span></tt> for example).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">2</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_e</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">3</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_e</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">5</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_e</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.pr_get_f">
<tt class="descname">pr_get_f</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.pr_get_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the residue class degree (over <span class="math">\(\QQ\)</span>) of this prime ideal.</p>
<p>NOTE: <tt class="docutils literal"><span class="pre">self</span></tt> must be a PARI prime ideal (as returned by
<tt class="docutils literal"><span class="pre">idealfactor</span></tt> for example).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">2</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_f</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">3</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_f</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">5</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_f</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.pr_get_gen">
<tt class="descname">pr_get_gen</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.pr_get_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the second generator of this PARI prime ideal, where the
first generator is <tt class="docutils literal"><span class="pre">self.pr_get_p()</span></tt>.</p>
<p>NOTE: <tt class="docutils literal"><span class="pre">self</span></tt> must be a PARI prime ideal (as returned by
<tt class="docutils literal"><span class="pre">idealfactor</span></tt> for example).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">2</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_gen</span><span class="p">();</span> <span class="n">g</span><span class="p">;</span> <span class="n">K</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">[1, 1]~</span>
<span class="go">i + 1</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">3</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_gen</span><span class="p">();</span> <span class="n">g</span><span class="p">;</span> <span class="n">K</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">[3, 0]~</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">5</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_gen</span><span class="p">();</span> <span class="n">g</span><span class="p">;</span> <span class="n">K</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">[-2, 1]~</span>
<span class="go">i - 2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.pr_get_p">
<tt class="descname">pr_get_p</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.pr_get_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the prime of <span class="math">\(\ZZ\)</span> lying below this prime ideal.</p>
<p>NOTE: <tt class="docutils literal"><span class="pre">self</span></tt> must be a PARI prime ideal (as returned by
<tt class="docutils literal"><span class="pre">idealfactor</span></tt> for example).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span> <span class="n">F</span>
<span class="go">[[5, [-2, 1]~, 1, 1, [2, -1; 1, 2]], 1; [5, [2, 1]~, 1, 1, [-2, -1; 1, -2]], 1]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_p</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.precision">
<tt class="descname">precision</tt><big>(</big><em>x</em>, <em>n=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.precision" title="Permalink to this definition">¶</a></dt>
<dd><p>precision(x,n): Change the precision of x to be n, where n is a
C-integer). If n is omitted, output the real precision of x.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> - (optional) int</li>
</ul>
<p>OUTPUT: nothing or gen if n is omitted</p>
<p>EXAMPLES:</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.primepi">
<tt class="descname">primepi</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.primepi" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of primes less than or equal to self.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">primepi</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">primepi</span><span class="p">()</span>
<span class="go">25</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span><span class="o">.</span><span class="n">primepi</span><span class="p">()</span>
<span class="go">168</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span><span class="o">.</span><span class="n">primepi</span><span class="p">()</span>
<span class="go">9592</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">primepi</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">)</span><span class="o">.</span><span class="n">primepi</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">500509</span><span class="p">)</span><span class="o">.</span><span class="n">primepi</span><span class="p">()</span>
<span class="go">41581</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.printtex">
<tt class="descname">printtex</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.printtex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.psi">
<tt class="descname">psi</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.psi" title="Permalink to this definition">¶</a></dt>
<dd><p>x.psi(): psi-function at x.</p>
<p>Return the <span class="math">\(\psi\)</span>-function of <span class="math">\(x\)</span>, i.e., the
logarithmic derivative <span class="math">\(\Gamma'(x)/\Gamma(x)\)</span>.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">psi</span><span class="p">()</span>
<span class="go">-0.577215664901533</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.python">
<tt class="descname">python</tt><big>(</big><em>locals=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.python" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Python eval of self.</p>
<p>Note: is self is a real (type t_REAL) the result will be a
RealField element of the equivalent precision; if self is a complex
(type t_COMPLEX) the result will be a ComplexField element of
precision the minimum precision of the real and imaginary parts.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;389/17&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">()</span>
<span class="go">389/17</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;(2/3)*x^3 + x - 5/7 + y&#39;</span><span class="p">);</span> <span class="n">f</span>
<span class="go">2/3*x^3 + x + (y - 5/7)</span>
<span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s">&#39;x,y&#39;</span><span class="p">)</span>
<span class="go">(x, y)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">python</span><span class="p">({</span><span class="s">&#39;x&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span>
<span class="go">2/3*x^3 + x + y - 5/7</span>
</pre></div>
</div>
<p>You can also use .sage, which is a psynonym:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">sage</span><span class="p">({</span><span class="s">&#39;x&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span>
<span class="go">2/3*x^3 + x + y - 5/7</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.python_list">
<tt class="descname">python_list</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.python_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Python list of the PARI gens. This object must be of type
t_VEC.</p>
<p>INPUT: None</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">list</span></tt> - Python list whose elements are the
elements of the input gen.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">v</span><span class="o">=</span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">102</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">python_list</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w</span>
<span class="go">[1, 2, 3, 10, 102, 10]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;sage.libs.pari.gen.gen&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&quot;[1,2,3]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">python_list</span><span class="p">()</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.python_list_small">
<tt class="descname">python_list_small</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.python_list_small" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Python list of the PARI gens. This object must be of type
t_VECSMALL, and the resulting list contains python &#8216;int&#8217;s.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">v</span><span class="o">=</span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">102</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">python_list_small</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w</span>
<span class="go">[1, 2, 3, 10, 102, 10]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.qfbclassno">
<tt class="descname">qfbclassno</tt><big>(</big><em>d</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.qfbclassno" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the class number of the quadratic order of discriminant <span class="math">\(d\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><span class="math">\(d\)</span> (gen) &#8211; a quadratic discriminant, which is an integer
congruent to <span class="math">\(0\)</span> or <span class="math">\(1\)</span>mod4`, not a square.</li>
<li><tt class="docutils literal"><span class="pre">flag</span></tt> (long int) &#8211; if 0 (default), uses Euler product
and the functional equation for <span class="math">\(d&gt;0\)</span> or Shanks&#8217;s method for
<span class="math">\(d&lt;0\)</span>; if 1, uses Euler products and the functional equation
in both cases.</li>
</ul>
<p>OUTPUT:</p>
<p>The class number of the quadratic order with discriminant <span class="math">\(d\)</span>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Using Euler products and the functional equation is
reliable but has complexity <span class="math">\(O(|d|^{1/2})\)</span>.  Using Shanks&#8217;s
method for <span class="math">\(d&lt;0\)</span> is <span class="math">\(O(|d|^{1/4})\)</span> but this function may give
incorrect results when the class group has many cyclic
factors, because implementing Shanks&#8217;s method in full
generality slows it down immensely. It is therefore
strongly recommended to double-check results using either
the version with <tt class="docutils literal"><span class="pre">flag</span></tt> = 1 or the function
<tt class="docutils literal"><span class="pre">quadclassunit</span></tt>. The result is unconditionally correct
for <span class="math">\(-d &lt; 2e10\)</span>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">qfbclassno</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">23</span><span class="p">)</span><span class="o">.</span><span class="n">qfbclassno</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">104</span><span class="p">)</span><span class="o">.</span><span class="n">qfbclassno</span><span class="p">()</span>
<span class="go">6</span>

<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">109</span><span class="p">)</span><span class="o">.</span><span class="n">qfbclassno</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10001</span><span class="p">)</span><span class="o">.</span><span class="n">qfbclassno</span><span class="p">()</span>
<span class="go">16</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10001</span><span class="p">)</span><span class="o">.</span><span class="n">qfbclassno</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">16</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>The input must be congruent to <span class="math">\(0\)</span> or <span class="math">\(1\mod4\)</span> and not a square:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">qfbclassno</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">domain error in classno2: disc % 4 &gt; 1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">qfbclassno</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">domain error in classno2: issquare(disc) = 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.qfbhclassno">
<tt class="descname">qfbhclassno</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.qfbhclassno" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Hurwitz-Kronecker class number of <span class="math">\(n\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><span class="math">\(n\)</span> (gen) &#8211; a non-negative integer</li>
</ul>
<p>OUTPUT:</p>
<p>0 if <span class="math">\(n&lt;0\)</span>, otherwise the Hurwitz-Kronecker class number of
<span class="math">\(n\)</span>.  This is <span class="math">\(0\)</span> if <span class="math">\(n\equiv1,2\mod4\)</span>, <span class="math">\(-1/12\)</span> when <span class="math">\(n=0\)</span>,
and otherwise it is the number of classes of positive definite
binary quadratic forms with discriminant <span class="math">\(-n\)</span>, each weighted
by the number of its automorphisms.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <span class="math">\(n\)</span> is large (more than <span class="math">\(5*10^5\)</span>), the result is
conditional upon GRH.</p>
</div>
<p>EXAMPLES:</p>
<p>The Hurwitz class number is 0 if n is congruent to 1 or 2 modulo 4:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10009</span><span class="p">)</span><span class="o">.</span><span class="n">qfbhclassno</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">qfbhclassno</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>It is -1/12 for n=0:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">qfbhclassno</span><span class="p">()</span>
<span class="go">-1/12</span>
</pre></div>
</div>
<p>Otherwise it is the number of classes of positive definite
binary quadratic forms with discriminant <span class="math">\(-n\)</span>, weighted by
<span class="math">\(1/m\)</span> where <span class="math">\(m\)</span> is the number of automorphisms of the form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">qfbhclassno</span><span class="p">()</span>
<span class="go">1/2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">qfbhclassno</span><span class="p">()</span>
<span class="go">1/3</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span><span class="o">.</span><span class="n">qfbhclassno</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.qfminim">
<tt class="descname">qfminim</tt><big>(</big><em>b=None</em>, <em>m=None</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.qfminim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vectors with bounded norm for this quadratic form.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; a quadratic form</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">b</span></tt> &#8211; a bound on vector norm (finds minimal non-zero
vectors if b is <tt class="docutils literal"><span class="pre">None</span></tt>)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">m</span></tt> &#8211; maximum number of vectors to return.  If <tt class="docutils literal"><span class="pre">None</span></tt>
(default), return all vectors of norm at most B</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">flag</span></tt> (optional) &#8211;</p>
<blockquote>
<div><ul class="simple">
<li>0: default;</li>
<li>1: return only the first minimal vector found (ignore <tt class="docutils literal"><span class="pre">max</span></tt>);</li>
<li>2: as 0 but uses a more robust, slower implementation,
valid for non integral quadratic forms.</li>
</ul>
</div></blockquote>
</li>
</ul>
<p>OUTPUT:</p>
<p>A triple consisting of</p>
<ul class="simple">
<li>the number of vectors of norm &lt;= b,</li>
<li>the actual maximum norm of vectors listed</li>
<li>a matrix whose columns are vectors with norm less than or
equal to b for the definite quadratic form. Only one of <span class="math">\(v\)</span>
and <span class="math">\(-v\)</span> is returned and the zero vector is never returned.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If max is specified then only max vectors will be output,
but all vectors withing the given norm bound will be computed.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">11</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_positive_definite</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The first 5 vectors of norm at most 10:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">qfminim</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">         [-17 -14 -15 -16 -13]</span>
<span class="go">         [  4   3   3   3   2]</span>
<span class="go">146, 10, [  3   3   3   3   3]</span>
<span class="go">]</span>
</pre></div>
</div>
<p>All vectors of minimal norm:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">qfminim</span><span class="p">()</span><span class="o">.</span><span class="n">python</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">      [-5 -2  1]</span>
<span class="go">      [ 1  1  0]</span>
<span class="go">6, 1, [ 1  0  0]</span>
<span class="go">]</span>
</pre></div>
</div>
<p>Use flag=2 for non-integral input:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">RR</span><span class="p">))</span><span class="o">.</span><span class="n">qfminim</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">                         [ -5 -10  -2  -7   3]</span>
<span class="go">                         [  1   2   1   2   0]</span>
<span class="go">10, 5.00000000000000000, [  1   2   0   1  -1]</span>
<span class="go">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.qfparam">
<tt class="descname">qfparam</tt><big>(</big><em>sol</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.qfparam" title="Permalink to this definition">¶</a></dt>
<dd><p>Coefficients of binary quadratic forms that parametrize the
solutions of the ternary quadratic form <tt class="docutils literal"><span class="pre">self</span></tt>, using the
particular solution <tt class="docutils literal"><span class="pre">sol</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; a rational symmetric matrix</li>
<li><tt class="docutils literal"><span class="pre">sol</span></tt> &#8211; a non-trivial solution to the quadratic form
<tt class="docutils literal"><span class="pre">self</span></tt></li>
</ul>
<p>OUTPUT:</p>
<p>A matrix whose rows define polynomials which parametrize all
solutions to the quadratic form <tt class="docutils literal"><span class="pre">self</span></tt> in the projective
plane.</p>
<p>EXAMPLES:</p>
<p>The following can be used to parametrize Pythagorean triples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">diagonal_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span><span class="o">.</span><span class="n">qfparam</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span> <span class="n">P</span>
<span class="go">[0, -2, 0; 1, 0, -1; -1, 0, -1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span> <span class="o">*</span> <span class="n">vector</span><span class="p">([</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="p">]);</span> <span class="n">v</span>
<span class="go">(-2*x*y, x^2 - y^2, -x^2 - y^2)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(-4, 3, -5)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="go">(-48, -55, -73)</span>
<span class="gp">sage: </span><span class="mi">48</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">55</span><span class="o">^</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">73</span><span class="o">^</span><span class="mi">2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.qfrep">
<tt class="descname">qfrep</tt><big>(</big><em>B</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.qfrep" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector of (half) the number of vectors of norms from 1 to <span class="math">\(B\)</span>
for the integral and definite quadratic form <tt class="docutils literal"><span class="pre">self</span></tt>.
Binary digits of flag mean 1: count vectors of even norm from
1 to <span class="math">\(2B\)</span>, 2: return a <tt class="docutils literal"><span class="pre">t_VECSMALL</span></tt> instead of a <tt class="docutils literal"><span class="pre">t_VEC</span></tt>
(which is faster).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;[5,1,1;1,3,1;1,1,1]&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">qfrep</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">[1, 1, 2, 2, 2, 4, 4, 3, 3, 4, 2, 4, 6, 0, 4, 6, 4, 5, 6, 4]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">qfrep</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[1, 2, 4, 3, 4, 4, 0, 6, 5, 4, 12, 4, 4, 8, 0, 3, 8, 6, 12, 12]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">qfrep</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Vecsmall([1, 1, 2, 2, 2, 4, 4, 3, 3, 4, 2, 4, 6, 0, 4, 6, 4, 5, 6, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.qfsolve">
<tt class="descname">qfsolve</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.qfsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to solve over <span class="math">\(\mathbb{Q}\)</span> the quadratic equation
<span class="math">\(X^t G X = 0\)</span> for a matrix G with rational coefficients.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; a rational symmetric matrix</li>
</ul>
<p>OUTPUT:</p>
<p>If the quadratic form is solvable, return a column or a matrix
with multiple columns spanning an isotropic subspace (there is
no guarantee that the maximal isotropic subspace is returned).</p>
<p>If the quadratic form is not solvable and the dimension is at
3, return the local obstruction: a place (<span class="math">\(-1\)</span> or a prime <span class="math">\(p\)</span>)
where the form is not locally solvable. For unsolvable forms in
dimension 2, the number -2 is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">diagonal_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span><span class="o">.</span><span class="n">qfsolve</span><span class="p">()</span>
<span class="go">[0, 1, -1, 0, -1]~</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">diagonal_matrix</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">9</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span><span class="o">.</span><span class="n">qfsolve</span><span class="p">()</span>
<span class="go">[6, 4]~</span>
</pre></div>
</div>
<p>An example of a real obstruction:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">diagonal_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span><span class="o">.</span><span class="n">qfsolve</span><span class="p">()</span>
<span class="go">-1</span>
</pre></div>
</div>
<p>An example of a <span class="math">\(p\)</span>-adic obstruction:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">diagonal_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span><span class="o">.</span><span class="n">qfsolve</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>In dimension 2, we get -2 if the form is not solvable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">diagonal_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">42</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span><span class="o">.</span><span class="n">qfsolve</span><span class="p">()</span>
<span class="go">-2</span>
</pre></div>
</div>
<p>For singular quadratic forms, the kernel is returned:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">diagonal_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span><span class="o">.</span><span class="n">qfsolve</span><span class="p">()</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">[0 0]</span>
<span class="go">[0 0]</span>
<span class="go">[1 0]</span>
<span class="go">[0 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.quadclassunit">
<tt class="descname">quadclassunit</tt><big>(</big><em>d</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.quadclassunit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the class group of a quadratic order of discriminant <span class="math">\(d\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><span class="math">\(d\)</span> (gen) &#8211; a quadratic discriminant, which is an integer
congruent to <span class="math">\(0\)</span> or <span class="math">\(1\)</span>mod4`, not a square.</li>
</ul>
<p>OUTPUT:</p>
<p>(h,cyc,gen,reg) where:</p>
<ul class="simple">
<li>h is the class number</li>
<li>cyc is the class group structure (list of invariants)</li>
<li>gen is the class group generators (list of quadratic forms)</li>
<li>reg is the regulator</li>
</ul>
<p>ALGORITHM:</p>
<p>Buchmann-McCurley&#8217;s sub-exponential algorithm</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">quadclassunit</span><span class="p">()</span>
<span class="go">[1, [], [], 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">23</span><span class="p">)</span><span class="o">.</span><span class="n">quadclassunit</span><span class="p">()</span>
<span class="go">[3, [3], [Qfb(2, 1, 3)], 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">104</span><span class="p">)</span><span class="o">.</span><span class="n">quadclassunit</span><span class="p">()</span>
<span class="go">[6, [6], [Qfb(5, -4, 6)], 1]</span>

<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">109</span><span class="p">)</span><span class="o">.</span><span class="n">quadclassunit</span><span class="p">()</span>
<span class="go">[1, [], [], 5.56453508676047]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10001</span><span class="p">)</span><span class="o">.</span><span class="n">quadclassunit</span><span class="p">()</span> <span class="c"># random generators</span>
<span class="go">[16, [16], [Qfb(10, 99, -5, 0.E-38)], 5.29834236561059]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10001</span><span class="p">)</span><span class="o">.</span><span class="n">quadclassunit</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">16</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10001</span><span class="p">)</span><span class="o">.</span><span class="n">quadclassunit</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[16]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10001</span><span class="p">)</span><span class="o">.</span><span class="n">quadclassunit</span><span class="p">()[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">5.29834236561059</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>The input must be congruent to <span class="math">\(0\)</span> or <span class="math">\(1\mod4\)</span> and not a square:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">quadclassunit</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">domain error in Buchquad: disc % 4 &gt; 1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">quadclassunit</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">domain error in Buchquad: issquare(disc) = 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.quadhilbert">
<tt class="descname">quadhilbert</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.quadhilbert" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a polynomial over <span class="math">\(\QQ\)</span> whose roots generate the
Hilbert class field of the quadratic field of discriminant
<tt class="docutils literal"><span class="pre">self</span></tt> (which must be fundamental).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">23</span><span class="p">)</span><span class="o">.</span><span class="n">quadhilbert</span><span class="p">()</span>
<span class="go">x^3 - x^2 + 1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">145</span><span class="p">)</span><span class="o">.</span><span class="n">quadhilbert</span><span class="p">()</span>
<span class="go">x^4 - 6*x^2 - 5*x - 1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">quadhilbert</span><span class="p">()</span>   <span class="c"># Not fundamental</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">domain error in quadray: isfundamental(D) = 0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.reverse">
<tt class="descname">reverse</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the polynomial obtained by reversing the coefficients of
this polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.rnfidealdown">
<tt class="descname">rnfidealdown</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.rnfidealdown" title="Permalink to this definition">¶</a></dt>
<dd><p>rnfidealdown(rnf,x): finds the intersection of the ideal x with the base field.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="s">&#39;xx1&#39;</span><span class="p">]</span><span class="o">.</span><span class="mi">0</span><span class="p">;</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">xx1</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="s">&#39;yy1&#39;</span><span class="p">]</span><span class="o">.</span><span class="mi">0</span><span class="p">;</span> <span class="n">pari</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">yy1</span>
<span class="gp">sage: </span><span class="n">nf</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">nfinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">rnf</span> <span class="o">=</span> <span class="n">nf</span><span class="o">.</span><span class="n">rnfinit</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">pari</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<p>This is the relative HNF of the inert ideal (2) in rnf:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;[[[1, 0]~, [0, 0]~; [0, 0]~, [1, 0]~], [[2, 0; 0, 2], [2, 0; 0, 1/2]]]&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>And this is the inert ideal (2) in nf:</p>
<blockquote>
<div>sage: rnf.rnfidealdown(P)
2</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.rnfinit">
<tt class="descname">rnfinit</tt><big>(</big><em>poly</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.rnfinit" title="Permalink to this definition">¶</a></dt>
<dd><p>EXAMPLES: We construct a relative number field.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;y^3+y+1&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">nfinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">5</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">rnfinit</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.rnfisnorm">
<tt class="descname">rnfisnorm</tt><big>(</big><em>T</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.rnfisnorm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.rnfpolred">
<tt class="descname">rnfpolred</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.rnfpolred" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.rnfpolredabs">
<tt class="descname">rnfpolredabs</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.rnfpolredabs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.round">
<tt class="descname">round</tt><big>(</big><em>x</em>, <em>estimate=False</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.round" title="Permalink to this definition">¶</a></dt>
<dd><p>round(x,estimate=False): If x is a real number, returns x rounded
to the nearest integer (rounding up). If the optional argument
estimate is True, also returns the binary exponent e of the
difference between the original and the rounded value (the
&#8220;fractional part&#8221;) (this is the integer ceiling of log_2(error)).</p>
<p>When x is a general PARI object, this function returns the result
of rounding every coefficient at every level of PARI object. Note
that this is different than what the truncate function does (see
the example below).</p>
<p>One use of round is to get exact results after a long approximate
computation, when theory tells you that the coefficients must be
integers.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
<li><tt class="docutils literal"><span class="pre">estimate</span></tt> - (optional) bool, False by default</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>if estimate is False, return a single gen.</li>
<li>if estimate is True, return rounded version of x and error
estimate in bits, both as gens.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1.5&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1.5&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(2, -1)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1.5 + 2.1*I&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">2 + 2*I</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1.0001&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(1, -14)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;(2.4*x^2 - 1.7)/x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">(2*x^2 - 2)/x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;(2.4*x^2 - 1.7)/x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
<span class="go">2.40000000000000*x</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sage">
<tt class="descname">sage</tt><big>(</big><em>locals=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.sage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Python eval of self.</p>
<p>Note: is self is a real (type t_REAL) the result will be a
RealField element of the equivalent precision; if self is a complex
(type t_COMPLEX) the result will be a ComplexField element of
precision the minimum precision of the real and imaginary parts.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;389/17&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">()</span>
<span class="go">389/17</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;(2/3)*x^3 + x - 5/7 + y&#39;</span><span class="p">);</span> <span class="n">f</span>
<span class="go">2/3*x^3 + x + (y - 5/7)</span>
<span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s">&#39;x,y&#39;</span><span class="p">)</span>
<span class="go">(x, y)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">python</span><span class="p">({</span><span class="s">&#39;x&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span>
<span class="go">2/3*x^3 + x + y - 5/7</span>
</pre></div>
</div>
<p>You can also use .sage, which is a psynonym:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">sage</span><span class="p">({</span><span class="s">&#39;x&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span>
<span class="go">2/3*x^3 + x + y - 5/7</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.serreverse">
<tt class="descname">serreverse</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.serreverse" title="Permalink to this definition">¶</a></dt>
<dd><p>serreverse(f): reversion of the power series f.</p>
<p>If f(t) is a series in t with valuation 1, find the series g(t)
such that g(f(t)) = t.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;x+x^2+x^3+O(x^4)&#39;</span><span class="p">);</span> <span class="n">f</span>
<span class="go">x + x^2 + x^3 + O(x^4)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">serreverse</span><span class="p">();</span> <span class="n">g</span>
<span class="go">x - x^2 + x^3 + O(x^4)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="n">g</span><span class="p">)</span>
<span class="go">x + O(x^4)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
<span class="go">x + O(x^4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sign">
<tt class="descname">sign</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign of x, where x is of type integer, real or
fraction.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span>
<span class="go">-1</span>
</pre></div>
</div>
<p>PARI throws an error if you attempt to take the sign of a
complex number:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">incorrect type in gsigne (t_COMPLEX)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.simplify">
<tt class="descname">simplify</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>simplify(x): Simplify the object x as much as possible, and return
the result.</p>
<p>A complex or quadratic number whose imaginary part is an exact 0
(i.e., not an approximate one such as O(3) or 0.E-28) is converted
to its real part, and a a polynomial of degree 0 is converted to
its constant term. Simplification occurs recursively.</p>
<p>This function is useful before using arithmetic functions, which
expect integer arguments:</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;9&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="n">y</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">9</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_POL&#39;</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">matrix(0,2)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;9&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">Mat([3, 2])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
<span class="go">9</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">Mat([3, 2])</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;1.5 + 0*I&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_REAL&#39;</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
<span class="go">1.50000000000000</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_REAL&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sin">
<tt class="descname">sin</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.sin" title="Permalink to this definition">¶</a></dt>
<dd><p>x.sin(): The sine of x.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sin</span><span class="p">()</span>
<span class="go">0.841470984807897</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">sin</span><span class="p">()</span>
<span class="go">1.29845758141598 + 0.634963914784736*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sinh">
<tt class="descname">sinh</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.sinh" title="Permalink to this definition">¶</a></dt>
<dd><p>The hyperbolic sine function.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sinh</span><span class="p">()</span>
<span class="go">0.E-19</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">sinh</span><span class="p">()</span>
<span class="go">0.634963914784736 + 1.29845758141598*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sizebyte">
<tt class="descname">sizebyte</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.sizebyte" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total number of bytes occupied by the complete tree
of the object x. Note that this number depends on whether the
computer is 32-bit or 64-bit.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
</ul>
<p>OUTPUT: int (a Python int)</p>
<p>EXAMPLE:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizebyte</span><span class="p">()</span>
<span class="go">12           # 32-bit</span>
<span class="go">24           # 64-bit</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sizedigit">
<tt class="descname">sizedigit</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.sizedigit" title="Permalink to this definition">¶</a></dt>
<dd><p>sizedigit(x): Return a quick estimate for the maximal number of
decimal digits before the decimal point of any component of x.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
</ul>
<p>OUTPUT: Python integer</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;10^100&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">Str</span><span class="p">()</span><span class="o">.</span><span class="n">length</span><span class="p">()</span>
<span class="go">101</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">sizedigit</span><span class="p">()</span>
<span class="go">doctest:...: DeprecationWarning: sizedigit() is deprecated in PARI</span>
<span class="go">See http://trac.sagemath.org/18203 for details.</span>
<span class="go">101</span>
</pre></div>
</div>
<p>Note that digits after the decimal point are ignored:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;1.234&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">1.23400000000000</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">sizedigit</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The estimate can be one too big:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;7234.1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizedigit</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;9234.1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizedigit</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sizeword">
<tt class="descname">sizeword</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.sizeword" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total number of machine words occupied by the
complete tree of the object x.  A machine word is 32 or
64 bits, depending on the computer.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
</ul>
<p>OUTPUT: int (a Python int)</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;0&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizeword</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizeword</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1000000&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizeword</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;10^100&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizeword</span><span class="p">()</span>
<span class="go">13      # 32-bit</span>
<span class="go">8       # 64-bit</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">RDF</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span><span class="o">.</span><span class="n">sizeword</span><span class="p">()</span>
<span class="go">4       # 32-bit</span>
<span class="go">3       # 64-bit</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizeword</span><span class="p">()</span>
<span class="go">9</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^20&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizeword</span><span class="p">()</span>
<span class="go">66</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[x, I]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizeword</span><span class="p">()</span>
<span class="go">20</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sqr">
<tt class="descname">sqr</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.sqr" title="Permalink to this definition">¶</a></dt>
<dd><p>x.sqr(): square of x. Faster than, and most of the time (but not
always - see the examples) identical to x*x.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sqr</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
<p>For <span class="math">\(2\)</span>-adic numbers, x.sqr() may not be identical to x*x
(squaring a <span class="math">\(2\)</span>-adic number increases its precision):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&quot;1+O(2^5)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sqr</span><span class="p">()</span>
<span class="go">1 + O(2^6)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&quot;1+O(2^5)&quot;</span><span class="p">)</span><span class="o">*</span><span class="n">pari</span><span class="p">(</span><span class="s">&quot;1+O(2^5)&quot;</span><span class="p">)</span>
<span class="go">1 + O(2^5)</span>
</pre></div>
</div>
<p>However:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;1+O(2^5)&quot;</span><span class="p">);</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
<span class="go">1 + O(2^6)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sqrt">
<tt class="descname">sqrt</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>x.sqrt(precision): The square root of x.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
<span class="go">1.41421356237310</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sqrtint">
<tt class="descname">sqrtint</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.sqrtint" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the integer square root of the integer <span class="math">\(x\)</span>, rounded
towards zero.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">sqrtint</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">sqrtint</span><span class="p">()</span>
<span class="go">100000000000000000000000000000000000000000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sqrtn">
<tt class="descname">sqrtn</tt><big>(</big><em>x</em>, <em>n</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.sqrtn" title="Permalink to this definition">¶</a></dt>
<dd><p>x.sqrtn(n): return the principal branch of the n-th root of x,
i.e., the one such that
<span class="math">\(\arg(\sqrt(x)) \in ]-\pi/n, \pi/n]\)</span>. Also returns a second
argument which is a suitable root of unity allowing one to recover
all the other roots. If it was not possible to find such a number,
then this second return value is 0. If the argument is present and
no square root exists, return 0 instead of raising an error.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">intmods (modulo a prime) and <span class="math">\(p\)</span>-adic numbers are
allowed as arguments.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> - integer</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - principal n-th root of x</li>
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - root of unity z that gives the other
roots</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">s</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sqrtn</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">z</span>
<span class="go">0.309016994374947 + 0.951056516295154*I</span>
<span class="gp">sage: </span><span class="n">s</span>
<span class="go">1.14869835499704</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">^</span><span class="mi">5</span>
<span class="go">2.00000000000000</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">^</span><span class="mi">5</span>
<span class="go">1.00000000000000 - 2.710505431 E-20*I       # 32-bit</span>
<span class="go">1.00000000000000 - 2.71050543121376 E-20*I  # 64-bit</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">^</span><span class="mi">5</span>
<span class="go">2.00000000000000 + 0.E-19*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.subst">
<tt class="descname">subst</tt><big>(</big><em>var</em>, <em>z</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.subst" title="Permalink to this definition">¶</a></dt>
<dd><p>In <tt class="docutils literal"><span class="pre">self</span></tt>, replace the variable <tt class="docutils literal"><span class="pre">var</span></tt> by the expression <span class="math">\(z\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^3 + 17*x + 3&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y^3 + 17*y + 3</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;z&quot;</span><span class="p">)</span>
<span class="go">z^3 + 17*z + 3</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;z&quot;</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="go">z^6 + 34*z^4 + 6*z^3 + 289*z^2 + 102*z + 9</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;x+1&quot;</span><span class="p">)</span>
<span class="go">x^3 + 3*x^2 + 20*x + 21</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;xyz&quot;</span><span class="p">)</span>
<span class="go">xyz^3 + 17*xyz + 3</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;xyz&quot;</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="go">xyz^6 + 34*xyz^4 + 6*xyz^3 + 289*xyz^2 + 102*xyz + 9</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sumdiv">
<tt class="descname">sumdiv</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.sumdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of the divisors of <span class="math">\(n\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">sumdiv</span><span class="p">()</span>
<span class="go">18</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sumdivk">
<tt class="descname">sumdivk</tt><big>(</big><em>n</em>, <em>k</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.sumdivk" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of the k-th powers of the divisors of n.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">sumdivk</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">130</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.tan">
<tt class="descname">tan</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.tan" title="Permalink to this definition">¶</a></dt>
<dd><p>x.tan() - tangent of x</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">tan</span><span class="p">()</span>
<span class="go">-2.18503986326152</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">tan</span><span class="p">()</span>
<span class="go">0.761594155955765*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.tanh">
<tt class="descname">tanh</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.tanh" title="Permalink to this definition">¶</a></dt>
<dd><p>x.tanh() - hyperbolic tangent of x</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tanh</span><span class="p">()</span>
<span class="go">0.761594155955765</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="n">z</span>
<span class="go">1.00000000000000*I</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">tanh</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">result</span><span class="o">.</span><span class="n">real</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mf">1e-18</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">result</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span>
<span class="go">1.55740772465490</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.teichmuller">
<tt class="descname">teichmuller</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.teichmuller" title="Permalink to this definition">¶</a></dt>
<dd><p>teichmuller(x): teichmuller character of p-adic number x.</p>
<p>This is the unique <span class="math">\((p-1)\)</span>-st root of unity congruent to
<span class="math">\(x/p^{v_p(x)}\)</span> modulo <span class="math">\(p\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;2+O(7^5)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">teichmuller</span><span class="p">()</span>
<span class="go">2 + 4*7 + 6*7^2 + 3*7^3 + O(7^5)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.theta">
<tt class="descname">theta</tt><big>(</big><em>q</em>, <em>z</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.theta" title="Permalink to this definition">¶</a></dt>
<dd><p>q.theta(z): Jacobi sine theta-function.</p>
<p>If <span class="math">\(q\)</span> or <span class="math">\(z\)</span> is an exact argument, it is first
converted to a real or complex number using the optional parameter
precision (in bits). If the arguments are inexact (e.g. real), the
smallest of their precisions is used in the computation, and the
parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">theta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1.63202590295260</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.thetanullk">
<tt class="descname">thetanullk</tt><big>(</big><em>q</em>, <em>k</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.thetanullk" title="Permalink to this definition">¶</a></dt>
<dd><p>q.thetanullk(k): return the k-th derivative at z=0 of theta(q,z).</p>
<p>If <span class="math">\(q\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(q\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">thetanullk</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0.548978532560341</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.trace">
<tt class="descname">trace</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trace of this PARI object.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;[1,2; 3,4]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.truncate">
<tt class="descname">truncate</tt><big>(</big><em>x</em>, <em>estimate=False</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.truncate" title="Permalink to this definition">¶</a></dt>
<dd><p>truncate(x,estimate=False): Return the truncation of x. If estimate
is True, also return the number of error bits.</p>
<p>When x is in the real numbers, this means that the part after the
decimal point is chopped away, e is the binary exponent of the
difference between the original and truncated value (the
&#8220;fractional part&#8221;). If x is a rational function, the result is the
integer part (Euclidean quotient of numerator by denominator) and
if requested the error estimate is 0.</p>
<p>When truncate is applied to a power series (in X), it transforms it
into a polynomial or a rational function with denominator a power
of X, by chopping away the <span class="math">\(O(X^k)\)</span>. Similarly, when
applied to a p-adic number, it transforms it into an integer or a
rational number by chopping away the <span class="math">\(O(p^k)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
<li><tt class="docutils literal"><span class="pre">estimate</span></tt> - (optional) bool, which is False by
default</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>if estimate is False, return a single gen.</li>
<li>if estimate is True, return rounded version of x and error
estimate in bits, both as gens.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;(x^2+1)/x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">(x^2 + 1)/x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;(x^2+1)/x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
<span class="go">x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1.043&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1.043&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(1, -5)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1.6&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1.6&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1/3 + 2 + 3^2 + O(3^3)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
<span class="go">34/3</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;sin(x+O(x^10))&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
<span class="go">1/362880*x^9 - 1/5040*x^7 + 1/120*x^5 - 1/6*x^3 + x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;sin(x+O(x^10))&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>   <span class="c"># each coefficient has abs &lt; 1</span>
<span class="go">x + O(x^10)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.type">
<tt class="descname">type</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the PARI type of self as a string.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In Cython, it is much faster to simply use typ(self.g) for
checking PARI types.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_INT&#39;</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_POL&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.valuation">
<tt class="descname">valuation</tt><big>(</big><em>x</em>, <em>p</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.valuation" title="Permalink to this definition">¶</a></dt>
<dd><p>valuation(x,p): Return the valuation of x with respect to p.</p>
<p>The valuation is the highest exponent of p dividing x.</p>
<ul class="simple">
<li>If p is an integer, x must be an integer, an intmod whose
modulus is divisible by p, a rational number, a p-adic
number, or a polynomial or power series in which case the
valuation is the minimum of the valuations of the
coefficients.</li>
<li>If p is a polynomial, x must be a polynomial or a rational
function. If p is a monomial then x may also be a power
series.</li>
<li>If x is a vector, complex or quadratic number, then the
valuation is the minimum of the component valuations.</li>
<li>If x = 0, the result is <span class="math">\(2^31-1\)</span> on 32-bit machines or
<span class="math">\(2^63-1\)</span> on 64-bit machines if x is an exact
object. If x is a p-adic number or power series, the result
is the exponent of the zero.</li>
</ul>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
<li><tt class="docutils literal"><span class="pre">p</span></tt> - coercible to gen</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - integer</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">valuation</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">valuation</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">Mod</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span> <span class="n">x</span><span class="o">.</span><span class="n">valuation</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;5/3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">valuation</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;9 + 3*x + 15*x^2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">valuation</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">])</span><span class="o">.</span><span class="n">valuation</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;9 + 3*x + 15*x^2 + O(x^5)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">valuation</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^2*(x+1)^3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">valuation</span><span class="p">(</span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x+1&#39;</span><span class="p">))</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x + O(x^5)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">valuation</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;2*x^2 + O(x^5)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">valuation</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">valuation</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">2147483647            # 32-bit</span>
<span class="go">9223372036854775807   # 64-bit</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.variable">
<tt class="descname">variable</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.variable" title="Permalink to this definition">¶</a></dt>
<dd><p>variable(x): Return the main variable of the object x, or p if x is
a p-adic number.</p>
<p>This function raises a TypeError exception on scalars, i.e., on
objects with no variable associated to them.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> - gen</li>
</ul>
<p>OUTPUT: gen</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x^2 + x -2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">variable</span><span class="p">()</span>
<span class="go">x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1+2^3 + O(2^5)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">variable</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;x+y0&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">variable</span><span class="p">()</span>
<span class="go">x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;y0+z0&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">variable</span><span class="p">()</span>
<span class="go">y0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.vecextract">
<tt class="descname">vecextract</tt><big>(</big><em>y</em>, <em>z=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.vecextract" title="Permalink to this definition">¶</a></dt>
<dd><p>self.vecextract(y,z): extraction of the components of the matrix or
vector x according to y and z. If z is omitted, y designates
columns, otherwise y corresponds to rows and z to columns. y and z
can be vectors (of indices), strings (indicating ranges as
in&#8221;1..10&#8221;) or masks (integers whose binary representation indicates
the indices to extract, from left to right 1, 2, 4, 8, etc.)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function uses the PARI row and column indexing, so the
first row or column is indexed by 1 instead of 0.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.vecmax">
<tt class="descname">vecmax</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.vecmax" title="Permalink to this definition">¶</a></dt>
<dd><p>vecmax(x): Return the maximum of the elements of the vector/matrix
x.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.vecmin">
<tt class="descname">vecmin</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.vecmin" title="Permalink to this definition">¶</a></dt>
<dd><p>vecmin(x): Return the maximum of the elements of the vector/matrix
x.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.weber">
<tt class="descname">weber</tt><big>(</big><em>x</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.weber" title="Permalink to this definition">¶</a></dt>
<dd><p>x.weber(flag=0): One of Weber&#8217;s f functions of x. flag is optional,
and can be 0: default, function
f(x)=exp(-i*Pi/24)*eta((x+1)/2)/eta(x) such that
<span class="math">\(j=(f^{24}-16)^3/f^{24}\)</span>, 1: function f1(x)=eta(x/2)/eta(x)
such that <span class="math">\(j=(f1^24+16)^3/f2^{24}\)</span>, 2: function
f2(x)=sqrt(2)*eta(2*x)/eta(x) such that
<span class="math">\(j=(f2^{24}+16)^3/f2^{24}\)</span>.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>TODO: Add further explanation from PARI manual.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">weber</span><span class="p">()</span>
<span class="go">1.18920711500272</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">weber</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1.09050773266526</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">weber</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1.09050773266526</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.xgcd">
<tt class="descname">xgcd</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.xgcd" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns u,v,d such that d=gcd(x,y) and u*x+v*y=d.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">xgcd</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="go">doctest:...: DeprecationWarning: xgcd() is deprecated, use gcdext() instead (note that the output is in a different order!)</span>
<span class="go">See http://trac.sagemath.org/18203 for details.</span>
<span class="go">(5, -1, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.zeta">
<tt class="descname">zeta</tt><big>(</big><em>s</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.zeta" title="Permalink to this definition">¶</a></dt>
<dd><p>zeta(s): zeta function at s with s a complex or a p-adic number.</p>
<p>If <span class="math">\(s\)</span> is a complex number, this is the Riemann zeta
function <span class="math">\(\zeta(s)=\sum_{n\geq 1} n^{-s}\)</span>, computed either
using the Euler-Maclaurin summation formula (if <span class="math">\(s\)</span> is not
an integer), or using Bernoulli numbers (if <span class="math">\(s\)</span> is a
negative integer or an even nonnegative integer), or using modular
forms (if <span class="math">\(s\)</span> is an odd nonnegative integer).</p>
<p>If <span class="math">\(s\)</span> is a <span class="math">\(p\)</span>-adic number, this is the
Kubota-Leopoldt zeta function, i.e. the unique continuous
<span class="math">\(p\)</span>-adic function on the <span class="math">\(p\)</span>-adic integers that
interpolates the values of <span class="math">\((1-p^{-k})\zeta(k)\)</span> at negative
integers <span class="math">\(k\)</span> such that <span class="math">\(k\equiv 1\pmod{p-1}\)</span> if
<span class="math">\(p\)</span> is odd, and at odd <span class="math">\(k\)</span> if <span class="math">\(p=2\)</span>.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">s</span></tt> - gen (real, complex, or p-adic number)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">gen</span></tt> - value of zeta at s.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">zeta</span><span class="p">()</span>
<span class="go">1.64493406684823</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">RR</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">/</span><span class="mi">6</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">1.64493406684823</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">zeta</span><span class="p">()</span>
<span class="go">1.20205690315959</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s">&#39;1+5*7+2*7^2+O(7^3)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">zeta</span><span class="p">()</span>
<span class="go">4*7^-2 + 5*7^-1 + O(7^0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.znprimroot">
<tt class="descname">znprimroot</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.znprimroot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a primitive root modulo <tt class="docutils literal"><span class="pre">self</span></tt>, whenever it exists.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; an integer <span class="math">\(n\)</span> such that <span class="math">\(|n|\)</span> is equal to 1, 2,
4, a power of an odd prime, or twice a power of an odd prime</li>
</ul>
<p>OUTPUT:</p>
<p>A generator (type <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt>) of <span class="math">\((\ZZ/n\ZZ)^*\)</span>.  Note that
this group is cyclic if and only if <span class="math">\(n\)</span> is of the above form.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">znprimroot</span><span class="p">()</span>
<span class="go">Mod(3, 4)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10007</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">znprimroot</span><span class="p">()</span>
<span class="go">Mod(5, 1002101470343)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">109</span><span class="o">^</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">znprimroot</span><span class="p">()</span>
<span class="go">Mod(236736367459211723407, 473472734918423446802)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.znstar">
<tt class="descname">znstar</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen.znstar" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the structure of the group <span class="math">\((\ZZ/n\ZZ)^*\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">self</span></tt> &#8211; any integer <span class="math">\(n\)</span> (type <tt class="docutils literal"><span class="pre">t_INT</span></tt>)</li>
</ul>
<p>OUTPUT:</p>
<p>A triple <span class="math">\([\phi(n), [d_1, \ldots, d_k], [x_1, \ldots, x_k]]\)</span>,
where</p>
<ul class="simple">
<li><span class="math">\(\phi(n)\)</span> is the order of <span class="math">\((\ZZ/n\ZZ)^*\)</span>;</li>
<li><span class="math">\(d_1, \ldots, d_k\)</span> are the unique integers greater than 1
with <span class="math">\(d_k \mid d_{k-1} \mid \ldots \mid d_1\)</span> such that
<span class="math">\((\ZZ/n\ZZ)^*\)</span> is isomorphic to <span class="math">\(\prod_{i=1}^k \ZZ/d_i\ZZ\)</span>;</li>
<li><span class="math">\(x_1, \ldots, x_k\)</span> are the images of the standard generators
under some isomorphism from <span class="math">\(\prod_{i=1}^k \ZZ/d_i\ZZ\)</span> to
<span class="math">\((\ZZ/n\ZZ)^*\)</span>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">znstar</span><span class="p">()</span>
<span class="go">[2, [2], [-1]]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">96</span><span class="p">)</span><span class="o">.</span><span class="n">znstar</span><span class="p">()</span>
<span class="go">[32, [8, 2, 2], [Mod(37, 96), Mod(79, 96), Mod(65, 96)]]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">znstar</span><span class="p">()</span>
<span class="go">[4, [4], [Mod(2, 5)]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.libs.pari.gen.gen_auto">
<em class="property">class </em><tt class="descclassname">sage.libs.pari.gen.</tt><tt class="descname">gen_auto</tt><a class="headerlink" href="#sage.libs.pari.gen.gen_auto" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/element.html#sage.structure.element.RingElement" title="(in Sage Reference Manual: Basic Structures v6.8)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.element.RingElement</span></tt></a></p>
<p>Part of the <a class="reference internal" href="#sage.libs.pari.gen.gen" title="sage.libs.pari.gen.gen"><tt class="xref py py-class docutils literal"><span class="pre">gen</span></tt></a> class containing auto-generated functions.</p>
<p>This class is not meant to be used directly, use the derived class
<a class="reference internal" href="#sage.libs.pari.gen.gen" title="sage.libs.pari.gen.gen"><tt class="xref py py-class docutils literal"><span class="pre">gen</span></tt></a> instead.</p>
<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Col">
<tt class="descname">Col</tt><big>(</big><em>x</em>, <em>n=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the object <span class="math">\(x\)</span> into a column vector. The dimension of the
resulting vector can be optionally specified via the extra parameter <span class="math">\(n\)</span>.</p>
<p>If <span class="math">\(n\)</span> is omitted or <span class="math">\(0\)</span>, the dimension depends on the type of <span class="math">\(x\)</span>; the
vector has a single component, except when <span class="math">\(x\)</span> is</p>
<ul class="simple">
<li>a vector or a quadratic form (in which case the resulting vector
is simply the initial object considered as a row vector),</li>
<li>a polynomial or a power series. In the case of a polynomial, the
coefficients of the vector start with the leading coefficient of the
polynomial, while for power series only the significant coefficients are
taken into account, but this time by increasing order of degree.
In this last case, <tt class="docutils literal"><span class="pre">Vec</span></tt> is the reciprocal function of <tt class="docutils literal"><span class="pre">Pol</span></tt> and
<tt class="docutils literal"><span class="pre">Ser</span></tt> respectively,</li>
<li>a matrix (the column of row vector comprising the matrix is returned),</li>
<li>a character string (a vector of individual characters is returned).</li>
</ul>
<p>In the last two cases (matrix and character string), <span class="math">\(n\)</span> is meaningless and
must be omitted or an error is raised. Otherwise, if <span class="math">\(n\)</span> is given, <span class="math">\(0\)</span>
entries are appended at the end of the vector if <span class="math">\(n &gt; 0\)</span>, and prepended at
the beginning if <span class="math">\(n &lt; 0\)</span>. The dimension of the resulting vector is <span class="math">\(\|n\|\)</span>.</p>
<p>Note that the function <tt class="docutils literal"><span class="pre">Colrev</span></tt> does not exist, use <tt class="docutils literal"><span class="pre">Vecrev</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Colrev">
<tt class="descname">Colrev</tt><big>(</big><em>x</em>, <em>n=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Colrev" title="Permalink to this definition">¶</a></dt>
<dd><p>As <span class="math">\(Col(x, -n)\)</span>, then reverse the result. In particular,
<tt class="docutils literal"><span class="pre">Colrev</span></tt> is the reciprocal function of <tt class="docutils literal"><span class="pre">Polrev</span></tt>: the
coefficients of the vector start with the constant coefficient of the
polynomial and the others follow by increasing degree.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.List">
<tt class="descname">List</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.List" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms a (row or column) vector <span class="math">\(x\)</span> into a list, whose components are
the entries of <span class="math">\(x\)</span>. Similarly for a list, but rather useless in this case.
For other types, creates a list with the single element <span class="math">\(x\)</span>. Note that,
except when <span class="math">\(x\)</span> is omitted, this function creates a small memory leak; so,
either initialize all lists to the empty list, or use them sparingly.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Map">
<tt class="descname">Map</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Map" title="Permalink to this definition">¶</a></dt>
<dd><p>A &#8220;Map&#8221; is an associative array, or dictionary: a data
type composed of a collection of (<em>key</em>, <em>value</em>) pairs, such that
each key appears just once in the collection. This function
converts the matrix <span class="math">\([a_1,b_1;a_2,b_2;...;a_n,b_n]\)</span> to the map <span class="math">\(a_i:---&gt;
b_i\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? M = Map(factor(13!));
? mapget(M,3)
%2 = 5
</pre></div>
</div>
<p>If the argument <span class="math">\(x\)</span> is omitted, create an empty map, which
may be filled later via <tt class="docutils literal"><span class="pre">mapput</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Mat">
<tt class="descname">Mat</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the object <span class="math">\(x\)</span> into a matrix.
If <span class="math">\(x\)</span> is already a matrix, a copy of <span class="math">\(x\)</span> is created.
If <span class="math">\(x\)</span> is a row (resp. column) vector, this creates a 1-row (resp.
1-column) matrix, <em>unless</em> all elements are column (resp.&nbsp;row) vectors
of the same length, in which case the vectors are concatenated sideways
and the associated big matrix is returned.
If <span class="math">\(x\)</span> is a binary quadratic form, creates the associated <span class="math">\(2 x 2\)</span>
matrix. Otherwise, this creates a <span class="math">\(1 x 1\)</span> matrix containing <span class="math">\(x\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? Mat(x + 1)
%1 =
[x + 1]
? Vec( matid(3) )
%2 = [[1, 0, 0]~, [0, 1, 0]~, [0, 0, 1]~]
? Mat(%)
%3 =
[1 0 0]

[0 1 0]

[0 0 1]
? Col( [1,2; 3,4] )
%4 = [[1, 2], [3, 4]]~
? Mat(%)
%5 =
[1 2]

[3 4]
? Mat(Qfb(1,2,3))
%6 =
[1 1]

[1 3]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Mod">
<tt class="descname">Mod</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Mod" title="Permalink to this definition">¶</a></dt>
<dd><p>In its basic form, creates an intmod or a polmod <span class="math">\((a mod b)\)</span>; <span class="math">\(b\)</span> must
be an integer or a polynomial. We then obtain a <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt> and a
<tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> respectively:</p>
<div class="highlight-python"><div class="highlight"><pre>? t = Mod(2,17); t^8
%1 = Mod(1, 17)
? t = Mod(x,x^2+1); t^2
%2 = Mod(-1, x^2+1)
</pre></div>
</div>
<p>If <span class="math">\(a \% b\)</span> makes sense and yields a result of the
appropriate type (<tt class="docutils literal"><span class="pre">t_INT</span></tt> or scalar/<tt class="docutils literal"><span class="pre">t_POL</span></tt>), the operation succeeds as
well:</p>
<div class="highlight-python"><div class="highlight"><pre>? Mod(1/2, 5)
%3 = Mod(3, 5)
? Mod(7 + O(3^6), 3)
%4 = Mod(1, 3)
? Mod(Mod(1,12), 9)
%5 = Mod(1, 3)
? Mod(1/x, x^2+1)
%6 = Mod(-1, x^2+1)
? Mod(exp(x), x^4)
%7 = Mod(1/6*x^3 + 1/2*x^2 + x + 1, x^4)
</pre></div>
</div>
<p>If <span class="math">\(a\)</span> is a complex object, &#8220;base change&#8221; it to <span class="math">\(\mathbb{Z}/b\mathbb{Z}\)</span> or <span class="math">\(K[x]/(b)\)</span>,
which is equivalent to, but faster than, multiplying it by <tt class="docutils literal"><span class="pre">Mod(1,b)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>? Mod([1,2;3,4], 2)
%8 =
[Mod(1, 2) Mod(0, 2)]

[Mod(1, 2) Mod(0, 2)]
? Mod(3*x+5, 2)
%9 = Mod(1, 2)*x + Mod(1, 2)
? Mod(x^2 + y*x + y^3, y^2+1)
%10 = Mod(1, y^2 + 1)*x^2 + Mod(y, y^2 + 1)*x + Mod(-y, y^2 + 1)
</pre></div>
</div>
<p>This function is not the same as <span class="math">\(x\)</span> <tt class="docutils literal"><span class="pre">%</span></tt> <span class="math">\(y\)</span>, the result of which
has no knowledge of the intended modulus <span class="math">\(y\)</span>. Compare</p>
<div class="highlight-python"><div class="highlight"><pre>? x = 4 % 5; x + 1
%1 = 5
? x = Mod(4,5); x + 1
%2 = Mod(0,5)
</pre></div>
</div>
<p>Note that such &#8220;modular&#8221; objects can be lifted via <tt class="docutils literal"><span class="pre">lift</span></tt> or
<tt class="docutils literal"><span class="pre">centerlift</span></tt>. The modulus of a <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt> or <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> <span class="math">\(z\)</span> can
be recovered via <tt class="docutils literal"><span class="pre">:math:`z</span></tt>.mod`.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Pol">
<tt class="descname">Pol</tt><big>(</big><em>t</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Pol" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the object <span class="math">\(t\)</span> into a polynomial with main variable <span class="math">\(v\)</span>. If <span class="math">\(t\)</span>
is a scalar, this gives a constant polynomial. If <span class="math">\(t\)</span> is a power series with
non-negative valuation or a rational function, the effect is similar to
<tt class="docutils literal"><span class="pre">truncate</span></tt>, i.e.&nbsp;we chop off the <span class="math">\(O(X^k)\)</span> or compute the Euclidean
quotient of the numerator by the denominator, then change the main variable
of the result to <span class="math">\(v\)</span>.</p>
<p>The main use of this function is when <span class="math">\(t\)</span> is a vector: it creates the
polynomial whose coefficients are given by <span class="math">\(t\)</span>, with <span class="math">\(t[1]\)</span> being the leading
coefficient (which can be zero). It is much faster to evaluate
<tt class="docutils literal"><span class="pre">Pol</span></tt> on a vector of coefficients in this way, than the corresponding
formal expression <span class="math">\(a_n X^n +...+ a_0\)</span>, which is evaluated naively exactly
as written (linear versus quadratic time in <span class="math">\(n\)</span>). <tt class="docutils literal"><span class="pre">Polrev</span></tt> can be used if
one wants <span class="math">\(x[1]\)</span> to be the constant coefficient:</p>
<div class="highlight-python"><div class="highlight"><pre>? Pol([1,2,3])
%1 = x^2 + 2*x + 3
? Polrev([1,2,3])
%2 = 3*x^2 + 2*x + 1
</pre></div>
</div>
<p>The reciprocal function of <tt class="docutils literal"><span class="pre">Pol</span></tt> (resp.&nbsp;<tt class="docutils literal"><span class="pre">Polrev</span></tt>) is <tt class="docutils literal"><span class="pre">Vec</span></tt> (resp.&nbsp;
<tt class="docutils literal"><span class="pre">Vecrev</span></tt>).</p>
<div class="highlight-python"><div class="highlight"><pre>? Vec(Pol([1,2,3]))
%1 = [1, 2, 3]
? Vecrev( Polrev([1,2,3]) )
%2 = [1, 2, 3]
</pre></div>
</div>
<p><strong>Warning.</strong> This is <em>not</em> a substitution function. It will not
transform an object containing variables of higher priority than&nbsp;<span class="math">\(v\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? Pol(x + y, y)
 *** at top-level: Pol(x+y,y)
 *** ^----------
 *** Pol: variable must have higher priority in gtopoly.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Polrev">
<tt class="descname">Polrev</tt><big>(</big><em>t</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Polrev" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the object <span class="math">\(t\)</span> into a polynomial
with main variable <span class="math">\(v\)</span>. If <span class="math">\(t\)</span> is a scalar, this gives a constant polynomial.
If <span class="math">\(t\)</span> is a power series, the effect is identical to <tt class="docutils literal"><span class="pre">truncate</span></tt>, i.e.&nbsp;it
chops off the <span class="math">\(O(X^k)\)</span>.</p>
<p>The main use of this function is when <span class="math">\(t\)</span> is a vector: it creates the
polynomial whose coefficients are given by <span class="math">\(t\)</span>, with <span class="math">\(t[1]\)</span> being the
constant term. <tt class="docutils literal"><span class="pre">Pol</span></tt> can be used if one wants <span class="math">\(t[1]\)</span> to be the leading
coefficient:</p>
<div class="highlight-python"><div class="highlight"><pre>? Polrev([1,2,3])
%1 = 3*x^2 + 2*x + 1
? Pol([1,2,3])
%2 = x^2 + 2*x + 3
</pre></div>
</div>
<p>The reciprocal function of <tt class="docutils literal"><span class="pre">Pol</span></tt> (resp.&nbsp;<tt class="docutils literal"><span class="pre">Polrev</span></tt>) is <tt class="docutils literal"><span class="pre">Vec</span></tt> (resp.&nbsp;
<tt class="docutils literal"><span class="pre">Vecrev</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Qfb">
<tt class="descname">Qfb</tt><big>(</big><em>a</em>, <em>b</em>, <em>c</em>, <em>D=None</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Qfb" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the binary quadratic form
<span class="math">\(ax^2+bxy+cy^2\)</span>. If <span class="math">\(b^2-4ac &gt; 0\)</span>, initialize Shanks&#8217; distance
function to <span class="math">\(D\)</span>. Negative definite forms are not implemented,
use their positive definite counterpart instead.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Ser">
<tt class="descname">Ser</tt><big>(</big><em>s</em>, <em>v=None</em>, <em>serprec=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Ser" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the object <span class="math">\(s\)</span> into a power series with main variable <span class="math">\(v\)</span>
(<span class="math">\(x\)</span> by default) and precision (number of significant terms) equal to
<span class="math">\(d &gt;= 0\)</span> (<span class="math">\(d = seriesprecision\)</span> by default). If <span class="math">\(s\)</span> is a
scalar, this gives a constant power series in <span class="math">\(v\)</span> with precision <tt class="docutils literal"><span class="pre">d</span></tt>.
If <span class="math">\(s\)</span> is a polynomial, the polynomial is truncated to <span class="math">\(d\)</span> terms if needed</p>
<div class="highlight-python"><div class="highlight"><pre>? Ser(1, &#39;y, 5)
%1 = 1 + O(y^5)
? Ser(x^2,, 5)
%2 = x^2 + O(x^7)
? T = polcyclo(100)
%3 = x^40 - x^30 + x^20 - x^10 + 1
? Ser(T, &#39;x, 11)
%4 = 1 - x^10 + O(x^11)
</pre></div>
</div>
<p>The function is more or less equivalent with multiplication by
<span class="math">\(1 + O(v^d)\)</span> in theses cases, only faster.</p>
<p>If <span class="math">\(s\)</span> is a vector, on the other hand, the coefficients of the vector are
understood to be the coefficients of the power series starting from the
constant term (as in <tt class="docutils literal"><span class="pre">Polrev</span></tt><span class="math">\((x)\)</span>), and the precision <span class="math">\(d\)</span> is ignored:
in other words, in this case, we convert <tt class="docutils literal"><span class="pre">t_VEC</span></tt> / <tt class="docutils literal"><span class="pre">t_COL</span></tt> to the power
series whose significant terms are exactly given by the vector entries.
Finally, if <span class="math">\(s\)</span> is already a power series in <span class="math">\(v\)</span>, we return it verbatim,
ignoring <span class="math">\(d\)</span> again. If <span class="math">\(d\)</span> significant terms are desired in the last two
cases, convert/truncate to <tt class="docutils literal"><span class="pre">t_POL</span></tt> first.</p>
<div class="highlight-python"><div class="highlight"><pre>? v = [1,2,3]; Ser(v, t, 7)
%5 = 1 + 2*t + 3*t^2 + O(t^3) \\ 3 terms: 7 is ignored!
? Ser(Polrev(v,t), t, 7)
%6 = 1 + 2*t + 3*t^2 + O(t^7)
? s = 1+x+O(x^2); Ser(s, x, 7)
%7 = 1 + x + O(x^2) \\ 2 terms: 7 ignored
? Ser(truncate(s), x, 7)
%8 = 1 + x + O(x^7)
</pre></div>
</div>
<p>The warning given for <tt class="docutils literal"><span class="pre">Pol</span></tt> also applies here: this is not a substitution
function.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Set">
<tt class="descname">Set</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Set" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts <span class="math">\(x\)</span> into a set, i.e.&nbsp;into a row vector, with strictly increasing
entries with respect to the (somewhat arbitrary) universal comparison function
<tt class="docutils literal"><span class="pre">cmp</span></tt>. Standard container types <tt class="docutils literal"><span class="pre">t_VEC</span></tt>, <tt class="docutils literal"><span class="pre">t_COL</span></tt>, <tt class="docutils literal"><span class="pre">t_LIST</span></tt> and
<tt class="docutils literal"><span class="pre">t_VECSMALL</span></tt> are converted to the set with corresponding elements. All
others are converted to a set with one element.</p>
<div class="highlight-python"><div class="highlight"><pre>? Set([1,2,4,2,1,3])
%1 = [1, 2, 3, 4]
? Set(x)
%2 = [x]
? Set(Vecsmall([1,3,2,1,3]))
%3 = [1, 2, 3]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Strchr">
<tt class="descname">Strchr</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Strchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts <span class="math">\(x\)</span> to a string, translating each integer
into a character.</p>
<div class="highlight-python"><div class="highlight"><pre>? Strchr(97)
%1 = &quot;a&quot;
? Vecsmall(&quot;hello world&quot;)
%2 = Vecsmall([104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100])
? Strchr(%)
%3 = &quot;hello world&quot;
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Vec">
<tt class="descname">Vec</tt><big>(</big><em>x</em>, <em>n=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the object <span class="math">\(x\)</span> into a row vector. The dimension of the
resulting vector can be optionally specified via the extra parameter <span class="math">\(n\)</span>.</p>
<p>If <span class="math">\(n\)</span> is omitted or <span class="math">\(0\)</span>, the dimension depends on the type of <span class="math">\(x\)</span>; the
vector has a single component, except when <span class="math">\(x\)</span> is</p>
<ul class="simple">
<li>a vector or a quadratic form (in which case the resulting vector
is simply the initial object considered as a row vector),</li>
<li>a polynomial or a power series. In the case of a polynomial, the
coefficients of the vector start with the leading coefficient of the
polynomial, while for power series only the significant coefficients are
taken into account, but this time by increasing order of degree.
In this last case, <tt class="docutils literal"><span class="pre">Vec</span></tt> is the reciprocal function of <tt class="docutils literal"><span class="pre">Pol</span></tt> and
<tt class="docutils literal"><span class="pre">Ser</span></tt> respectively,</li>
<li>a matrix: return the vector of columns comprising the matrix.</li>
<li>a character string: return the vector of individual characters.</li>
<li>an error context (<tt class="docutils literal"><span class="pre">t_ERROR</span></tt>): return the error components, see
<tt class="docutils literal"><span class="pre">iferr</span></tt>.</li>
</ul>
<p>In the last three cases (matrix, character string, error), <span class="math">\(n\)</span> is
meaningless and must be omitted or an error is raised. Otherwise, if <span class="math">\(n\)</span> is
given, <span class="math">\(0\)</span> entries are appended at the end of the vector if <span class="math">\(n &gt; 0\)</span>, and
prepended at the beginning if <span class="math">\(n &lt; 0\)</span>. The dimension of the resulting vector
is <span class="math">\(\|n\|\)</span>. Variant: <tt class="docutils literal"><span class="pre">GEN</span> <span class="pre">:strong:`gtovec`(GEN</span> <span class="pre">x)</span></tt> is also available.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Vecrev">
<tt class="descname">Vecrev</tt><big>(</big><em>x</em>, <em>n=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Vecrev" title="Permalink to this definition">¶</a></dt>
<dd><p>As <span class="math">\(Vec(x, -n)\)</span>, then reverse the result. In particular,
<tt class="docutils literal"><span class="pre">Vecrev</span></tt> is the reciprocal function of <tt class="docutils literal"><span class="pre">Polrev</span></tt>: the
coefficients of the vector start with the constant coefficient of the
polynomial and the others follow by increasing degree.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Vecsmall">
<tt class="descname">Vecsmall</tt><big>(</big><em>x</em>, <em>n=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Vecsmall" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the object <span class="math">\(x\)</span> into a row vector of type <tt class="docutils literal"><span class="pre">t_VECSMALL</span></tt>. The
dimension of the resulting vector can be optionally specified via the extra
parameter <span class="math">\(n\)</span>.</p>
<p>This acts as <tt class="docutils literal"><span class="pre">Vec</span></tt><span class="math">\((x,n)\)</span>, but only on a limited set of objects:
the result must be representable as a vector of small integers.
If <span class="math">\(x\)</span> is a character string, a vector of individual characters in ASCII
encoding is returned (<tt class="docutils literal"><span class="pre">Strchr</span></tt> yields back the character string).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.abs">
<tt class="descname">abs</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Absolute value of <span class="math">\(x\)</span> (modulus if <span class="math">\(x\)</span> is complex).
Rational functions are not allowed. Contrary to most transcendental
functions, an exact argument is <em>not</em> converted to a real number before
applying <tt class="docutils literal"><span class="pre">abs</span></tt> and an exact result is returned if possible.</p>
<div class="highlight-python"><div class="highlight"><pre>? abs(-1)
%1 = 1
? abs(3/7 + 4/7*I)
%2 = 5/7
? abs(1 + I)
%3 = 1.414213562373095048801688724
</pre></div>
</div>
<p>If <span class="math">\(x\)</span> is a polynomial, returns <span class="math">\(-x\)</span> if the leading coefficient is
real and negative else returns <span class="math">\(x\)</span>. For a power series, the constant
coefficient is considered instead.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.acos">
<tt class="descname">acos</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.acos" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of <span class="math">\({cos}^{-1}(x) = -i \log (x + i\sqrt{1-x^2})\)</span>.
In particular, <span class="math">\({Re(acos}(x)) belongs to [0,\Pi]\)</span> and if <span class="math">\(x belongs to \mathbb{R}\)</span> and <span class="math">\(\|x\| &gt; 1\)</span>,
then <span class="math">\({acos}(x)\)</span> is complex. The branch cut is in two pieces:
<span class="math">\(]- oo ,-1]\)</span> , continuous with quadrant II, and <span class="math">\([1,+ oo [\)</span>, continuous
with quadrant IV. We have <span class="math">\({acos}(x) = \Pi/2 - {asin}(x)\)</span> for all
<span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.acosh">
<tt class="descname">acosh</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.acosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of <span class="math">\({cosh}^{-1}(x) = 2
\log(\sqrt{(x+1)/2} + \sqrt{(x-1)/2})\)</span>. In particular,
<span class="math">\({Re}({acosh}(x)) &gt;= 0\)</span> and
<span class="math">\({In}({acosh}(x)) belongs to ]-\Pi,\Pi]0\)</span>; if <span class="math">\(x belongs to \mathbb{R}\)</span> and <span class="math">\(x &lt; 1\)</span>, then
<span class="math">\({acosh}(x)\)</span> is complex.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.addprimes">
<tt class="descname">addprimes</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.addprimes" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the integers contained in the
vector <span class="math">\(x\)</span> (or the single integer <span class="math">\(x\)</span>) to a special table of
&#8220;user-defined primes&#8221;, and returns that table. Whenever <tt class="docutils literal"><span class="pre">factor</span></tt> is
subsequently called, it will trial divide by the elements in this table.
If <span class="math">\(x\)</span> is empty or omitted, just returns the current list of extra
primes.</p>
<p>The entries in <span class="math">\(x\)</span> must be primes: there is no internal check, even if
the <tt class="docutils literal"><span class="pre">factor_proven</span></tt> default is set. To remove primes from the list use
<tt class="docutils literal"><span class="pre">removeprimes</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.agm">
<tt class="descname">agm</tt><big>(</big><em>x</em>, <em>y</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.agm" title="Permalink to this definition">¶</a></dt>
<dd><p>Arithmetic-geometric mean of <span class="math">\(x\)</span> and <span class="math">\(y\)</span>. In the
case of complex or negative numbers, the optimal AGM is returned
(the largest in absolute value over all choices of the signs of the square
roots). <span class="math">\(p\)</span>-adic or power series arguments are also allowed. Note that
a <span class="math">\(p\)</span>-adic agm exists only if <span class="math">\(x/y\)</span> is congruent to 1 modulo <span class="math">\(p\)</span> (modulo
16 for <span class="math">\(p = 2\)</span>). <span class="math">\(x\)</span> and <span class="math">\(y\)</span> cannot both be vectors or matrices.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algabsdim">
<tt class="descname">algabsdim</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algabsdim" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt> or by
<tt class="docutils literal"><span class="pre">algtableinit</span></tt>, returns the dimension of <em>al</em> over its prime subfield
(<span class="math">\(\mathbb{Q}\)</span> or <span class="math">\(\mathbb{F}_p\)</span>).</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^3-y+1);
? A = alginit(nf, [-1,-1]);
? algabsdim(A)
%3 = 12
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algadd">
<tt class="descname">algadd</tt><big>(</big><em>al</em>, <em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algadd" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in <em>al</em>, computes their sum <span class="math">\(x+y\)</span> in
the algebra&nbsp;<em>al</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? A = alginit(nfinit(y),[-1,1]);
? algadd(A,[1,0]~,[1,2]~)
%2 = [2, 2]~
</pre></div>
</div>
<p>Also accepts matrices with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algalgtobasis">
<tt class="descname">algalgtobasis</tt><big>(</big><em>al</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algalgtobasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <em>x</em> in the central simple algebra <em>al</em> output
by <tt class="docutils literal"><span class="pre">alginit</span></tt>, transforms it to a column vector on the integral basis of
<em>al</em>. This is the inverse function of <tt class="docutils literal"><span class="pre">algbasistoalg</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>? A = alginit(nfinit(y^2-5),[2,y]);
? algalgtobasis(A,[y,1]~)
%2 = [0, 2, 0, -1, 2, 0, 0, 0]~
? algbasistoalg(A,algalgtobasis(A,[y,1]~))
%3 = [Mod(Mod(y, y^2 - 5), x^2 - 2), 1]~
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algaut">
<tt class="descname">algaut</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algaut" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a cyclic algebra <span class="math">\(al = (L/K,\sigma,b)\)</span> output by
<tt class="docutils literal"><span class="pre">alginit</span></tt>, returns the automorphism <span class="math">\(\sigma\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y);
? p = idealprimedec(nf,7)[1];
? p2 = idealprimedec(nf,11)[1];
? A = alginit(nf,[3,[[p,p2],[1/3,2/3]],[0]]);
? algaut(A)
%5 = -1/3*x^2 + 1/3*x + 26/3
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algb">
<tt class="descname">algb</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algb" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a cyclic algebra <span class="math">\(al = (L/K,\sigma,b)\)</span> output by
<tt class="docutils literal"><span class="pre">alginit</span></tt>, returns the element <span class="math">\(b belongs to K\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>nf = nfinit(y);
? p = idealprimedec(nf,7)[1];
? p2 = idealprimedec(nf,11)[1];
? A = alginit(nf,[3,[[p,p2],[1/3,2/3]],[0]]);
? algb(A)
%5 = Mod(-77, y)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algbasis">
<tt class="descname">algbasis</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an central simple algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, returns
a <span class="math">\(\mathbb{Z}\)</span>-basis of the order&nbsp;<span class="math">\({\\cal O}_0\)</span> stored in <em>al</em> with respect to the
natural order in <em>al</em>. It is a maximal order if one has been computed.</p>
<div class="highlight-python"><div class="highlight"><pre>A = alginit(nfinit(y), [-1,-1]);
? algbasis(A)
%2 =
[1 0 0 1/2]

[0 1 0 1/2]

[0 0 1 1/2]

[0 0 0 1/2]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algbasistoalg">
<tt class="descname">algbasistoalg</tt><big>(</big><em>al</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algbasistoalg" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <em>x</em> in the central simple algebra <em>al</em> output
by <tt class="docutils literal"><span class="pre">alginit</span></tt>, transforms it to its algebraic representation in <em>al</em>.
This is the inverse function of <tt class="docutils literal"><span class="pre">algalgtobasis</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>? A = alginit(nfinit(y^2-5),[2,y]);
? z = algbasistoalg(A,[0,1,0,0,2,-3,0,0]~);
? liftall(z)
%3 = [(-1/2*y - 2)*x + (-1/4*y + 5/4), -3/4*y + 7/4]~
? algalgtobasis(A,z)
%4 = [0, 1, 0, 0, 2, -3, 0, 0]~
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algcenter">
<tt class="descname">algcenter</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algcenter" title="Permalink to this definition">¶</a></dt>
<dd><p>If <em>al</em> is a table algebra output by <tt class="docutils literal"><span class="pre">algtableinit</span></tt>, returns a
basis of the center of the algebra&nbsp;<em>al</em> over its prime field (<span class="math">\(\mathbb{Q}\)</span> or
<span class="math">\(\mathbb{F}_p\)</span>). If <em>al</em> is a central simple algebra output by <tt class="docutils literal"><span class="pre">alginit</span></tt>,
returns the center of&nbsp;<em>al</em>, which is stored in <em>al</em>.</p>
<p>A simple example: the <span class="math">\(2 x 2\)</span> upper triangular matrices over <span class="math">\(\mathbb{Q}\)</span>,
generated by <span class="math">\(I_2\)</span>, <span class="math">\(a = [0,1;0,0]\)</span> and <span class="math">\(b = [0,0;0,1]\)</span>,
such that <span class="math">\(a^2 = 0\)</span>, <span class="math">\(ab = a\)</span>, <span class="math">\(ba = 0\)</span>, <span class="math">\(b^2 = b\)</span>: the diagonal matrices
for the center.</p>
<div class="highlight-python"><div class="highlight"><pre>? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
? A = algtableinit(mt);
? algcenter(A) \\ = (I_2)
%3 =
[1]

[0]

[0]
</pre></div>
</div>
<p>An example in the central simple case:</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^3-y+1);
? A = alginit(nf, [-1,-1]);
? algcenter(A).pol
%3 = y^3 - y + 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algcentralproj">
<tt class="descname">algcentralproj</tt><big>(</big><em>al</em>, <em>z</em>, <em>maps=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algcentralproj" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a table algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">algtableinit</span></tt> and a
<tt class="docutils literal"><span class="pre">t_VEC</span></tt> <span class="math">\(z = [z_1,...,z_n]\)</span> of orthogonal central idempotents,
returns a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> <span class="math">\([al_1,...,al_n]\)</span> of algebras such that
<span class="math">\(al_i = z_i al\)</span>. If <span class="math">\(maps = 1\)</span>, each <span class="math">\(al_i\)</span> is a <tt class="docutils literal"><span class="pre">t_VEC</span></tt>
<span class="math">\([quo,proj,lift]\)</span> where <em>quo</em> is the quotient algebra, <em>proj</em> is a
<tt class="docutils literal"><span class="pre">t_MAT</span></tt> representing the projection onto this quotient and <em>lift</em> is a
<tt class="docutils literal"><span class="pre">t_MAT</span></tt> representing a lift.</p>
<p>A simple example: <span class="math">\(\mathbb{F}_2\oplus \mathbb{F}_4\)</span>, generated by&nbsp;<span class="math">\(1 = (1,1)\)</span>, <span class="math">\(e = (1,0)\)</span>
and&nbsp;<span class="math">\(x\)</span> such that&nbsp;<span class="math">\(x^2+x+1 = 0\)</span>. We have&nbsp;<span class="math">\(e^2 = e\)</span>, <span class="math">\(x^2 = x+1\)</span> and&nbsp;<span class="math">\(ex = 0\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,2);
? e = [0,1,0]~;
? e2 = algsub(A,[1,0,0]~,e);
? [a,a2] = algcentralproj(A,[e,e2]);
? algdim(a)
%6 = 1
? algdim(a2)
%7 = 2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algchar">
<tt class="descname">algchar</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algchar" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt> or <tt class="docutils literal"><span class="pre">algtableinit</span></tt>,
returns the characteristic of <em>al</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,13);
? algchar(A)
%3 = 13
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algcharpoly">
<tt class="descname">algcharpoly</tt><big>(</big><em>al</em>, <em>b</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algcharpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(b\)</span> in <em>al</em>, returns its characteristic polynomial
as a polynomial in the variable <span class="math">\(v\)</span>. If <em>al</em> is a table algebra output
by <tt class="docutils literal"><span class="pre">algtableinit</span></tt>, returns the absolute characteristic polynomial of
<em>b</em>, which is an element of <span class="math">\(\mathbb{F}_p[v]\)</span> or&nbsp;<span class="math">\(\mathbb{Q}[v]\)</span>; if <em>al</em> is a
central simple algebra output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, returns the reduced
characteristic polynomial of <em>b</em>, which is an element of <span class="math">\(K[v]\)</span> where&nbsp;<span class="math">\(K\)</span>
is the center of <em>al</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? al = alginit(nfinit(y), [-1,-1]); \\ (-1,-1)_Q
? algcharpoly(al, [0,1]~)
%2 = x^2 + 1
</pre></div>
</div>
<p>Also accepts a square matrix with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algdecomposition">
<tt class="descname">algdecomposition</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algdecomposition" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being a table algebra output by <tt class="docutils literal"><span class="pre">algtableinit</span></tt>, returns
<span class="math">\([J,[al_1,...,al_n]]\)</span> where <span class="math">\(J\)</span> is a basis of the Jacobson radical of
<em>al</em> and <span class="math">\(al_1,...,al_n\)</span> are the simple factors of the semisimple
algebra <span class="math">\(al/J\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algdegree">
<tt class="descname">algdegree</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algdegree" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, returns
the degree of <em>al</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^3-y+1);
? A = alginit(nf, [-1,-1]);
? algdegree(A)
%3 = 2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algdep">
<tt class="descname">algdep</tt><big>(</big><em>x</em>, <em>k</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algdep" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> being real/complex, or <span class="math">\(p\)</span>-adic, finds a polynomial of degree at most
<span class="math">\(k\)</span> with integer coefficients having <span class="math">\(x\)</span> as approximate root. Note that the
polynomial which is obtained is not necessarily the &#8220;correct&#8221; one. In fact
it is not even guaranteed to be irreducible. One can check the closeness
either by a polynomial evaluation (use <tt class="docutils literal"><span class="pre">subst</span></tt>), or by computing the
roots of the polynomial given by <tt class="docutils literal"><span class="pre">algdep</span></tt> (use <tt class="docutils literal"><span class="pre">polroots</span></tt>).</p>
<p>Internally, <tt class="docutils literal"><span class="pre">lindep</span></tt><span class="math">\(([1,x,...,x^k], flag)\)</span> is used.
A non-zero value of <span class="math">\(flag\)</span> may improve on the default behavior
if the input number is known to a <em>huge</em> accuracy, and you suspect the
last bits are incorrect (this truncates the number, throwing away the least
significant bits), but default values are usually sufficient:</p>
<div class="highlight-python"><div class="highlight"><pre>? \p200
? algdep(2^(1/6)+3^(1/5), 30); \\ wrong in 0.8s
? algdep(2^(1/6)+3^(1/5), 30, 100); \\ wrong in 0.4s
? algdep(2^(1/6)+3^(1/5), 30, 170); \\ right in 0.8s
? algdep(2^(1/6)+3^(1/5), 30, 200); \\ wrong in 1.0s
? \p250
? algdep(2^(1/6)+3^(1/5), 30); \\ right in 1.0s
? algdep(2^(1/6)+3^(1/5), 30, 200); \\ right in 1.0s
? \p500
? algdep(2^(1/6)+3^(1/5), 30); \\ right in 2.9s
? \p1000
? algdep(2^(1/6)+3^(1/5), 30); \\ right in 10.6s
</pre></div>
</div>
<p>The changes in <tt class="docutils literal"><span class="pre">defaultprecision</span></tt> only affect the quality of the
initial approximation to <span class="math">\(2^{1/6} + 3^{1/5}\)</span>, <tt class="docutils literal"><span class="pre">algdep</span></tt> itself uses
exact operations (the size of its operands depend on the accuracy of the
input of course: more accurate input means slower operations).</p>
<p>Proceeding by increments of 5 digits of accuracy, <tt class="docutils literal"><span class="pre">algdep</span></tt> with default
flag produces its first correct result at 205 digits, and from then on a
steady stream of correct results.</p>
<p>The above example is the test case studied in a 2000 paper by Borwein and
Lisonek: Applications of integer relation algorithms, <em>Discrete Math.</em>,
<strong>217</strong>, p.&nbsp;65&#8211;82. The version of PARI tested there was 1.39, which
succeeded reliably from precision 265 on, in about 200 as much time as the
current version.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algdim">
<tt class="descname">algdim</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algdim" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, returns
the dimension of <em>al</em> over its center. Given a table algebra <em>al</em>
output by <tt class="docutils literal"><span class="pre">algtableinit</span></tt>, returns the dimension of <em>al</em> over its prime
subfield (<span class="math">\(\mathbb{Q}\)</span> or <span class="math">\(\mathbb{F}_p\)</span>).</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^3-y+1);
? A = alginit(nf, [-1,-1]);
? algdim(A)
%3 = 4
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algdisc">
<tt class="descname">algdisc</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algdisc" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, computes
the discriminant of the order <span class="math">\({\\cal O}_0\)</span> stored in <em>al</em>, that is the
determinant of the trace form <span class="math">\(\\rm{Tr} : {\\cal O}_0 x {\\cal O}_0 \\to \mathbb{Z}\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2-5);
? A = alginit(nf, [-3,1-y]);
? [PR,h] = alghassef(A);
%3 = [[[2, [2, 0]~, 1, 2, 1], [3, [3, 0]~, 1, 2, 1]], Vecsmall([0, 1])]
? n = algdegree(A);
? D = algabsdim(A);
? h = vector(#h, i, n - gcd(n,h[i]));
? n^D * nf.disc^(n^2) * idealnorm(nf, idealfactorback(nf,PR,h))^n
%4 = 12960000
? algdisc(A)
%5 = 12960000
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algdivl">
<tt class="descname">algdivl</tt><big>(</big><em>al</em>, <em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algdivl" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in <em>al</em>, computes their left quotient
<span class="math">\(x\\y\)</span> in the algebra <em>al</em>: an element <span class="math">\(z\)</span> such that <span class="math">\(xz = y\)</span> (such
an element is not unique when <span class="math">\(x\)</span> is a zerodivisor). If&nbsp;<span class="math">\(x\)</span> is invertible, this
is the same as <span class="math">\(x^{-1}y\)</span>. Assumes that <span class="math">\(y\)</span> is left divisible by <span class="math">\(x\)</span> (i.e. that
<span class="math">\(z\)</span> exists). Also accepts matrices with coefficients in&nbsp;<em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algdivr">
<tt class="descname">algdivr</tt><big>(</big><em>al</em>, <em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algdivr" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in <em>al</em>, return <span class="math">\(xy^{-1}\)</span>. Also accepts
matrices with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.alghasse">
<tt class="descname">alghasse</tt><big>(</big><em>al</em>, <em>pl</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.alghasse" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt> and a prime
ideal or an integer between <span class="math">\(1\)</span> and <span class="math">\(r_1+r_2\)</span>, returns a <tt class="docutils literal"><span class="pre">t_FRAC</span></tt> <span class="math">\(h\)</span> : the
local Hasse invariant of <em>al</em> at the place specified by <em>pl</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? alghasse(A, 1)
%3 = 1/2
? alghasse(A, 2)
%4 = 0
? alghasse(A, idealprimedec(nf,2)[1])
%5 = 1/2
? alghasse(A, idealprimedec(nf,5)[1])
%6 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.alghassef">
<tt class="descname">alghassef</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.alghassef" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, returns
a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> <span class="math">\([PR, h_f]\)</span> describing the local Hasse invariants at the
finite places of the center: <tt class="docutils literal"><span class="pre">PR</span></tt> is a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> of primes and <span class="math">\(h_f\)</span> is a
<tt class="docutils literal"><span class="pre">t_VECSMALL</span></tt> of integers modulo the degree <span class="math">\(d\)</span> of <em>al</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,2*y-1]);
? [PR,hf] = alghassef(A);
? PR
%4 = [[19, [10, 2]~, 1, 1, [-8, 2; 2, -10]], [2, [2, 0]~, 1, 2, 1]]
? hf
%5 = Vecsmall([1, 0])
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.alghassei">
<tt class="descname">alghassei</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.alghassei" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, returns
a <tt class="docutils literal"><span class="pre">t_VECSMALL</span></tt> <span class="math">\(h_i\)</span> of <span class="math">\(r_1\)</span> integers modulo the degree <span class="math">\(d\)</span> of <em>al</em>,
where <span class="math">\(r_1\)</span> is the number of real places of the center: the local Hasse
invariants of <em>al</em> at infinite places.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? alghassei(A)
%3 = Vecsmall([1, 0])
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algindex">
<tt class="descname">algindex</tt><big>(</big><em>al</em>, <em>pl=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the central simple algebra&nbsp;<span class="math">\(A\)</span> over&nbsp;<span class="math">\(K\)</span> (as output by
alginit), that is the degree&nbsp;<span class="math">\(e\)</span> of the unique central division algebra&nbsp;<span class="math">\(D\)</span>
over <span class="math">\(K\)</span> such that&nbsp;<span class="math">\(A\)</span> is isomorphic to some matrix algebra&nbsp;<span class="math">\(M_d(D)\)</span>. If
<em>pl</em> is set, it should be a prime ideal of&nbsp;<span class="math">\(K\)</span> or an integer between&nbsp;<span class="math">\(1\)</span>
and&nbsp;<span class="math">\(r_1+r_2\)</span>, and in that case return the local index at the place <em>pl</em>
instead.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? algindex(A, 1)
%3 = 2
? algindex(A, 2)
%4 = 1
? algindex(A, idealprimedec(nf,2)[1])
%5 = 2
? algindex(A, idealprimedec(nf,5)[1])
%6 = 1
? algindex(A)
%7 = 2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.alginit">
<tt class="descname">alginit</tt><big>(</big><em>B</em>, <em>C</em>, <em>v=None</em>, <em>flag=1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.alginit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the central simple algebra defined by data <span class="math">\(B\)</span>, <span class="math">\(C\)</span> and
variable <span class="math">\(v\)</span>, as follows.</p>
<ul class="simple">
<li>(multiplication table) <span class="math">\(B\)</span> is the base number field <span class="math">\(K\)</span> in <tt class="docutils literal"><span class="pre">nfinit</span></tt>
form, <span class="math">\(C\)</span> is a &#8220;multiplication table&#8221; over <span class="math">\(K\)</span>.
As a <span class="math">\(K\)</span>-vector space, the algebra is generated by a basis
<span class="math">\((e_1 = 1,..., e_n)\)</span>; the table is given as a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> of <span class="math">\(n\)</span> matrices in
<span class="math">\(M_n(K)\)</span>, giving the left multiplication by the basis elements <span class="math">\(e_i\)</span>, in the
given basis.
Assumes that <span class="math">\(e_1 = 1\)</span>, that the multiplication table is integral, and that
<span class="math">\(K[e_1,...,e_n]\)</span> describes a central simple algebra over <span class="math">\(K\)</span>; <span class="math">\(v\)</span> and <span class="math">\(flag\)</span>
are ignored.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>{ m_i = [0,-1,0, 0;
 1, 0,0, 0;
 0, 0,0,-1;
 0, 0,1, 0];
 m_j = [0, 0,-1,0;
 0, 0, 0,1;
 1, 0, 0,0;
 0,-1, 0,0];
 m_k = [0, 0, 0, 0;
 0, 0,-1, 0;
 0, 1, 0, 0;
 1, 0, 0,-1];
 A = alginit(nfinit(y), [matid(4), m_i,m_j,m_k], 0); }
</pre></div>
</div>
<p>represents (in a complicated way) the quaternion algebra <span class="math">\((-1,-1)_\mathbb{Q}\)</span>.
See below for a simpler solution.</p>
<ul class="simple">
<li>(cyclic algebra) <span class="math">\(B\)</span> is an <em>rnf</em> structure associated with a cyclic
number field extension <span class="math">\(L/K\)</span> of degree <span class="math">\(d\)</span>, <span class="math">\(C\)</span> is a <tt class="docutils literal"><span class="pre">t_VEC</span></tt>
<tt class="docutils literal"><span class="pre">[sigma,b]</span></tt> with 2 components: <tt class="docutils literal"><span class="pre">sigma</span></tt> is a <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> representing
an automorphism generating <span class="math">\({Gal}(L/K)\)</span>, <span class="math">\(b\)</span> is an element in <span class="math">\(K^*\)</span>. This
represents the cyclic algebra&nbsp;<span class="math">\((L/K,\sigma,b)\)</span>. Currently the element <span class="math">\(b\)</span> has
to be integral.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? Q = nfinit(y); T = polcyclo(5, &#39;x); F = rnfinit(Q, T);
? A = alginit(F, [Mod(x^2,T), 3]);
</pre></div>
</div>
<p>defines the cyclic algebra <span class="math">\((L/\mathbb{Q}, \sigma, 3)\)</span>, where
<span class="math">\(L = \mathbb{Q}(\zeta_5)\)</span> and <span class="math">\(\sigma:\zeta:---&gt;\zeta^2\)</span> generates
<span class="math">\({Gal}(L/\mathbb{Q})\)</span>.</p>
<ul class="simple">
<li>(quaternion algebra, special case of the above) <span class="math">\(B\)</span> is an <em>nf</em>
structure associated with a number field <span class="math">\(K\)</span>, <span class="math">\(C = [a,b]\)</span> is a vector
containing two elements of <span class="math">\(K^*\)</span> with <span class="math">\(a\)</span> not a square in <span class="math">\(K\)</span>, returns the quaternion algebra <span class="math">\((a,b)_K\)</span>.
The variable <span class="math">\(v\)</span> (<tt class="docutils literal"><span class="pre">'x</span></tt> by default) must have higher priority than the
variable of <span class="math">\(K\)</span><tt class="docutils literal"><span class="pre">.pol</span></tt> and is used to represent elements in the splitting
field <span class="math">\(L = K[x]/(x^2-a)\)</span>.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? Q = nfinit(y); A = alginit(Q, [-1,-1]); \\ (-1,-1)_Q
</pre></div>
</div>
<ul class="simple">
<li>(algebra/<span class="math">\(K\)</span> defined by local Hasse invariants)
<span class="math">\(B\)</span> is an <em>nf</em> structure associated with a number field <span class="math">\(K\)</span>,
<span class="math">\(C = [d, [PR,h_f], h_i]\)</span> is a triple
containing an integer <span class="math">\(d &gt; 1\)</span>, a pair <span class="math">\([PR, h_f]\)</span> describing the
Hasse invariants at finite places, and <span class="math">\(h_i\)</span> the Hasse invariants
at archimedean (real) places. A local Hasse invariant belongs to <span class="math">\((1/d)\mathbb{Z}/\mathbb{Z}
\subset \mathbb{Q}/\mathbb{Z}\)</span>, and is given either as a <tt class="docutils literal"><span class="pre">t_FRAC</span></tt> (lift to <span class="math">\((1/d)\mathbb{Z}\)</span>),
a <tt class="docutils literal"><span class="pre">t_INT</span></tt> or <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt> modulo <span class="math">\(d\)</span> (lift to <span class="math">\(\mathbb{Z}/d\mathbb{Z}\)</span>); a whole vector
of local invariants can also be given as a <tt class="docutils literal"><span class="pre">t_VECSMALL</span></tt>, whose
entries are handled as <tt class="docutils literal"><span class="pre">t_INT</span></tt>&nbsp;s. <tt class="docutils literal"><span class="pre">PR</span></tt> is a list of prime ideals
(<em>prid</em> structures), and <span class="math">\(h_f\)</span> is a vector of the same length giving the
local invariants at those maximal ideals. The invariants at infinite real
places are indexed by the real roots <span class="math">\(K\)</span><tt class="docutils literal"><span class="pre">.roots</span></tt>: if the Archimedean
place <span class="math">\(v\)</span> is associated with the <span class="math">\(j\)</span>-th root, the value of
<span class="math">\(h_v\)</span> is given by <span class="math">\(h_i[j]\)</span>, must be <span class="math">\(0\)</span> or <span class="math">\(1/2\)</span> (or&nbsp;<span class="math">\(d/2\)</span> modulo&nbsp;<span class="math">\(d\)</span>), and
can be nonzero only if&nbsp;<span class="math">\(d\)</span> is even.</li>
</ul>
<p>By class field theory, provided the local invariants <span class="math">\(h_v\)</span> sum to <span class="math">\(0\)</span>, up
to Brauer equivalence, there is a unique central simple algebra over <span class="math">\(K\)</span>
with given local invariants and trivial invariant elsewhere. In particular,
up to isomorphism, there is a unique such algebra <span class="math">\(A\)</span> of degree <span class="math">\(d\)</span>.</p>
<p>We realize <span class="math">\(A\)</span> as a cyclic algebra through class field theory. The variable <span class="math">\(v\)</span>
(<tt class="docutils literal"><span class="pre">'x</span></tt> by default) must have higher priority than the variable of
<span class="math">\(K\)</span><tt class="docutils literal"><span class="pre">.pol</span></tt> and is used to represent elements in the (cyclic) splitting
field extension <span class="math">\(L/K\)</span> for <span class="math">\(A\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2+1);
? PR = idealprimedec(nf,5); #PR
%2 = 2
? hi = [];
? hf = [PR, [1/3,-1/3]];
? A = alginit(nf, [3,hf,hi]);
? algsplittingfield(A).pol
%6 = x^3 - 21*x + 7
</pre></div>
</div>
<ul class="simple">
<li>(matrix algebra, toy example) <span class="math">\(B\)</span> is an <em>nf</em> structure associated
to a number field <span class="math">\(K\)</span>, <span class="math">\(C = d\)</span> is a positive integer. Returns a cyclic
algebra isomorphic to the matrix algebra <span class="math">\(M_d(K)\)</span>.</li>
</ul>
<p>In all cases, this function computes a maximal order for the algebra by default,
which may require a lot of time. Setting <span class="math">\(flag = 0\)</span> prevents this computation.</p>
<p>The pari object representing such an algebra <span class="math">\(A\)</span> is a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> with the
following data:</p>
<ul class="simple">
<li>A splitting field <span class="math">\(L\)</span> of <span class="math">\(A\)</span> of the same degree over <span class="math">\(K\)</span> as <span class="math">\(A\)</span>, in
<tt class="docutils literal"><span class="pre">rnfinit</span></tt> format, accessed with <tt class="docutils literal"><span class="pre">algsplittingfield</span></tt>.</li>
<li>The same splitting field <span class="math">\(L\)</span> in <tt class="docutils literal"><span class="pre">nfinit</span></tt> format.</li>
<li>The Hasse invariants at the real places of <span class="math">\(K\)</span>, accessed with
<tt class="docutils literal"><span class="pre">alghassei</span></tt>.</li>
<li>The Hasse invariants of <span class="math">\(A\)</span> at the finite primes of <span class="math">\(K\)</span> that ramify in
the natural order of <span class="math">\(A\)</span>, accessed with <tt class="docutils literal"><span class="pre">alghassef</span></tt>.</li>
<li>A basis of an order <span class="math">\({\\cal O}_0\)</span> expressed on the basis of the natural
order, accessed with <tt class="docutils literal"><span class="pre">algord</span></tt>.</li>
<li>A basis of the natural order expressed on the basis of <span class="math">\({\\cal O}_0\)</span>,
accessed with <tt class="docutils literal"><span class="pre">alginvord</span></tt>.</li>
<li>The left multiplication table of <span class="math">\({\\cal O}_0\)</span> on the previous basis,
accessed with <tt class="docutils literal"><span class="pre">algmultable</span></tt>.</li>
<li>The characteristic of <span class="math">\(A\)</span> (always <span class="math">\(0\)</span>), accessed with <tt class="docutils literal"><span class="pre">algchar</span></tt>.</li>
<li>The absolute traces of the elements of the basis of <span class="math">\({\\cal O}_0\)</span>.</li>
<li>If <span class="math">\(A\)</span> was constructed as a cyclic algebra&nbsp;<span class="math">\((L/K,\sigma,b)\)</span> of degree
<span class="math">\(d\)</span>, a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> <span class="math">\([\sigma,\sigma^2,...,\sigma^{d-1}]\)</span>. The function
<tt class="docutils literal"><span class="pre">algaut</span></tt> returns <span class="math">\(\sigma\)</span>.</li>
<li>If <span class="math">\(A\)</span> was constructed as a cyclic algebra&nbsp;<span class="math">\((L/K,\sigma,b)\)</span>, the
element <span class="math">\(b\)</span>, accessed with <tt class="docutils literal"><span class="pre">algb</span></tt>.</li>
<li>If <span class="math">\(A\)</span> was constructed with its multiplication table <span class="math">\(mt\)</span> over <span class="math">\(K\)</span>,
the <tt class="docutils literal"><span class="pre">t_VEC</span></tt> of <tt class="docutils literal"><span class="pre">t_MAT</span></tt> <span class="math">\(mt\)</span>, accessed with <tt class="docutils literal"><span class="pre">algrelmultable</span></tt>.</li>
<li>If <span class="math">\(A\)</span> was constructed with its multiplication table <span class="math">\(mt\)</span> over <span class="math">\(K\)</span>,
a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> with three components: a <tt class="docutils literal"><span class="pre">t_COL</span></tt> representing an element of <span class="math">\(A\)</span>
generating the splitting field <span class="math">\(L\)</span> as a maximal subfield of <span class="math">\(A\)</span>, a <tt class="docutils literal"><span class="pre">t_MAT</span></tt>
representing an <span class="math">\(L\)</span>-basis <span class="math">\({\cal B}\)</span> of <span class="math">\(A\)</span> expressed on the <span class="math">\(\mathbb{Z}\)</span>-basis of
<span class="math">\({\cal O}_0\)</span>, and a <tt class="docutils literal"><span class="pre">t_MAT</span></tt> representing the <span class="math">\(\mathbb{Z}\)</span>-basis of <span class="math">\({\cal O}_0\)</span>
expressed on <span class="math">\({\cal B}\)</span>. This data is accessed with <tt class="docutils literal"><span class="pre">algsplittingdata</span></tt>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.alginv">
<tt class="descname">alginv</tt><big>(</big><em>al</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.alginv" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(x\)</span> in <em>al</em>, computes its inverse <span class="math">\(x^{-1}\)</span> in the
algebra <em>al</em>. Assumes that <span class="math">\(x\)</span> is invertible.</p>
<div class="highlight-python"><div class="highlight"><pre>? A = alginit(nfinit(y), [-1,-1]);
? alginv(A,[1,1,0,0]~)
%2 = [1/2, 1/2, 0, 0]~
</pre></div>
</div>
<p>Also accepts matrices with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.alginvbasis">
<tt class="descname">alginvbasis</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.alginvbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an central simple algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, returns
a <span class="math">\(\mathbb{Z}\)</span>-basis of the natural order in <em>al</em> with respect to the order&nbsp;<span class="math">\({\\cal
O}_0\)</span> stored in <em>al</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>A = alginit(nfinit(y), [-1,-1]);
? alginvbasis(A)
%2 =
[1 0 0 -1]

[0 1 0 -1]

[0 0 1 -1]

[0 0 0 2]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algisassociative">
<tt class="descname">algisassociative</tt><big>(</big><em>mt</em>, <em>p=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algisassociative" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if the multiplication table <tt class="docutils literal"><span class="pre">mt</span></tt> is suitable for
<tt class="docutils literal"><span class="pre">algtableinit(mt,p)</span></tt>, 0 otherwise. More precisely, <tt class="docutils literal"><span class="pre">mt</span></tt> should be
a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> of <span class="math">\(n\)</span> matrices in <span class="math">\(M_n(K)\)</span>, giving the left multiplications
by the basis elements <span class="math">\(e_1,..., e_n\)</span> (structure constants).
We check whether the first basis element <span class="math">\(e_1\)</span> is <span class="math">\(1\)</span> and <span class="math">\(e_i(e_je_k) = 
(e_ie_j)e_k\)</span> for all <span class="math">\(i,j,k\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
? algisassociative(mt)
%2 = 1
</pre></div>
</div>
<p>May be used to check a posteriori an algebra: we also allow <tt class="docutils literal"><span class="pre">mt</span></tt> as
output by <tt class="docutils literal"><span class="pre">algtableinit</span></tt> (<span class="math">\(p\)</span> is ignored in this case).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algiscommutative">
<tt class="descname">algiscommutative</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algiscommutative" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being a table algebra output by <tt class="docutils literal"><span class="pre">algtableinit</span></tt> or a central
simple algebra output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, tests whether the algebra <em>al</em> is
commutative.</p>
<div class="highlight-python"><div class="highlight"><pre>? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
? A = algtableinit(mt);
? algiscommutative(A)
%3 = 0
? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,2);
? algiscommutative(A)
%6 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algisdivision">
<tt class="descname">algisdivision</tt><big>(</big><em>al</em>, <em>pl=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algisdivision" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, test
whether <em>al</em> is a division algebra. If <em>pl</em> is set, it should be a
prime ideal of&nbsp;<span class="math">\(K\)</span> or an integer between&nbsp;<span class="math">\(1\)</span> and&nbsp;<span class="math">\(r_1+r_2\)</span>, and in that case
test whether <em>al</em> is locally a division algebra at the place <em>pl</em>
instead.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? algisdivision(A, 1)
%3 = 1
? algisdivision(A, 2)
%4 = 0
? algisdivision(A, idealprimedec(nf,2)[1])
%5 = 1
? algisdivision(A, idealprimedec(nf,5)[1])
%6 = 0
? algisdivision(A)
%7 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algisramified">
<tt class="descname">algisramified</tt><big>(</big><em>al</em>, <em>pl=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algisramified" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, test
whether <em>al</em> is ramified, i.e. not isomorphic to a matrix algebra over its
center. If <em>pl</em> is set, it should be a prime ideal of&nbsp;<span class="math">\(K\)</span> or an integer
between&nbsp;<span class="math">\(1\)</span> and&nbsp;<span class="math">\(r_1+r_2\)</span>, and in that case test whether <em>al</em> is locally
ramified at the place <em>pl</em> instead.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? algisramified(A, 1)
%3 = 1
? algisramified(A, 2)
%4 = 0
? algisramified(A, idealprimedec(nf,2)[1])
%5 = 1
? algisramified(A, idealprimedec(nf,5)[1])
%6 = 0
? algisramified(A)
%7 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algissemisimple">
<tt class="descname">algissemisimple</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algissemisimple" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being a table algebra output by <tt class="docutils literal"><span class="pre">algtableinit</span></tt> or a central
simple algebra output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, tests whether the algebra <em>al</em> is
semisimple.</p>
<div class="highlight-python"><div class="highlight"><pre>? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
? A = algtableinit(mt);
? algissemisimple(A)
%3 = 0
? m_i=[0,-1,0,0;1,0,0,0;0,0,0,-1;0,0,1,0]; \\quaternion algebra (-1,-1)
? m_j=[0,0,-1,0;0,0,0,1;1,0,0,0;0,-1,0,0];
? m_k=[0,0,0,-1;0,0,-1,0;0,1,0,0;1,0,0,0];
? mt = [matid(4), m_i, m_j, m_k];
? A = algtableinit(mt);
? algissemisimple(A)
%9 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algissimple">
<tt class="descname">algissimple</tt><big>(</big><em>al</em>, <em>ss=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algissimple" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being a table algebra output by <tt class="docutils literal"><span class="pre">algtableinit</span></tt> or a central
simple algebra output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, tests whether the algebra <em>al</em> is
simple. If <span class="math">\(ss = 1\)</span>, assumes that the algebra&nbsp;<em>al</em> is semisimple
without testing it.</p>
<div class="highlight-python"><div class="highlight"><pre>? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
? A = algtableinit(mt); \\ matrices [*,*; 0,*]
? algissimple(A)
%3 = 0
? algissimple(A,1) \\ incorrectly assume that A is semisimple
%4 = 1
? m_i=[0,-1,0,0;1,0,0,0;0,0,0,-1;0,0,1,0];
? m_j=[0,0,-1,0;0,0,0,1;1,0,0,0;0,-1,0,0];
? m_k=[0,0,0,-1;0,0,b,0;0,1,0,0;1,0,0,0];
? mt = [matid(4), m_i, m_j, m_k];
? A = algtableinit(mt); \\ quaternion algebra (-1,-1)
? algissimple(A)
%10 = 1
? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,2); \\ direct sum F_4+F_2
? algissimple(A)
%13 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algissplit">
<tt class="descname">algissplit</tt><big>(</big><em>al</em>, <em>pl=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algissplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, test
whether <em>al</em> is split, i.e. isomorphic to a matrix algebra over its center.
If <em>pl</em> is set, it should be a prime ideal of&nbsp;<span class="math">\(K\)</span> or an integer between&nbsp;<span class="math">\(1\)</span>
and&nbsp;<span class="math">\(r_1+r_2\)</span>, and in that case test whether <em>al</em> is locally split at the
place <em>pl</em> instead.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? algissplit(A, 1)
%3 = 0
? algissplit(A, 2)
%4 = 1
? algissplit(A, idealprimedec(nf,2)[1])
%5 = 0
? algissplit(A, idealprimedec(nf,5)[1])
%6 = 1
? algissplit(A)
%7 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algmul">
<tt class="descname">algmul</tt><big>(</big><em>al</em>, <em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in <em>al</em>, computes their product <span class="math">\(x*y\)</span>
in the algebra&nbsp;<em>al</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? A = alginit(nfinit(y), [-1,-1]);
? algmul(A,[1,1,0,0]~,[0,0,2,1]~)
%2 = [2, 3, 5, -4]~
</pre></div>
</div>
<p>Also accepts matrices with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algmultable">
<tt class="descname">algmultable</tt><big>(</big><em>al</em>, <em>x=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algmultable" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <em>x</em> in <em>al</em>, computes its left multiplication
table. If <em>x</em> is given in basis form, returns its multiplication table on
the integral basis; if <em>x</em> is given in algebraic form, returns its
multiplication table on the basis corresponding to the algebraic form of
elements of <em>al</em>. In every case, if <em>x</em> is a <tt class="docutils literal"><span class="pre">t_COL</span></tt> of length <span class="math">\(n\)</span>,
then the output is a <span class="math">\(n x n\)</span> <tt class="docutils literal"><span class="pre">t_MAT</span></tt>.
Also accepts a square matrix with coefficients in <em>al</em>.</p>
<p>If <em>x</em> is not set, returns a multiplication table of <em>al</em> over its
prime subfield (<span class="math">\(\mathbb{Q}\)</span> or <span class="math">\(\mathbb{F}_p\)</span>), as a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> of <tt class="docutils literal"><span class="pre">t_MAT</span></tt>: the left
multiplication tables of basis elements. If <em>al</em> was output by
<tt class="docutils literal"><span class="pre">algtableinit</span></tt>, returns the multiplication table used to define <em>al</em>.
If <em>al</em> was output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, returns the multiplication table of
the order&nbsp;<span class="math">\({\\cal O}_0\)</span> stored in <em>al</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? A = alginit(nfinit(y), [-1,-1]);
? algmultable(A,[0,1,0,0]~)
%2 =
[0 -1 1 0]

[1 0 1 1]

[0 0 1 1]

[0 0 -2 -1]
</pre></div>
</div>
<p>Another example:</p>
<div class="highlight-python"><div class="highlight"><pre>? A = alginit(nfinit(y), [-1,-1]);
? M = algmultable(A);
? #M
%3 = 4
? M[1]
%4 =
[1 0 0 0]

[0 1 0 0]

[0 0 1 0]

[0 0 0 1]

? M[2]
%5 =
[0 -1 1 0]

[1 0 1 1]

[0 0 1 1]

[0 0 -2 -1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algneg">
<tt class="descname">algneg</tt><big>(</big><em>al</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algneg" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(x\)</span> in <em>al</em>, computes its opposite <span class="math">\(-x\)</span> in the
algebra <em>al</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? A = alginit(nfinit(y), [-1,-1]);
? algneg(A,[1,1,0,0]~)
%2 = [-1, -1, 0, 0]~
</pre></div>
</div>
<p>Also accepts matrices with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algnorm">
<tt class="descname">algnorm</tt><big>(</big><em>al</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <em>x</em> in <em>al</em>, computes its norm. If <em>al</em> is
a table algebra output by <tt class="docutils literal"><span class="pre">algtableinit</span></tt>, returns the absolute norm of
<em>x</em>, which is an element of <span class="math">\(\mathbb{F}_p\)</span> of&nbsp;<span class="math">\(\mathbb{Q}\)</span>; if <em>al</em> is a central
simple algebra output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, returns the reduced norm of <em>x</em>,
which is an element of the center of <em>al</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,19);
? algnorm(A,[0,-2,3]~)
%3 = 18
</pre></div>
</div>
<p>Also accepts a square matrix with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algpoleval">
<tt class="descname">algpoleval</tt><big>(</big><em>al</em>, <em>T</em>, <em>b</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algpoleval" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(b\)</span> in <em>al</em> and a polynomial <span class="math">\(T\)</span> in <span class="math">\(K[X]\)</span>,
computes <span class="math">\(T(b)\)</span> in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algpow">
<tt class="descname">algpow</tt><big>(</big><em>al</em>, <em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(x\)</span> in <em>al</em> and an integer <span class="math">\(n\)</span>, computes the
power <span class="math">\(x^n\)</span> in the algebra <em>al</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? A = alginit(nfinit(y), [-1,-1]);
? algpow(A,[1,1,0,0]~,7)
%2 = [8, -8, 0, 0]~
</pre></div>
</div>
<p>Also accepts a square matrix with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algprimesubalg">
<tt class="descname">algprimesubalg</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algprimesubalg" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being the output of <tt class="docutils literal"><span class="pre">algtableinit</span></tt> representing a semisimple
algebra of positive characteristic, returns a basis of the prime subalgebra
of&nbsp;<em>al</em>. The prime subalgebra of&nbsp;<em>al</em> is the subalgebra fixed by the
Frobenius automorphism of the center of <em>al</em>. It is abstractly isomorphic
to a product of copies of <span class="math">\(\mathbb{F}_p\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,2);
? algprimesubalg(A)
%3 =
[1 0]

[0 1]

[0 0]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algquotient">
<tt class="descname">algquotient</tt><big>(</big><em>al</em>, <em>I</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algquotient" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being a table algebra output by <tt class="docutils literal"><span class="pre">algtableinit</span></tt> and <em>I</em>
being a basis of a two-sided ideal of <em>al</em> represented by a matrix,
returns the quotient <span class="math">\(al/I\)</span>. When <span class="math">\(flag = 1\)</span>, returns a
<tt class="docutils literal"><span class="pre">t_VEC</span></tt> <span class="math">\([al/I,proj,lift]\)</span> where <em>proj</em> and
<em>lift</em> are matrices respectively representing the projection map and a
section of it.</p>
<div class="highlight-python"><div class="highlight"><pre>? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,2);
? AQ = algquotient(A,[0;1;0]);
? algdim(AQ)
%4 = 2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algradical">
<tt class="descname">algradical</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algradical" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being a table algebra output by <tt class="docutils literal"><span class="pre">algtableinit</span></tt>, returns a
basis of the Jacobson radical of the algebra <em>al</em> over its prime field
(<span class="math">\(\mathbb{Q}\)</span> or <span class="math">\(\mathbb{F}_p\)</span>).</p>
<p>Here is an example with <span class="math">\(A = \mathbb{Q}[x]/(x^2)\)</span>, generated by <span class="math">\((1,x)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>? mt = [matid(2),[0,0;1,0]];
? A = algtableinit(mt);
? algradical(A) \\ = (x)
%3 =
[0]

[1]
</pre></div>
</div>
<p>Another one with <span class="math">\(2 x 2\)</span> upper triangular matrices over <span class="math">\(\mathbb{Q}\)</span>, generated
by <span class="math">\(I_2\)</span>, <span class="math">\(a = [0,1;0,0]\)</span> and <span class="math">\(b = [0,0;0,1]\)</span>, such that <span class="math">\(a^2 = 
0\)</span>, <span class="math">\(ab = a\)</span>, <span class="math">\(ba = 0\)</span>, <span class="math">\(b^2 = b\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
? A = algtableinit(mt);
? algradical(A) \\ = (a)
%6 =
[0]

[1]

[0]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algramifiedplaces">
<tt class="descname">algramifiedplaces</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algramifiedplaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, return a
<tt class="docutils literal"><span class="pre">t_VEC</span></tt> containing the list of places of the center of <em>al</em> that are
ramified in <em>al</em>. Each place is described as an integer between&nbsp;<span class="math">\(1\)</span>
and&nbsp;<span class="math">\(r_1\)</span> or as a prime ideal.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? algramifiedplaces(A)
%3 = [1, [2, [2, 0]~, 1, 2, 1]]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algrandom">
<tt class="descname">algrandom</tt><big>(</big><em>al</em>, <em>b</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algrandom" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an algebra <em>al</em> and an integer <em>b</em>, returns a random
element in <em>al</em> with coefficients in&nbsp;<span class="math">\([-b,b]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algrelmultable">
<tt class="descname">algrelmultable</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algrelmultable" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt> defined by a multiplication table over its center (a number field), returns this multiplication table.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^3-5); a = y; b = y^2;
? {m_i = [0,a,0,0;
 1,0,0,0;
 0,0,0,a;
 0,0,1,0];}
? {m_j = [0, 0,b, 0;
 0, 0,0,-b;
 1, 0,0, 0;
 0,-1,0, 0];}
? {m_k = [0, 0,0,-a*b;
 0, 0,b, 0;
 0,-a,0, 0;
 1, 0,0, 0];}
? mt = [matid(4), m_i, m_j, m_k];
? A = alginit(nf,mt,&#39;x);
? M = algrelmultable(A);
? M[2] == m_i
%8 = 1
? M[3] == m_j
%9 = 1
? M[4] == m_k
%10 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algsimpledec">
<tt class="descname">algsimpledec</tt><big>(</big><em>al</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algsimpledec" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being the output of <tt class="docutils literal"><span class="pre">algtableinit</span></tt> representing a semisimple
algebra, returns a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> <span class="math">\([al_1,al_2,...,al_n]\)</span> such
that&nbsp;<em>al</em> is isomorphic to the direct sum of the simple algebras
<span class="math">\(al_i\)</span>. When <span class="math">\(flag = 1\)</span>, each component is instead a <tt class="docutils literal"><span class="pre">t_VEC</span></tt>
<span class="math">\([al_i,proj_i,lift_i]\)</span> where <span class="math">\(proj_i\)</span>
and&nbsp;<span class="math">\(lift_i\)</span> are matrices respectively representing the projection map
on the <span class="math">\(i\)</span>-th factor and a section of it.</p>
<p><strong>Warning.</strong> The images of the <span class="math">\(lift_i\)</span> are not guaranteed to form a direct sum.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algsplittingdata">
<tt class="descname">algsplittingdata</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algsplittingdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt> defined
by a multiplication table over its center&nbsp;<span class="math">\(K\)</span> (a number field), returns data
stored to compute a splitting of <em>al</em> over an extension. This data is a
<tt class="docutils literal"><span class="pre">t_VEC</span></tt> <tt class="docutils literal"><span class="pre">[t,Lbas,Lbasinv]</span></tt> with <span class="math">\(3\)</span> components:</p>
<ul class="simple">
<li>an element <span class="math">\(t\)</span> of <em>al</em> such that <span class="math">\(L = K(t)\)</span> is a maximal subfield
of <em>al</em>;</li>
<li>a matrix <tt class="docutils literal"><span class="pre">Lbas</span></tt> expressing a <span class="math">\(L\)</span>-basis of <em>al</em> (given an
<span class="math">\(L\)</span>-vector space structure by multiplication on the right) on the integral
basis of <em>al</em>;</li>
<li>a matrix <tt class="docutils literal"><span class="pre">Lbasinv</span></tt> expressing the integral basis of <em>al</em> on
the previous <span class="math">\(L\)</span>-basis.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^3-5); a = y; b = y^2;
? {m_i = [0,a,0,0;
 1,0,0,0;
 0,0,0,a;
 0,0,1,0];}
? {m_j = [0, 0,b, 0;
 0, 0,0,-b;
 1, 0,0, 0;
 0,-1,0, 0];}
? {m_k = [0, 0,0,-a*b;
 0, 0,b, 0;
 0,-a,0, 0;
 1, 0,0, 0];}
? mt = [matid(4), m_i, m_j, m_k];
? A = alginit(nf,mt,&#39;x);
? [t,Lb,Lbi] = algsplittingdata(A);
? t
%8 = [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]~;
? matsize(Lb)
%9 = [12, 2]
? matsize(Lbi)
%10 = [2, 12]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algsplittingfield">
<tt class="descname">algsplittingfield</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algsplittingfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt>, returns
an <em>rnf</em> structure: the splitting field of <em>al</em> that is stored in
<em>al</em>, as a relative extension of the center.</p>
<div class="highlight-python"><div class="highlight"><pre>nf = nfinit(y^3-5);
a = y; b = y^2;
{m_i = [0,a,0,0;
 1,0,0,0;
 0,0,0,a;
 0,0,1,0];}
{m_j = [0, 0,b, 0;
 0, 0,0,-b;
 1, 0,0, 0;
 0,-1,0, 0];}
{m_k = [0, 0,0,-a*b;
 0, 0,b, 0;
 0,-a,0, 0;
 1, 0,0, 0];}
mt = [matid(4), m_i, m_j, m_k];
A = alginit(nf,mt,&#39;x);
algsplittingfield(A).pol
%8 = x^2 - y
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algsplittingmatrix">
<tt class="descname">algsplittingmatrix</tt><big>(</big><em>al</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algsplittingmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>A central simple algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt> contains data
describing an isomorphism&nbsp;<span class="math">\(\phi : A\\otimes_K L \\to M_d(L)\)</span>, where <span class="math">\(d\)</span> is the
degree of the algebra and <span class="math">\(L\)</span> is an extension of <span class="math">\(L\)</span> with&nbsp;<span class="math">\([L:K] = d\)</span>. Returns
the matrix <span class="math">\(\phi(x)\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? A = alginit(nfinit(y), [-1,-1]);
? algsplittingmatrix(A,[0,0,0,2]~)
%2 =
[Mod(x + 1, x^2 + 1) Mod(Mod(1, y)*x + Mod(-1, y), x^2 + 1)]

[Mod(x + 1, x^2 + 1) Mod(-x + 1, x^2 + 1)]
</pre></div>
</div>
<p>Also accepts matrices with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algsqr">
<tt class="descname">algsqr</tt><big>(</big><em>al</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algsqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(x\)</span> in <em>al</em>, computes its square <span class="math">\(x^2\)</span> in the
algebra <em>al</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? A = alginit(nfinit(y), [-1,-1]);
? algsqr(A,[1,0,2,0]~)
%2 = [-3, 0, 4, 0]~
</pre></div>
</div>
<p>Also accepts a square matrix with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algsub">
<tt class="descname">algsub</tt><big>(</big><em>al</em>, <em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algsub" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in <em>al</em>, computes their difference
<span class="math">\(x-y\)</span> in the algebra <em>al</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? A = alginit(nfinit(y), [-1,-1]);
? algsub(A,[1,1,0,0]~,[1,0,1,0]~)
%2 = [0, 1, -1, 0]~
</pre></div>
</div>
<p>Also accepts matrices with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algsubalg">
<tt class="descname">algsubalg</tt><big>(</big><em>al</em>, <em>B</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algsubalg" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being a table algebra output by <tt class="docutils literal"><span class="pre">algtableinit</span></tt> and <em>B</em>
being a basis of a subalgebra of <em>al</em> represented by a matrix, returns an
algebra isomorphic to <em>B</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,2);
? B = algsubalg(A,[1,0; 0,0; 0,1]);
? algdim(A)
%4 = 3
? algdim(B)
%5 = 2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algtableinit">
<tt class="descname">algtableinit</tt><big>(</big><em>mt</em>, <em>p=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algtableinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the associative algebra over <span class="math">\(K = \mathbb{Q}\)</span> (p omitted) or <span class="math">\(\mathbb{F}_p\)</span>
defined by the multiplication table <em>mt</em>.
As a <span class="math">\(K\)</span>-vector space, the algebra is generated by a basis
<span class="math">\((e_1 = 1, e_2,..., e_n)\)</span>; the table is given as a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> of <span class="math">\(n\)</span> matrices in
<span class="math">\(M_n(K)\)</span>, giving the left multiplication by the basis elements <span class="math">\(e_i\)</span>, in the
given basis.
Assumes that <span class="math">\(e_1 = 1\)</span>, that <span class="math">\(K e_1\oplus...\oplus K e_n]\)</span> describes an
associative algebra over <span class="math">\(K\)</span>, and in the case <span class="math">\(K = \mathbb{Q}\)</span> that the multiplication
table is integral. If the algebra is already known to be central
and simple, then the case <span class="math">\(K = \mathbb{F}_p\)</span> is useless, and one should use
<tt class="docutils literal"><span class="pre">alginit</span></tt> directly.</p>
<p>The point of this function is to input a finite dimensional <span class="math">\(K\)</span>-algebra, so
as to later compute its radical, then to split the quotient algebra as a
product of simple algebras over <span class="math">\(K\)</span>.</p>
<p>The pari object representing such an algebra <span class="math">\(A\)</span> is a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> with the
following data:</p>
<ul class="simple">
<li>The characteristic of <span class="math">\(A\)</span>, accessed with <tt class="docutils literal"><span class="pre">algchar</span></tt>.</li>
<li>The multiplication table of <span class="math">\(A\)</span>, accessed with <tt class="docutils literal"><span class="pre">algmultable</span></tt>.</li>
<li>The traces of the elements of the basis.</li>
</ul>
<p>A simple example: the <span class="math">\(2 x 2\)</span> upper triangular matrices over <span class="math">\(\mathbb{Q}\)</span>,
generated by <span class="math">\(I_2\)</span>, <span class="math">\(a = [0,1;0,0]\)</span> and <span class="math">\(b = [0,0;0,1]\)</span>,
such that <span class="math">\(a^2 = 0\)</span>, <span class="math">\(ab = a\)</span>, <span class="math">\(ba = 0\)</span>, <span class="math">\(b^2 = b\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
? A = algtableinit(mt);
? algradical(A) \\ = (a)
%6 =
[0]

[1]

[0]
? algcenter(A) \\ = (I_2)
%7 =
[1]

[0]

[0]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algtensor">
<tt class="descname">algtensor</tt><big>(</big><em>al1</em>, <em>al2</em>, <em>maxord=1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algtensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two algebras <em>al1</em> and <em>al2</em>, computes their tensor
product. For table algebras output by <tt class="docutils literal"><span class="pre">algtableinit</span></tt>, the flag
<em>maxord</em> is ignored. For central simple algebras output by <tt class="docutils literal"><span class="pre">alginit</span></tt>,
computes a maximal order by default. Prevent this computation by setting
<span class="math">\(maxord = 0\)</span>.</p>
<p>Currently only implemented for cyclic algebras of coprime degree over the same
center&nbsp;<span class="math">\(K\)</span>, and the tensor product is over&nbsp;<span class="math">\(K\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algtrace">
<tt class="descname">algtrace</tt><big>(</big><em>al</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <em>x</em> in <em>al</em>, computes its trace. If <em>al</em> is
a table algebra output by <tt class="docutils literal"><span class="pre">algtableinit</span></tt>, returns the absolute trace of
<em>x</em>, which is an element of <span class="math">\(\mathbb{F}_p\)</span> or&nbsp;<span class="math">\(\mathbb{Q}\)</span>; if <em>al</em> is the output of
<tt class="docutils literal"><span class="pre">alginit</span></tt>, returns the reduced trace of <em>x</em>, which is an element of
the center of <em>al</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? A = alginit(nfinit(y), [-1,-1]);
? algtrace(A,[5,0,0,1]~)
%2 = 11
</pre></div>
</div>
<p>Also accepts a square matrix with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algtype">
<tt class="descname">algtype</tt><big>(</big><em>al</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an algebra <em>al</em> output by <tt class="docutils literal"><span class="pre">alginit</span></tt> or by <tt class="docutils literal"><span class="pre">algtableinit</span></tt>, returns an integer indicating the type of algebra:</p>
<ul class="simple">
<li><span class="math">\(0\)</span>: not a valid algebra.</li>
<li><span class="math">\(1\)</span>: table algebra output by <tt class="docutils literal"><span class="pre">algtableinit</span></tt>.</li>
<li><span class="math">\(2\)</span>: central simple algebra output by <tt class="docutils literal"><span class="pre">alginit</span></tt> and represented by
a multiplication table over its center.</li>
<li><span class="math">\(3\)</span>: central simple algebra output by <tt class="docutils literal"><span class="pre">alginit</span></tt> and represented by
a cyclic algebra.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? algtype([])
%1 = 0
? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,2);
? algtype(A)
%4 = 1
? nf = nfinit(y^3-5);
? a = y; b = y^2;
? {m_i = [0,a,0,0;
 1,0,0,0;
 0,0,0,a;
 0,0,1,0];}
? {m_j = [0, 0,b, 0;
 0, 0,0,-b;
 1, 0,0, 0;
 0,-1,0, 0];}
? {m_k = [0, 0,0,-a*b;
 0, 0,b, 0;
 0,-a,0, 0;
 1, 0,0, 0];}
? mt = [matid(4), m_i, m_j, m_k];
? A = alginit(nf,mt,&#39;x);
? algtype(A)
%12 = 2
? A = alginit(nfinit(y), [-1,-1]);
? algtype(A)
%14 = 3
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.allocatemem">
<tt class="descname">allocatemem</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.allocatemem" title="Permalink to this definition">¶</a></dt>
<dd><p>This special operation changes the stack size <em>after</em>
initialization. <span class="math">\(x\)</span> must be a non-negative integer. If <span class="math">\(x &gt; 0\)</span>, a new stack
of at least <span class="math">\(x\)</span> bytes is allocated. We may allocate more than <span class="math">\(x\)</span> bytes if
<span class="math">\(x\)</span> is way too small, or for alignment reasons: the current formula is
<span class="math">\(\\max(16*ceil{x/16}, 500032)\)</span> bytes.</p>
<p>If <span class="math">\(x = 0\)</span>, the size of the new stack is twice the size of the old one.</p>
<p>This command is much more useful if <tt class="docutils literal"><span class="pre">parisizemax</span></tt> is non-zero, and we
describe this case first. With <tt class="docutils literal"><span class="pre">parisizemax</span></tt> enabled, there are three
sizes of interest:</p>
<ul class="simple">
<li>a virtual stack size, <tt class="docutils literal"><span class="pre">parisizemax</span></tt>, which is an absolute upper
limit for the stack size; this is set by <tt class="docutils literal"><span class="pre">default(parisizemax,</span> <span class="pre">...)</span></tt>.</li>
<li>the desired typical stack size, <tt class="docutils literal"><span class="pre">parisize</span></tt>, that will grow as
needed, up to <tt class="docutils literal"><span class="pre">parisizemax</span></tt>; this is set by <tt class="docutils literal"><span class="pre">default(parisize,</span> <span class="pre">...)</span></tt>.</li>
<li>the current stack size, which is less that <tt class="docutils literal"><span class="pre">parisizemax</span></tt>,
typically equal to <tt class="docutils literal"><span class="pre">parisize</span></tt> but possibly larger and increasing
dynamically as needed; <tt class="docutils literal"><span class="pre">allocatemem</span></tt> allows to change that one
explicitly.</li>
</ul>
<p>The <tt class="docutils literal"><span class="pre">allocatemem</span></tt> command forces stack
usage to increase temporarily (up to <tt class="docutils literal"><span class="pre">parisizemax</span></tt> of course); for
instance if you notice using <tt class="docutils literal"><span class="pre">\gm2</span></tt> that we seem to collect garbage a
lot, e.g.</p>
<div class="highlight-python"><div class="highlight"><pre>? \gm2
 debugmem = 2
? default(parisize,&quot;32M&quot;)
 *** Warning: new stack size = 32000000 (30.518 Mbytes).
? bnfinit(&#39;x^2+10^30-1)
 *** bnfinit: collecting garbage in hnffinal, i = 1.
 *** bnfinit: collecting garbage in hnffinal, i = 2.
 *** bnfinit: collecting garbage in hnffinal, i = 3.
</pre></div>
</div>
<p>and so on for hundred of lines. Then, provided the
<tt class="docutils literal"><span class="pre">breakloop</span></tt> default is set, you can interrupt the computation, type
<tt class="docutils literal"><span class="pre">allocatemem(100*10^6)</span></tt> at the break loop prompt, then let the
computation go on by typing :literal:` &lt; Enter &gt; <span class="math">\(. Back at the :literal:`gp\)</span> prompt,
the desired stack size of <tt class="docutils literal"><span class="pre">parisize</span></tt> is restored. Note that changing either
<tt class="docutils literal"><span class="pre">parisize</span></tt> or <tt class="docutils literal"><span class="pre">parisizemax</span></tt> at the break loop prompt would interrupt
the computation, contrary to the above.</p>
<p>In most cases, <tt class="docutils literal"><span class="pre">parisize</span></tt> will increase automatically (up to
<tt class="docutils literal"><span class="pre">parisizemax</span></tt>) and there is no need to perform the above maneuvers.
But that the garbage collector is sufficiently efficient that
a given computation can still run without increasing the stack size,
albeit very slowly due to the frequent garbage collections.</p>
<p><strong>Deprecated: when :literal:`parisizemax.</strong> is unset`
This is currently still the default behavior in order not to break backward
compatibility. The rest of this section documents the
behavior of <tt class="docutils literal"><span class="pre">allocatemem</span></tt> in that (deprecated) situation: it becomes a
synonym for <tt class="docutils literal"><span class="pre">default(parisize,...)</span></tt>. In that case, there is no
notion of a virtual stack, and the stack size is always equal to
<tt class="docutils literal"><span class="pre">parisize</span></tt>. If more memory is needed, the PARI stack overflows, aborting
the computation.</p>
<p>Thus, increasing <tt class="docutils literal"><span class="pre">parisize</span></tt> via <tt class="docutils literal"><span class="pre">allocatemem</span></tt> or
<tt class="docutils literal"><span class="pre">default(parisize,...)</span></tt> before a big computation is important.
Unfortunately, either must be typed at the <tt class="docutils literal"><span class="pre">gp</span></tt> prompt in
interactive usage, or left by itself at the start of batch files.
They cannot be used meaningfully in loop-like constructs, or as part of a
larger expression sequence, e.g</p>
<div class="highlight-python"><div class="highlight"><pre>allocatemem(); x = 1; \\ This will not set x!
</pre></div>
</div>
<p>In fact, all loops are immediately exited, user functions terminated, and
the rest of the sequence following <tt class="docutils literal"><span class="pre">allocatemem()</span></tt> is silently
discarded, as well as all pending sequences of instructions. We just go on
reading the next instruction sequence from the file we are in (or from the
user). In particular, we have the following possibly unexpected behavior: in</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">read</span><span class="p">(</span><span class="s">&quot;file.gp&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>were <tt class="docutils literal"><span class="pre">file.gp</span></tt> contains an <tt class="docutils literal"><span class="pre">allocatemem</span></tt> statement,
the <tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span></tt> is never executed, since all pending instructions in the
current sequence are discarded.</p>
<p>The reason for these unfortunate side-effects is that, with
<tt class="docutils literal"><span class="pre">parisizemax</span></tt> disabled, increasing the stack size physically
moves the stack, so temporary objects created during the current expression
evaluation are not correct anymore. (In particular byte-compiled expressions,
which are allocated on the stack.) To avoid accessing obsolete pointers to
the old stack, this routine ends by a <tt class="docutils literal"><span class="pre">longjmp</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.apply">
<tt class="descname">apply</tt><big>(</big><em>f</em>, <em>A</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the <tt class="docutils literal"><span class="pre">t_CLOSURE</span></tt> <tt class="docutils literal"><span class="pre">f</span></tt> to the entries of <tt class="docutils literal"><span class="pre">A</span></tt>. If <tt class="docutils literal"><span class="pre">A</span></tt>
is a scalar, return <tt class="docutils literal"><span class="pre">f(A)</span></tt>. If <tt class="docutils literal"><span class="pre">A</span></tt> is a polynomial or power series,
apply <tt class="docutils literal"><span class="pre">f</span></tt> on all coefficients. If <tt class="docutils literal"><span class="pre">A</span></tt> is a vector or list, return
the elements <span class="math">\(f(x)\)</span> where <span class="math">\(x\)</span> runs through <tt class="docutils literal"><span class="pre">A</span></tt>. If <tt class="docutils literal"><span class="pre">A</span></tt> is a matrix,
return the matrix whose entries are the <span class="math">\(f(A[i,j])\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? apply(x-&gt;x^2, [1,2,3,4])
%1 = [1, 4, 9, 16]
? apply(x-&gt;x^2, [1,2;3,4])
%2 =
[1 4]

[9 16]
? apply(x-&gt;x^2, 4*x^2 + 3*x+ 2)
%3 = 16*x^2 + 9*x + 4
</pre></div>
</div>
<p>Note that many functions already act componentwise on
vectors or matrices, but they almost never act on lists; in this
case, <tt class="docutils literal"><span class="pre">apply</span></tt> is a good solution:</p>
<div class="highlight-python"><div class="highlight"><pre>? L = List([Mod(1,3), Mod(2,4)]);
? lift(L)
 *** at top-level: lift(L)
 *** ^-------
 *** lift: incorrect type in lift.
? apply(lift, L);
%2 = List([1, 2])
</pre></div>
</div>
<p><strong>Remark.</strong> For <span class="math">\(v\)</span> a <tt class="docutils literal"><span class="pre">t_VEC</span></tt>, <tt class="docutils literal"><span class="pre">t_COL</span></tt>, <tt class="docutils literal"><span class="pre">t_LIST</span></tt> or <tt class="docutils literal"><span class="pre">t_MAT</span></tt>,
the alternative set-notations</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="p">[</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">]</span>
</pre></div>
</div>
<p>are available as shortcuts for</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">apply</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">select</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Vec</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
<span class="n">select</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Vec</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="nb">apply</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">Vec</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
</pre></div>
</div>
<p>respectively:</p>
<div class="highlight-python"><div class="highlight"><pre>? L = List([Mod(1,3), Mod(2,4)]);
? [ lift(x) | x&lt;-L ]
%2 = [1, 2]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.arg">
<tt class="descname">arg</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.arg" title="Permalink to this definition">¶</a></dt>
<dd><p>Argument of the complex number <span class="math">\(x\)</span>, such that <span class="math">\(-\Pi &lt; {arg}(x) &lt;= \Pi\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.asin">
<tt class="descname">asin</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.asin" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of <span class="math">\({sin}^{-1}(x) = -i \log(ix + \sqrt{1 - x^2})\)</span>.
In particular, <span class="math">\({Re(asin}(x)) belongs to [-\Pi/2,\Pi/2]\)</span> and if <span class="math">\(x belongs to \mathbb{R}\)</span> and
<span class="math">\(\|x\| &gt; 1\)</span> then <span class="math">\({asin}(x)\)</span> is complex. The branch cut is in two pieces:
<span class="math">\(]- oo ,-1]\)</span>, continuous with quadrant II, and <span class="math">\([1,+ oo [\)</span> continuous
with quadrant IV. The function satisfies <span class="math">\(i {asin}(x) = 
{asinh}(ix)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.asinh">
<tt class="descname">asinh</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.asinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of <span class="math">\({sinh}^{-1}(x) = \log(x + \sqrt{1+x^2})\)</span>. In
particular <span class="math">\({Im(asinh}(x)) belongs to [-\Pi/2,\Pi/2]\)</span>.
The branch cut is in two pieces: [-i oo ,-i], continuous with quadrant III
and [i,+i oo [ continuous with quadrant I.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.atan">
<tt class="descname">atan</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.atan" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of <span class="math">\({tan}^{-1}(x) = \log ((1+ix)/(1-ix)) /
2i\)</span>. In particular the real part of <span class="math">\({atan}(x))\)</span> belongs to
<span class="math">\(]-\Pi/2,\Pi/2[\)</span>.
The branch cut is in two pieces:
<span class="math">\(]-i oo ,-i[\)</span>, continuous with quadrant IV, and <span class="math">\(]i,+i oo [\)</span> continuous
with quadrant II. The function satisfies <span class="math">\(i {atan}(x) = 
-i{atanh}(ix)\)</span> for all <span class="math">\(x != ± i\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.atanh">
<tt class="descname">atanh</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.atanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of <span class="math">\({tanh}^{-1}(x) = log ((1+x)/(1-x)) / 2\)</span>. In
particular the imaginary part of <span class="math">\({atanh}(x)\)</span> belongs to
<span class="math">\([-\Pi/2,\Pi/2]\)</span>; if <span class="math">\(x belongs to \mathbb{R}\)</span> and <span class="math">\(\|x\| &gt; 1\)</span> then <span class="math">\({atanh}(x)\)</span> is complex.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.besselh1">
<tt class="descname">besselh1</tt><big>(</big><em>nu</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.besselh1" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(H^1\)</span>-Bessel function of index <em>nu</em> and argument <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.besselh2">
<tt class="descname">besselh2</tt><big>(</big><em>nu</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.besselh2" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(H^2\)</span>-Bessel function of index <em>nu</em> and argument <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.besseli">
<tt class="descname">besseli</tt><big>(</big><em>nu</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.besseli" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(I\)</span>-Bessel function of index <em>nu</em> and
argument <span class="math">\(x\)</span>. If <span class="math">\(x\)</span> converts to a power series, the initial factor
<span class="math">\((x/2)^\nu/\Gamma(\nu+1)\)</span> is omitted (since it cannot be represented in PARI
when <span class="math">\(\nu\)</span> is not integral).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.besselj">
<tt class="descname">besselj</tt><big>(</big><em>nu</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.besselj" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(J\)</span>-Bessel function of index <em>nu</em> and
argument <span class="math">\(x\)</span>. If <span class="math">\(x\)</span> converts to a power series, the initial factor
<span class="math">\((x/2)^\nu/\Gamma(\nu+1)\)</span> is omitted (since it cannot be represented in PARI
when <span class="math">\(\nu\)</span> is not integral).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.besseljh">
<tt class="descname">besseljh</tt><big>(</big><em>n</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.besseljh" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(J\)</span>-Bessel function of half integral index.
More precisely, <span class="math">\(besseljh(n,x)\)</span> computes <span class="math">\(J_{n+1/2}(x)\)</span> where <span class="math">\(n\)</span>
must be of type integer, and <span class="math">\(x\)</span> is any element of <span class="math">\(\mathbb{C}\)</span>. In the
present version <strong>2.8.0</strong>, this function is not very accurate when <span class="math">\(x\)</span> is small.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.besselk">
<tt class="descname">besselk</tt><big>(</big><em>nu</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.besselk" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(K\)</span>-Bessel function of index <em>nu</em> and argument <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.besseln">
<tt class="descname">besseln</tt><big>(</big><em>nu</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.besseln" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(N\)</span>-Bessel function of index <em>nu</em> and argument <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bestappr">
<tt class="descname">bestappr</tt><big>(</big><em>x</em>, <em>B=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bestappr" title="Permalink to this definition">¶</a></dt>
<dd><p>Using variants of the extended Euclidean algorithm, returns a rational
approximation <span class="math">\(a/b\)</span> to <span class="math">\(x\)</span>, whose denominator is limited
by <span class="math">\(B\)</span>, if present. If <span class="math">\(B\)</span> is omitted, return the best approximation
affordable given the input accuracy; if you are looking for true rational
numbers, presumably approximated to sufficient accuracy, you should first
try that option. Otherwise, <span class="math">\(B\)</span> must be a positive real scalar (impose
<span class="math">\(0 &lt; b &lt;= B\)</span>).</p>
<ul class="simple">
<li>If <span class="math">\(x\)</span> is a <tt class="docutils literal"><span class="pre">t_REAL</span></tt> or a <tt class="docutils literal"><span class="pre">t_FRAC</span></tt>, this function uses continued
fractions.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? bestappr(Pi, 100)
%1 = 22/7
? bestappr(0.1428571428571428571428571429)
%2 = 1/7
? bestappr([Pi, sqrt(2) + &#39;x], 10^3)
%3 = [355/113, x + 1393/985]
</pre></div>
</div>
<p>By definition, <span class="math">\(a/b\)</span> is the best rational approximation to <span class="math">\(x\)</span> if
<span class="math">\(\|b x - a\| &lt; \|v x - u\|\)</span> for all integers <span class="math">\((u,v)\)</span> with <span class="math">\(0 &lt; v &lt;= B\)</span>.
(Which implies that <span class="math">\(n/d\)</span> is a convergent of the continued fraction of <span class="math">\(x\)</span>.)</p>
<ul class="simple">
<li>If <span class="math">\(x\)</span> is a <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt> modulo <span class="math">\(N\)</span> or a <tt class="docutils literal"><span class="pre">t_PADIC</span></tt> of precision <span class="math">\(N = 
p^k\)</span>, this function performs rational modular reconstruction modulo <span class="math">\(N\)</span>. The
routine then returns the unique rational number <span class="math">\(a/b\)</span> in coprime integers
<span class="math">\(|a| &lt; N/2B\)</span> and <span class="math">\(b &lt;= B\)</span> which is congruent to <span class="math">\(x\)</span> modulo <span class="math">\(N\)</span>. Omitting
<span class="math">\(B\)</span> amounts to choosing it of the order of <span class="math">\(\sqrt{N/2}\)</span>. If rational
reconstruction is not possible (no suitable <span class="math">\(a/b\)</span> exists), returns <span class="math">\([]\)</span>.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? bestappr(Mod(18526731858, 11^10))
%1 = 1/7
? bestappr(Mod(18526731858, 11^20))
%2 = []
? bestappr(3 + 5 + 3*5^2 + 5^3 + 3*5^4 + 5^5 + 3*5^6 + O(5^7))
%2 = -1/3
</pre></div>
</div>
<p>In most concrete uses, <span class="math">\(B\)</span> is a prime power and we performed
Hensel lifting to obtain <span class="math">\(x\)</span>.</p>
<p>The function applies recursively to components of complex objects
(polynomials, vectors,...). If rational reconstruction fails for even a
single entry, return <span class="math">\([]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bestapprPade">
<tt class="descname">bestapprPade</tt><big>(</big><em>x</em>, <em>B=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bestapprPade" title="Permalink to this definition">¶</a></dt>
<dd><p>Using variants of the extended Euclidean algorithm, returns a rational
function approximation <span class="math">\(a/b\)</span> to <span class="math">\(x\)</span>, whose denominator is limited
by <span class="math">\(B\)</span>, if present. If <span class="math">\(B\)</span> is omitted, return the best approximation
affordable given the input accuracy; if you are looking for true rational
functions, presumably approximated to sufficient accuracy, you should first
try that option. Otherwise, <span class="math">\(B\)</span> must be a non-negative real (impose
<span class="math">\(0 &lt;= {degree}(b) &lt;= B\)</span>).</p>
<ul class="simple">
<li>If <span class="math">\(x\)</span> is a <tt class="docutils literal"><span class="pre">t_RFRAC</span></tt> or <tt class="docutils literal"><span class="pre">t_SER</span></tt>, this function uses continued
fractions.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? bestapprPade((1-x^11)/(1-x)+O(x^11))
%1 = 1/(-x + 1)
? bestapprPade([1/(1+x+O(x^10)), (x^3-2)/(x^3+1)], 1)
%2 = [1/(x + 1), -2]
</pre></div>
</div>
<ul class="simple">
<li>If <span class="math">\(x\)</span> is a <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> modulo <span class="math">\(N\)</span> or a <tt class="docutils literal"><span class="pre">t_SER</span></tt> of precision <span class="math">\(N = 
t^k\)</span>, this function performs rational modular reconstruction modulo <span class="math">\(N\)</span>. The
routine then returns the unique rational function <span class="math">\(a/b\)</span> in coprime
polynomials, with <span class="math">\({degree}(b) &lt;= B\)</span> which is congruent to <span class="math">\(x\)</span> modulo
<span class="math">\(N\)</span>. Omitting <span class="math">\(B\)</span> amounts to choosing it of the order of <span class="math">\(N/2\)</span>. If rational
reconstruction is not possible (no suitable <span class="math">\(a/b\)</span> exists), returns <span class="math">\([]\)</span>.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? bestapprPade(Mod(1+x+x^2+x^3+x^4, x^4-2))
%1 = (2*x - 1)/(x - 1)
? % * Mod(1,x^4-2)
%2 = Mod(x^3 + x^2 + x + 3, x^4 - 2)
? bestapprPade(Mod(1+x+x^2+x^3+x^5, x^9))
%2 = []
? bestapprPade(Mod(1+x+x^2+x^3+x^5, x^10))
%3 = (2*x^4 + x^3 - x - 1)/(-x^5 + x^3 + x^2 - 1)
</pre></div>
</div>
<p>The function applies recursively to components of complex objects
(polynomials, vectors,...). If rational reconstruction fails for even a
single entry, return <span class="math">\([]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bezout">
<tt class="descname">bezout</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bezout" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated alias for <tt class="docutils literal"><span class="pre">gcdext</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bezoutres">
<tt class="descname">bezoutres</tt><big>(</big><em>A</em>, <em>B</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bezoutres" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated alias for <tt class="docutils literal"><span class="pre">polresultantext</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bigomega">
<tt class="descname">bigomega</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bigomega" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of prime divisors of the integer <span class="math">\(\|x\|\)</span> counted with
multiplicity:</p>
<div class="highlight-python"><div class="highlight"><pre>? factor(392)
%1 =
[2 3]

[7 2]

? bigomega(392)
%2 = 5; \\ = 3+2
? omega(392)
%3 = 2; \\ without multiplicity
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.binary">
<tt class="descname">binary</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the vector of the binary digits of <span class="math">\(\|x\|\)</span>.
Here <span class="math">\(x\)</span> can be an integer, a real number (in which case the result has two
components, one for the integer part, one for the fractional part) or a
vector/matrix.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.binomial">
<tt class="descname">binomial</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.binomial" title="Permalink to this definition">¶</a></dt>
<dd><p>binomial coefficient <span class="math">\(binom{x}{y}\)</span>.
Here <span class="math">\(y\)</span> must be an integer, but <span class="math">\(x\)</span> can be any PARI object.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bitand">
<tt class="descname">bitand</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bitand" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise <tt class="docutils literal"><span class="pre">and</span></tt>
of two integers <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, that is the integer</p>
<div class="math">
\[\begin{split}\sum_i (x_i&nbsp;and&nbsp;y_i) 2^i\end{split}\]</div>
<p>Negative numbers behave <span class="math">\(2\)</span>-adically, i.e.&nbsp;the result is the <span class="math">\(2\)</span>-adic limit
of <tt class="docutils literal"><span class="pre">bitand</span></tt><span class="math">\((x_n,y_n)\)</span>, where <span class="math">\(x_n\)</span> and <span class="math">\(y_n\)</span> are non-negative integers
tending to <span class="math">\(x\)</span> and <span class="math">\(y\)</span> respectively. (The result is an ordinary integer,
possibly negative.)</p>
<div class="highlight-python"><div class="highlight"><pre>? bitand(5, 3)
%1 = 1
? bitand(-5, 3)
%2 = 3
? bitand(-5, -3)
%3 = -7
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bitneg">
<tt class="descname">bitneg</tt><big>(</big><em>x</em>, <em>n=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bitneg" title="Permalink to this definition">¶</a></dt>
<dd><p>bitwise negation of an integer <span class="math">\(x\)</span>,
truncated to <span class="math">\(n\)</span> bits, <span class="math">\(n &gt;= 0\)</span>, that is the integer</p>
<div class="math">
\[\sum_{i = 0}^{n-1} not(x_i) 2^i.\]</div>
<p>The special case <span class="math">\(n = -1\)</span> means no truncation: an infinite sequence of
leading <span class="math">\(1\)</span> is then represented as a negative number.</p>
<p>See <tt class="docutils literal"><span class="pre">bitand</span></tt> (in the PARI manual) for the behavior for negative arguments.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bitnegimply">
<tt class="descname">bitnegimply</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bitnegimply" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise negated imply of two integers <span class="math">\(x\)</span> and
<span class="math">\(y\)</span> (or <tt class="docutils literal"><span class="pre">not</span></tt> <span class="math">\((x ==&gt; y)\)</span>), that is the integer</p>
<div class="math">
\[\begin{split}\sum
(x_i&nbsp;and not(y_i)) 2^i\end{split}\]</div>
<p>See <tt class="docutils literal"><span class="pre">bitand</span></tt> (in the PARI manual) for the behavior for negative arguments.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bitor">
<tt class="descname">bitor</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bitor" title="Permalink to this definition">¶</a></dt>
<dd><p>bitwise (inclusive)
<tt class="docutils literal"><span class="pre">or</span></tt> of two integers <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, that is the integer</p>
<div class="math">
\[\begin{split}\sum
(x_i&nbsp;or&nbsp;y_i) 2^i\end{split}\]</div>
<p>See <tt class="docutils literal"><span class="pre">bitand</span></tt> (in the PARI manual) for the behavior for negative arguments.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bittest">
<tt class="descname">bittest</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bittest" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the <span class="math">\(n-th\)</span> bit of <span class="math">\(x\)</span> starting
from the right (i.e.&nbsp;the coefficient of <span class="math">\(2^n\)</span> in the binary expansion of <span class="math">\(x\)</span>).
The result is 0 or 1.</p>
<div class="highlight-python"><div class="highlight"><pre>? bittest(7, 3)
%1 = 1 \\ the 3rd bit is 1
? bittest(7, 4)
%2 = 0 \\ the 4th bit is 0
</pre></div>
</div>
<p>See <tt class="docutils literal"><span class="pre">bitand</span></tt> (in the PARI manual) for the behavior at negative arguments.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bitxor">
<tt class="descname">bitxor</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bitxor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise (exclusive) <tt class="docutils literal"><span class="pre">or</span></tt>
of two integers <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, that is the integer</p>
<div class="math">
\[\begin{split}\sum (x_i&nbsp;xor&nbsp;y_i) 2^i\end{split}\]</div>
<p>See <tt class="docutils literal"><span class="pre">bitand</span></tt> (in the PARI manual) for the behavior for negative arguments.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfcertify">
<tt class="descname">bnfcertify</tt><big>(</big><em>bnf</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfcertify" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(bnf\)</span> being as output by
<tt class="docutils literal"><span class="pre">bnfinit</span></tt>, checks whether the result is correct, i.e.&nbsp;whether it is
possible to remove the assumption of the Generalized Riemann
Hypothesis. It is correct if and only if the answer is 1. If it is
incorrect, the program may output some error message, or loop indefinitely.
You can check its progress by increasing the debug level. The <em>bnf</em>
structure must contain the fundamental units:</p>
<div class="highlight-python"><div class="highlight"><pre>? K = bnfinit(x^3+2^2^3+1); bnfcertify(K)
 *** at top-level: K=bnfinit(x^3+2^2^3+1);bnfcertify(K)
 *** ^-------------
 *** bnfcertify: missing units in bnf.
? K = bnfinit(x^3+2^2^3+1, 1); \\ include units
? bnfcertify(K)
%3 = 1
</pre></div>
</div>
<p>If flag is present, only certify that the class group is a quotient of the
one computed in bnf (much simpler in general); likewise, the computed units
may form a subgroup of the full unit group. In this variant, the units are
no longer needed:</p>
<div class="highlight-python"><div class="highlight"><pre>? K = bnfinit(x^3+2^2^3+1); bnfcertify(K, 1)
%4 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfcompress">
<tt class="descname">bnfcompress</tt><big>(</big><em>bnf</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfcompress" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a compressed version of <em>bnf</em> (from <tt class="docutils literal"><span class="pre">bnfinit</span></tt>), a
&#8220;small Buchmann&#8217;s number field&#8221; (or <em>sbnf</em> for short) which contains
enough information to recover a full <span class="math">\(bnf\)</span> vector very rapidly, but
which is much smaller and hence easy to store and print. Calling
<tt class="docutils literal"><span class="pre">bnfinit</span></tt> on the result recovers a true <tt class="docutils literal"><span class="pre">bnf</span></tt>, in general different
from the original. Note that an <em>snbf</em> is useless for almost all
purposes besides storage, and must be converted back to <em>bnf</em> form
before use; for instance, no <tt class="docutils literal"><span class="pre">nf*</span></tt>, <tt class="docutils literal"><span class="pre">bnf*</span></tt> or member function
accepts them.</p>
<p>An <em>sbnf</em> is a 12 component vector <span class="math">\(v\)</span>, as follows. Let <tt class="docutils literal"><span class="pre">bnf</span></tt> be
the result of a full <tt class="docutils literal"><span class="pre">bnfinit</span></tt>, complete with units. Then <span class="math">\(v[1]\)</span> is
<tt class="docutils literal"><span class="pre">bnf.pol</span></tt>, <span class="math">\(v[2]\)</span> is the number of real embeddings <tt class="docutils literal"><span class="pre">bnf.sign[1]</span></tt>,
<span class="math">\(v[3]\)</span> is <tt class="docutils literal"><span class="pre">bnf.disc</span></tt>, <span class="math">\(v[4]\)</span> is <tt class="docutils literal"><span class="pre">bnf.zk</span></tt>, <span class="math">\(v[5]\)</span> is the list of roots
<tt class="docutils literal"><span class="pre">bnf.roots</span></tt>, <span class="math">\(v[7]\)</span> is the matrix <span class="math">\(W = bnf[1]\)</span>,
<span class="math">\(v[8]\)</span> is the matrix <span class="math">\(matalpha = bnf[2]\)</span>,
<span class="math">\(v[9]\)</span> is the prime ideal factor base <tt class="docutils literal"><span class="pre">bnf[5]</span></tt> coded in a compact way,
and ordered according to the permutation <tt class="docutils literal"><span class="pre">bnf[6]</span></tt>, <span class="math">\(v[10]\)</span> is the
2-component vector giving the number of roots of unity and a generator,
expressed on the integral basis, <span class="math">\(v[11]\)</span> is the list of fundamental units,
expressed on the integral basis, <span class="math">\(v[12]\)</span> is a vector containing the algebraic
numbers alpha corresponding to the columns of the matrix <tt class="docutils literal"><span class="pre">matalpha</span></tt>,
expressed on the integral basis.</p>
<p>All the components are exact (integral or rational), except for the roots in
<span class="math">\(v[5]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfdecodemodule">
<tt class="descname">bnfdecodemodule</tt><big>(</big><em>nf</em>, <em>m</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfdecodemodule" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(m\)</span> is a module as output in the
first component of an extension given by <tt class="docutils literal"><span class="pre">bnrdisclist</span></tt>, outputs the
true module.</p>
<div class="highlight-python"><div class="highlight"><pre>? K = bnfinit(x^2+23); L = bnrdisclist(K, 10); s = L[1][2]
%1 = [[Mat([8, 1]), [[0, 0, 0]]], [Mat([9, 1]), [[0, 0, 0]]]]
? bnfdecodemodule(K, s[1][1])
%2 =
[2 0]

[0 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfinit">
<tt class="descname">bnfinit</tt><big>(</big><em>P</em>, <em>flag=0</em>, <em>tech=None</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a
<em>bnf</em> structure. Used in programs such as <tt class="docutils literal"><span class="pre">bnfisprincipal</span></tt>,
<tt class="docutils literal"><span class="pre">bnfisunit</span></tt> or <tt class="docutils literal"><span class="pre">bnfnarrow</span></tt>. By default, the results are conditional
on the GRH, see <tt class="docutils literal"><span class="pre">GRHbnf</span></tt> (in the PARI manual). The result is a
10-component vector <em>bnf</em>.</p>
<p>This implements Buchmann&#8217;s sub-exponential algorithm for computing the
class group, the regulator and a system of fundamental units of the
general algebraic number field <span class="math">\(K\)</span> defined by the irreducible polynomial <span class="math">\(P\)</span>
with integer coefficients.</p>
<p>If the precision becomes insufficient, <tt class="docutils literal"><span class="pre">gp</span></tt> does not strive to compute
the units by default (<span class="math">\(flag = 0\)</span>).</p>
<p>When <span class="math">\(flag = 1\)</span>, we insist on finding the fundamental units exactly. Be
warned that this can take a very long time when the coefficients of the
fundamental units on the integral basis are very large. If the fundamental
units are simply too large to be represented in this form, an error message
is issued. They could be obtained using the so-called compact representation
of algebraic numbers as a formal product of algebraic integers. The latter is
implemented internally but not publicly accessible yet.</p>
<p><span class="math">\(tech\)</span> is a technical vector (empty by default, see <tt class="docutils literal"><span class="pre">GRHbnf</span></tt> (in the PARI manual)).
Careful use of this parameter may speed up your computations,
but it is mostly obsolete and you should leave it alone.</p>
<p>The components of a <em>bnf</em> or <em>sbnf</em> are technical and never used by
the casual user. In fact: <em>never access a component directly, always use
a proper member function.</em> However, for the sake of completeness and internal
documentation, their description is as follows. We use the notations
explained in the book by H. Cohen, <em>A Course in Computational Algebraic
Number Theory</em>, Graduate Texts in Maths <strong>138</strong>, Springer-Verlag, 1993,
Section 6.5, and subsection 6.5.5 in particular.</p>
<p><span class="math">\(bnf[1]\)</span> contains the matrix <span class="math">\(W\)</span>, i.e.&nbsp;the matrix in Hermite normal
form giving relations for the class group on prime ideal generators
<span class="math">\((p_i)_{1 &lt;= i &lt;= r}\)</span>.</p>
<p><span class="math">\(bnf[2]\)</span> contains the matrix <span class="math">\(B\)</span>, i.e.&nbsp;the matrix containing the
expressions of the prime ideal factorbase in terms of the <span class="math">\(p_i\)</span>.
It is an <span class="math">\(r x c\)</span> matrix.</p>
<p><span class="math">\(bnf[3]\)</span> contains the complex logarithmic embeddings of the system of
fundamental units which has been found. It is an <span class="math">\((r_1+r_2) x (r_1+r_2-1)\)</span>
matrix.</p>
<p><span class="math">\(bnf[4]\)</span> contains the matrix <span class="math">\(M&quot;_C\)</span> of Archimedean components of the
relations of the matrix <span class="math">\((W\|B)\)</span>.</p>
<p><span class="math">\(bnf[5]\)</span> contains the prime factor base, i.e.&nbsp;the list of prime
ideals used in finding the relations.</p>
<p><span class="math">\(bnf[6]\)</span> used to contain a permutation of the prime factor base, but
has been obsoleted. It contains a dummy <span class="math">\(0\)</span>.</p>
<p><span class="math">\(bnf[7]\)</span> or <tt class="docutils literal"><span class="pre">:emphasis:`bnf</span></tt>.nf` is equal to the number field data
<span class="math">\(nf\)</span> as would be given by <tt class="docutils literal"><span class="pre">nfinit</span></tt>.</p>
<p><span class="math">\(bnf[8]\)</span> is a vector containing the classgroup <tt class="docutils literal"><span class="pre">:emphasis:`bnf</span></tt>.clgp`
as a finite abelian group, the regulator <tt class="docutils literal"><span class="pre">:emphasis:`bnf</span></tt>.reg`, a <span class="math">\(1\)</span> (used to
contain an obsolete &#8220;check number&#8221;), the number of roots of unity and a
generator <tt class="docutils literal"><span class="pre">:emphasis:`bnf</span></tt>.tu`, the fundamental units <tt class="docutils literal"><span class="pre">:emphasis:`bnf</span></tt>.fu`.</p>
<p><span class="math">\(bnf[9]\)</span> is a 3-element row vector used in <tt class="docutils literal"><span class="pre">bnfisprincipal</span></tt> only
and obtained as follows. Let <span class="math">\(D = U W V\)</span> obtained by applying the
Smith normal form algorithm to the matrix <span class="math">\(W\)</span> ( = <span class="math">\(bnf[1]\)</span>) and
let <span class="math">\(U_r\)</span> be the reduction of <span class="math">\(U\)</span> modulo <span class="math">\(D\)</span>. The first elements of the
factorbase are given (in terms of <tt class="docutils literal"><span class="pre">bnf.gen</span></tt>) by the columns of <span class="math">\(U_r\)</span>,
with Archimedean component <span class="math">\(g_a\)</span>; let also <span class="math">\(GD_a\)</span> be the Archimedean
components of the generators of the (principal) ideals defined by the
<tt class="docutils literal"><span class="pre">bnf.gen[i]^bnf.cyc[i]</span></tt>. Then <span class="math">\(bnf[9] = [U_r, g_a, GD_a]\)</span>.</p>
<p><span class="math">\(bnf[10]\)</span> is by default unused and set equal to 0. This field is used
to store further information about the field as it becomes available, which
is rarely needed, hence would be too expensive to compute during the initial
<tt class="docutils literal"><span class="pre">bnfinit</span></tt> call. For instance, the generators of the principal ideals
<tt class="docutils literal"><span class="pre">bnf.gen[i]^bnf.cyc[i]</span></tt> (during a call to <tt class="docutils literal"><span class="pre">bnrisprincipal</span></tt>), or
those corresponding to the relations in <span class="math">\(W\)</span> and <span class="math">\(B\)</span> (when the <tt class="docutils literal"><span class="pre">bnf</span></tt>
internal precision needs to be increased).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfisintnorm">
<tt class="descname">bnfisintnorm</tt><big>(</big><em>bnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfisintnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a complete system of
solutions (modulo units of positive norm) of the absolute norm equation
<span class="math">\(\mathrm{Norm}(a) = x\)</span>,
where <span class="math">\(a\)</span> is an integer in <span class="math">\(bnf\)</span>. If <span class="math">\(bnf\)</span> has not been certified,
the correctness of the result depends on the validity of GRH.</p>
<p>See also <tt class="docutils literal"><span class="pre">bnfisnorm</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfisnorm">
<tt class="descname">bnfisnorm</tt><big>(</big><em>bnf</em>, <em>x</em>, <em>flag=1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfisnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to tell whether the
rational number <span class="math">\(x\)</span> is the norm of some element y in <span class="math">\(bnf\)</span>. Returns a
vector <span class="math">\([a,b]\)</span> where <span class="math">\(x = Norm(a)*b\)</span>. Looks for a solution which is an <span class="math">\(S\)</span>-unit,
with <span class="math">\(S\)</span> a certain set of prime ideals containing (among others) all primes
dividing <span class="math">\(x\)</span>. If <span class="math">\(bnf\)</span> is known to be Galois, set <span class="math">\(flag = 0\)</span> (in
this case, <span class="math">\(x\)</span> is a norm iff <span class="math">\(b = 1\)</span>). If <span class="math">\(flag\)</span> is non zero the program adds to
<span class="math">\(S\)</span> the following prime ideals, depending on the sign of <span class="math">\(flag\)</span>. If <span class="math">\(flag &gt; 0\)</span>,
the ideals of norm less than <span class="math">\(flag\)</span>. And if <span class="math">\(flag &lt; 0\)</span> the ideals dividing <span class="math">\(flag\)</span>.</p>
<p>Assuming GRH, the answer is guaranteed (i.e.&nbsp;<span class="math">\(x\)</span> is a norm iff <span class="math">\(b = 1\)</span>),
if <span class="math">\(S\)</span> contains all primes less than <span class="math">\(12\log(\mathrm{disc}(Bnf))^2\)</span>, where
<span class="math">\(Bnf\)</span> is the Galois closure of <span class="math">\(bnf\)</span>.</p>
<p>See also <tt class="docutils literal"><span class="pre">bnfisintnorm</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfisprincipal">
<tt class="descname">bnfisprincipal</tt><big>(</big><em>bnf</em>, <em>x</em>, <em>flag=1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfisprincipal" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(bnf\)</span> being the 
number field data output by <tt class="docutils literal"><span class="pre">bnfinit</span></tt>, and <span class="math">\(x\)</span> being an ideal, this
function tests whether the ideal is principal or not. The result is more
complete than a simple true/false answer and solves general discrete
logarithm problem. Assume the class group is <span class="math">\(\oplus (\mathbb{Z}/d_i\mathbb{Z})g_i\)</span>
(where the generators <span class="math">\(g_i\)</span> and their orders <span class="math">\(d_i\)</span> are respectively given by
<tt class="docutils literal"><span class="pre">bnf.gen</span></tt> and <tt class="docutils literal"><span class="pre">bnf.cyc</span></tt>). The routine returns a row vector <span class="math">\([e,t]\)</span>,
where <span class="math">\(e\)</span> is a vector of exponents <span class="math">\(0 &lt;= e_i &lt; d_i\)</span>, and <span class="math">\(t\)</span> is a number
field element such that</p>
<div class="math">
\[x = (t) \prod_i g_i^{e_i}.\]</div>
<p>For <em>given</em> <span class="math">\(g_i\)</span> (i.e. for a given <tt class="docutils literal"><span class="pre">bnf</span></tt>), the <span class="math">\(e_i\)</span> are unique,
and <span class="math">\(t\)</span> is unique modulo units.</p>
<p>In particular, <span class="math">\(x\)</span> is principal if and only if <span class="math">\(e\)</span> is the zero vector. Note
that the empty vector, which is returned when the class number is <span class="math">\(1\)</span>, is
considered to be a zero vector (of dimension <span class="math">\(0\)</span>).</p>
<div class="highlight-python"><div class="highlight"><pre>? K = bnfinit(y^2+23);
? K.cyc
%2 = [3]
? K.gen
%3 = [[2, 0; 0, 1]] \\ a prime ideal above 2
? P = idealprimedec(K,3)[1]; \\ a prime ideal above 3
? v = bnfisprincipal(K, P)
%5 = [[2]~, [3/4, 1/4]~]
? idealmul(K, v[2], idealfactorback(K, K.gen, v[1]))
%6 =
[3 0]

[0 1]
? % == idealhnf(K, P)
%7 = 1
</pre></div>
</div>
<p>The binary digits of <em>flag</em> mean:</p>
<ul class="simple">
<li><span class="math">\(1\)</span>: If set, outputs <span class="math">\([e,t]\)</span> as explained above, otherwise returns
only <span class="math">\(e\)</span>, which is much easier to compute. The following idiom only tests
whether an ideal is principal:</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>is_principal(bnf, x) = !bnfisprincipal(bnf,x,0);
</pre></div>
</div>
<ul class="simple">
<li><span class="math">\(2\)</span>: It may not be possible to recover <span class="math">\(t\)</span>, given the initial accuracy
to which <tt class="docutils literal"><span class="pre">bnf</span></tt> was computed. In that case, a warning is printed and <span class="math">\(t\)</span> is
set equal to the empty vector <tt class="docutils literal"><span class="pre">[]~</span></tt>. If this bit is set,
increase the precision and recompute needed quantities until <span class="math">\(t\)</span> can be
computed. Warning: setting this may induce <em>very</em> lengthy computations.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfissunit">
<tt class="descname">bnfissunit</tt><big>(</big><em>bnf</em>, <em>sfu</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfissunit" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(bnf\)</span> being output by
<tt class="docutils literal"><span class="pre">bnfinit</span></tt>, <em>sfu</em> by <tt class="docutils literal"><span class="pre">bnfsunit</span></tt>, gives the column vector of
exponents of <span class="math">\(x\)</span> on the fundamental <span class="math">\(S\)</span>-units and the roots of unity.
If <span class="math">\(x\)</span> is not a unit, outputs an empty vector.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfisunit">
<tt class="descname">bnfisunit</tt><big>(</big><em>bnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfisunit" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bnf</em> being the number field data
output by <tt class="docutils literal"><span class="pre">bnfinit</span></tt> and <span class="math">\(x\)</span> being an algebraic number (type integer,
rational or polmod), this outputs the decomposition of <span class="math">\(x\)</span> on the fundamental
units and the roots of unity if <span class="math">\(x\)</span> is a unit, the empty vector otherwise.
More precisely, if <span class="math">\(u_1\)</span>,...,:math:<span class="math">\(u_r\)</span> are the fundamental units, and <span class="math">\(\zeta\)</span>
is the generator of the group of roots of unity (<tt class="docutils literal"><span class="pre">bnf.tu</span></tt>), the output is
a vector <span class="math">\([x_1,...,x_r,x_{r+1}]\)</span> such that <span class="math">\(x = u_1^{x_1}...
u_r^{x_r}.\zeta^{x_{r+1}}\)</span>. The <span class="math">\(x_i\)</span> are integers for <span class="math">\(i &lt;= r\)</span> and is an
integer modulo the order of <span class="math">\(\zeta\)</span> for <span class="math">\(i = r+1\)</span>.</p>
<p>Note that <em>bnf</em> need not contain the fundamental unit explicitly:</p>
<div class="highlight-python"><div class="highlight"><pre>? setrand(1); bnf = bnfinit(x^2-x-100000);
? bnf.fu
 *** at top-level: bnf.fu
 *** ^--
 *** _.fu: missing units in .fu.
? u = [119836165644250789990462835950022871665178127611316131167, \
 379554884019013781006303254896369154068336082609238336]~;
? bnfisunit(bnf, u)
%3 = [-1, Mod(0, 2)]~
</pre></div>
</div>
<p>The given <span class="math">\(u\)</span> is the inverse of the fundamental unit
implicitly stored in <em>bnf</em>. In this case, the fundamental unit was not
computed and stored in algebraic form since the default accuracy was too
low. (Re-run the command at \g1 or higher to see such diagnostics.)</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfnarrow">
<tt class="descname">bnfnarrow</tt><big>(</big><em>bnf</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfnarrow" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(bnf\)</span> being as output by
<tt class="docutils literal"><span class="pre">bnfinit</span></tt>, computes the narrow class group of <span class="math">\(bnf\)</span>. The output is
a 3-component row vector <span class="math">\(v\)</span> analogous to the corresponding class group
component <tt class="docutils literal"><span class="pre">:emphasis:`bnf</span></tt>.clgp` (<tt class="docutils literal"><span class="pre">:emphasis:`bnf`[8][1]</span></tt>): the first component
is the narrow class number <tt class="docutils literal"><span class="pre">:math:`v</span></tt>.no`, the second component is a vector
containing the SNF cyclic components <tt class="docutils literal"><span class="pre">:math:`v</span></tt>.cyc` of
the narrow class group, and the third is a vector giving the generators of
the corresponding <tt class="docutils literal"><span class="pre">:math:`v</span></tt>.gen` cyclic groups. Note that this function is a
special case of <tt class="docutils literal"><span class="pre">bnrinit</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfsignunit">
<tt class="descname">bnfsignunit</tt><big>(</big><em>bnf</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfsignunit" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(bnf\)</span> being as output by
<tt class="docutils literal"><span class="pre">bnfinit</span></tt>, this computes an <span class="math">\(r_1 x (r_1+r_2-1)\)</span> matrix having <span class="math">\(±1\)</span>
components, giving the signs of the real embeddings of the fundamental units.
The following functions compute generators for the totally positive units:</p>
<div class="highlight-python"><div class="highlight"><pre>/* exponents of totally positive units generators on bnf.tufu */
tpuexpo(bnf)=
{ my(S,d,K);

 S = bnfsignunit(bnf); d = matsize(S);
 S = matrix(d[1],d[2], i,j, if (S[i,j] &lt; 0, 1,0));
 S = concat(vectorv(d[1],i,1), S); \\ add sign(-1)
 K = lift(matker(S * Mod(1,2)));
 if (K, mathnfmodid(K, 2), 2*matid(d[1]))
}

/* totally positive units */
tpu(bnf)=
{ my(vu = bnf.tufu, ex = tpuexpo(bnf));

 vector(#ex-1, i, factorback(vu, ex[,i+1])) \\ ex[,1] is 1
}
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfsunit">
<tt class="descname">bnfsunit</tt><big>(</big><em>bnf</em>, <em>S</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfsunit" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the fundamental <span class="math">\(S\)</span>-units of the
number field <span class="math">\(bnf\)</span> (output by <tt class="docutils literal"><span class="pre">bnfinit</span></tt>), where <span class="math">\(S\)</span> is a list of
prime ideals (output by <tt class="docutils literal"><span class="pre">idealprimedec</span></tt>). The output is a vector <span class="math">\(v\)</span> with
6 components.</p>
<p><span class="math">\(v[1]\)</span> gives a minimal system of (integral) generators of the <span class="math">\(S\)</span>-unit group
modulo the unit group.</p>
<p><span class="math">\(v[2]\)</span> contains technical data needed by <tt class="docutils literal"><span class="pre">bnfissunit</span></tt>.</p>
<p><span class="math">\(v[3]\)</span> is an empty vector (used to give the logarithmic embeddings of the
generators in <span class="math">\(v[1]\)</span> in version 2.0.16).</p>
<p><span class="math">\(v[4]\)</span> is the <span class="math">\(S\)</span>-regulator (this is the product of the regulator, the
determinant of <span class="math">\(v[2]\)</span> and the natural logarithms of the norms of the ideals
in <span class="math">\(S\)</span>).</p>
<p><span class="math">\(v[5]\)</span> gives the <span class="math">\(S\)</span>-class group structure, in the usual format
(a row vector whose three components give in order the <span class="math">\(S\)</span>-class number,
the cyclic components and the generators).</p>
<p><span class="math">\(v[6]\)</span> is a copy of <span class="math">\(S\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrL1">
<tt class="descname">bnrL1</tt><big>(</big><em>bnr</em>, <em>H=None</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrL1" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <em>bnr</em> be the number field data output by <tt class="docutils literal"><span class="pre">bnrinit(,,1)</span></tt> and
<em>H</em> be a square matrix defining a congruence subgroup of the
ray class group corresponding to <em>bnr</em> (the trivial congruence subgroup
if omitted). This function returns, for each character <span class="math">\(\chi\)</span> of the ray
class group which is trivial on <span class="math">\(H\)</span>, the value at <span class="math">\(s = 1\)</span> (or <span class="math">\(s = 0\)</span>) of the
abelian <span class="math">\(L\)</span>-function associated to <span class="math">\(\chi\)</span>. For the value at <span class="math">\(s = 0\)</span>, the
function returns in fact for each <span class="math">\(\chi\)</span> a vector <span class="math">\([r_\chi, c_\chi]\)</span> where</p>
<div class="math">
\[L(s, \chi) = c.s^r + O(s^{r + 1})\]</div>
<p>near <span class="math">\(0\)</span>.</p>
<p>The argument <em>flag</em> is optional, its binary digits
mean 1: compute at <span class="math">\(s = 0\)</span> if unset or <span class="math">\(s = 1\)</span> if set, 2: compute the
primitive <span class="math">\(L\)</span>-function associated to <span class="math">\(\chi\)</span> if unset or the <span class="math">\(L\)</span>-function
with Euler factors at prime ideals dividing the modulus of <em>bnr</em> removed
if set (that is <span class="math">\(L_S(s, \chi)\)</span>, where <span class="math">\(S\)</span> is the
set of infinite places of the number field together with the finite prime
ideals dividing the modulus of <em>bnr</em>), 3: return also the character if
set.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">K</span> <span class="o">=</span> <span class="n">bnfinit</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">229</span><span class="p">);</span>
<span class="n">bnr</span> <span class="o">=</span> <span class="n">bnrinit</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">bnrL1</span><span class="p">(</span><span class="n">bnr</span><span class="p">)</span>
</pre></div>
</div>
<p>returns the order and the first non-zero term of <span class="math">\(L(s, \chi)\)</span> at <span class="math">\(s = 0\)</span>
where <span class="math">\(\chi\)</span> runs through the characters of the class group of
<span class="math">\(K = \mathbb{Q}(\sqrt{229})\)</span>. Then</p>
<div class="highlight-python"><div class="highlight"><pre>bnr2 = bnrinit(K,2,1);
bnrL1(bnr2,,2)
</pre></div>
</div>
<p>returns the order and the first non-zero terms of <span class="math">\(L_S(s, \chi)\)</span> at <span class="math">\(s = 0\)</span>
where <span class="math">\(\chi\)</span> runs through the characters of the class group of <span class="math">\(K\)</span> and <span class="math">\(S\)</span> is
the set of infinite places of <span class="math">\(K\)</span> together with the finite prime <span class="math">\(2\)</span>. Note
that the ray class group modulo <span class="math">\(2\)</span> is in fact the class group, so
<tt class="docutils literal"><span class="pre">bnrL1(bnr2,0)</span></tt> returns the same answer as <tt class="docutils literal"><span class="pre">bnrL1(bnr,0)</span></tt>.</p>
<p>This function will fail with the message</p>
<div class="highlight-python"><div class="highlight"><pre>*** bnrL1: overflow in zeta_get_N0 [need too many primes].
</pre></div>
</div>
<p>if the approximate functional equation requires us to sum
too many terms (if the discriminant of <span class="math">\(K\)</span> is too large).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrclassno">
<tt class="descname">bnrclassno</tt><big>(</big><em>A</em>, <em>B=None</em>, <em>C=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrclassno" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(A\)</span>, <span class="math">\(B\)</span>, <span class="math">\(C\)</span> define a class field <span class="math">\(L\)</span> over a ground field <span class="math">\(K\)</span>
(of type <tt class="docutils literal"><span class="pre">[:emphasis:`bnr</span></tt>]`,
<tt class="docutils literal"><span class="pre">[:emphasis:`bnr</span></tt>, <em>subgroup</em>]`,
or <tt class="docutils literal"><span class="pre">[:emphasis:`bnf</span></tt>, <em>modulus</em>]`,
or <tt class="docutils literal"><span class="pre">[:emphasis:`bnf</span></tt>, <em>modulus</em>,:emphasis:<span class="math">\(subgroup\)</span>]`,
<tt class="docutils literal"><span class="pre">CFT</span></tt> (in the PARI manual)); this function returns the relative degree <span class="math">\([L:K]\)</span>.</p>
<p>In particular if <span class="math">\(A\)</span> is a <em>bnf</em> (with units), and <span class="math">\(B\)</span> a modulus,
this function returns the corresponding ray class number modulo <span class="math">\(B\)</span>.
One can input the associated <em>bid</em> (with generators if the subgroup
<span class="math">\(C\)</span> is non trivial) for <span class="math">\(B\)</span> instead of the module itself, saving some time.</p>
<p>This function is faster than <tt class="docutils literal"><span class="pre">bnrinit</span></tt> and should be used if only the
ray class number is desired. See <tt class="docutils literal"><span class="pre">bnrclassnolist</span></tt> if you need ray class
numbers for all moduli less than some bound.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrclassnolist">
<tt class="descname">bnrclassnolist</tt><big>(</big><em>bnf</em>, <em>list</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrclassnolist" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(bnf\)</span> being as
output by <tt class="docutils literal"><span class="pre">bnfinit</span></tt>, and <em>list</em> being a list of moduli (with units) as
output by <tt class="docutils literal"><span class="pre">ideallist</span></tt> or <tt class="docutils literal"><span class="pre">ideallistarch</span></tt>, outputs the list of the
class numbers of the corresponding ray class groups. To compute a single
class number, <tt class="docutils literal"><span class="pre">bnrclassno</span></tt> is more efficient.</p>
<div class="highlight-python"><div class="highlight"><pre>? bnf = bnfinit(x^2 - 2);
? L = ideallist(bnf, 100, 2);
? H = bnrclassnolist(bnf, L);
? H[98]
%4 = [1, 3, 1]
? l = L[1][98]; ids = vector(#l, i, l[i].mod[1])
%5 = [[98, 88; 0, 1], [14, 0; 0, 7], [98, 10; 0, 1]]
</pre></div>
</div>
<p>The weird <tt class="docutils literal"><span class="pre">l[i].mod[1]</span></tt>, is the first component of <tt class="docutils literal"><span class="pre">l[i].mod</span></tt>, i.e.
the finite part of the conductor. (This is cosmetic: since by construction
the Archimedean part is trivial, I do not want to see it). This tells us that
the ray class groups modulo the ideals of norm 98 (printed as <tt class="docutils literal"><span class="pre">%5</span></tt>) have
respectively order <span class="math">\(1\)</span>, <span class="math">\(3\)</span> and <span class="math">\(1\)</span>. Indeed, we may check directly:</p>
<div class="highlight-python"><div class="highlight"><pre>? bnrclassno(bnf, ids[2])
%6 = 3
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrconductor">
<tt class="descname">bnrconductor</tt><big>(</big><em>A</em>, <em>B=None</em>, <em>C=None</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrconductor" title="Permalink to this definition">¶</a></dt>
<dd><p>Conductor <span class="math">\(f\)</span> of the subfield of a ray class field as defined by <span class="math">\([A,B,C]\)</span>
(of type <tt class="docutils literal"><span class="pre">[:emphasis:`bnr</span></tt>]`,
<tt class="docutils literal"><span class="pre">[:emphasis:`bnr</span></tt>, <em>subgroup</em>]`,
<tt class="docutils literal"><span class="pre">[:emphasis:`bnf</span></tt>, <em>modulus</em>]` or
<tt class="docutils literal"><span class="pre">[:emphasis:`bnf</span></tt>, <em>modulus</em>, <em>subgroup</em>]`,
<tt class="docutils literal"><span class="pre">CFT</span></tt> (in the PARI manual))</p>
<p>If <span class="math">\(flag = 0\)</span>, returns <span class="math">\(f\)</span>.</p>
<p>If <span class="math">\(flag = 1\)</span>, returns <span class="math">\([f, Cl_f, H]\)</span>, where <span class="math">\(Cl_f\)</span> is the ray class group
modulo <span class="math">\(f\)</span>, as a finite abelian group; finally <span class="math">\(H\)</span> is the subgroup of <span class="math">\(Cl_f\)</span>
defining the extension.</p>
<p>If <span class="math">\(flag = 2\)</span>, returns <span class="math">\([f, bnr(f), H]\)</span>, as above except <span class="math">\(Cl_f\)</span> is
replaced by a <tt class="docutils literal"><span class="pre">bnr</span></tt> structure, as output by <span class="math">\(bnrinit(,f,1)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrconductorofchar">
<tt class="descname">bnrconductorofchar</tt><big>(</big><em>bnr</em>, <em>chi</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrconductorofchar" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bnr</em> being a big
ray number field as output by <tt class="docutils literal"><span class="pre">bnrinit</span></tt>, and <em>chi</em> being a row vector
representing a character as expressed on the generators of the ray
class group, gives the conductor of this character as a modulus.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrdisc">
<tt class="descname">bnrdisc</tt><big>(</big><em>A</em>, <em>B=None</em>, <em>C=None</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrdisc" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(A\)</span>, <span class="math">\(B\)</span>, <span class="math">\(C\)</span> defining a class field <span class="math">\(L\)</span> over a ground field <span class="math">\(K\)</span>
(of type <tt class="docutils literal"><span class="pre">[:emphasis:`bnr</span></tt>]`,
<tt class="docutils literal"><span class="pre">[:emphasis:`bnr</span></tt>, <em>subgroup</em>]`,
<tt class="docutils literal"><span class="pre">[:emphasis:`bnf</span></tt>, <em>modulus</em>]` or
<tt class="docutils literal"><span class="pre">[:emphasis:`bnf</span></tt>, <em>modulus</em>, <em>subgroup</em>]`,
<tt class="docutils literal"><span class="pre">CFT</span></tt> (in the PARI manual)), outputs data <span class="math">\([N,r_1,D]\)</span> giving the discriminant and
signature of <span class="math">\(L\)</span>, depending on the binary digits of <em>flag</em>:</p>
<ul class="simple">
<li>1: if this bit is unset, output absolute data related to <span class="math">\(L/\mathbb{Q}\)</span>:
<span class="math">\(N\)</span> is the absolute degree <span class="math">\([L:\mathbb{Q}]\)</span>, <span class="math">\(r_1\)</span> the number of real places of <span class="math">\(L\)</span>,
and <span class="math">\(D\)</span> the discriminant of <span class="math">\(L/\mathbb{Q}\)</span>. Otherwise, output relative data for <span class="math">\(L/K\)</span>:
<span class="math">\(N\)</span> is the relative degree <span class="math">\([L:K]\)</span>, <span class="math">\(r_1\)</span> is the number of real places of <span class="math">\(K\)</span>
unramified in <span class="math">\(L\)</span> (so that the number of real places of <span class="math">\(L\)</span> is equal to <span class="math">\(r_1\)</span>
times <span class="math">\(N\)</span>), and <span class="math">\(D\)</span> is the relative discriminant ideal of <span class="math">\(L/K\)</span>.</li>
<li>2: if this bit is set and if the modulus is not the conductor of <span class="math">\(L\)</span>,
only return 0.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrdisclist">
<tt class="descname">bnrdisclist</tt><big>(</big><em>bnf</em>, <em>bound</em>, <em>arch=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrdisclist" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(bnf\)</span> being as output by <tt class="docutils literal"><span class="pre">bnfinit</span></tt> (with units), computes a
list of discriminants of Abelian extensions of the number field by increasing
modulus norm up to bound <em>bound</em>. The ramified Archimedean places are
given by <em>arch</em>; all possible values are taken if <em>arch</em> is omitted.</p>
<p>The alternative syntax <span class="math">\(bnrdisclist(bnf,list)\)</span> is
supported, where <em>list</em> is as output by <tt class="docutils literal"><span class="pre">ideallist</span></tt> or
<tt class="docutils literal"><span class="pre">ideallistarch</span></tt> (with units), in which case <em>arch</em> is disregarded.</p>
<p>The output <span class="math">\(v\)</span> is a vector of vectors, where <span class="math">\(v[i][j]\)</span> is understood to be in
fact <span class="math">\(V[2^{15}(i-1)+j]\)</span> of a unique big vector <span class="math">\(V\)</span>. (This awkward scheme
allows for larger vectors than could be otherwise represented.)</p>
<p><span class="math">\(V[k]\)</span> is itself a vector <span class="math">\(W\)</span>, whose length is the number of ideals of norm
<span class="math">\(k\)</span>. We consider first the case where <em>arch</em> was specified. Each
component of <span class="math">\(W\)</span> corresponds to an ideal <span class="math">\(m\)</span> of norm <span class="math">\(k\)</span>, and
gives invariants associated to the ray class field <span class="math">\(L\)</span> of <span class="math">\(bnf\)</span> of
conductor <span class="math">\([m, arch]\)</span>. Namely, each contains a vector <span class="math">\([m,d,r,D]\)</span> with
the following meaning: <span class="math">\(m\)</span> is the prime ideal factorization of the modulus,
<span class="math">\(d = [L:\mathbb{Q}]\)</span> is the absolute degree of <span class="math">\(L\)</span>, <span class="math">\(r\)</span> is the number of real places
of <span class="math">\(L\)</span>, and <span class="math">\(D\)</span> is the factorization of its absolute discriminant. We set <span class="math">\(d
= r = D = 0\)</span> if <span class="math">\(m\)</span> is not the finite part of a conductor.</p>
<p>If <em>arch</em> was omitted, all <span class="math">\(t = 2^{r_1}\)</span> possible values are taken and a
component of <span class="math">\(W\)</span> has the form <span class="math">\([m, [[d_1,r_1,D_1],..., [d_t,r_t,D_t]]]\)</span>,
where <span class="math">\(m\)</span> is the finite part of the conductor as above, and
<span class="math">\([d_i,r_i,D_i]\)</span> are the invariants of the ray class field of conductor
<span class="math">\([m,v_i]\)</span>, where <span class="math">\(v_i\)</span> is the <span class="math">\(i\)</span>-th Archimedean component, ordered by
inverse lexicographic order; so <span class="math">\(v_1 = [0,...,0]\)</span>, <span class="math">\(v_2 = [1,0...,0]\)</span>,
etc. Again, we set <span class="math">\(d_i = r_i = D_i = 0\)</span> if <span class="math">\([m,v_i]\)</span> is not a conductor.</p>
<p>Finally, each prime ideal <span class="math">\(pr = [p,\alpha,e,f,\beta]\)</span> in the prime
factorization <span class="math">\(m\)</span> is coded as the integer <span class="math">\(p.n^2+(f-1).n+(j-1)\)</span>,
where <span class="math">\(n\)</span> is the degree of the base field and <span class="math">\(j\)</span> is such that</p>
<p><tt class="docutils literal"><span class="pre">pr</span> <span class="pre">=</span> <span class="pre">idealprimedec(:emphasis:`nf</span></tt>,p)[j]`.</p>
<p><span class="math">\(m\)</span> can be decoded using <tt class="docutils literal"><span class="pre">bnfdecodemodule</span></tt>.</p>
<p>Note that to compute such data for a single field, either <tt class="docutils literal"><span class="pre">bnrclassno</span></tt>
or <tt class="docutils literal"><span class="pre">bnrdisc</span></tt> is more efficient.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrgaloisapply">
<tt class="descname">bnrgaloisapply</tt><big>(</big><em>bnr</em>, <em>mat</em>, <em>H</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrgaloisapply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the automorphism given by its matrix <em>mat</em> to the congruence
subgroup <span class="math">\(H\)</span> given as a HNF matrix.
The matrix <em>mat</em> can be computed with <tt class="docutils literal"><span class="pre">bnrgaloismatrix</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrgaloismatrix">
<tt class="descname">bnrgaloismatrix</tt><big>(</big><em>bnr</em>, <em>aut</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrgaloismatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix of the action of the automorphism <em>aut</em> of the base
field <tt class="docutils literal"><span class="pre">bnf.nf</span></tt> on the generators of the ray class field <tt class="docutils literal"><span class="pre">bnr.gen</span></tt>.
<em>aut</em> can be given as a polynomial, an algebraic number, or a vector of
automorphisms or a Galois group as output by <tt class="docutils literal"><span class="pre">galoisinit</span></tt>, in which case a
vector of matrices is returned (in the later case, only for the generators
<tt class="docutils literal"><span class="pre">aut.gen</span></tt>).</p>
<p>See <tt class="docutils literal"><span class="pre">bnrisgalois</span></tt> for an example.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrinit">
<tt class="descname">bnrinit</tt><big>(</big><em>bnf</em>, <em>f</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrinit" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(bnf\)</span> is as
output by <tt class="docutils literal"><span class="pre">bnfinit</span></tt>, <span class="math">\(f\)</span> is a modulus, initializes data linked to
the ray class group structure corresponding to this module, a so-called
<em>bnr</em> structure. One can input the associated <em>bid</em> with generators
for <span class="math">\(f\)</span> instead of the module itself, saving some time.
(As in <tt class="docutils literal"><span class="pre">idealstar</span></tt>, the finite part of the conductor may be given
by a factorization into prime ideals, as produced by <tt class="docutils literal"><span class="pre">idealfactor</span></tt>.)</p>
<p>The following member functions are available
on the result: <tt class="docutils literal"><span class="pre">.bnf</span></tt> is the underlying <em>bnf</em>,
<tt class="docutils literal"><span class="pre">.mod</span></tt> the modulus, <tt class="docutils literal"><span class="pre">.bid</span></tt> the <em>bid</em> structure associated to the
modulus; finally, <tt class="docutils literal"><span class="pre">.clgp</span></tt>, <tt class="docutils literal"><span class="pre">.no</span></tt>, <tt class="docutils literal"><span class="pre">.cyc</span></tt>, <tt class="docutils literal"><span class="pre">.gen</span></tt> refer to the
ray class group (as a finite abelian group), its cardinality, its elementary
divisors, its generators (only computed if <span class="math">\(flag = 1\)</span>).</p>
<p>The last group of functions are different from the members of the underlying
<em>bnf</em>, which refer to the class group; use <tt class="docutils literal"><span class="pre">:emphasis:`bnr</span></tt>.bnf.:emphasis:<span class="math">\(xxx`\)</span>
to access these, e.g.&nbsp;<tt class="docutils literal"><span class="pre">:emphasis:`bnr</span></tt>.bnf.cyc` to get the cyclic decomposition
of the class group.</p>
<p>They are also different from the members of the underlying <em>bid</em>, which
refer to <span class="math">\((\mathbb{Z}_K/f)^*\)</span>; use <tt class="docutils literal"><span class="pre">:emphasis:`bnr</span></tt>.bid.:emphasis:<span class="math">\(xxx`\)</span> to access these,
e.g.&nbsp;<tt class="docutils literal"><span class="pre">:emphasis:`bnr</span></tt>.bid.no` to get <span class="math">\(\phi(f)\)</span>.</p>
<p>If <span class="math">\(flag = 0\)</span> (default), the generators of the ray class group are not computed,
which saves time. Hence <tt class="docutils literal"><span class="pre">:emphasis:`bnr</span></tt>.gen` would produce an error.</p>
<p>If <span class="math">\(flag = 1\)</span>, as the default, except that generators are computed.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrisconductor">
<tt class="descname">bnrisconductor</tt><big>(</big><em>A</em>, <em>B=None</em>, <em>C=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrisconductor" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(A\)</span>, <span class="math">\(B\)</span>, <span class="math">\(C\)</span> represent
an extension of the base field, given by class field theory
(see&nbsp;<tt class="docutils literal"><span class="pre">CFT</span></tt> (in the PARI manual)). Outputs 1 if this modulus is the conductor, and 0
otherwise. This is slightly faster than <tt class="docutils literal"><span class="pre">bnrconductor</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrisgalois">
<tt class="descname">bnrisgalois</tt><big>(</big><em>bnr</em>, <em>gal</em>, <em>H</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrisgalois" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the class field associated to the subgroup <span class="math">\(H\)</span> is Galois
over the subfield of <tt class="docutils literal"><span class="pre">bnr.nf</span></tt> fixed by the group <em>gal</em>, which can be
given as output by <tt class="docutils literal"><span class="pre">galoisinit</span></tt>, or as a matrix or a vector of matrices as
output by <tt class="docutils literal"><span class="pre">bnrgaloismatrix</span></tt>, the second option being preferable, since it
saves the recomputation of the matrices. Note: The function assumes that the
ray class field associated to bnr is Galois, which is not checked.</p>
<p>In the following example, we lists the congruence subgroups of subextension of
degree at most <span class="math">\(3\)</span> of the ray class field of conductor <span class="math">\(9\)</span> which are Galois
over the rationals.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">K</span><span class="o">=</span><span class="n">bnfinit</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="mi">4</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">253009</span><span class="p">);</span>
<span class="n">G</span><span class="o">=</span><span class="n">galoisinit</span><span class="p">(</span><span class="n">K</span><span class="p">);</span>
<span class="n">B</span><span class="o">=</span><span class="n">bnrinit</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">L1</span><span class="o">=</span><span class="p">[</span><span class="n">H</span><span class="o">|</span><span class="n">H</span><span class="o">&lt;-</span><span class="n">subgrouplist</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">bnrisgalois</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">H</span><span class="p">)]</span>
<span class="c">##</span>
<span class="n">M</span><span class="o">=</span><span class="n">bnrgaloismatrix</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">G</span><span class="p">)</span>
<span class="n">L2</span><span class="o">=</span><span class="p">[</span><span class="n">H</span><span class="o">|</span><span class="n">H</span><span class="o">&lt;-</span><span class="n">subgrouplist</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">bnrisgalois</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">H</span><span class="p">)]</span>
<span class="c">##</span>
</pre></div>
</div>
<p>The second computation is much faster since <tt class="docutils literal"><span class="pre">bnrgaloismatrix(B,G)</span></tt> is
computed only once.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrisprincipal">
<tt class="descname">bnrisprincipal</tt><big>(</big><em>bnr</em>, <em>x</em>, <em>flag=1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrisprincipal" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bnr</em> being the
number field data which is output by <tt class="docutils literal"><span class="pre">bnrinit</span></tt><span class="math">\((,,1)\)</span> and <span class="math">\(x\)</span> being an
ideal in any form, outputs the components of <span class="math">\(x\)</span> on the ray class group
generators in a way similar to <tt class="docutils literal"><span class="pre">bnfisprincipal</span></tt>. That is a 2-component
vector <span class="math">\(v\)</span> where <span class="math">\(v[1]\)</span> is the vector of components of <span class="math">\(x\)</span> on the ray class
group generators, <span class="math">\(v[2]\)</span> gives on the integral basis an element <span class="math">\(\alpha\)</span> such
that <span class="math">\(x = \alpha\prod_ig_i^{x_i}\)</span>.</p>
<p>If <span class="math">\(flag = 0\)</span>, outputs only <span class="math">\(v_1\)</span>. In that case, <em>bnr</em> need not contain the
ray class group generators, i.e.&nbsp;it may be created with <tt class="docutils literal"><span class="pre">bnrinit</span></tt><span class="math">\((,,0)\)</span>
If <span class="math">\(x\)</span> is not coprime to the modulus of <em>bnr</em> the result is undefined.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrrootnumber">
<tt class="descname">bnrrootnumber</tt><big>(</big><em>bnr</em>, <em>chi</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrrootnumber" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(\chi = chi\)</span> is a
character over <em>bnr</em>, not necessarily primitive, let
<span class="math">\(L(s,\chi) = \sum_{id} \chi(id) N(id)^{-s}\)</span> be the associated
Artin L-function. Returns the so-called Artin root number, i.e.&nbsp;the
complex number <span class="math">\(W(\chi)\)</span> of modulus 1 such that</p>
<div class="math">
\[\begin{split}\Lambda(1-s,\chi) = W(\chi) \Lambda(s,\\overline{\chi})\end{split}\]</div>
<p>where <span class="math">\(\Lambda(s,\chi) = A(\chi)^{s/2}\gamma_\chi(s) L(s,\chi)\)</span> is
the enlarged L-function associated to <span class="math">\(L\)</span>.</p>
<p>The generators of the ray class group are needed, and you can set <span class="math">\(flag = 1\)</span> if
the character is known to be primitive. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bnf</span> <span class="o">=</span> <span class="n">bnfinit</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">57</span><span class="p">);</span>
<span class="n">bnr</span> <span class="o">=</span> <span class="n">bnrinit</span><span class="p">(</span><span class="n">bnf</span><span class="p">,</span> <span class="p">[</span><span class="mi">7</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">bnrrootnumber</span><span class="p">(</span><span class="n">bnr</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>returns the root number of the character <span class="math">\(\chi\)</span> of
<span class="math">\(\mathrm{Cl}_{7 oo _1 oo _2}(\mathbb{Q}(\sqrt{229}))\)</span> defined by <span class="math">\(\chi(g_1^ag_2^b)
= \zeta_1^{2a}\zeta_2^b\)</span>. Here <span class="math">\(g_1, g_2\)</span> are the generators of the
ray-class group given by <tt class="docutils literal"><span class="pre">bnr.gen</span></tt> and <span class="math">\(\zeta_1 = e^{2i\Pi/N_1},
\zeta_2 = e^{2i\Pi/N_2}\)</span> where <span class="math">\(N_1, N_2\)</span> are the orders of <span class="math">\(g_1\)</span> and
<span class="math">\(g_2\)</span> respectively (<span class="math">\(N_1 = 6\)</span> and <span class="math">\(N_2 = 3\)</span> as <tt class="docutils literal"><span class="pre">bnr.cyc</span></tt> readily tells us).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrstark">
<tt class="descname">bnrstark</tt><big>(</big><em>bnr</em>, <em>subgroup=None</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrstark" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bnr</em> being as output by <tt class="docutils literal"><span class="pre">bnrinit(,,1)</span></tt>, finds a relative equation
for the class field corresponding to the modulus in <em>bnr</em> and the given
congruence subgroup (as usual, omit <span class="math">\(subgroup\)</span> if you want the whole ray
class group).</p>
<p>The main variable of <em>bnr</em> must not be <span class="math">\(x\)</span>, and the ground field and the
class field must be totally real. When the base field is <span class="math">\(\mathbb{Q}\)</span>, the vastly
simpler <tt class="docutils literal"><span class="pre">galoissubcyclo</span></tt> is used instead. Here is an example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bnf</span> <span class="o">=</span> <span class="n">bnfinit</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">bnr</span> <span class="o">=</span> <span class="n">bnrinit</span><span class="p">(</span><span class="n">bnf</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">bnrstark</span><span class="p">(</span><span class="n">bnr</span><span class="p">)</span>
</pre></div>
</div>
<p>returns the ray class field of <span class="math">\(\mathbb{Q}(\sqrt{3})\)</span> modulo <span class="math">\(5\)</span>. Usually, one wants
to apply to the result one of</p>
<div class="highlight-python"><div class="highlight"><pre>rnfpolredabs(bnf, pol, 16) \\ compute a reduced relative polynomial
rnfpolredabs(bnf, pol, 16 + 2) \\ compute a reduced absolute polynomial
</pre></div>
</div>
<p>The routine uses Stark units and needs to find a suitable auxiliary
conductor, which may not exist when the class field is not cyclic over the
base. In this case <tt class="docutils literal"><span class="pre">bnrstark</span></tt> is allowed to return a vector of
polynomials defining <em>independent</em> relative extensions, whose compositum
is the requested class field. It was decided that it was more useful
to keep the extra information thus made available, hence the user has to take
the compositum herself.</p>
<p>Even if it exists, the auxiliary conductor may be so large that later
computations become unfeasible. (And of course, Stark&#8217;s conjecture may simply
be wrong.) In case of difficulties, try <tt class="docutils literal"><span class="pre">rnfkummer</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>? bnr = bnrinit(bnfinit(y^8-12*y^6+36*y^4-36*y^2+9,1), 2, 1);
? bnrstark(bnr)
 *** at top-level: bnrstark(bnr)
 *** ^-------------
 *** bnrstark: need 3919350809720744 coefficients in initzeta.
 *** Computation impossible.
? lift( rnfkummer(bnr) )
time = 24 ms.
%2 = x^2 + (1/3*y^6 - 11/3*y^4 + 8*y^2 - 5)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ceil">
<tt class="descname">ceil</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Ceiling of <span class="math">\(x\)</span>. When <span class="math">\(x\)</span> is in <span class="math">\(\mathbb{R}\)</span>, the result is the
smallest integer greater than or equal to <span class="math">\(x\)</span>. Applied to a rational
function, <span class="math">\(ceil(x)\)</span> returns the Euclidean quotient of the numerator by
the denominator.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.centerlift">
<tt class="descname">centerlift</tt><big>(</big><em>x</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.centerlift" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <tt class="docutils literal"><span class="pre">lift</span></tt>, except that <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt> and <tt class="docutils literal"><span class="pre">t_PADIC</span></tt> components
are lifted using centered residues:</p>
<ul class="simple">
<li>for a <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt> <span class="math">\(x belongs to \mathbb{Z}/n\mathbb{Z}\)</span>, the lift <span class="math">\(y\)</span> is such that
<span class="math">\(-n/2 &lt; y &lt;= n/2\)</span>.</li>
<li>a <tt class="docutils literal"><span class="pre">t_PADIC</span></tt> <span class="math">\(x\)</span> is lifted in the same way as above (modulo
<span class="math">\(p^padicprec(x)\)</span>) if its valuation <span class="math">\(v\)</span> is non-negative; if not, returns
the fraction <span class="math">\(p^v\)</span> <tt class="docutils literal"><span class="pre">centerlift</span></tt><span class="math">\((x p^{-v})\)</span>; in particular, rational
reconstruction is not attempted. Use <tt class="docutils literal"><span class="pre">bestappr</span></tt> for this.</li>
</ul>
<p>For backward compatibility, <tt class="docutils literal"><span class="pre">centerlift(x,'v)</span></tt> is allowed as an alias
for <tt class="docutils literal"><span class="pre">lift(x,'v)</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.characteristic">
<tt class="descname">characteristic</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.characteristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the characteristic of the base ring over which <span class="math">\(x\)</span> is defined (as
defined by <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt> and <tt class="docutils literal"><span class="pre">t_FFELT</span></tt> components). The function raises an
exception if incompatible primes arise from <tt class="docutils literal"><span class="pre">t_FFELT</span></tt> and <tt class="docutils literal"><span class="pre">t_PADIC</span></tt>
components.</p>
<div class="highlight-python"><div class="highlight"><pre>? characteristic(Mod(1,24)*x + Mod(1,18)*y)
%1 = 6
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.charpoly">
<tt class="descname">charpoly</tt><big>(</big><em>A</em>, <em>v=None</em>, <em>flag=5</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.charpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>characteristic polynomial
of <span class="math">\(A\)</span> with respect to the variable <span class="math">\(v\)</span>, i.e.&nbsp;determinant of <span class="math">\(v*I-A\)</span> if <span class="math">\(A\)</span>
is a square matrix.</p>
<div class="highlight-python"><div class="highlight"><pre>? charpoly([1,2;3,4]);
%1 = x^2 - 5*x - 2
? charpoly([1,2;3,4],, &#39;t)
%2 = t^2 - 5*t - 2
</pre></div>
</div>
<p>If <span class="math">\(A\)</span> is not a square matrix, the function returns the characteristic
polynomial of the map &#8220;multiplication by <span class="math">\(A\)</span>&#8221; if <span class="math">\(A\)</span> is a scalar:</p>
<div class="highlight-python"><div class="highlight"><pre>? charpoly(Mod(x+2, x^3-2))
%1 = x^3 - 6*x^2 + 12*x - 10
? charpoly(I)
%2 = x^2 + 1
? charpoly(quadgen(5))
%3 = x^2 - x - 1
? charpoly(ffgen(ffinit(2,4)))
%4 = Mod(1, 2)*x^4 + Mod(1, 2)*x^3 + Mod(1, 2)*x^2 + Mod(1, 2)*x + Mod(1, 2)
</pre></div>
</div>
<p>The value of <span class="math">\(flag\)</span> is only significant for matrices, and we advise to stick
to the default value. Let <span class="math">\(n\)</span> be the dimension of <span class="math">\(A\)</span>.</p>
<p>If <span class="math">\(flag = 0\)</span>, same method (Le Verrier&#8217;s) as for computing the adjoint matrix,
i.e.&nbsp;using the traces of the powers of <span class="math">\(A\)</span>. Assumes that <span class="math">\(n!\)</span> is
invertible; uses <span class="math">\(O(n^4)\)</span> scalar operations.</p>
<p>If <span class="math">\(flag = 1\)</span>, uses Lagrange interpolation which is usually the slowest method.
Assumes that <span class="math">\(n!\)</span> is invertible; uses <span class="math">\(O(n^4)\)</span> scalar operations.</p>
<p>If <span class="math">\(flag = 2\)</span>, uses the Hessenberg form. Assumes that the base ring is a field.
Uses <span class="math">\(O(n^3)\)</span> scalar operations, but suffers from coefficient explosion
unless the base field is finite or <span class="math">\(\mathbb{R}\)</span>.</p>
<p>If <span class="math">\(flag = 3\)</span>, uses Berkowitz&#8217;s division free algorithm, valid over any
ring (commutative, with unit). Uses <span class="math">\(O(n^4)\)</span> scalar operations.</p>
<p>If <span class="math">\(flag = 4\)</span>, <span class="math">\(x\)</span> must be integral. Uses a modular algorithm: Hessenberg form
for various small primes, then Chinese remainders.</p>
<p>If <span class="math">\(flag = 5\)</span> (default), uses the &#8220;best&#8221; method given <span class="math">\(x\)</span>.
This means we use Berkowitz unless the base ring is <span class="math">\(\mathbb{Z}\)</span> (use <span class="math">\(flag = 4\)</span>)
or a field where coefficient explosion does not occur,
e.g.&nbsp;a finite field or the reals (use <span class="math">\(flag = 2\)</span>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.chinese">
<tt class="descname">chinese</tt><big>(</big><em>x</em>, <em>y=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.chinese" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are both intmods or both polmods, creates (with the same
type) a <span class="math">\(z\)</span> in the same residue class as <span class="math">\(x\)</span> and in the same residue class as
<span class="math">\(y\)</span>, if it is possible.</p>
<div class="highlight-python"><div class="highlight"><pre>? chinese(Mod(1,2), Mod(2,3))
%1 = Mod(5, 6)
? chinese(Mod(x,x^2-1), Mod(x+1,x^2+1))
%2 = Mod(-1/2*x^2 + x + 1/2, x^4 - 1)
</pre></div>
</div>
<p>This function also allows vector and matrix arguments, in which case the
operation is recursively applied to each component of the vector or matrix.</p>
<div class="highlight-python"><div class="highlight"><pre>? chinese([Mod(1,2),Mod(1,3)], [Mod(1,5),Mod(2,7)])
%3 = [Mod(1, 10), Mod(16, 21)]
</pre></div>
</div>
<p>For polynomial arguments in the same variable, the function is applied to each
coefficient; if the polynomials have different degrees, the high degree terms
are copied verbatim in the result, as if the missing high degree terms in the
polynomial of lowest degree had been <tt class="docutils literal"><span class="pre">Mod(0,1)</span></tt>. Since the latter
behavior is usually <em>not</em> the desired one, we propose to convert the
polynomials to vectors of the same length first:</p>
<div class="highlight-python"><div class="highlight"><pre>? P = x+1; Q = x^2+2*x+1;
? chinese(P*Mod(1,2), Q*Mod(1,3))
%4 = Mod(1, 3)*x^2 + Mod(5, 6)*x + Mod(3, 6)
? chinese(Vec(P,3)*Mod(1,2), Vec(Q,3)*Mod(1,3))
%5 = [Mod(1, 6), Mod(5, 6), Mod(4, 6)]
? Pol(%)
%6 = Mod(1, 6)*x^2 + Mod(5, 6)*x + Mod(4, 6)
</pre></div>
</div>
<p>If <span class="math">\(y\)</span> is omitted, and <span class="math">\(x\)</span> is a vector, <tt class="docutils literal"><span class="pre">chinese</span></tt> is applied recursively
to the components of <span class="math">\(x\)</span>, yielding a residue belonging to the same class as all
components of <span class="math">\(x\)</span>.</p>
<p>Finally <span class="math">\(chinese(x,x) = x\)</span> regardless of the type of <span class="math">\(x\)</span>; this allows
vector arguments to contain other data, so long as they are identical in both
vectors.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.cmp">
<tt class="descname">cmp</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.cmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the result of a comparison between arbitrary objects <span class="math">\(x\)</span> and <span class="math">\(y\)</span>
(as <span class="math">\(-1\)</span>, <span class="math">\(0\)</span> or <span class="math">\(1\)</span>). The underlying order relation is transitive,
the function returns <span class="math">\(0\)</span> if and only if <span class="math">\(x&nbsp; === &nbsp;y\)</span>, and its
restriction to integers coincides with the customary one. Besides that,
it has no useful mathematical meaning.</p>
<p>In case all components are equal up to the smallest length of the operands,
the more complex is considered to be larger. More precisely, the longest is
the largest; when lengths are equal, we have matrix <span class="math">\(&gt;\)</span> vector <span class="math">\(&gt;\)</span> scalar.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre>? cmp(1, 2)
%1 = -1
? cmp(2, 1)
%2 = 1
? cmp(1, 1.0) \\ note that 1 == 1.0, but (1===1.0) is false.
%3 = -1
? cmp(x + Pi, [])
%4 = -1
</pre></div>
</div>
<p>This function is mostly useful to handle sorted lists or
vectors of arbitrary objects. For instance, if <span class="math">\(v\)</span> is a vector, the
construction <tt class="docutils literal"><span class="pre">vecsort(v,</span> <span class="pre">cmp)</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">Set(v)</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.component">
<tt class="descname">component</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.component" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts the <span class="math">\(n-th\)</span>-component of <span class="math">\(x\)</span>. This is to be understood
as follows: every PARI type has one or two initial code words. The
components are counted, starting at 1, after these code words. In particular
if <span class="math">\(x\)</span> is a vector, this is indeed the <span class="math">\(n-th\)</span>-component of <span class="math">\(x\)</span>, if
<span class="math">\(x\)</span> is a matrix, the <span class="math">\(n-th\)</span> column, if <span class="math">\(x\)</span> is a polynomial, the
<span class="math">\(n-th\)</span> coefficient (i.e.&nbsp;of degree <span class="math">\(n-1\)</span>), and for power series,
the <span class="math">\(n-th\)</span> significant coefficient.</p>
<p>For polynomials and power series, one should rather use <tt class="docutils literal"><span class="pre">polcoeff</span></tt>, and
for vectors and matrices, the <tt class="docutils literal"><span class="pre">[]</span></tt> operator. Namely, if <span class="math">\(x\)</span> is a
vector, then <tt class="docutils literal"><span class="pre">x[n]</span></tt> represents the <span class="math">\(n-th\)</span> component of <span class="math">\(x\)</span>. If
<span class="math">\(x\)</span> is a matrix, <tt class="docutils literal"><span class="pre">x[m,n]</span></tt> represents the coefficient of row <tt class="docutils literal"><span class="pre">m</span></tt> and
column <tt class="docutils literal"><span class="pre">n</span></tt> of the matrix, <tt class="docutils literal"><span class="pre">x[m,]</span></tt> represents the <span class="math">\(m-th\)</span>
<em>row</em> of <span class="math">\(x\)</span>, and <tt class="docutils literal"><span class="pre">x[,n]</span></tt> represents the <span class="math">\(n-th\)</span>
<em>column</em> of <span class="math">\(x\)</span>.</p>
<p>Using of this function requires detailed knowledge of the structure of the
different PARI types, and thus it should almost never be used directly.
Some useful exceptions:</p>
<div class="highlight-python"><div class="highlight"><pre>? x = 3 + O(3^5);
? component(x, 2)
%2 = 81 \\ p^(p-adic accuracy)
? component(x, 1)
%3 = 3 \\ p
? q = Qfb(1,2,3);
? component(q, 1)
%5 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.concat">
<tt class="descname">concat</tt><big>(</big><em>x</em>, <em>y=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenation of <span class="math">\(x\)</span> and <span class="math">\(y\)</span>. If <span class="math">\(x\)</span> or <span class="math">\(y\)</span> is
not a vector or matrix, it is considered as a one-dimensional vector. All
types are allowed for <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, but the sizes must be compatible. Note
that matrices are concatenated horizontally, i.e.&nbsp;the number of rows stays
the same. Using transpositions, one can concatenate them vertically,
but it is often simpler to use <tt class="docutils literal"><span class="pre">matconcat</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>? x = matid(2); y = 2*matid(2);
? concat(x,y)
%2 =
[1 0 2 0]

[0 1 0 2]
? concat(x~,y~)~
%3 =
[1 0]

[0 1]

[2 0]

[0 2]
? matconcat([x;y])
%4 =
[1 0]

[0 1]

[2 0]

[0 2]
</pre></div>
</div>
<p>To concatenate vectors sideways (i.e.&nbsp;to obtain a two-row or two-column
matrix), use <tt class="docutils literal"><span class="pre">Mat</span></tt> instead, or <tt class="docutils literal"><span class="pre">matconcat</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>? x = [1,2];
? y = [3,4];
? concat(x,y)
%3 = [1, 2, 3, 4]

? Mat([x,y]~)
%4 =
[1 2]

[3 4]
? matconcat([x;y])
%5 =
[1 2]

[3 4]
</pre></div>
</div>
<p>Concatenating a row vector to a matrix having the same number of columns will
add the row to the matrix (top row if the vector is <span class="math">\(x\)</span>, i.e.&nbsp;comes first, and
bottom row otherwise).</p>
<p>The empty matrix <tt class="docutils literal"><span class="pre">[;]</span></tt> is considered to have a number of rows compatible
with any operation, in particular concatenation. (Note that this is
<em>not</em> the case for empty vectors <tt class="docutils literal"><span class="pre">[&nbsp;]</span></tt> or <tt class="docutils literal"><span class="pre">[&nbsp;]~</span></tt>.)</p>
<p>If <span class="math">\(y\)</span> is omitted, <span class="math">\(x\)</span> has to be a row vector or a list, in which case its
elements are concatenated, from left to right, using the above rules.</p>
<div class="highlight-python"><div class="highlight"><pre>? concat([1,2], [3,4])
%1 = [1, 2, 3, 4]
? a = [[1,2]~, [3,4]~]; concat(a)
%2 =
[1 3]

[2 4]

? concat([1,2; 3,4], [5,6]~)
%3 =
[1 2 5]

[3 4 6]
? concat([%, [7,8]~, [1,2,3,4]])
%5 =
[1 2 5 7]

[3 4 6 8]

[1 2 3 4]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.conj">
<tt class="descname">conj</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Conjugate of <span class="math">\(x\)</span>. The meaning of this
is clear, except that for real quadratic numbers, it means conjugation in the
real quadratic field. This function has no effect on integers, reals,
intmods, fractions or <span class="math">\(p\)</span>-adics. The only forbidden type is polmod
(see <tt class="docutils literal"><span class="pre">conjvec</span></tt> for this).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.conjvec">
<tt class="descname">conjvec</tt><big>(</big><em>z</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.conjvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Conjugate vector representation of <span class="math">\(z\)</span>. If <span class="math">\(z\)</span> is a
polmod, equal to <tt class="docutils literal"><span class="pre">Mod</span></tt><span class="math">\((a,T)\)</span>, this gives a vector of length
<span class="math">\({degree}(T)\)</span> containing:</p>
<ul class="simple">
<li>the complex embeddings of <span class="math">\(z\)</span> if <span class="math">\(T\)</span> has rational coefficients,
i.e.&nbsp;the <span class="math">\(a(r[i])\)</span> where <span class="math">\(r = polroots(T)\)</span>;</li>
<li>the conjugates of <span class="math">\(z\)</span> if <span class="math">\(T\)</span> has some intmod coefficients;</li>
</ul>
<p>if <span class="math">\(z\)</span> is a finite field element, the result is the vector of
conjugates <span class="math">\([z,z^p,z^{p^2},...,z^{p^{n-1}}]\)</span> where <span class="math">\(n = {degree}(T)\)</span>.</p>
<p>If <span class="math">\(z\)</span> is an integer or a rational number, the result is&nbsp;<span class="math">\(z\)</span>. If
<span class="math">\(z\)</span> is a (row or column) vector, the result is a matrix whose columns are
the conjugate vectors of the individual elements of <span class="math">\(z\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.content">
<tt class="descname">content</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.content" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the gcd of all the coefficients of <span class="math">\(x\)</span>,
when this gcd makes sense. This is the natural definition
if <span class="math">\(x\)</span> is a polynomial (and by extension a power series) or a
vector/matrix. This is in general a weaker notion than the <em>ideal</em>
generated by the coefficients:</p>
<div class="highlight-python"><div class="highlight"><pre>? content(2*x+y)
%1 = 1 \\ = gcd(2,y) over Q[y]
</pre></div>
</div>
<p>If <span class="math">\(x\)</span> is a scalar, this simply returns the absolute value of <span class="math">\(x\)</span> if <span class="math">\(x\)</span> is
rational (<tt class="docutils literal"><span class="pre">t_INT</span></tt> or <tt class="docutils literal"><span class="pre">t_FRAC</span></tt>), and either <span class="math">\(1\)</span> (inexact input) or <span class="math">\(x\)</span>
(exact input) otherwise; the result should be identical to <tt class="docutils literal"><span class="pre">gcd(x,</span> <span class="pre">0)</span></tt>.</p>
<p>The content of a rational function is the ratio of the contents of the
numerator and the denominator. In recursive structures, if a
matrix or vector <em>coefficient</em> <span class="math">\(x\)</span> appears, the gcd is taken
not with <span class="math">\(x\)</span>, but with its content:</p>
<div class="highlight-python"><div class="highlight"><pre>? content([ [2], 4*matid(3) ])
%1 = 2
</pre></div>
</div>
<p>The content of a <tt class="docutils literal"><span class="pre">t_VECSMALL</span></tt> is computed assuming the
entries are signed integers in <span class="math">\([-2^{BIL-1}, 2^{BIL-1}[\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.contfrac">
<tt class="descname">contfrac</tt><big>(</big><em>x</em>, <em>b=None</em>, <em>nmax=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.contfrac" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the row vector whose components are the partial quotients of the
continued fraction expansion of <span class="math">\(x\)</span>. In other words, a result
<span class="math">\([a_0,...,a_n]\)</span> means that <span class="math">\(x ~ a_0+1/(a_1+...+1/a_n)\)</span>. The
output is normalized so that <span class="math">\(a_n != 1\)</span> (unless we also have <span class="math">\(n = 0\)</span>).</p>
<p>The number of partial quotients <span class="math">\(n+1\)</span> is limited by <tt class="docutils literal"><span class="pre">nmax</span></tt>. If
<tt class="docutils literal"><span class="pre">nmax</span></tt> is omitted, the expansion stops at the last significant partial
quotient.</p>
<div class="highlight-python"><div class="highlight"><pre>? \p19
 realprecision = 19 significant digits
? contfrac(Pi)
%1 = [3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2]
? contfrac(Pi,, 3) \\ n = 2
%2 = [3, 7, 15]
</pre></div>
</div>
<p><span class="math">\(x\)</span> can also be a rational function or a power series.</p>
<p>If a vector <span class="math">\(b\)</span> is supplied, the numerators are equal to the coefficients
of <span class="math">\(b\)</span>, instead of all equal to <span class="math">\(1\)</span> as above; more precisely, <span class="math">\(x ~ 
(1/b_0)(a_0+b_1/(a_1+...+b_n/a_n))\)</span>; for a numerical continued fraction
(<span class="math">\(x\)</span> real), the <span class="math">\(a_i\)</span> are integers, as large as possible; if <span class="math">\(x\)</span> is a
rational function, they are polynomials with <span class="math">\(\deg a_i = \deg b_i + 1\)</span>.
The length of the result is then equal to the length of <span class="math">\(b\)</span>, unless the next
partial quotient cannot be reliably computed, in which case the expansion
stops. This happens when a partial remainder is equal to zero (or too small
compared to the available significant digits for <span class="math">\(x\)</span> a <tt class="docutils literal"><span class="pre">t_REAL</span></tt>).</p>
<p>A direct implementation of the numerical continued fraction
<tt class="docutils literal"><span class="pre">contfrac(x,b)</span></tt> described above would be</p>
<div class="highlight-python"><div class="highlight"><pre>\\ &quot;greedy&quot; generalized continued fraction
cf(x, b) =
{ my( a= vector(#b), t );

 x *= b[1];
 for (i = 1, #b,
 a[i] = floor(x);
 t = x - a[i]; if (!t || i == #b, break);
 x = b[i+1] / t;
 ); a;
}
</pre></div>
</div>
<p>There is some degree of freedom when choosing the <span class="math">\(a_i\)</span>; the
program above can easily be modified to derive variants of the standard
algorithm. In the same vein, although no builtin
function implements the related Engel expansion (a special kind of
Egyptian fraction decomposition: <span class="math">\(x = 1/a_1 + 1/(a_1a_2) +...\)</span> ),
it can be obtained as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>\\ n terms of the Engel expansion of x
engel(x, n = 10) =
{ my( u = x, a = vector(n) );
 for (k = 1, n,
 a[k] = ceil(1/u);
 u = u*a[k] - 1;
 if (!u, break);
 ); a
}
</pre></div>
</div>
<p><strong>Obsolete hack.</strong> (don&#8217;t use this): If <span class="math">\(b\)</span> is an integer, <em>nmax</em>
is ignored and the command is understood as <tt class="docutils literal"><span class="pre">contfrac(:math:`x,,</span> <span class="pre">b</span></tt>)`.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.contfraceval">
<tt class="descname">contfraceval</tt><big>(</big><em>CF</em>, <em>t</em>, <em>lim=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.contfraceval" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a continued fraction <tt class="docutils literal"><span class="pre">CF</span></tt> output by <tt class="docutils literal"><span class="pre">contfracinit</span></tt>, evaluate
the first <tt class="docutils literal"><span class="pre">lim</span></tt> terms of the continued fraction at <tt class="docutils literal"><span class="pre">t</span></tt> (all
terms if <tt class="docutils literal"><span class="pre">lim</span></tt> is negative or omitted; if positive, <tt class="docutils literal"><span class="pre">lim</span></tt> must be
less than or equal to the length of <tt class="docutils literal"><span class="pre">CF</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.contfracinit">
<tt class="descname">contfracinit</tt><big>(</big><em>M</em>, <em>lim=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.contfracinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <span class="math">\(M\)</span> representing the power series <span class="math">\(S = \sum_{n &gt;= 0} M[n+1]z^n\)</span>,
transform it into a continued fraction; restrict to <span class="math">\(n &lt;= lim\)</span>
if latter is non-negative. <span class="math">\(M\)</span> can be a vector, a power
series, a polynomial, or a rational function.
The result is a 2-component vector <span class="math">\([A,B]\)</span> such that
<span class="math">\(S = M[1] / (1+A[1]z+B[1]z^2/(1+A[2]z+B[2]z^2/(1+...1/(1+A[lim/2]z))))\)</span>.
Does not work if any coefficient of <span class="math">\(M\)</span> vanishes, nor for series for
which certain partial denominators vanish.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.contfracpnqn">
<tt class="descname">contfracpnqn</tt><big>(</big><em>x</em>, <em>n=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.contfracpnqn" title="Permalink to this definition">¶</a></dt>
<dd><p>When <span class="math">\(x\)</span> is a vector or a one-row matrix, <span class="math">\(x\)</span>
is considered as the list of partial quotients <span class="math">\([a_0,a_1,...,a_n]\)</span> of a
rational number, and the result is the 2 by 2 matrix
<span class="math">\([p_n,p_{n-1};q_n,q_{n-1}]\)</span> in the standard notation of continued fractions,
so <span class="math">\(p_n/q_n = a_0+1/(a_1+...+1/a_n)\)</span>. If <span class="math">\(x\)</span> is a matrix with two rows
<span class="math">\([b_0,b_1,...,b_n]\)</span> and <span class="math">\([a_0,a_1,...,a_n]\)</span>, this is then considered as a
generalized continued fraction and we have similarly
<span class="math">\(p_n/q_n = (1/b_0)(a_0+b_1/(a_1+...+b_n/a_n))\)</span>. Note that in this case one
usually has <span class="math">\(b_0 = 1\)</span>.</p>
<p>If <span class="math">\(n &gt;= 0\)</span> is present, returns all convergents from <span class="math">\(p_0/q_0\)</span> up to
<span class="math">\(p_n/q_n\)</span>. (All convergents if <span class="math">\(x\)</span> is too small to compute the <span class="math">\(n+1\)</span>
requested convergents.)</p>
<div class="highlight-python"><div class="highlight"><pre>? a=contfrac(Pi,20)
%1 = [3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2, 2, 2]
? contfracpnqn(a,3)
%2 =
[3 22 333 355]

[1 7 106 113]

? contfracpnqn(a,7)
%3 =
[3 22 333 355 103993 104348 208341 312689]

[1 7 106 113 33102 33215 66317 99532]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.core">
<tt class="descname">core</tt><big>(</big><em>n</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.core" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(n\)</span> is an integer written as
<span class="math">\(n = df^2\)</span> with <span class="math">\(d\)</span> squarefree, returns <span class="math">\(d\)</span>. If <span class="math">\(flag\)</span> is non-zero,
returns the two-element row vector <span class="math">\([d,f]\)</span>. By convention, we write <span class="math">\(0 = 0
x 1^2\)</span>, so <tt class="docutils literal"><span class="pre">core(0,</span> <span class="pre">1)</span></tt> returns <span class="math">\([0,1]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.coredisc">
<tt class="descname">coredisc</tt><big>(</big><em>n</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.coredisc" title="Permalink to this definition">¶</a></dt>
<dd><p>A <em>fundamental discriminant</em> is an integer of the form <span class="math">\(t = 1
mod 4\)</span> or <span class="math">\(4t = 8,12 mod 16\)</span>, with <span class="math">\(t\)</span> squarefree (i.e.&nbsp;<span class="math">\(1\)</span> or the
discriminant of a quadratic number field). Given a non-zero integer
<span class="math">\(n\)</span>, this routine returns the (unique) fundamental discriminant <span class="math">\(d\)</span>
such that <span class="math">\(n = df^2\)</span>, <span class="math">\(f\)</span> a positive rational number. If <span class="math">\(flag\)</span> is non-zero,
returns the two-element row vector <span class="math">\([d,f]\)</span>. If <span class="math">\(n\)</span> is congruent to
0 or 1 modulo 4, <span class="math">\(f\)</span> is an integer, and a half-integer otherwise.</p>
<p>By convention, <tt class="docutils literal"><span class="pre">coredisc(0,</span> <span class="pre">1))</span></tt> returns <span class="math">\([0,1]\)</span>.</p>
<p>Note that <tt class="docutils literal"><span class="pre">quaddisc</span></tt><span class="math">\((n)\)</span> returns the same value as <tt class="docutils literal"><span class="pre">coredisc</span></tt><span class="math">\((n)\)</span>,
and also works with rational inputs <span class="math">\(n belongs to \mathbb{Q}^*\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.cos">
<tt class="descname">cos</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.cos" title="Permalink to this definition">¶</a></dt>
<dd><p>Cosine of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.cosh">
<tt class="descname">cosh</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.cosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Hyperbolic cosine of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.cotan">
<tt class="descname">cotan</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.cotan" title="Permalink to this definition">¶</a></dt>
<dd><p>Cotangent of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.denominator">
<tt class="descname">denominator</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.denominator" title="Permalink to this definition">¶</a></dt>
<dd><p>Denominator of <span class="math">\(x\)</span>. The meaning of this
is clear when <span class="math">\(x\)</span> is a rational number or function. If <span class="math">\(x\)</span> is an integer
or a polynomial, it is treated as a rational number or function,
respectively, and the result is equal to <span class="math">\(1\)</span>. For polynomials, you
probably want to use</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">denominator</span><span class="p">(</span> <span class="n">content</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>instead. As for modular objects, <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt> and <tt class="docutils literal"><span class="pre">t_PADIC</span></tt> have
denominator <span class="math">\(1\)</span>, and the denominator of a <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> is the denominator
of its (minimal degree) polynomial representative.</p>
<p>If <span class="math">\(x\)</span> is a recursive structure, for instance a vector or matrix, the lcm
of the denominators of its components (a common denominator) is computed.
This also applies for <tt class="docutils literal"><span class="pre">t_COMPLEX</span></tt>&nbsp;s and <tt class="docutils literal"><span class="pre">t_QUAD</span></tt>&nbsp;s.</p>
<p><strong>Warning.</strong> Multivariate objects are created according to variable
priorities, with possibly surprising side effects (<span class="math">\(x/y\)</span> is a polynomial, but
<span class="math">\(y/x\)</span> is a rational function). See <tt class="docutils literal"><span class="pre">priority</span></tt> (in the PARI manual).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.deriv">
<tt class="descname">deriv</tt><big>(</big><em>x</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.deriv" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of <span class="math">\(x\)</span> with respect to the main
variable if <span class="math">\(v\)</span> is omitted, and with respect to <span class="math">\(v\)</span> otherwise. The derivative
of a scalar type is zero, and the derivative of a vector or matrix is done
componentwise. One can use <span class="math">\(x'\)</span> as a shortcut if the derivative is with
respect to the main variable of <span class="math">\(x\)</span>.</p>
<p>By definition, the main variable of a <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> is the main variable among
the coefficients from its two polynomial components (representative and
modulus); in other words, assuming a polmod represents an element of
<span class="math">\(R[X]/(T(X))\)</span>, the variable <span class="math">\(X\)</span> is a mute variable and the derivative is
taken with respect to the main variable used in the base ring <span class="math">\(R\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.diffop">
<tt class="descname">diffop</tt><big>(</big><em>x</em>, <em>v</em>, <em>d</em>, <em>n=1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.diffop" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(v\)</span> be a vector of variables, and <span class="math">\(d\)</span> a vector of the same length,
return the image of <span class="math">\(x\)</span> by the <span class="math">\(n\)</span>-power (<span class="math">\(1\)</span> if n is not given) of the differential
operator <span class="math">\(D\)</span> that assumes the value <tt class="docutils literal"><span class="pre">d[i]</span></tt> on the variable <tt class="docutils literal"><span class="pre">v[i]</span></tt>.
The value of <span class="math">\(D\)</span> on a scalar type is zero, and <span class="math">\(D\)</span> applies componentwise to a vector
or matrix. When applied to a <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt>, if no value is provided for the variable
of the modulus, such value is derived using the implicit function theorem.</p>
<p>Some examples:
This function can be used to differentiate formal expressions:
If <span class="math">\(E = \exp(X^2)\)</span> then we have <span class="math">\(E' = 2*X*E\)</span>. We can derivate <span class="math">\(X*exp(X^2)\)</span> as follow:</p>
<div class="highlight-python"><div class="highlight"><pre>? diffop(E*X,[X,E],[1,2*X*E])
%1 = (2*X^2 + 1)*E
</pre></div>
</div>
<p>Let <tt class="docutils literal"><span class="pre">Sin</span></tt> and <tt class="docutils literal"><span class="pre">Cos</span></tt> be two function such that <span class="math">\(Sin^2+Cos^2 = 1\)</span>
and <span class="math">\(Cos' = -Sin\)</span>. We can differentiate <span class="math">\(Sin/Cos\)</span> as follow,
PARI inferring the value of <span class="math">\(Sin'\)</span> from the equation:</p>
<div class="highlight-python"><div class="highlight"><pre>? diffop(Mod(&#39;Sin/&#39;Cos,&#39;Sin^2+&#39;Cos^2-1),[&#39;Cos],[-&#39;Sin])
%1 = Mod(1/Cos^2, Sin^2 + (Cos^2 - 1))
</pre></div>
</div>
<p>Compute the Bell polynomials (both complete and partial) via the Faa di Bruno formula:</p>
<div class="highlight-python"><div class="highlight"><pre>Bell(k,n=-1)=
{
 my(var(i)=eval(Str(&quot;X&quot;,i)));
 my(x,v,dv);
 v=vector(k,i,if(i==1,&#39;E,var(i-1)));
 dv=vector(k,i,if(i==1,&#39;X*var(1)*&#39;E,var(i)));
 x=diffop(&#39;E,v,dv,k)/&#39;E;
 if(n&lt;0,subst(x,&#39;X,1),polcoeff(x,n,&#39;X))
}
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.digits">
<tt class="descname">digits</tt><big>(</big><em>x</em>, <em>b=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.digits" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the vector of the digits of <span class="math">\(\|x\|\)</span> in base <span class="math">\(b\)</span>, where <span class="math">\(x\)</span> and <span class="math">\(b\)</span> are integers.
See <tt class="docutils literal"><span class="pre">fromdigits</span></tt> for the reverse operation.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.dilog">
<tt class="descname">dilog</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.dilog" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of the dilogarithm of <span class="math">\(x\)</span>,
i.e.&nbsp;analytic continuation of the power series <span class="math">\(\log_2(x) = \sum_{n &gt;= 1}x^n/n^2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.dirdiv">
<tt class="descname">dirdiv</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.dirdiv" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> and <span class="math">\(y\)</span> being vectors of perhaps different
lengths but with <span class="math">\(y[1] != 0\)</span> considered as Dirichlet series, computes
the quotient of <span class="math">\(x\)</span> by <span class="math">\(y\)</span>, again as a vector.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.dirmul">
<tt class="descname">dirmul</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.dirmul" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> and <span class="math">\(y\)</span> being vectors of perhaps different lengths representing
the Dirichlet series <span class="math">\(\sum_n x_n n^{-s}\)</span> and <span class="math">\(\sum_n y_n n^{-s}\)</span>,
computes the product of <span class="math">\(x\)</span> by <span class="math">\(y\)</span>, again as a vector.</p>
<div class="highlight-python"><div class="highlight"><pre>? dirmul(vector(10,n,1), vector(10,n,moebius(n)))
%1 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</pre></div>
</div>
<p>The product
length is the minimum of <span class="math">\(\#&nbsp;x*&nbsp;v(y)\)</span> and <span class="math">\(\#&nbsp;y*&nbsp;v(x)\)</span>,
where <span class="math">\(v(x)\)</span> is the index of the first non-zero coefficient.</p>
<div class="highlight-python"><div class="highlight"><pre>? dirmul([0,1], [0,1]);
%2 = [0, 0, 0, 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.dirzetak">
<tt class="descname">dirzetak</tt><big>(</big><em>nf</em>, <em>b</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.dirzetak" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives as a vector the first <span class="math">\(b\)</span>
coefficients of the Dedekind zeta function of the number field <span class="math">\(nf\)</span>
considered as a Dirichlet series.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.divisors">
<tt class="descname">divisors</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.divisors" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a row vector whose components are the
divisors of <span class="math">\(x\)</span>. The factorization of <span class="math">\(x\)</span> (as output by <tt class="docutils literal"><span class="pre">factor</span></tt>) can
be used instead.</p>
<p>By definition, these divisors are the products of the irreducible
factors of <span class="math">\(n\)</span>, as produced by <tt class="docutils literal"><span class="pre">factor(n)</span></tt>, raised to appropriate
powers (no negative exponent may occur in the factorization). If <span class="math">\(n\)</span> is
an integer, they are the positive divisors, in increasing order.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.divrem">
<tt class="descname">divrem</tt><big>(</big><em>x</em>, <em>y</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.divrem" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a column vector with two components, the first being the Euclidean
quotient (<tt class="docutils literal"><span class="pre">:math:`x</span></tt> \:math:<span class="math">\(y`\)</span>), the second the Euclidean remainder
(<tt class="docutils literal"><span class="pre">:math:`x</span></tt> - (<span class="math">\(x\)</span>\:math:<span class="math">\(y\)</span>)*:math:<span class="math">\(y`\)</span>), of the division of <span class="math">\(x\)</span> by <span class="math">\(y\)</span>. This avoids the
need to do two divisions if one needs both the quotient and the remainder.
If <span class="math">\(v\)</span> is present, and <span class="math">\(x\)</span>, <span class="math">\(y\)</span> are multivariate
polynomials, divide with respect to the variable <span class="math">\(v\)</span>.</p>
<p>Beware that <tt class="docutils literal"><span class="pre">divrem(:math:`x</span></tt>,:math:<span class="math">\(y\)</span>)[2]` is in general not the same as
<tt class="docutils literal"><span class="pre">:math:`x</span></tt> % <span class="math">\(y`\)</span>; no GP operator corresponds to it:</p>
<div class="highlight-python"><div class="highlight"><pre>? divrem(1/2, 3)[2]
%1 = 1/2
? (1/2) % 3
%2 = 2
? divrem(Mod(2,9), 3)[2]
 *** at top-level: divrem(Mod(2,9),3)[2
 *** ^--------------------
 *** forbidden division t_INTMOD \ t_INT.
? Mod(2,9) % 6
%3 = Mod(2,3)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.eint1">
<tt class="descname">eint1</tt><big>(</big><em>x</em>, <em>n=None</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.eint1" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential integral <span class="math">\(\int_x^ oo (e^{-t})/(t)dt = 
incgam(0, x)\)</span>, where the latter expression extends the function
definition from real <span class="math">\(x &gt; 0\)</span> to all complex <span class="math">\(x != 0\)</span>.</p>
<p>If <span class="math">\(n\)</span> is present, we must have <span class="math">\(x &gt; 0\)</span>; the function returns the
<span class="math">\(n\)</span>-dimensional vector <span class="math">\([eint1(x),...,eint1(nx)]\)</span>. Contrary to
other transcendental functions, and to the default case (<span class="math">\(n\)</span> omitted), the
values are correct up to a bounded <em>absolute</em>, rather than relative,
error <span class="math">\(10^-n\)</span>, where <span class="math">\(n\)</span> is <tt class="docutils literal"><span class="pre">precision</span></tt><span class="math">\((x)\)</span> if <span class="math">\(x\)</span> is a <tt class="docutils literal"><span class="pre">t_REAL</span></tt>
and defaults to <tt class="docutils literal"><span class="pre">realprecision</span></tt> otherwise. (In the most important
application, to the computation of <span class="math">\(L\)</span>-functions via approximate functional
equations, those values appear as weights in long sums and small individual
relative errors are less useful than controlling the absolute error.) This is
faster than repeatedly calling <tt class="docutils literal"><span class="pre">eint1(:math:`i</span></tt> * x)`, but less precise.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellL1">
<tt class="descname">ellL1</tt><big>(</big><em>e</em>, <em>r=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellL1" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value at <span class="math">\(s = 1\)</span> of the derivative of order <span class="math">\(r\)</span> of the
<span class="math">\(L\)</span>-function of the elliptic curve <span class="math">\(e\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? e = ellinit(&quot;11a1&quot;); \\ order of vanishing is 0
? ellL1(e)
%2 = 0.2538418608559106843377589233
? e = ellinit(&quot;389a1&quot;); \\ order of vanishing is 2
? ellL1(e)
%4 = -5.384067311837218089235032414 E-29
? ellL1(e, 1)
%5 = 0
? ellL1(e, 2)
%6 = 1.518633000576853540460385214
</pre></div>
</div>
<p>The main use of this function, after computing at <em>low</em> accuracy the
order of vanishing using <tt class="docutils literal"><span class="pre">ellanalyticrank</span></tt>, is to compute the
leading term at <em>high</em> accuracy to check (or use) the Birch and
Swinnerton-Dyer conjecture:</p>
<div class="highlight-python"><div class="highlight"><pre>? \p18
 realprecision = 18 significant digits
? e = ellinit(&quot;5077a1&quot;); ellanalyticrank(e)
time = 8 ms.
%1 = [3, 10.3910994007158041]
? \p200
 realprecision = 202 significant digits (200 digits displayed)
? ellL1(e, 3)
time = 104 ms.
%3 = 10.3910994007158041387518505103609170697263563756570092797[...]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elladd">
<tt class="descname">elladd</tt><big>(</big><em>E</em>, <em>z1</em>, <em>z2</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elladd" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of the points <span class="math">\(z1\)</span> and <span class="math">\(z2\)</span> on the
elliptic curve corresponding to <span class="math">\(E\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellak">
<tt class="descname">ellak</tt><big>(</big><em>E</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellak" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the coefficient <span class="math">\(a_n\)</span> of the <span class="math">\(L\)</span>-function of the elliptic curve
<span class="math">\(E/\mathbb{Q}\)</span>, i.e.&nbsp;coefficients of a newform of weight 2 by the modularity theorem
(Taniyama-Shimura-Weil conjecture). <span class="math">\(E\)</span> must be an <em>ell</em> structure
over <span class="math">\(\mathbb{Q}\)</span> as output by <tt class="docutils literal"><span class="pre">ellinit</span></tt>. <span class="math">\(E\)</span> must be given by an integral model,
not necessarily minimal, although a minimal model will make the function
faster.</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([0,1]);
? ellak(E, 10)
%2 = 0
? e = ellinit([5^4,5^6]); \\ not minimal at 5
? ellak(e, 5) \\ wasteful but works
%3 = -3
? E = ellminimalmodel(e); \\ now minimal
? ellak(E, 5)
%5 = -3
</pre></div>
</div>
<p>If the model is not minimal at a number of bad primes, then
the function will be slower on those <span class="math">\(n\)</span> divisible by the bad primes.
The speed should be comparable for other <span class="math">\(n\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>? for(i=1,10^6, ellak(E,5))
time = 820 ms.
? for(i=1,10^6, ellak(e,5)) \\ 5 is bad, markedly slower
time = 1,249 ms.

? for(i=1,10^5,ellak(E,5*i))
time = 977 ms.
? for(i=1,10^5,ellak(e,5*i)) \\ still slower but not so much on average
time = 1,008 ms.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellan">
<tt class="descname">ellan</tt><big>(</big><em>E</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellan" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the vector of the first <span class="math">\(n\)</span> Fourier coefficients <span class="math">\(a_k\)</span>
corresponding to the elliptic curve <span class="math">\(E\)</span>. The curve must be given by an
integral model, not necessarily minimal, although a minimal model will make
the function faster.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellanalyticrank">
<tt class="descname">ellanalyticrank</tt><big>(</big><em>e</em>, <em>eps=None</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellanalyticrank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the order of vanishing at <span class="math">\(s = 1\)</span> of the <span class="math">\(L\)</span>-function of the
elliptic curve <span class="math">\(e\)</span> and the value of the first non-zero derivative. To
determine this order, it is assumed that any value less than <tt class="docutils literal"><span class="pre">eps</span></tt> is
zero. If no value of <tt class="docutils literal"><span class="pre">eps</span></tt> is given, a value of half the current
precision is used.</p>
<div class="highlight-python"><div class="highlight"><pre>? e = ellinit(&quot;11a1&quot;); \\ rank 0
? ellanalyticrank(e)
%2 = [0, 0.2538418608559106843377589233]
? e = ellinit(&quot;37a1&quot;); \\ rank 1
? ellanalyticrank(e)
%4 = [1, 0.3059997738340523018204836835]
? e = ellinit(&quot;389a1&quot;); \\ rank 2
? ellanalyticrank(e)
%6 = [2, 1.518633000576853540460385214]
? e = ellinit(&quot;5077a1&quot;); \\ rank 3
? ellanalyticrank(e)
%8 = [3, 10.39109940071580413875185035]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellap">
<tt class="descname">ellap</tt><big>(</big><em>E</em>, <em>p=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellap" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(E\)</span> be an <em>ell</em> structure as output by <tt class="docutils literal"><span class="pre">ellinit</span></tt>, defined over
<span class="math">\(\mathbb{Q}\)</span> or a finite field <span class="math">\(\mathbb{F}_q\)</span>. The argument <span class="math">\(p\)</span> is best left omitted if the
curve is defined over a finite field, and must be a prime number otherwise.
This function computes the trace of Frobenius <span class="math">\(t\)</span> for the elliptic curve <span class="math">\(E\)</span>,
defined by the equation <span class="math">\(\#E(\mathbb{F}_q) = q+1 - t\)</span>.</p>
<p>If the curve is defined over <span class="math">\(\mathbb{Q}\)</span>, <span class="math">\(p\)</span> must be explicitly given and the
function computes the trace of the reduction over <span class="math">\(\mathbb{F}_p\)</span>.
The trace of Frobenius is also the <span class="math">\(a_p\)</span> coefficient in the curve <span class="math">\(L\)</span>-series
<span class="math">\(L(E,s) = \sum_n a_n n^{-s}\)</span>, whence the function name. The equation must be
integral at <span class="math">\(p\)</span> but need not be minimal at <span class="math">\(p\)</span>; of course, a minimal model
will be more efficient.</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([0,1]); \\ y^2 = x^3 + 0.x + 1, defined over Q
? ellap(E, 7) \\ 7 necessary here
%2 = -4 \\ #E(F_7) = 7+1-(-4) = 12
? ellcard(E, 7)
%3 = 12 \\ OK

? E = ellinit([0,1], 11); \\ defined over F_11
? ellap(E) \\ no need to repeat 11
%4 = 0
? ellap(E, 11) \\ ... but it also works
%5 = 0
? ellgroup(E, 13) \\ ouch, inconsistent input!
 *** at top-level: ellap(E,13)
 *** ^-----------
 *** ellap: inconsistent moduli in Rg_to_Fp:
 11
 13

? Fq = ffgen(ffinit(11,3), &#39;a); \\ defines F_q := F_{11^3}
? E = ellinit([a+1,a], Fq); \\ y^2 = x^3 + (a+1)x + a, defined over F_q
? ellap(E)
%8 = -3
</pre></div>
</div>
<p><strong>Algorithms used.</strong> If <span class="math">\(E/\mathbb{F}_q\)</span> has CM by a principal imaginary
quadratic order we use a fast explicit formula (involving essentially Kronecker
symbols and Cornacchia&#8217;s algorithm), in <span class="math">\(O(\log q)^2\)</span>.
Otherwise, we use Shanks-Mestre&#8217;s baby-step/giant-step method, which runs in
time <span class="math">\(~{O}(q^{1/4})\)</span> using <span class="math">\(~{O}(q^{1/4})\)</span> storage, hence becomes
unreasonable when <span class="math">\(q\)</span> has about 30&nbsp;digits. If the <tt class="docutils literal"><span class="pre">seadata</span></tt> package is
installed, the <tt class="docutils literal"><span class="pre">SEA</span></tt> algorithm becomes available, heuristically in
<span class="math">\(~{O}(\log q)^4\)</span>, and primes of the order of 200&nbsp;digits become feasible.
In very small characteristic (2,3,5,7 or <span class="math">\(13\)</span>), we use Harley&#8217;s algorithm.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellbil">
<tt class="descname">ellbil</tt><big>(</big><em>E</em>, <em>z1</em>, <em>z2</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellbil" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated alias for <tt class="docutils literal"><span class="pre">ellheight(E,P,Q)</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellcard">
<tt class="descname">ellcard</tt><big>(</big><em>E</em>, <em>p=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellcard" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(E\)</span> be an <em>ell</em> structure as output by <tt class="docutils literal"><span class="pre">ellinit</span></tt>, defined over
<span class="math">\(\mathbb{Q}\)</span> or a finite field <span class="math">\(\mathbb{F}_q\)</span>. The argument <span class="math">\(p\)</span> is best left omitted if the
curve is defined over a finite field, and must be a prime number otherwise.
This function computes the order of the group <span class="math">\(E(\mathbb{F}_q)\)</span> (as would be
computed by <tt class="docutils literal"><span class="pre">ellgroup</span></tt>).</p>
<p>If the curve is defined over <span class="math">\(\mathbb{Q}\)</span>, <span class="math">\(p\)</span> must be explicitly given and the
function computes the cardinality of the reduction over <span class="math">\(\mathbb{F}_p\)</span>; the
equation need not be minimal at <span class="math">\(p\)</span>, but a minimal model will be more
efficient. The reduction is allowed to be singular, and we return the order
of the group of non-singular points in this case.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellchangecurve">
<tt class="descname">ellchangecurve</tt><big>(</big><em>E</em>, <em>v</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellchangecurve" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the data for the elliptic curve <span class="math">\(E\)</span>
by changing the coordinates using the vector <tt class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">[u,r,s,t]</span></tt>, i.e.&nbsp;if <span class="math">\(x'\)</span>
and <span class="math">\(y'\)</span> are the new coordinates, then <span class="math">\(x = u^2x'+r\)</span>, <span class="math">\(y = u^3y'+su^2x'+t\)</span>.
<span class="math">\(E\)</span> must be an <em>ell</em> structure as output by <tt class="docutils literal"><span class="pre">ellinit</span></tt>. The special
case <span class="math">\(v = 1\)</span> is also used instead of <span class="math">\([1,0,0,0]\)</span> to denote the
trivial coordinate change.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellchangepoint">
<tt class="descname">ellchangepoint</tt><big>(</big><em>x</em>, <em>v</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellchangepoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the coordinates of the point or
vector of points <span class="math">\(x\)</span> using the vector <tt class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">[u,r,s,t]</span></tt>, i.e.&nbsp;if <span class="math">\(x'\)</span> and
<span class="math">\(y'\)</span> are the new coordinates, then <span class="math">\(x = u^2x'+r\)</span>, <span class="math">\(y = u^3y'+su^2x'+t\)</span> (see also
<tt class="docutils literal"><span class="pre">ellchangecurve</span></tt>).</p>
<div class="highlight-python"><div class="highlight"><pre>? E0 = ellinit([1,1]); P0 = [0,1]; v = [1,2,3,4];
? E = ellchangecurve(E0, v);
? P = ellchangepoint(P0,v)
%3 = [-2, 3]
? ellisoncurve(E, P)
%4 = 1
? ellchangepointinv(P,v)
%5 = [0, 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellchangepointinv">
<tt class="descname">ellchangepointinv</tt><big>(</big><em>x</em>, <em>v</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellchangepointinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the coordinates of the point or vector of points <span class="math">\(x\)</span> using
the inverse of the isomorphism associated to <tt class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">[u,r,s,t]</span></tt>,
i.e.&nbsp;if <span class="math">\(x'\)</span> and <span class="math">\(y'\)</span> are the old coordinates, then <span class="math">\(x = u^2x'+r\)</span>,
<span class="math">\(y = u^3y'+su^2x'+t\)</span> (inverse of <tt class="docutils literal"><span class="pre">ellchangepoint</span></tt>).</p>
<div class="highlight-python"><div class="highlight"><pre>? E0 = ellinit([1,1]); P0 = [0,1]; v = [1,2,3,4];
? E = ellchangecurve(E0, v);
? P = ellchangepoint(P0,v)
%3 = [-2, 3]
? ellisoncurve(E, P)
%4 = 1
? ellchangepointinv(P,v)
%5 = [0, 1] \\ we get back P0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellconvertname">
<tt class="descname">ellconvertname</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellconvertname" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an elliptic curve name, as found in the <tt class="docutils literal"><span class="pre">elldata</span></tt> database,
from a string to a triplet <span class="math">\([conductor, isogeny class,
index]\)</span>. It will also convert a triplet back to a curve name.
Examples:</p>
<div class="highlight-python"><div class="highlight"><pre>? ellconvertname(&quot;123b1&quot;)
%1 = [123, 1, 1]
? ellconvertname(%)
%2 = &quot;123b1&quot;
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elldivpol">
<tt class="descname">elldivpol</tt><big>(</big><em>E</em>, <em>n</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elldivpol" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(n\)</span>-division polynomial <span class="math">\(f_n\)</span> for the curve <span class="math">\(E\)</span> in the
variable <span class="math">\(v\)</span>. In standard notation, for any affine point <span class="math">\(P = (X,Y)\)</span> on the
curve, we have</p>
<div class="math">
\[[n]P = (\phi_n(P)\psi_n(P) : \omega_n(P) : \psi_n(P)^3)\]</div>
<p>for some polynomials <span class="math">\(\phi_n,\omega_n,\psi_n\)</span> in
<span class="math">\(\mathbb{Z}[a_1,a_2,a_3,a_4,a_6][X,Y]\)</span>. We have <span class="math">\(f_n(X) = \psi_n(X)\)</span> for <span class="math">\(n\)</span> odd, and
<span class="math">\(f_n(X) = \psi_n(X,Y) (2Y + a_1X+a_3)\)</span> for <span class="math">\(n\)</span> even. We have</p>
<div class="math">
\[f_1 = 1, f_2 = 4X^3 + b_2X^2 + 2b_4 X + b_6, f_3 = 3 X^4 + b_2 X^3 + 3b_4 X^2 + 3 b_6 X + b8,\]</div>
<div class="math">
\[f_4 = f_2(2X^6 + b_2 X^5 + 5b_4 X^4 + 10 b_6 X^3 + 10 b_8 X^2 +
(b_2b_8-b_4b_6)X + (b_8b_4 - b_6^2)),...\]</div>
<p>For <span class="math">\(n &gt;= 2\)</span>, the roots of <span class="math">\(f_n\)</span> are the <span class="math">\(X\)</span>-coordinates of points in <span class="math">\(E[n]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elleisnum">
<tt class="descname">elleisnum</tt><big>(</big><em>w</em>, <em>k</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elleisnum" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(k\)</span> being an even positive integer, computes the numerical value of the
Eisenstein series of weight <span class="math">\(k\)</span> at the lattice <span class="math">\(w\)</span>, as given by
<tt class="docutils literal"><span class="pre">ellperiods</span></tt>, namely</p>
<div class="math">
\[\begin{split}(2i \Pi/\omega_2)^k
(1 + 2/\zeta(1-k) \sum_{n &gt;= 1} n^{k-1}q^n / (1-q^n)),\end{split}\]</div>
<p>where <span class="math">\(q = \exp(2i\Pi \tau)\)</span> and <span class="math">\(\tau := \omega_1/\omega_2\)</span> belongs to the
complex upper half-plane. It is also possible to directly input <span class="math">\(w = 
[\omega_1,\omega_2]\)</span>, or an elliptic curve <span class="math">\(E\)</span> as given by <tt class="docutils literal"><span class="pre">ellinit</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>? w = ellperiods([1,I]);
? elleisnum(w, 4)
%2 = 2268.8726415508062275167367584190557607
? elleisnum(w, 6)
%3 = -3.977978632282564763 E-33
? E = ellinit([1, 0]);
? elleisnum(E, 4, 1)
%5 = -47.999999999999999999999999999999999998
</pre></div>
</div>
<p>When <em>flag</em> is non-zero and <span class="math">\(k = 4\)</span> or 6, returns the elliptic invariants <span class="math">\(g_2\)</span>
or <span class="math">\(g_3\)</span>, such that</p>
<div class="math">
\[y^2 = 4x^3 - g_2 x - g_3\]</div>
<p>is a Weierstrass equation for <span class="math">\(E\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elleta">
<tt class="descname">elleta</tt><big>(</big><em>w</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elleta" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the quasi-periods <span class="math">\([\eta_1,\eta_2]\)</span>
associated to the lattice basis <span class="math">\(w = [\omega_1, \omega_2]\)</span>.
Alternatively, <em>w</em> can be an elliptic curve <span class="math">\(E\)</span> as output by
<tt class="docutils literal"><span class="pre">ellinit</span></tt>, in which case, the quasi periods associated to the period
lattice basis <tt class="docutils literal"><span class="pre">:math:`E</span></tt>.omega` (namely, <tt class="docutils literal"><span class="pre">:math:`E</span></tt>.eta`) are returned.</p>
<div class="highlight-python"><div class="highlight"><pre>? elleta([1, I])
%1 = [3.141592653589793238462643383, 9.424777960769379715387930149*I]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellformaldifferential">
<tt class="descname">ellformaldifferential</tt><big>(</big><em>E</em>, <em>serprec=-1</em>, <em>n=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellformaldifferential" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(\omega := dx / (2y+a_1x+a_3\)</span> be the invariant differential form
associated to the model <span class="math">\(E\)</span> of some elliptic curve (<tt class="docutils literal"><span class="pre">ellinit</span></tt> form),
and <span class="math">\(\eta := x(t)\omega\)</span>. Return <span class="math">\(n\)</span> terms (<tt class="docutils literal"><span class="pre">seriesprecision</span></tt> by default)
of <span class="math">\(f(t),g(t)\)</span> two power series in the formal parameter <span class="math">\(t = -x/y\)</span> such that
<span class="math">\(\omega = f(t) dt\)</span>, <span class="math">\(\eta = g(t) dt\)</span>:</p>
<div class="math">
\[f(t) = 1+a_1 t + (a_1^2 + a_2) t^2 +..., 
g(t) = t^{-2} +...\]</div>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([-1,1/4]); [f,g] = ellformaldifferential(E,7,&#39;t);
? f
%2 = 1 - 2*t^4 + 3/4*t^6 + O(t^7)
? g
%3 = t^-2 - t^2 + 1/2*t^4 + O(t^5)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellformalexp">
<tt class="descname">ellformalexp</tt><big>(</big><em>E</em>, <em>serprec=-1</em>, <em>n=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellformalexp" title="Permalink to this definition">¶</a></dt>
<dd><p>The elliptic formal exponential <tt class="docutils literal"><span class="pre">Exp</span></tt> attached to <span class="math">\(E\)</span> is the
isomorphism from the formal additive law to the formal group of <span class="math">\(E\)</span>. It is
normalized so as to be the inverse of the elliptic logarithm (see
<tt class="docutils literal"><span class="pre">ellformallog</span></tt>): <span class="math">\(Exp o L = \mathrm{Id}\)</span>. Return <span class="math">\(n\)</span> terms of this
power series:</p>
<div class="highlight-python"><div class="highlight"><pre>? E=ellinit([-1,1/4]); Exp = ellformalexp(E,10,&#39;z)
%1 = z + 2/5*z^5 - 3/28*z^7 + 2/15*z^9 + O(z^11)
? L = ellformallog(E,10,&#39;t);
? subst(Exp,z,L)
%3 = t + O(t^11)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellformallog">
<tt class="descname">ellformallog</tt><big>(</big><em>E</em>, <em>serprec=-1</em>, <em>n=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellformallog" title="Permalink to this definition">¶</a></dt>
<dd><p>The formal elliptic logarithm is a series <span class="math">\(L\)</span> in <span class="math">\(t K[[t]]\)</span>
such that <span class="math">\(d L = \omega = dx / (2y + a_1x + a_3\)</span>, the canonical invariant
differential attached to the model <span class="math">\(E\)</span>. It gives an isomorphism
from the formal group of <span class="math">\(E\)</span> to the additive formal group.</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([-1,1/4]); L = ellformallog(E, 9, &#39;t)
%1 = t - 2/5*t^5 + 3/28*t^7 + 2/3*t^9 + O(t^10)
? [f,g] = ellformaldifferential(E,8,&#39;t);
? L&#39; - f
%3 = O(t^8)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellformalpoint">
<tt class="descname">ellformalpoint</tt><big>(</big><em>E</em>, <em>serprec=-1</em>, <em>n=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellformalpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(E\)</span> is an elliptic curve, return the coordinates <span class="math">\(x(t), y(t)\)</span> in the
formal group of the elliptic curve <span class="math">\(E\)</span> in the formal parameter <span class="math">\(t = -x/y\)</span>
at <span class="math">\(oo\)</span>:</p>
<div class="math">
\[x = t^{-2} -a_1 t^{-1} - a_2 - a_3 t +...\]</div>
<div class="math">
\[y = - t^{-3} -a_1 t^{-2} - a_2t^{-1} -a_3 +...\]</div>
<p>Return <span class="math">\(n\)</span> terms (<tt class="docutils literal"><span class="pre">seriesprecision</span></tt> by default) of these two power
series, whose coefficients are in <span class="math">\(\mathbb{Z}[a_1,a_2,a_3,a_4,a_6]\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([0,0,1,-1,0]); [x,y] = ellformalpoint(E,8);
? x
%2 = x^-2 - x + x^2 - x^4 + 2*x^5 + O(x^6)
? y
%3 = -x^-3 + 1 - x + x^3 - 2*x^4 + O(x^5)
? E = ellinit([0,1/2]); ellformalpoint(E,7)
%4 = [x^-2 - 1/2*x^4 + O(x^5), -x^-3 + 1/2*x^3 + O(x^4)]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellformalw">
<tt class="descname">ellformalw</tt><big>(</big><em>E</em>, <em>serprec=-1</em>, <em>n=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellformalw" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the formal power series <span class="math">\(w\)</span> associated to the elliptic curve <span class="math">\(E\)</span>,
in the variable <span class="math">\(t\)</span>:</p>
<div class="math">
\[w(t) = t^3 + a_1 t^4 + (a_2 + a_1^2) t^5 +...+ O(t^{n+3}),\]</div>
<p>which is the formal expansion of <span class="math">\(-1/y\)</span> in the formal parameter <span class="math">\(t := -x/y\)</span>
at <span class="math">\(oo\)</span> (take <span class="math">\(n = seriesprecision\)</span> if <span class="math">\(n\)</span> is omitted). The
coefficients of <span class="math">\(w\)</span> belong to <span class="math">\(\mathbb{Z}[a_1,a_2,a_3,a_4,a_6]\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? E=ellinit([3,2,-4,-2,5]); ellformalw(E, 5, &#39;t)
%1 = t^3 + 3*t^4 + 11*t^5 + 35*t^6 + 101*t^7 + O(t^8)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellfromeqn">
<tt class="descname">ellfromeqn</tt><big>(</big><em>P</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellfromeqn" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a genus <span class="math">\(1\)</span> plane curve, defined by the affine equation <span class="math">\(f(x,y) = 0\)</span>,
return the coefficients <span class="math">\([a_1,a_2,a_3,a_4,a_6]\)</span> of a Weierstrass equation
for its Jacobian. This allows to recover a Weierstrass model for an elliptic
curve given by a general plane cubic or by a binary quartic or biquadratic
model.</p>
<p>The function implements the <span class="math">\(f :---&gt;&nbsp;f^*\)</span> formulae of Artin, Tate and
Villegas (Advances in Math. 198 (2005), pp. 366&#8211;382).</p>
<p>In the example below, the function is used to convert between twisted Edward
coordinates and Weierstrass coordinates.</p>
<div class="highlight-python"><div class="highlight"><pre>? e = ellfromeqn(a*x^2+y^2-(1+d*x^2*y^2))
%1 = [0,-a-d,0,-4*d*a,4*d*a^2+4*d^2*a]
? E = ellinit(ellfromeqn(y^2-x^2 - 1 +(121665/121666*x^2*y^2)),2^255-19);
? ellcard(E)
%2 = 57896044618658097711785492504343953926856930875039260848015607506283634007912
</pre></div>
</div>
<p>The elliptic curve associated to the sum of two cubes is given by</p>
<div class="highlight-python"><div class="highlight"><pre>? ellfromeqn(x^3+y^3-a)
%1 = [0,0,-9*a,0,-27*a^2]
</pre></div>
</div>
<p>Congruent number problem: Let <span class="math">\(n\)</span> be an integer,
if <span class="math">\(a^2+b^2 = c^2\)</span> and <span class="math">\(a b = 2 n\)</span>,
then by substituting <span class="math">\(b\)</span> by <span class="math">\(2 n/a\)</span> in the first equation,
we get <span class="math">\(((a^2+(2 n/a)^2)-c^2)*a^2 = 0\)</span>.
We set <span class="math">\(x = a\)</span>, <span class="math">\(y = a*c\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? ellfromeqn((x^2+(2*n/x)^2-(y/x)^2)*x^2)
%1 = [0,0,0,-16*n^2,0]
</pre></div>
</div>
<p>For example <span class="math">\(23\)</span> is congruent since the curve has a point of infinite order,
namely:</p>
<div class="highlight-python"><div class="highlight"><pre>? ellheegner(ellinit(subst([0,0,0,-16*n^2,0],n,23)))
%2 = [168100/289,68053440/4913]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellfromj">
<tt class="descname">ellfromj</tt><big>(</big><em>j</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellfromj" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coefficients <span class="math">\([a_1,a_2,a_3,a_4,a_6]\)</span> of a fixed elliptic curve
with <span class="math">\(j\)</span>-invariant <span class="math">\(j\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellgenerators">
<tt class="descname">ellgenerators</tt><big>(</big><em>E</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellgenerators" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(E\)</span> is an elliptic curve over the rationals, return a <span class="math">\(\mathbb{Z}\)</span>-basis of the
free part of the Mordell-Weil group associated to <span class="math">\(E\)</span>. This relies on
the <tt class="docutils literal"><span class="pre">elldata</span></tt> database being installed and referencing the curve, and so
is only available for curves over <span class="math">\(\mathbb{Z}\)</span> of small conductors.
If <span class="math">\(E\)</span> is an elliptic curve over a finite field <span class="math">\(\mathbb{F}_q\)</span> as output by
<tt class="docutils literal"><span class="pre">ellinit</span></tt>, return a minimal set of generators for the group <span class="math">\(E(\mathbb{F}_q)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellglobalred">
<tt class="descname">ellglobalred</tt><big>(</big><em>E</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellglobalred" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the arithmetic conductor, the global
minimal model of <span class="math">\(E\)</span> and the global Tamagawa number <span class="math">\(c\)</span>.
<span class="math">\(E\)</span> must be an <em>ell</em> structure as output by <tt class="docutils literal"><span class="pre">ellinit</span></tt>, defined over
<span class="math">\(\mathbb{Q}\)</span>. The result is a vector <span class="math">\([N,v,c,F,L]\)</span>, where</p>
<ul class="simple">
<li><span class="math">\(N\)</span> is the arithmetic conductor of the curve,</li>
<li><span class="math">\(v\)</span> gives the coordinate change for <span class="math">\(E\)</span> over <span class="math">\(\mathbb{Q}\)</span> to the minimal
integral model (see <tt class="docutils literal"><span class="pre">ellminimalmodel</span></tt>),</li>
<li><span class="math">\(c\)</span> is the product of the local Tamagawa numbers <span class="math">\(c_p\)</span>, a quantity
which enters in the Birch and Swinnerton-Dyer conjecture,</li>
<li><span class="math">\(F\)</span> is the factorization of <span class="math">\(N\)</span> over <span class="math">\(\mathbb{Z}\)</span>.</li>
<li><span class="math">\(L\)</span> is a vector, whose <span class="math">\(i\)</span>-th entry contains the local data
at the <span class="math">\(i\)</span>-th prime divisor of <span class="math">\(N\)</span>, i.e. <tt class="docutils literal"><span class="pre">L[i]</span> <span class="pre">=</span> <span class="pre">elllocalred(E,F[i,1])</span></tt>,
where the local coordinate change has been deleted, and replaced by a <span class="math">\(0\)</span>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellgroup">
<tt class="descname">ellgroup</tt><big>(</big><em>E</em>, <em>p=None</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellgroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(E\)</span> be an <em>ell</em> structure as output by <tt class="docutils literal"><span class="pre">ellinit</span></tt>, defined over
<span class="math">\(\mathbb{Q}\)</span> or a finite field <span class="math">\(\mathbb{F}_q\)</span>. The argument <span class="math">\(p\)</span> is best left omitted if the
curve is defined over a finite field, and must be a prime number otherwise.
This function computes the structure of the group <span class="math">\(E(\mathbb{F}_q) ~ \mathbb{Z}/d_1\mathbb{Z}
x \mathbb{Z}/d_2\mathbb{Z}\)</span>, with <span class="math">\(d_2 \| d_1\)</span>.</p>
<p>If the curve is defined over <span class="math">\(\mathbb{Q}\)</span>, <span class="math">\(p\)</span> must be explicitly given and the
function computes the structure of the reduction over <span class="math">\(\mathbb{F}_p\)</span>; the
equation need not be minimal at <span class="math">\(p\)</span>, but a minimal model will be more
efficient. The reduction is allowed to be singular, and we return the
structure of the (cyclic) group of non-singular points in this case.</p>
<p>If the flag is <span class="math">\(0\)</span> (default), return <span class="math">\([d_1]\)</span> or <span class="math">\([d_1, d_2]\)</span>, if <span class="math">\(d_2 &gt; 1\)</span>.
If the flag is <span class="math">\(1\)</span>, return a triple <span class="math">\([h,cyc,gen]\)</span>, where
<span class="math">\(h\)</span> is the curve cardinality, <em>cyc</em> gives the group structure as a
product of cyclic groups (as per <span class="math">\(flag = 0\)</span>). More precisely, if <span class="math">\(d_2 &gt; 1\)</span>,
the output is <span class="math">\([d_1d_2, [d_1,d_2],[P,Q]]\)</span> where <span class="math">\(P\)</span> is
of order <span class="math">\(d_1\)</span> and <span class="math">\([P,Q]\)</span> generates the curve.
<strong>Caution.</strong> It is not guaranteed that <span class="math">\(Q\)</span> has order <span class="math">\(d_2\)</span>, which in
the worst case requires an expensive discrete log computation. Only that
<tt class="docutils literal"><span class="pre">ellweilpairing(E,</span> <span class="pre">P,</span> <span class="pre">Q,</span> <span class="pre">d1)</span></tt> has order <span class="math">\(d_2\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([0,1]); \\ y^2 = x^3 + 0.x + 1, defined over Q
? ellgroup(E, 7)
%2 = [6, 2] \\ Z/6 x Z/2, non-cyclic
? E = ellinit([0,1] * Mod(1,11)); \\ defined over F_11
? ellgroup(E) \\ no need to repeat 11
%4 = [12]
? ellgroup(E, 11) \\ ... but it also works
%5 = [12]
? ellgroup(E, 13) \\ ouch, inconsistent input!
 *** at top-level: ellgroup(E,13)
 *** ^--------------
 *** ellgroup: inconsistent moduli in Rg_to_Fp:
 11
 13
? ellgroup(E, 7, 1)
%6 = [12, [6, 2], [[Mod(2, 7), Mod(4, 7)], [Mod(4, 7), Mod(4, 7)]]]
</pre></div>
</div>
<p>If <span class="math">\(E\)</span> is defined over <span class="math">\(\mathbb{Q}\)</span>, we allow singular reduction and in this case we
return the structure of the group of non-singular points, satisfying
<span class="math">\(\#E_{ns}(\mathbb{F}_p) = p - a_p\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([0,5]);
? ellgroup(E, 5, 1)
%2 = [5, [5], [[Mod(4, 5), Mod(2, 5)]]]
? ellap(E, 5)
%3 = 0 \\ additive reduction at 5
? E = ellinit([0,-1,0,35,0]);
? ellgroup(E, 5, 1)
%5 = [4, [4], [[Mod(2, 5), Mod(2, 5)]]]
? ellap(E, 5)
%6 = 1 \\ split multiplicative reduction at 5
? ellgroup(E, 7, 1)
%7 = [8, [8], [[Mod(3, 7), Mod(5, 7)]]]
? ellap(E, 7)
%8 = -1 \\ non-split multiplicative reduction at 7
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellheegner">
<tt class="descname">ellheegner</tt><big>(</big><em>E</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellheegner" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(E\)</span> be an elliptic curve over the rationals, assumed to be of
(analytic) rank <span class="math">\(1\)</span>. This returns a non-torsion rational point on the curve,
whose canonical height is equal to the product of the elliptic regulator by the
analytic Sha.</p>
<p>This uses the Heegner point method, described in Cohen GTM 239; the complexity
is proportional to the product of the square root of the conductor and the
height of the point (thus, it is preferable to apply it to strong Weil curves).</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([-157^2,0]);
? u = ellheegner(E); print(u[1], &quot;\n&quot;, u[2])
69648970982596494254458225/166136231668185267540804
538962435089604615078004307258785218335/67716816556077455999228495435742408
? ellheegner(ellinit([0,1])) \\ E has rank 0 !
 *** at top-level: ellheegner(E=ellinit
 *** ^--------------------
 *** ellheegner: The curve has even analytic rank.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellheight">
<tt class="descname">ellheight</tt><big>(</big><em>E</em>, <em>P</em>, <em>Q=None</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellheight" title="Permalink to this definition">¶</a></dt>
<dd><p>Global Néron-Tate height <span class="math">\(h(P)\)</span> of the point <span class="math">\(P\)</span> on the elliptic curve
<span class="math">\(E/\mathbb{Q}\)</span>, using the normalization in Cremona&#8217;s <em>Algorithms for modular
elliptic curves</em>. <span class="math">\(E\)</span> must be an <tt class="docutils literal"><span class="pre">ell</span></tt> as output by <tt class="docutils literal"><span class="pre">ellinit</span></tt>; it
needs not be given by a minimal model although the computation will be faster
if it is.</p>
<p>If the argument <span class="math">\(Q\)</span> is present, computes the value of the bilinear
form <span class="math">\((h(P+Q)-h(P-Q)) / 4\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellheightmatrix">
<tt class="descname">ellheightmatrix</tt><big>(</big><em>E</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellheightmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> being a vector of points, this
function outputs the Gram matrix of <span class="math">\(x\)</span> with respect to the Néron-Tate
height, in other words, the <span class="math">\((i,j)\)</span> component of the matrix is equal to
<tt class="docutils literal"><span class="pre">ellbil(:math:`E</span></tt>,x[<span class="math">\(i\)</span>],x[<span class="math">\(j\)</span>])`. The rank of this matrix, at least in some
approximate sense, gives the rank of the set of points, and if <span class="math">\(x\)</span> is a
basis of the Mordell-Weil group of <span class="math">\(E\)</span>, its determinant is equal to
the regulator of <span class="math">\(E\)</span>. Note our height normalization follows Cremona&#8217;s
<em>Algorithms for modular elliptic curves</em>: this matrix should be divided
by 2 to be in accordance with, e.g., Silverman&#8217;s normalizations.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellidentify">
<tt class="descname">ellidentify</tt><big>(</big><em>E</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellidentify" title="Permalink to this definition">¶</a></dt>
<dd><p>Look up the elliptic curve <span class="math">\(E\)</span>, defined by an arbitrary model over <span class="math">\(\mathbb{Q}\)</span>,
in the <tt class="docutils literal"><span class="pre">elldata</span></tt> database.
Return <tt class="docutils literal"><span class="pre">[[N,</span> <span class="pre">M,</span> <span class="pre">G],</span> <span class="pre">C]</span></tt> where <span class="math">\(N\)</span> is the curve name in Cremona&#8217;s
elliptic curve database, <span class="math">\(M\)</span> is the minimal model, <span class="math">\(G\)</span> is a <span class="math">\(\mathbb{Z}\)</span>-basis of
the free part of the Mordell-Weil group <span class="math">\(E(\mathbb{Q})\)</span> and <span class="math">\(C\)</span> is the
change of coordinates change, suitable for <tt class="docutils literal"><span class="pre">ellchangecurve</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellinit">
<tt class="descname">ellinit</tt><big>(</big><em>x</em>, <em>D=None</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an <tt class="docutils literal"><span class="pre">ell</span></tt> structure, associated to the elliptic curve <span class="math">\(E\)</span>.
<span class="math">\(E\)</span> is either</p>
<ul class="simple">
<li>a <span class="math">\(5\)</span>-component vector <span class="math">\([a_1,a_2,a_3,a_4,a_6]\)</span> defining the elliptic
curve with Weierstrass equation</li>
</ul>
<div class="math">
\[Y^2 + a_1 XY + a_3 Y = X^3 + a_2 X^2 + a_4 X + a_6,\]</div>
<ul class="simple">
<li>a <span class="math">\(2\)</span>-component vector <span class="math">\([a_4,a_6]\)</span> defining the elliptic
curve with short Weierstrass equation</li>
</ul>
<div class="math">
\[Y^2 = X^3 + a_4 X + a_6,\]</div>
<ul class="simple">
<li>a character string in Cremona&#8217;s notation, e.g. <tt class="docutils literal"><span class="pre">&quot;11a1&quot;</span></tt>, in which
case the curve is retrieved from the <tt class="docutils literal"><span class="pre">elldata</span></tt> database if available.</li>
</ul>
<p>The optional argument <span class="math">\(D\)</span> describes the domain over which the curve is
defined:</p>
<ul class="simple">
<li>the <tt class="docutils literal"><span class="pre">t_INT</span></tt> <span class="math">\(1\)</span> (default): the field of rational numbers <span class="math">\(\mathbb{Q}\)</span>.</li>
<li>a <tt class="docutils literal"><span class="pre">t_INT</span></tt> <span class="math">\(p\)</span>, where <span class="math">\(p\)</span> is a prime number: the prime finite field
<span class="math">\(\mathbb{F}_p\)</span>.</li>
<li>an <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt> <tt class="docutils literal"><span class="pre">Mod(a,</span> <span class="pre">p)</span></tt>, where <span class="math">\(p\)</span> is a prime number: the
prime finite field <span class="math">\(\mathbb{F}_p\)</span>.</li>
<li>a <tt class="docutils literal"><span class="pre">t_FFELT</span></tt>, as returned by <tt class="docutils literal"><span class="pre">ffgen</span></tt>: the corresponding finite
field <span class="math">\(\mathbb{F}_q\)</span>.</li>
<li>a <tt class="docutils literal"><span class="pre">t_PADIC</span></tt>, <span class="math">\(O(p^n)\)</span>: the field <span class="math">\(\mathbb{Q}_p\)</span>, where <span class="math">\(p\)</span>-adic quantities
will be computed to a relative accuracy of <span class="math">\(n\)</span> digits. We advise to input a
model defined over <span class="math">\(\mathbb{Q}\)</span> for such curves. In any case, if you input an
approximate model with <tt class="docutils literal"><span class="pre">t_PADIC</span></tt> coefficients, it will be replaced by a lift
to <span class="math">\(\mathbb{Q}\)</span> (an exact model &#8220;close&#8221; to the one that was input) and all quantities
will then be computed in terms of this lifted model, at the given accuracy.</li>
<li>a <tt class="docutils literal"><span class="pre">t_REAL</span></tt> <span class="math">\(x\)</span>: the field <span class="math">\(\mathbb{C}\)</span> of complex numbers, where floating
point quantities are by default computed to a relative accuracy of
<tt class="docutils literal"><span class="pre">precision</span></tt><span class="math">\((x)\)</span>. If no such argument is given, the value of
<tt class="docutils literal"><span class="pre">realprecision</span></tt> at the time <tt class="docutils literal"><span class="pre">ellinit</span></tt> is called will be used.</li>
<li>a number field <span class="math">\(K\)</span>, given by a <em>nf</em> or <em>bnf</em> structure.</li>
<li>a prime ideal <span class="math">\(p\)</span>, given by a <em>prid</em> structure; valid if
<span class="math">\(x\)</span> is a curve defined over a number field <span class="math">\(K\)</span> and the equation is integral
and minimal at <span class="math">\(p\)</span>.</li>
</ul>
<p>This argument <span class="math">\(D\)</span> is indicative: the curve coefficients are checked for
compatibility, possibly changing <span class="math">\(D\)</span>; for instance if <span class="math">\(D = 1\)</span> and
an <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt> is found. If inconsistencies are detected, an error is
raised:</p>
<div class="highlight-python"><div class="highlight"><pre>? ellinit([1 + O(5), 1], O(7));
 *** at top-level: ellinit([1+O(5),1],O
 *** ^--------------------
 *** ellinit: inconsistent moduli in ellinit: 7 != 5
</pre></div>
</div>
<p>If the curve coefficients are too general to fit any of the
above domain categories, only basic operations, such as point addition, will
be supported later.</p>
<p>If the curve (seen over the domain <span class="math">\(D\)</span>) is singular, fail and return an
empty vector <span class="math">\([]\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([0,0,0,0,1]); \\ y^2 = x^3 + 1, over Q
? E = ellinit([0,1]); \\ the same curve, short form
? E = ellinit(&quot;36a1&quot;); \\ sill the same curve, Cremona&#39;s notations
? E = ellinit([0,1], 2) \\ over F2: singular curve
%4 = []
? E = ellinit([&#39;a4,&#39;a6] * Mod(1,5)); \\ over F_5[a4,a6], basic support !
</pre></div>
</div>
<p>The result of <tt class="docutils literal"><span class="pre">ellinit</span></tt> is an <em>ell</em> structure. It contains at least
the following information in its components:</p>
<div class="math">
\[a_1,a_2,a_3,a_4,a_6,b_2,b_4,b_6,b_8,c_4,c_6,\Delta,j.\]</div>
<p>All are accessible via member functions. In particular, the discriminant is
<tt class="docutils literal"><span class="pre">:math:`E</span></tt>.disc`, and the <span class="math">\(j\)</span>-invariant is <tt class="docutils literal"><span class="pre">:math:`E</span></tt>.j`.</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([a4, a6]);
? E.disc
%2 = -64*a4^3 - 432*a6^2
? E.j
%3 = -6912*a4^3/(-4*a4^3 - 27*a6^2)
</pre></div>
</div>
<p>Further components contain domain-specific data, which are in general dynamic:
only computed when needed, and then cached in the structure.</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([2,3], 10^60+7); \\ E over F_p, p large
? ellap(E)
time = 4,440 ms.
%2 = -1376268269510579884904540406082
? ellcard(E); \\ now instantaneous !
time = 0 ms.
? ellgenerators(E);
time = 5,965 ms.
? ellgenerators(E); \\ second time instantaneous
time = 0 ms.
</pre></div>
</div>
<p>See the description of member functions related to elliptic curves at the
beginning of this section.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellisogeny">
<tt class="descname">ellisogeny</tt><big>(</big><em>E</em>, <em>G</em>, <em>only_image=0</em>, <em>x=None</em>, <em>y=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellisogeny" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an elliptic curve <span class="math">\(E\)</span>, a finite subgroup <span class="math">\(G\)</span> of <span class="math">\(E\)</span> is given either
as a generating point <span class="math">\(P\)</span> (for a cyclic <span class="math">\(G\)</span>) or as a polynomial whose roots
vanish on the <span class="math">\(x\)</span>-coordinates of the non-zero elements of <span class="math">\(G\)</span> (general case
and more efficient if available). This function returns the
<span class="math">\([a_1,a_2,a_3,a_4,a_6]\)</span> invariants of the quotient elliptic curve <span class="math">\(E/G\)</span> and
(if <em>only_image</em> is zero (the default)) a vector of rational
functions <span class="math">\([f, g, h]\)</span> such that the isogeny <span class="math">\(E \\to E/G\)</span> is given by <span class="math">\((x,y)
:---&gt;(f(x)/h(x)^2, g(x,y)/h(x)^3)\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([0,1]);
? elltors(E)
%2 = [6, [6], [[2, 3]]]
? ellisogeny(E, [2,3], 1) \\ Weierstrass model for E/&lt;P&gt;
%3 = [0, 0, 0, -135, -594]
? ellisogeny(E,[-1,0])
%4 = [[0,0,0,-15,22], [x^3+2*x^2+4*x+3, y*x^3+3*y*x^2-2*y, x+1]]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellisogenyapply">
<tt class="descname">ellisogenyapply</tt><big>(</big><em>f</em>, <em>g</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellisogenyapply" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an isogeny of elliptic curves <span class="math">\(f:E'\\to E\)</span> (being the result of a call
to <tt class="docutils literal"><span class="pre">ellisogeny</span></tt>), apply <span class="math">\(f\)</span> to <span class="math">\(x\)</span>:</p>
<ul class="simple">
<li>if <span class="math">\(x\)</span> is a point <span class="math">\(P\)</span> in the domain of <span class="math">\(f\)</span>, return the image <span class="math">\(f(P)\)</span>;</li>
<li>if <span class="math">\(x\)</span> is a compatible isogeny <span class="math">\(g:E&quot;\\to E'\)</span>, return the composite
isogeny <span class="math">\(f o g: E&quot;\to E\)</span>.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? one = ffgen(101, &#39;t)^0;
? E = ellinit([6, 53, 85, 32, 34] * one);
? P = [84, 71] * one;
? ellorder(E, P)
%4 = 5
? [F, f] = ellisogeny(E, P); \\ f: E-&gt;F = E/&lt;P&gt;
? ellisogenyapply(f, P)
%6 = [0]
? F = ellinit(F);
? Q = [89, 44] * one;
? ellorder(F, Q)
%9 = 2;
? [G, g] = ellisogeny(F, Q); \\ g: F-&gt;G = F/&lt;Q&gt;
? gof = ellisogenyapply(g, f); \\ gof: E -&gt; G
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellisoncurve">
<tt class="descname">ellisoncurve</tt><big>(</big><em>E</em>, <em>z</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellisoncurve" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives 1 (i.e.&nbsp;true) if the point <span class="math">\(z\)</span> is on the elliptic curve <span class="math">\(E\)</span>, 0
otherwise. If <span class="math">\(E\)</span> or <span class="math">\(z\)</span> have imprecise coefficients, an attempt is made to
take this into account, i.e.&nbsp;an imprecise equality is checked, not a precise
one. It is allowed for <span class="math">\(z\)</span> to be a vector of points in which case a vector
(of the same type) is returned.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellissupersingular">
<tt class="descname">ellissupersingular</tt><big>(</big><em>E</em>, <em>p=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellissupersingular" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1 if the elliptic curve <span class="math">\(E\)</span> defined over Q or a finite field is supersingular
at <span class="math">\(p\)</span>, and <span class="math">\(0\)</span> otherwise.
If the curve is defined over <span class="math">\(\mathbb{Q}\)</span>, <span class="math">\(p\)</span> must be explicitly given and have good
reduction at <span class="math">\(p\)</span>.
Alternatively, <span class="math">\(E\)</span> can be given byt its <span class="math">\(j\)</span>-invariant in a finite field. In
this case <span class="math">\(p\)</span> must be omitted.</p>
<div class="highlight-python"><div class="highlight"><pre>? g = ffprimroot(ffgen(7^5))
%1 = x^3 + 2*x^2 + 3*x + 1
? [g^n | n &lt;- [1 .. 7^5 - 1], ellissupersingular(g^n)]
%2 = [6]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellj">
<tt class="descname">ellj</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellj" title="Permalink to this definition">¶</a></dt>
<dd><p>Elliptic <span class="math">\(j\)</span>-invariant. <span class="math">\(x\)</span> must be a complex number
with positive imaginary part, or convertible into a power series or a
<span class="math">\(p\)</span>-adic number with positive valuation.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elllocalred">
<tt class="descname">elllocalred</tt><big>(</big><em>E</em>, <em>p</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elllocalred" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Kodaira type of the local fiber of the elliptic curve
<span class="math">\(E\)</span> at <span class="math">\(p\)</span>. <span class="math">\(E\)</span> must be an <em>ell</em> structure as output by
<tt class="docutils literal"><span class="pre">ellinit</span></tt>, over <span class="math">\(\mathbb{Q}\)</span> (<span class="math">\(p\)</span> a rational prime) or a number field <span class="math">\(K\)</span> (<span class="math">\(p\)</span>
a maximal ideal given by a <em>prid</em> structure), and is assumed to have all
its coefficients <span class="math">\(a_i\)</span> integral.
The result is a 4-component vector <span class="math">\([f,kod,v,c]\)</span>. Here <span class="math">\(f\)</span> is the exponent of
<span class="math">\(p\)</span> in the arithmetic conductor of <span class="math">\(E\)</span>, and <span class="math">\(kod\)</span> is the Kodaira type which
is coded as follows:</p>
<p>1 means good reduction (type I:math:<span class="math">\(_0\)</span>), 2, 3 and 4 mean types II, III and IV
respectively, <span class="math">\(4+\nu\)</span> with <span class="math">\(\nu &gt; 0\)</span> means type I:math:<span class="math">\(_\nu\)</span>;
finally the opposite values <span class="math">\(-1\)</span>, <span class="math">\(-2\)</span>, etc.&nbsp;refer to the starred types
I:math:<span class="math">\(_0^*\)</span>, II:math:<span class="math">\(^*\)</span>, etc. The third component <span class="math">\(v\)</span> is itself a vector <span class="math">\([u,r,s,t]\)</span>
giving the coordinate changes done during the local reduction;
<span class="math">\(u = 1\)</span> if and only if the given equation was already minimal at <span class="math">\(p\)</span>.
Finally, the last component <span class="math">\(c\)</span> is the local Tamagawa number <span class="math">\(c_p\)</span>.</p>
<p><strong>Caveat.</strong> If <span class="math">\(E\)</span> is not defined over <span class="math">\(\mathbb{Q}\)</span>, the current
implementation requires that <span class="math">\(p\)</span> be above a prime <span class="math">\(&gt;= 5\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elllog">
<tt class="descname">elllog</tt><big>(</big><em>E</em>, <em>P</em>, <em>G</em>, <em>o=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elllog" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two points <span class="math">\(P\)</span> and <span class="math">\(G\)</span> on the elliptic curve <span class="math">\(E/\mathbb{F}_q\)</span>, returns the
discrete logarithm of <span class="math">\(P\)</span> in base <span class="math">\(G\)</span>, i.e. the smallest non-negative
integer <span class="math">\(n\)</span> such that <span class="math">\(P = [n]G\)</span>.
See <tt class="docutils literal"><span class="pre">znlog</span></tt> for the limitations of the underlying discrete log algorithms.
If present, <span class="math">\(o\)</span> represents the order of <span class="math">\(G\)</span>, see <tt class="docutils literal"><span class="pre">DLfun</span></tt> (in the PARI manual);
the preferred format for this parameter is <tt class="docutils literal"><span class="pre">[N,</span> <span class="pre">factor(N)]</span></tt>, where <span class="math">\(N\)</span>
is the order of <span class="math">\(G\)</span>.</p>
<p>If no <span class="math">\(o\)</span> is given, assume that <span class="math">\(G\)</span> generates the curve.
The function also assumes that <span class="math">\(P\)</span> is a multiple of <span class="math">\(G\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? a = ffgen(ffinit(2,8),&#39;a);
? E = ellinit([a,1,0,0,1]); \\ over F_{2^8}
? x = a^3; y = ellordinate(E,x)[1];
? P = [x,y]; G = ellmul(E, P, 113);
? ord = [242, factor(242)]; \\ P generates a group of order 242. Initialize.
? ellorder(E, G, ord)
%4 = 242
? e = elllog(E, P, G, ord)
%5 = 15
? ellmul(E,G,e) == P
%6 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elllseries">
<tt class="descname">elllseries</tt><big>(</big><em>E</em>, <em>s</em>, <em>A=None</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elllseries" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(E\)</span> being an elliptic curve, given by an arbitrary model over <span class="math">\(\mathbb{Q}\)</span> as output
by <tt class="docutils literal"><span class="pre">ellinit</span></tt>, this function computes the value of the <span class="math">\(L\)</span>-series of <span class="math">\(E\)</span> at
the (complex) point <span class="math">\(s\)</span>. This function uses an <span class="math">\(O(N^{1/2})\)</span> algorithm, where
<span class="math">\(N\)</span> is the conductor.</p>
<p>The optional parameter <span class="math">\(A\)</span> fixes a cutoff point for the integral and is best
left omitted; the result must be independent of <span class="math">\(A\)</span>, up to
<tt class="docutils literal"><span class="pre">realprecision</span></tt>, so this allows to check the function&#8217;s accuracy.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellmul">
<tt class="descname">ellmul</tt><big>(</big><em>E</em>, <em>z</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes <span class="math">\([n]z\)</span>, where <span class="math">\(z\)</span> is a point on the elliptic curve <span class="math">\(E\)</span>. The
exponent <span class="math">\(n\)</span> is in <span class="math">\(\mathbb{Z}\)</span>, or may be a complex quadratic integer if the curve <span class="math">\(E\)</span>
has complex multiplication by <span class="math">\(n\)</span> (if not, an error message is issued).</p>
<div class="highlight-python"><div class="highlight"><pre>? Ei = ellinit([1,0]); z = [0,0];
? ellmul(Ei, z, 10)
%2 = [0] \\ unsurprising: z has order 2
? ellmul(Ei, z, I)
%3 = [0, 0] \\ Ei has complex multiplication by Z[i]
? ellmul(Ei, z, quadgen(-4))
%4 = [0, 0] \\ an alternative syntax for the same query
? Ej = ellinit([0,1]); z = [-1,0];
? ellmul(Ej, z, I)
 *** at top-level: ellmul(Ej,z,I)
 *** ^--------------
 *** ellmul: not a complex multiplication in ellmul.
? ellmul(Ej, z, 1+quadgen(-3))
%6 = [1 - w, 0]
</pre></div>
</div>
<p>The simple-minded algorithm for the CM case assumes that we are in
characteristic <span class="math">\(0\)</span>, and that the quadratic order to which <span class="math">\(n\)</span> belongs has
small discriminant.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellneg">
<tt class="descname">ellneg</tt><big>(</big><em>E</em>, <em>z</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellneg" title="Permalink to this definition">¶</a></dt>
<dd><p>Opposite of the point <span class="math">\(z\)</span> on elliptic curve <span class="math">\(E\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellnonsingularmultiple">
<tt class="descname">ellnonsingularmultiple</tt><big>(</big><em>E</em>, <em>P</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellnonsingularmultiple" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an elliptic curve <span class="math">\(E/\mathbb{Q}\)</span> (more precisely, a model defined over <span class="math">\(\mathbb{Q}\)</span>
of a curve) and a rational point <span class="math">\(P belongs to E(\mathbb{Q})\)</span>, returns the pair <span class="math">\([R,n]\)</span>,
where <span class="math">\(n\)</span> is the least positive integer such that <span class="math">\(R := [n]P\)</span> has good
reduction at every prime. More precisely, its image in a minimal model is
everywhere non-singular.</p>
<div class="highlight-python"><div class="highlight"><pre>? e = ellinit(&quot;57a1&quot;); P = [2,-2];
? ellnonsingularmultiple(e, P)
%2 = [[1, -1], 2]
? e = ellinit(&quot;396b2&quot;); P = [35, -198];
? [R,n] = ellnonsingularmultiple(e, P);
? n
%5 = 12
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellorder">
<tt class="descname">ellorder</tt><big>(</big><em>E</em>, <em>z</em>, <em>o=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the order of the point <span class="math">\(z\)</span> on the elliptic
curve <span class="math">\(E\)</span>, defined over a finite field or a number field.
Return (the impossible value) zero if the point has infinite order.</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([-157^2,0]); \\ the &quot;157-is-congruent&quot; curve
? P = [2,2]; ellorder(E, P)
%2 = 2
? P = ellheegner(E); ellorder(E, P) \\ infinite order
%3 = 0
? K = nfinit(polcyclo(11,t)); E=ellinit(&quot;11a3&quot;, K); T = elltors(E);
? ellorder(E, T.gen[1])
%5 = 25
? E = ellinit(ellfromj(ffgen(5^10)));
? ellcard(E)
%7 = 9762580
? P = random(E); ellorder(E, P)
%8 = 4881290
? p = 2^160+7; E = ellinit([1,2], p);
? N = ellcard(E)
%9 = 1461501637330902918203686560289225285992592471152
? o = [N, factor(N)];
? for(i=1,100, ellorder(E,random(E)))
time = 260 ms.
</pre></div>
</div>
<p>The parameter <span class="math">\(o\)</span>, is now mostly useless, and kept for backward
compatibility. If present, it represents a non-zero multiple of the order
of <span class="math">\(z\)</span>, see <tt class="docutils literal"><span class="pre">DLfun</span></tt> (in the PARI manual); the preferred format for this parameter is
<tt class="docutils literal"><span class="pre">[ord,</span> <span class="pre">factor(ord)]</span></tt>, where <tt class="docutils literal"><span class="pre">ord</span></tt> is the cardinality of the curve.
It is no longer needed since PARI is now able to compute it over large
finite fields (was restricted to small prime fields at the time this feature
was introduced), <em>and</em> caches the result in <span class="math">\(E\)</span> so that it is computed
and factored only once. Modifying the last example, we see that including
this extra parameter provides no improvement:</p>
<div class="highlight-python"><div class="highlight"><pre>? o = [N, factor(N)];
? for(i=1,100, ellorder(E,random(E),o))
time = 260 ms.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellordinate">
<tt class="descname">ellordinate</tt><big>(</big><em>E</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellordinate" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a 0, 1 or 2-component vector containing
the <span class="math">\(y\)</span>-coordinates of the points of the curve <span class="math">\(E\)</span> having <span class="math">\(x\)</span> as
<span class="math">\(x\)</span>-coordinate.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellpadicL">
<tt class="descname">ellpadicL</tt><big>(</big><em>E</em>, <em>p</em>, <em>n</em>, <em>r=0</em>, <em>D=None</em>, <em>character=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellpadicL" title="Permalink to this definition">¶</a></dt>
<dd><p>The <span class="math">\(p\)</span>-adic <span class="math">\(L\)</span> function is defined on the set of continuous characters
of <span class="math">\({Gal}(\mathbb{Q}(\mu_{p^{ oo }})/ \mathbb{Q})\)</span>, identified to <span class="math">\(\mathbb{Z}_p^*\)</span>
via the cyclotomic character <span class="math">\(\chi_p\)</span> with values in <span class="math">\(\\overline{Q_p}^*\)</span>.
Denote by <span class="math">\(tau:\mathbb{Z}_p^*\\to\mathbb{Z}_p^*\)</span> the Teichmüller character.</p>
<p>When <span class="math">\(E\)</span> has good supersingular reduction, the <span class="math">\(L\)</span> function takes its
values in <span class="math">\(\mathbb{Q}_p \\otimes H^1_{dR}(E/\mathbb{Q})\)</span> and satisfies</p>
<div class="math">
\[(1-p^{-1} F)^{-2} L_p(E, \tau^0) = (L(E,1) / \Omega).\omega\]</div>
<p>where <span class="math">\(F\)</span> is the Frobenius, <span class="math">\(L(E,1)\)</span> is the value of the complex <span class="math">\(L\)</span>
function at <span class="math">\(1\)</span>, <span class="math">\(\omega\)</span> is the Néron differential
and <span class="math">\(\Omega\)</span> its associated period on <span class="math">\(E(\mathbb{R})\)</span>. Here, <span class="math">\(\tau^0\)</span> represents
the trivial character.</p>
<p>The derivative is taken at <span class="math">\(s = 1\)</span> along <span class="math">\(&lt;\chi_p^s&gt;\)</span>.
In other words, the function <span class="math">\(L_p\)</span> is defined as
<span class="math">\(\int_{\mathbb{Z}_p^*} d \mu\)</span> for a certain <span class="math">\(p\)</span>-adic distribution <span class="math">\(\mu\)</span> on
<span class="math">\(\mathbb{Z}_p^*\)</span>, and we have</p>
<div class="math">
\[L_p^{(r)}(E, \tau^0) = \int_{\mathbb{Z}_p^*} \log_p^r(a) d\mu(a).\]</div>
<p>The function returns the components of <span class="math">\(L_p{(r)}(E,\tau^0)\)</span> in
the basis <span class="math">\((\omega, F(\omega))\)</span>.</p>
<p>When <span class="math">\(E\)</span> has ordinary good reduction, this method only defines
the projection of <span class="math">\(L_p(E,\tau^0)\)</span> on the <span class="math">\(\alpha\)</span>-eigenspace,
where <span class="math">\(\alpha\)</span> is the unit eigenvalue for <span class="math">\(F\)</span>. This is what the function
returns. This value satisfies</p>
<div class="math">
\[(1- \alpha^{-1})^{-2} L_{p,\alpha}(E,\tau^0) = L(E,1) / \Omega.\]</div>
<div class="highlight-python"><div class="highlight"><pre>? cxL(e) = bestappr( ellL1(e,0) / e.omega[1] );

? e = ellinit(&quot;17a1&quot;); p=3; \\ supersingular
? L = ellpadicL(e,p,4);
? F = [0,-p;1,ellap(e,p)]; \\ Frobenius matrix in the basis (omega,F(omega)
? (1-p^(-1)*F)^-2 * L~ / cxL(e)
%4 = [1 + O(3^4), O(3^4)]~

? p=5; ap = ellap(e,p); \\ ordinary
? L = ellpadicL(e,p,4);
? al = padicappr(x^2 - ap*x + p, ap + O(p^7))[1];
? (1-al^(-1))^(-2) * L / cxL(e)
%8 = 1 + O(5^4)

? e = ellinit(&quot;116a1&quot;); p=3; \\ supersingular
? L = ellpadicL(e,p,4);
? F = [0,-p; 1,ellap(e,p)];
? (1-p^(-1)*F)^-2*L~ / cxL(e)
%12 = [1 + O(3^4), O(3^5)]~

? e = ellinit(&quot;26b1&quot;); p=3;
? L = ellpadicL(e,p,4);
? F = [0,-p;1,ellap(e,p)];
? (1-p^(-1)*F)^-2*L~ / cxL(e)
%16 = [1 + O(3^4), O(3^5)]~
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellpadicfrobenius">
<tt class="descname">ellpadicfrobenius</tt><big>(</big><em>E</em>, <em>p</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellpadicfrobenius" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(p &gt; 2\)</span> is a prime and <span class="math">\(E\)</span> is a elliptic curve on <span class="math">\(\mathbb{Q}\)</span> with good
reduction at <span class="math">\(p\)</span>, return the matrix of the Frobenius endomorphism <span class="math">\(\varphi\)</span> on
the crystalline module <span class="math">\(D_p(E) = \mathbb{Q}_p \\otimes H^1_{dR}(E/\mathbb{Q})\)</span> with respect to
the basis of the given model <span class="math">\((\omega, \eta = x \omega)\)</span>, where
<span class="math">\(\omega = dx/(2 y+a_1 x+a_3)\)</span> is the invariant differential.
The characteristic polynomial of <span class="math">\(\varphi\)</span> is <span class="math">\(x^2 - a_p x + p\)</span>.
The matrix is computed to absolute <span class="math">\(p\)</span>-adic precision <span class="math">\(p^n\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([1,-1,1,0,0]);
? F = ellpadicfrobenius(E,5,3);
? lift(F)
%3 =
[120 29]

[ 55 5]
? charpoly(F)
%4 = x^2 + O(5^3)*x + (5 + O(5^3))
? ellap(E, 5)
%5 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellpadicheight">
<tt class="descname">ellpadicheight</tt><big>(</big><em>E</em>, <em>p</em>, <em>n</em>, <em>P</em>, <em>Q=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellpadicheight" title="Permalink to this definition">¶</a></dt>
<dd><p>Cyclotomic <span class="math">\(p\)</span>-adic height of the rational point <span class="math">\(P\)</span> on the elliptic curve
<span class="math">\(E\)</span> (defined over <span class="math">\(\mathbb{Q}\)</span>), given to <span class="math">\(n\)</span> <span class="math">\(p\)</span>-adic digits.
If the argument <span class="math">\(Q\)</span> is present, computes the value of the bilinear
form <span class="math">\((h(P+Q)-h(P-Q)) / 4\)</span>.</p>
<p>Let <span class="math">\(D_{dR}(E) := H^1_{dR}(E) \\otimes_\mathbb{Q} \mathbb{Q}_p\)</span> be the <span class="math">\(\mathbb{Q}_p\)</span> vector space
spanned by <span class="math">\(\omega\)</span>
(invariant differential <span class="math">\(dx/(2y+a_1x+a3)\)</span> related to the given model) and
<span class="math">\(\eta = x \omega\)</span>. Then the cyclotomic <span class="math">\(p\)</span>-adic height associates to
<span class="math">\(P belongs to E(\mathbb{Q})\)</span> an element <span class="math">\(f \omega + g\eta\)</span> in <span class="math">\(D_{dR}\)</span>.
This routine returns the vector <span class="math">\([f, g]\)</span> to <span class="math">\(n\)</span> <span class="math">\(p\)</span>-adic digits.</p>
<p>If <span class="math">\(P belongs to E(\mathbb{Q})\)</span> is in the kernel of reduction mod <span class="math">\(p\)</span> and if its reduction
at all finite places is non singular, then <span class="math">\(g = -(\log_E P)^2\)</span>, where
<span class="math">\(\log_E\)</span> is the logarithm for the formal group of <span class="math">\(E\)</span> at <span class="math">\(p\)</span>.</p>
<p>If furthermore the model is of the form <span class="math">\(Y^2 = X^3 + a X + b\)</span> and <span class="math">\(P = (x,y)\)</span>,
then</p>
<div class="math">
\[f = \log_p(denominator(x)) - 2 \log_p(\sigma(P))\]</div>
<p>where <span class="math">\(\sigma(P)\)</span> is given by <tt class="docutils literal"><span class="pre">ellsigma</span></tt><span class="math">\((E,P)\)</span>.</p>
<p>Recall (<em>Advanced topics in the arithmetic of elliptic
curves</em>, Theorem&nbsp;3.2) that the local height function over the complex numbers
is of the form</p>
<div class="math">
\[\lambda(z) = -\log (\|E.disc\|) / 6 + \Re(z \eta(z)) - 2 \log(
\sigma(z).\]</div>
<p>(N.B. our normalization for local and global heights is twice that of
Silverman&#8217;s).</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([1,-1,1,0,0]); P = [0,0];
? ellpadicheight(E,5,4, P)
%2 = [3*5 + 5^2 + 2*5^3 + O(5^4), 5^2 + 4*5^4 + O(5^6)]
? E = ellinit(&quot;11a1&quot;); P = [5,5]; \\ torsion point
? ellpadicheight(E,19,6, P)
%4 = O(19^6)
? E = ellinit([0,0,1,-4,2]); P = [-2,1];
? ellpadicheight(E,3,5, P)
%6 = [2*3^2 + 2*3^3 + 3^4 + O(3^5), 2*3^2 + 3^4 + 2*3^5 + 3^6 + O(3^7)]
? ellpadicheight(E,3,5, P, elladd(E,P,P))
</pre></div>
</div>
<p>One can replace the parameter <span class="math">\(p\)</span> prime by a vector <span class="math">\([p,[a,b]]\)</span>, in which
case the routine returns the <span class="math">\(p\)</span>-adic number <span class="math">\(af + bg\)</span>.</p>
<p>When <span class="math">\(E\)</span> has good ordinary reduction at <span class="math">\(p\)</span>, the &#8220;canonical&#8221;
<span class="math">\(p\)</span>-adic height is given by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">s2</span> <span class="o">=</span> <span class="n">ellpadics2</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">ellpadicheight</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="p">[</span><span class="n">p</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="n">s2</span><span class="p">]],</span> <span class="n">n</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
</pre></div>
</div>
<p>Since <span class="math">\(s_2\)</span> does not depend on <span class="math">\(P\)</span>, it is preferable to
compute it only once:</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit(&quot;5077a1&quot;); p = 5; n = 7;
? s2 = ellpadics2(E,p,n);
? M = ellpadicheightmatrix(E,[p,[1,-s2]], n, E.gen);
? matdet(M) \\ p-adic regulator
%4 = 5 + 5^2 + 4*5^3 + 2*5^4 + 2*5^5 + 5^6 + O(5^7)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellpadicheightmatrix">
<tt class="descname">ellpadicheightmatrix</tt><big>(</big><em>E</em>, <em>p</em>, <em>n</em>, <em>v</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellpadicheightmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(v\)</span> being a vector of points, this function outputs the Gram matrix of
<span class="math">\(v\)</span> with respect to the cyclotomic <span class="math">\(p\)</span>-adic height, given to <span class="math">\(n\)</span> <span class="math">\(p\)</span>-adic
digits; in other words, the <span class="math">\((i,j)\)</span> component of the matrix is equal to
<tt class="docutils literal"><span class="pre">ellpadicheight</span></tt><span class="math">\((E,p,n, v[i],v[j]) = [f,g]\)</span>.</p>
<p>See <tt class="docutils literal"><span class="pre">ellpadicheight</span></tt>; in particular one can replace the parameter <span class="math">\(p\)</span>
prime by a vector <span class="math">\([p,[a,b]]\)</span>, in which case the routine returns the matrix
containing the <span class="math">\(p\)</span>-adic numbers <span class="math">\(af + bg\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellpadiclog">
<tt class="descname">ellpadiclog</tt><big>(</big><em>E</em>, <em>p</em>, <em>n</em>, <em>P</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellpadiclog" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <span class="math">\(E\)</span> defined over <span class="math">\(K = \mathbb{Q}\)</span> or <span class="math">\(\mathbb{Q}_p\)</span> and <span class="math">\(P = [x,y]\)</span> on <span class="math">\(E(K)\)</span> in the
kernel of reduction mod <span class="math">\(p\)</span>, let <span class="math">\(t(P) = -x/y\)</span> be the formal group
parameter; this function returns <span class="math">\(L(t)\)</span>, where <span class="math">\(L\)</span> denotes the formal
logarithm (mapping the formal group of <span class="math">\(E\)</span> to the additive formal group)
attached to the canonical invariant differential:
<span class="math">\(dL = dx/(2y + a_1x + a_3)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellpadics2">
<tt class="descname">ellpadics2</tt><big>(</big><em>E</em>, <em>p</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellpadics2" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(p &gt; 2\)</span> is a prime and <span class="math">\(E/\mathbb{Q}\)</span> is a elliptic curve with ordinary good
reduction at <span class="math">\(p\)</span>, returns the slope of the unit eigenvector
of <tt class="docutils literal"><span class="pre">ellpadicfrobenius(E,p,n)</span></tt>, i.e. the action of Frobenius <span class="math">\(\varphi\)</span> on
the crystalline module <span class="math">\(D_p(E) = \mathbb{Q}_p \\otimes H^1_{dR}(E/\mathbb{Q})\)</span> in the basis of
the given model <span class="math">\((\omega, \eta = x \omega)\)</span>, where <span class="math">\(\omega\)</span> is the invariant
differential <span class="math">\(dx/(2 y+a_1 x+a_3)\)</span>. In other words, <span class="math">\(\eta + s_2\omega\)</span>
is an eigenvector for the unit eigenvalue of <span class="math">\(\varphi\)</span>.</p>
<p>This slope is the unique <span class="math">\(c belongs to 3^{-1}\mathbb{Z}_p\)</span> such that the odd solution
<span class="math">\(\sigma(t) = t + O(t^2)\)</span> of</p>
<div class="math">
\[- d((1)/(\sigma) (d \sigma)/(\omega))
= (x(t) + c) \omega\]</div>
<p>is in <span class="math">\(t\mathbb{Z}_p[[t]]\)</span>.</p>
<p>It is equal to <span class="math">\(b_2/12 - E_2/12\)</span> where <span class="math">\(E_2\)</span> is the value of the Katz
<span class="math">\(p\)</span>-adic Eisenstein series of weight 2 on <span class="math">\((E,\omega)\)</span>. This is
used to construct a canonical <span class="math">\(p\)</span>-adic height when <span class="math">\(E\)</span> has good ordinary
reduction at <span class="math">\(p\)</span> as follows</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">s2</span> <span class="o">=</span> <span class="n">ellpadics2</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">h</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">n</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">=</span> <span class="n">ellpadicheight</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="p">[</span><span class="n">p</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="n">s2</span><span class="p">]],</span><span class="n">n</span><span class="p">,</span> <span class="n">P</span><span class="p">);</span>
</pre></div>
</div>
<p>Since <span class="math">\(s_2\)</span> does not depend on the point <span class="math">\(P\)</span>, we compute it
only once.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellperiods">
<tt class="descname">ellperiods</tt><big>(</big><em>w</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellperiods" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(w\)</span> describe a complex period lattice (<span class="math">\(w = [w_1,w_2]\)</span>
or an ellinit structure). Returns normalized periods <span class="math">\([W_1,W_2]\)</span> generating
the same lattice such that <span class="math">\(\tau := W_1/W_2\)</span> has positive imaginary part
and lies in the standard fundamental domain for <span class="math">\({SL}_2(\mathbb{Z})\)</span>.</p>
<p>If <span class="math">\(flag = 1\)</span>, the function returns <span class="math">\([[W_1,W_2], [\eta_1,\eta_2]]\)</span>, where
<span class="math">\(\eta_1\)</span> and <span class="math">\(\eta_2\)</span> are the quasi-periods associated to
<span class="math">\([W_1,W_2]\)</span>, satisfying <span class="math">\(\eta_1 W_2 - \eta_2 W_1 = 2 i \Pi\)</span>.</p>
<p>The output of this function is meant to be used as the first argument
given to ellwp, ellzeta, ellsigma or elleisnum. Quasi-periods are
needed by ellzeta and ellsigma only.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellpointtoz">
<tt class="descname">ellpointtoz</tt><big>(</big><em>E</em>, <em>P</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellpointtoz" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(E/\mathbb{C} ~ \mathbb{C}/\Lambda\)</span> is a complex elliptic curve (<span class="math">\(\Lambda = 
E.omega\)</span>),
computes a complex number <span class="math">\(z\)</span>, well-defined modulo the lattice <span class="math">\(\Lambda\)</span>,
corresponding to the point <span class="math">\(P\)</span>; i.e.&nbsp;such that
<span class="math">\(P = [\wp_\Lambda(z),\wp'_\Lambda(z)]\)</span>
satisfies the equation</p>
<div class="math">
\[y^2 = 4x^3 - g_2 x - g_3,\]</div>
<p>where <span class="math">\(g_2\)</span>, <span class="math">\(g_3\)</span> are the elliptic invariants.</p>
<p>If <span class="math">\(E\)</span> is defined over <span class="math">\(\mathbb{R}\)</span> and <span class="math">\(P belongs to E(\mathbb{R})\)</span>, we have more precisely, <span class="math">\(0 \\leq
\Re(t) &lt; w1\)</span> and <span class="math">\(0 &lt;= \Im(t) &lt; \Im(w2)\)</span>, where <span class="math">\((w1,w2)\)</span> are the real and
complex periods of <span class="math">\(E\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([0,1]); P = [2,3];
? z = ellpointtoz(E, P)
%2 = 3.5054552633136356529375476976257353387
? ellwp(E, z)
%3 = 2.0000000000000000000000000000000000000
? ellztopoint(E, z) - P
%4 = [6.372367644529809109 E-58, 7.646841173435770930 E-57]
? ellpointtoz(E, [0]) \\ the point at infinity
%5 = 0
</pre></div>
</div>
<p>If <span class="math">\(E/\mathbb{Q}_p\)</span> has multiplicative reduction, then <span class="math">\(E/\\bar{\mathbb{Q}_p}\)</span> is analytically
isomorphic to <span class="math">\(\\bar{\mathbb{Q}}_p^*/q^\mathbb{Z}\)</span> (Tate curve) for some <span class="math">\(p\)</span>-adic integer <span class="math">\(q\)</span>.
The behaviour is then as follows:</p>
<ul class="simple">
<li>If the reduction is split (<span class="math">\(E.tate[2]\)</span> is a <tt class="docutils literal"><span class="pre">t_PADIC</span></tt>), we have
an isomorphism <span class="math">\(\phi: E(\mathbb{Q}_p) ~ \mathbb{Q}_p^*/q^\mathbb{Z}\)</span> and the function returns
<span class="math">\(\phi(P) belongs to \mathbb{Q}_p\)</span>.</li>
<li>If the reduction is <em>not</em> split (<span class="math">\(E.tate[2]\)</span> is a
<tt class="docutils literal"><span class="pre">t_POLMOD</span></tt>), we only have an isomorphism <span class="math">\(\phi: E(K) ~ K^*/q^\mathbb{Z}\)</span> over
the unramified quadratic extension <span class="math">\(K/\mathbb{Q}_p\)</span>. In this case, the output
<span class="math">\(\phi(P) belongs to K\)</span> is a <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt>.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([0,-1,1,0,0], O(11^5)); P = [0,0];
? [u2,u,q] = E.tate; type(u) \\ split multiplicative reduction
%2 = &quot;t_PADIC&quot;
? ellmul(E, P, 5) \\ P has order 5
%3 = [0]
? z = ellpointtoz(E, [0,0])
%4 = 3 + 11^2 + 2*11^3 + 3*11^4 + O(11^5)
? z^5
%5 = 1 + O(11^5)
? E = ellinit(ellfromj(1/4), O(2^6)); x=1/2; y=ellordinate(E,x)[1];
? z = ellpointtoz(E,[x,y]); \\ t_POLMOD of t_POL with t_PADIC coeffs
? liftint(z) \\ lift all p-adics
%8 = Mod(8*u + 7, u^2 + 437)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellpow">
<tt class="descname">ellpow</tt><big>(</big><em>E</em>, <em>z</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated alias for <tt class="docutils literal"><span class="pre">ellmul</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellrootno">
<tt class="descname">ellrootno</tt><big>(</big><em>E</em>, <em>p=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellrootno" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(E\)</span> being an <em>ell</em> structure over <span class="math">\(\mathbb{Q}\)</span> as output by <tt class="docutils literal"><span class="pre">ellinit</span></tt>,
this function computes the local root number of its <span class="math">\(L\)</span>-series at the place
<span class="math">\(p\)</span> (at the infinite place if <span class="math">\(p = 0\)</span>). If <span class="math">\(p\)</span> is omitted, return the global
root number. Note that the global root number is the sign of the functional
equation and conjecturally is the parity of the rank of the \idx{Mordell-Weil
group}. The equation for <span class="math">\(E\)</span> needs not be minimal at <span class="math">\(p\)</span>, but if the model
is already minimal the function will run faster.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellsearch">
<tt class="descname">ellsearch</tt><big>(</big><em>N</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellsearch" title="Permalink to this definition">¶</a></dt>
<dd><p>This function finds all curves in the <tt class="docutils literal"><span class="pre">elldata</span></tt> database satisfying
the constraint defined by the argument <span class="math">\(N\)</span>:</p>
<ul class="simple">
<li>if <span class="math">\(N\)</span> is a character string, it selects a given curve, e.g.
<tt class="docutils literal"><span class="pre">&quot;11a1&quot;</span></tt>, or curves in the given isogeny class, e.g. <tt class="docutils literal"><span class="pre">&quot;11a&quot;</span></tt>, or
curves with given conductor, e.g. <tt class="docutils literal"><span class="pre">&quot;11&quot;</span></tt>;</li>
<li>if <span class="math">\(N\)</span> is a vector of integers, it encodes the same constraints
as the character string above, according to the <tt class="docutils literal"><span class="pre">ellconvertname</span></tt>
correspondance, e.g. <tt class="docutils literal"><span class="pre">[11,0,1]</span></tt> for <tt class="docutils literal"><span class="pre">&quot;11a1&quot;</span></tt>, <tt class="docutils literal"><span class="pre">[11,0]</span></tt> for
<tt class="docutils literal"><span class="pre">&quot;11a&quot;</span></tt> and <tt class="docutils literal"><span class="pre">[11]</span></tt> for <tt class="docutils literal"><span class="pre">&quot;11&quot;</span></tt>;</li>
<li>if <span class="math">\(N\)</span> is an integer, curves with conductor <span class="math">\(N\)</span> are selected.</li>
</ul>
<p>If <span class="math">\(N\)</span> is a full curve name, e.g. <tt class="docutils literal"><span class="pre">&quot;11a1&quot;</span></tt> or <tt class="docutils literal"><span class="pre">[11,0,1]</span></tt>,
the output format is <span class="math">\([N, [a_1,a_2,a_3,a_4,a_6], G]\)</span> where
<span class="math">\([a_1,a_2,a_3,a_4,a_6]\)</span> are the coefficients of the Weierstrass equation of
the curve and <span class="math">\(G\)</span> is a <span class="math">\(\mathbb{Z}\)</span>-basis of the free part of the \idx{Mordell-Weil
group} associated to the curve.</p>
<div class="highlight-python"><div class="highlight"><pre>? ellsearch(&quot;11a3&quot;)
%1 = [&quot;11a3&quot;, [0, -1, 1, 0, 0], []]
? ellsearch([11,0,3])
%2 = [&quot;11a3&quot;, [0, -1, 1, 0, 0], []]
</pre></div>
</div>
<p>If <span class="math">\(N\)</span> is not a full curve name, then the output is a vector of all matching
curves in the above format:</p>
<div class="highlight-python"><div class="highlight"><pre>? ellsearch(&quot;11a&quot;)
%1 = [[&quot;11a1&quot;, [0, -1, 1, -10, -20], []],
 [&quot;11a2&quot;, [0, -1, 1, -7820, -263580], []],
 [&quot;11a3&quot;, [0, -1, 1, 0, 0], []]]
? ellsearch(&quot;11b&quot;)
%2 = []
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellsigma">
<tt class="descname">ellsigma</tt><big>(</big><em>L</em>, <em>z=None</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellsigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the value at <span class="math">\(z\)</span> of the Weierstrass <span class="math">\(\sigma\)</span> function attached to
the lattice <span class="math">\(L\)</span> as given by <tt class="docutils literal"><span class="pre">ellperiods</span></tt><span class="math">\((,1)\)</span>: including quasi-periods
is useful, otherwise there are recomputed from scratch for each new <span class="math">\(z\)</span>.</p>
<div class="math">
\[\sigma(z, L) = z \prod_{\omega belongs to L^*} (1 -
(z)/(\omega))e^{(z)/(\omega) + (z^2)/(2\omega^2)}.\]</div>
<p>It is also possible to directly input <span class="math">\(L = [\omega_1,\omega_2]\)</span>,
or an elliptic curve <span class="math">\(E\)</span> as given by <tt class="docutils literal"><span class="pre">ellinit</span></tt> (<span class="math">\(L = E.omega\)</span>).</p>
<div class="highlight-python"><div class="highlight"><pre>? w = ellperiods([1,I], 1);
? ellsigma(w, 1/2)
%2 = 0.47494937998792065033250463632798296855
? E = ellinit([1,0]);
? ellsigma(E) \\ at &#39;x, implicitly at default seriesprecision
%4 = x + 1/60*x^5 - 1/10080*x^9 - 23/259459200*x^13 + O(x^17)
</pre></div>
</div>
<p>If <span class="math">\(flag = 1\)</span>, computes an arbitrary determination of <span class="math">\(\log(\sigma(z))\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellsub">
<tt class="descname">ellsub</tt><big>(</big><em>E</em>, <em>z1</em>, <em>z2</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellsub" title="Permalink to this definition">¶</a></dt>
<dd><p>Difference of the points <span class="math">\(z1\)</span> and <span class="math">\(z2\)</span> on the
elliptic curve corresponding to <span class="math">\(E\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elltaniyama">
<tt class="descname">elltaniyama</tt><big>(</big><em>E</em>, <em>serprec=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elltaniyama" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the modular parametrization of the elliptic curve <span class="math">\(E/\mathbb{Q}\)</span>,
where <span class="math">\(E\)</span> is an <em>ell</em> structure as output by <tt class="docutils literal"><span class="pre">ellinit</span></tt>. This returns
a two-component vector <span class="math">\([u,v]\)</span> of power series, given to <span class="math">\(d\)</span> significant
terms (<tt class="docutils literal"><span class="pre">seriesprecision</span></tt> by default), characterized by the following two
properties. First the point <span class="math">\((u,v)\)</span> satisfies the equation of the elliptic
curve. Second, let <span class="math">\(N\)</span> be the conductor of <span class="math">\(E\)</span> and <span class="math">\(\Phi: X_0(N)\\to E\)</span>
be a modular parametrization; the pullback by <span class="math">\(\Phi\)</span> of the
Néron differential <span class="math">\(du/(2v+a_1u+a_3)\)</span> is equal to <span class="math">\(2i\Pi
f(z)dz\)</span>, a holomorphic differential form. The variable used in the power
series for <span class="math">\(u\)</span> and <span class="math">\(v\)</span> is <span class="math">\(x\)</span>, which is implicitly understood to be equal to
<span class="math">\(\exp(2i\Pi z)\)</span>.</p>
<p>The algorithm assumes that <span class="math">\(E\)</span> is a <em>strong</em> Weil curve
and that the Manin constant is equal to 1: in fact, <span class="math">\(f(x) = \sum_{n &gt; 0}
ellan(E, n) x^n\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elltatepairing">
<tt class="descname">elltatepairing</tt><big>(</big><em>E</em>, <em>P</em>, <em>Q</em>, <em>m</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elltatepairing" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Tate pairing of the two points <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> on the elliptic
curve <span class="math">\(E\)</span>. The point <span class="math">\(P\)</span> must be of <span class="math">\(m\)</span>-torsion.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elltors">
<tt class="descname">elltors</tt><big>(</big><em>E</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elltors" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(E\)</span> is an elliptic curve defined over a number field or a finite field,
outputs the torsion subgroup of <span class="math">\(E\)</span> as a 3-component vector <tt class="docutils literal"><span class="pre">[t,v1,v2]</span></tt>,
where <tt class="docutils literal"><span class="pre">t</span></tt> is the order of the torsion group, <tt class="docutils literal"><span class="pre">v1</span></tt> gives the structure
of the torsion group as a product of cyclic groups (sorted by decreasing
order), and <tt class="docutils literal"><span class="pre">v2</span></tt> gives generators for these cyclic groups. <span class="math">\(E\)</span> must be an
<em>ell</em> structure as output by <tt class="docutils literal"><span class="pre">ellinit</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([-1,0]);
? elltors(E)
%1 = [4, [2, 2], [[0, 0], [1, 0]]]
</pre></div>
</div>
<p>Here, the torsion subgroup is isomorphic to <span class="math">\(\mathbb{Z}/2\mathbb{Z} x \mathbb{Z}/2\mathbb{Z}\)</span>, with
generators <span class="math">\([0,0]\)</span> and <span class="math">\([1,0]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellweilpairing">
<tt class="descname">ellweilpairing</tt><big>(</big><em>E</em>, <em>P</em>, <em>Q</em>, <em>m</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellweilpairing" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Weil pairing of the two points of <span class="math">\(m\)</span>-torsion <span class="math">\(P\)</span> and <span class="math">\(Q\)</span>
on the elliptic curve <span class="math">\(E\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellwp">
<tt class="descname">ellwp</tt><big>(</big><em>w</em>, <em>z=None</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellwp" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the value at <span class="math">\(z\)</span> of the Weierstrass <span class="math">\(\wp\)</span> function attached to
the lattice <span class="math">\(w\)</span> as given by <tt class="docutils literal"><span class="pre">ellperiods</span></tt>. It is also possible to
directly input <span class="math">\(w = [\omega_1,\omega_2]\)</span>, or an elliptic curve <span class="math">\(E\)</span> as given
by <tt class="docutils literal"><span class="pre">ellinit</span></tt> (<span class="math">\(w = E.omega\)</span>).</p>
<div class="highlight-python"><div class="highlight"><pre>? w = ellperiods([1,I]);
? ellwp(w, 1/2)
%2 = 6.8751858180203728274900957798105571978
? E = ellinit([1,1]);
? ellwp(E, 1/2)
%4 = 3.9413112427016474646048282462709151389
</pre></div>
</div>
<p>One can also compute the series expansion around <span class="math">\(z = 0\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([1,0]);
? ellwp(E) \\ &#39;x implicitly at default seriesprecision
%5 = x^-2 - 1/5*x^2 + 1/75*x^6 - 2/4875*x^10 + O(x^14)
? ellwp(E, x + O(x^12)) \\ explicit precision
%6 = x^-2 - 1/5*x^2 + 1/75*x^6 + O(x^9)
</pre></div>
</div>
<p>Optional <em>flag</em> means 0 (default): compute only <span class="math">\(\wp(z)\)</span>, 1: compute
<span class="math">\([\wp(z),\wp'(z)]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellxn">
<tt class="descname">ellxn</tt><big>(</big><em>E</em>, <em>n</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellxn" title="Permalink to this definition">¶</a></dt>
<dd><p>In standard notation, for any affine point <span class="math">\(P = (v,w)\)</span> on the
curve <span class="math">\(E\)</span>, we have</p>
<div class="math">
\[[n]P = (\phi_n(P)\psi_n(P) : \omega_n(P) : \psi_n(P)^3)\]</div>
<p>for some polynomials <span class="math">\(\phi_n,\omega_n,\psi_n\)</span> in
<span class="math">\(\mathbb{Z}[a_1,a_2,a_3,a_4,a_6][v,w]\)</span>. This function returns
<span class="math">\([\phi_n(P),\psi_n(P)^2]\)</span>, which give the numerator and denominator of
the abcissa of <span class="math">\([n]P\)</span> and depend only on <span class="math">\(v\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellzeta">
<tt class="descname">ellzeta</tt><big>(</big><em>w</em>, <em>z=None</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellzeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the value at <span class="math">\(z\)</span> of the Weierstrass <span class="math">\(\zeta\)</span> function attached to
the lattice <span class="math">\(w\)</span> as given by <tt class="docutils literal"><span class="pre">ellperiods</span></tt><span class="math">\((,1)\)</span>: including quasi-periods
is useful, otherwise there are recomputed from scratch for each new <span class="math">\(z\)</span>.</p>
<div class="math">
\[\zeta(z, L) = (1)/(z) + z^2\sum_{\omega belongs to L^*}
(1)/(\omega^2(z-\omega)).\]</div>
<p>It is also possible to directly input <span class="math">\(w = [\omega_1,\omega_2]\)</span>,
or an elliptic curve <span class="math">\(E\)</span> as given by <tt class="docutils literal"><span class="pre">ellinit</span></tt> (<span class="math">\(w = E.omega\)</span>).
The quasi-periods of <span class="math">\(\zeta\)</span>, such that</p>
<div class="math">
\[\zeta(z + a\omega_1 + b\omega_2) = \zeta(z) + a\eta_1 + b\eta_2\]</div>
<p>for integers <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are obtained as <span class="math">\(\eta_i = 2\zeta(\omega_i/2)\)</span>.
Or using directly <tt class="docutils literal"><span class="pre">elleta</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>? w = ellperiods([1,I],1);
? ellzeta(w, 1/2)
%2 = 1.5707963267948966192313216916397514421
? E = ellinit([1,0]);
? ellzeta(E, E.omega[1]/2)
%4 = 0.84721308479397908660649912348219163647
</pre></div>
</div>
<p>One can also compute the series expansion around <span class="math">\(z = 0\)</span>
(the quasi-periods are useless in this case):</p>
<div class="highlight-python"><div class="highlight"><pre>? E = ellinit([0,1]);
? ellzeta(E) \\ at &#39;x, implicitly at default seriesprecision
%4 = x^-1 + 1/35*x^5 - 1/7007*x^11 + O(x^15)
? ellzeta(E, x + O(x^20)) \\ explicit precision
%5 = x^-1 + 1/35*x^5 - 1/7007*x^11 + 1/1440257*x^17 + O(x^18)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellztopoint">
<tt class="descname">ellztopoint</tt><big>(</big><em>E</em>, <em>z</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellztopoint" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(E\)</span> being an <em>ell</em> as output by
<tt class="docutils literal"><span class="pre">ellinit</span></tt>, computes the coordinates <span class="math">\([x,y]\)</span> on the curve <span class="math">\(E\)</span>
corresponding to the complex number <span class="math">\(z\)</span>. Hence this is the inverse function
of <tt class="docutils literal"><span class="pre">ellpointtoz</span></tt>. In other words, if the curve is put in Weierstrass
form <span class="math">\(y^2 = 4x^3 - g_2x - g_3\)</span>, <span class="math">\([x,y]\)</span> represents the Weierstrass
<span class="math">\(\wp\)</span>-function and its derivative. More
precisely, we have</p>
<div class="math">
\[x = \wp(z) - b_2/12, y = \wp'(z) - (a_1 x + a_3)/2.\]</div>
<p>If <span class="math">\(z\)</span> is in the lattice defining <span class="math">\(E\)</span> over <span class="math">\(\mathbb{C}\)</span>, the result is the point at
infinity <span class="math">\([0]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.erfc">
<tt class="descname">erfc</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.erfc" title="Permalink to this definition">¶</a></dt>
<dd><p>Complementary error function, analytic continuation of
<span class="math">\((2/\sqrt\Pi)\int_x^ oo e^{-t^2}dt = incgam(1/2,x^2)/\sqrt\Pi\)</span>,
where the latter expression extends the function definition from real <span class="math">\(x\)</span> to
all complex <span class="math">\(x != 0\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.errname">
<tt class="descname">errname</tt><big>(</big><em>E</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.errname" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of the error message <tt class="docutils literal"><span class="pre">E</span></tt> as a string.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.eta">
<tt class="descname">eta</tt><big>(</big><em>z</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.eta" title="Permalink to this definition">¶</a></dt>
<dd><p>Variants of Dedekind&#8217;s <span class="math">\(\eta\)</span> function.
If <span class="math">\(flag = 0\)</span>, return <span class="math">\(\prod_{n = 1}^ oo (1-q^n)\)</span>, where <span class="math">\(q\)</span> depends on <span class="math">\(x\)</span>
in the following way:</p>
<ul class="simple">
<li><span class="math">\(q = e^{2i\Pi x}\)</span> if <span class="math">\(x\)</span> is a <em>complex number</em> (which must then
have positive imaginary part); notice that the factor <span class="math">\(q^{1/24}\)</span> is
missing!</li>
<li><span class="math">\(q = x\)</span> if <span class="math">\(x\)</span> is a <tt class="docutils literal"><span class="pre">t_PADIC</span></tt>, or can be converted to a
<em>power series</em> (which must then have positive valuation).</li>
</ul>
<p>If <span class="math">\(flag\)</span> is non-zero, <span class="math">\(x\)</span> is converted to a complex number and we return the
true <span class="math">\(\eta\)</span> function, <span class="math">\(q^{1/24}\prod_{n = 1}^ oo (1-q^n)\)</span>,
where <span class="math">\(q = e^{2i\Pi x}\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.eulerphi">
<tt class="descname">eulerphi</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.eulerphi" title="Permalink to this definition">¶</a></dt>
<dd><p>Euler&#8217;s <span class="math">\(\phi\)</span> (totient) function of the
integer <span class="math">\(\|x\|\)</span>, in other words <span class="math">\(\|(\mathbb{Z}/x\mathbb{Z})^*\|\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? eulerphi(40)
%1 = 16
</pre></div>
</div>
<p>According to this definition we let <span class="math">\(\phi(0) := 2\)</span>, since <span class="math">\(\mathbb{Z}^ *= {-1,1}\)</span>;
this is consistent with <tt class="docutils literal"><span class="pre">znstar(0)</span></tt>: we have \kbd{znstar:math:<span class="math">\((n)\)</span>.no = 
eulerphi(n)} for all <span class="math">\(n belongs to \mathbb{Z}\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.exp">
<tt class="descname">exp</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential of <span class="math">\(x\)</span>.
<span class="math">\(p\)</span>-adic arguments with positive valuation are accepted.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.expm1">
<tt class="descname">expm1</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.expm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <span class="math">\(\exp(x)-1\)</span>, computed in a way that is also accurate
when the real part of <span class="math">\(x\)</span> is near <span class="math">\(0\)</span>.
A naive direct computation would suffer from catastrophic cancellation;
PARI&#8217;s direct computation of <span class="math">\(\exp(x)\)</span> alleviates this well known problem at
the expense of computing <span class="math">\(\exp(x)\)</span> to a higher accuracy when <span class="math">\(x\)</span> is small.
Using <tt class="docutils literal"><span class="pre">expm1</span></tt> is recommended instead:</p>
<div class="highlight-python"><div class="highlight"><pre>? default(realprecision, 10000); x = 1e-100;
? a = expm1(x);
time = 4 ms.
? b = exp(x)-1;
time = 28 ms.
? default(realprecision, 10040); x = 1e-100;
? c = expm1(x); \\ reference point
? abs(a-c)/c \\ relative error in expm1(x)
%7 = 0.E-10017
? abs(b-c)/c \\ relative error in exp(x)-1
%8 = 1.7907031188259675794 E-9919
</pre></div>
</div>
<p>As the example above shows, when <span class="math">\(x\)</span> is near <span class="math">\(0\)</span>,
<tt class="docutils literal"><span class="pre">expm1</span></tt> is both faster and more accurate than <tt class="docutils literal"><span class="pre">exp(x)-1</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.factor">
<tt class="descname">factor</tt><big>(</big><em>x</em>, <em>lim=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.factor" title="Permalink to this definition">¶</a></dt>
<dd><p>General factorization function, where <span class="math">\(x\)</span> is a
rational (including integers), a complex number with rational
real and imaginary parts, or a rational function (including polynomials).
The result is a two-column matrix: the first contains the irreducibles
dividing <span class="math">\(x\)</span> (rational or Gaussian primes, irreducible polynomials),
and the second the exponents. By convention, <span class="math">\(0\)</span> is factored as <span class="math">\(0^1\)</span>.</p>
<p><strong>:math:</strong>mathbb{Q}` and <span class="math">\(\mathbb{Q}(i)\)</span>.`
See <tt class="docutils literal"><span class="pre">factorint</span></tt> for more information about the algorithms used.
The rational or Gaussian primes are in fact <em>pseudoprimes</em>
(see <tt class="docutils literal"><span class="pre">ispseudoprime</span></tt>), a priori not rigorously proven primes. In fact,
any factor which is <span class="math">\(&lt;= 2^{64}\)</span> (whose norm is <span class="math">\(&lt;= 2^{64}\)</span> for an
irrational Gaussian prime) is a genuine prime. Use <tt class="docutils literal"><span class="pre">isprime</span></tt> to prove
primality of other factors, as in</p>
<div class="highlight-python"><div class="highlight"><pre>? fa = factor(2^2^7 + 1)
%1 =
[59649589127497217 1]

[5704689200685129054721 1]

? isprime( fa[,1] )
%2 = [1, 1]~ \\ both entries are proven primes
</pre></div>
</div>
<p>Another possibility is to set the global default <tt class="docutils literal"><span class="pre">factor_proven</span></tt>, which
will perform a rigorous primality proof for each pseudoprime factor.</p>
<p>A <tt class="docutils literal"><span class="pre">t_INT</span></tt> argument <em>lim</em> can be added, meaning that we look only for
prime factors <span class="math">\(p &lt; lim\)</span>. The limit <em>lim</em> must be non-negative.
In this case, all but the last factor are proven primes, but the remaining
factor may actually be a proven composite! If the remaining factor is less
than <span class="math">\(lim^2\)</span>, then it is prime.</p>
<div class="highlight-python"><div class="highlight"><pre>? factor(2^2^7 +1, 10^5)
%3 =
[340282366920938463463374607431768211457 1]
</pre></div>
</div>
<p><strong>Deprecated feature.</strong> Setting <span class="math">\(lim = 0\)</span> is the same
as setting it to <span class="math">\(primelimit + 1\)</span>. Don&#8217;t use this: it is unwise to
rely on global variables when you can specify an explicit argument.</p>
<p>This routine uses trial division and perfect power tests, and should not be
used for huge values of <em>lim</em> (at most <span class="math">\(10^9\)</span>, say):
<tt class="docutils literal"><span class="pre">factorint(,</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">8)</span></tt> will in general be faster. The latter does not
guarantee that all small
prime factors are found, but it also finds larger factors, and in a much more
efficient way.</p>
<div class="highlight-python"><div class="highlight"><pre>? F = (2^2^7 + 1) * 1009 * 100003; factor(F, 10^5) \\ fast, incomplete
time = 0 ms.
%4 =
[1009 1]

[34029257539194609161727850866999116450334371 1]

? factor(F, 10^9) \\ very slow
time = 6,892 ms.
%6 =
[1009 1]

[100003 1]

[340282366920938463463374607431768211457 1]

? factorint(F, 1+8) \\ much faster, all small primes were found
time = 12 ms.
%7 =
[1009 1]

[100003 1]

[340282366920938463463374607431768211457 1]

? factor(F) \\ complete factorisation
time = 112 ms.
%8 =
[1009 1]

[100003 1]

[59649589127497217 1]

[5704689200685129054721 1]
</pre></div>
</div>
<p>Over <span class="math">\(\mathbb{Q}\)</span>, the prime factors are sorted in increasing order.</p>
<p><strong>Rational functions.</strong>
The polynomials or rational functions to be factored must have scalar
coefficients. In particular PARI does not know how to factor
<em>multivariate</em> polynomials. The following domains are currently
supported: <span class="math">\(\mathbb{Q}\)</span>, <span class="math">\(\mathbb{R}\)</span>, <span class="math">\(\mathbb{C}\)</span>, <span class="math">\(\mathbb{Q}_p\)</span>, finite fields and number fields.
See <tt class="docutils literal"><span class="pre">factormod</span></tt> and <tt class="docutils literal"><span class="pre">factorff</span></tt> for
the algorithms used over finite fields, <tt class="docutils literal"><span class="pre">factornf</span></tt> for the algorithms
over number fields. Over <span class="math">\(\mathbb{Q}\)</span>, van Hoeij&#8217;s method is used, which is
able to cope with hundreds of modular factors.</p>
<p>The routine guesses a sensible ring over which to factor: the
smallest ring containing all coefficients, taking into account quotient
structures induced by <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt>&nbsp;s and <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt>&nbsp;s (e.g.&nbsp;if a coefficient
in <span class="math">\(\mathbb{Z}/n\mathbb{Z}\)</span> is known, all rational numbers encountered are first mapped to
<span class="math">\(\mathbb{Z}/n\mathbb{Z}\)</span>; different moduli will produce an error). Factoring modulo a
non-prime number is not supported; to factor in <span class="math">\(\mathbb{Q}_p\)</span>, use <tt class="docutils literal"><span class="pre">t_PADIC</span></tt>
coefficients not <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt> modulo <span class="math">\(p^n\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? T = x^2+1;
? factor(T); \\ over Q
? factor(T*Mod(1,3)) \\ over F_3
? factor(T*ffgen(ffinit(3,2,&#39;t))^0) \\ over F_{3^2}
? factor(T*Mod(Mod(1,3), t^2+t+2)) \\ over F_{3^2}, again
? factor(T*(1 + O(3^6)) \\ over Q_3, precision 6
? factor(T*1.) \\ over R, current precision
? factor(T*(1.+0.*I)) \\ over C
? factor(T*Mod(1, y^3-2)) \\ over Q(2^{1/3})
</pre></div>
</div>
<p>In most cases, it is clearer and simpler to call an
explicit variant than to rely on the generic <tt class="docutils literal"><span class="pre">factor</span></tt> function and
the above detection mechanism:</p>
<div class="highlight-python"><div class="highlight"><pre>? factormod(T, 3) \\ over F_3
? factorff(T, 3, t^2+t+2)) \\ over F_{3^2}
? factorpadic(T, 3,6) \\ over Q_3, precision 6
? nffactor(y^3-2, T) \\ over Q(2^{1/3})
? polroots(T) \\ over C
</pre></div>
</div>
<p>Note that factorization of polynomials is done up to
multiplication by a constant. In particular, the factors of rational
polynomials will have integer coefficients, and the content of a polynomial
or rational function is discarded and not included in the factorization. If
needed, you can always ask for the content explicitly:</p>
<div class="highlight-python"><div class="highlight"><pre>? factor(t^2 + 5/2*t + 1)
%1 =
[2*t + 1 1]

[t + 2 1]

? content(t^2 + 5/2*t + 1)
%2 = 1/2
</pre></div>
</div>
<p>The irreducible factors are sorted by increasing degree.
See also <tt class="docutils literal"><span class="pre">nffactor</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.factorback">
<tt class="descname">factorback</tt><big>(</big><em>f</em>, <em>e=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.factorback" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives back the factored object
corresponding to a factorization. The integer <span class="math">\(1\)</span> corresponds to the empty
factorization.</p>
<p>If <span class="math">\(e\)</span> is present, <span class="math">\(e\)</span> and <span class="math">\(f\)</span> must be vectors of the same length (<span class="math">\(e\)</span> being
integral), and the corresponding factorization is the product of the
<span class="math">\(f[i]^{e[i]}\)</span>.</p>
<p>If not, and <span class="math">\(f\)</span> is vector, it is understood as in the preceding case with <span class="math">\(e\)</span>
a vector of 1s: we return the product of the <span class="math">\(f[i]\)</span>. Finally, <span class="math">\(f\)</span> can be a
regular factorization, as produced with any <tt class="docutils literal"><span class="pre">factor</span></tt> command. A few
examples:</p>
<div class="highlight-python"><div class="highlight"><pre>? factor(12)
%1 =
[2 2]

[3 1]

? factorback(%)
%2 = 12
? factorback([2,3], [2,1]) \\ 2^3 * 3^1
%3 = 12
? factorback([5,2,3])
%4 = 30
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.factorcantor">
<tt class="descname">factorcantor</tt><big>(</big><em>x</em>, <em>p</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.factorcantor" title="Permalink to this definition">¶</a></dt>
<dd><p>Factors the polynomial <span class="math">\(x\)</span> modulo the
prime <span class="math">\(p\)</span>, using distinct degree plus
Cantor-Zassenhaus. The coefficients of <span class="math">\(x\)</span> must be
operation-compatible with <span class="math">\(\mathbb{Z}/p\mathbb{Z}\)</span>. The result is a two-column matrix, the
first column being the irreducible polynomials dividing <span class="math">\(x\)</span>, and the second
the exponents. If you want only the <em>degrees</em> of the irreducible
polynomials (for example for computing an <span class="math">\(L\)</span>-function), use
<span class="math">\(factormod(x,p,1)\)</span>. Note that the <tt class="docutils literal"><span class="pre">factormod</span></tt> algorithm is
usually faster than <tt class="docutils literal"><span class="pre">factorcantor</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.factorff">
<tt class="descname">factorff</tt><big>(</big><em>x</em>, <em>p=None</em>, <em>a=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.factorff" title="Permalink to this definition">¶</a></dt>
<dd><p>Factors the polynomial <span class="math">\(x\)</span> in the field
<span class="math">\(\mathbb{F}_q\)</span> defined by the irreducible polynomial <span class="math">\(a\)</span> over <span class="math">\(\mathbb{F}_p\)</span>. The
coefficients of <span class="math">\(x\)</span> must be operation-compatible with <span class="math">\(\mathbb{Z}/p\mathbb{Z}\)</span>. The result
is a two-column matrix: the first column contains the irreducible factors of
<span class="math">\(x\)</span>, and the second their exponents. If all the coefficients of <span class="math">\(x\)</span> are in
<span class="math">\(\mathbb{F}_p\)</span>, a much faster algorithm is applied, using the computation of
isomorphisms between finite fields.</p>
<p>Either <span class="math">\(a\)</span> or <span class="math">\(p\)</span> can omitted (in which case both are ignored) if x has
<tt class="docutils literal"><span class="pre">t_FFELT</span></tt> coefficients; the function then becomes identical to <tt class="docutils literal"><span class="pre">factor</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>? factorff(x^2 + 1, 5, y^2+3) \\ over F_5[y]/(y^2+3) ~ F_25
%1 =
[Mod(Mod(1, 5), Mod(1, 5)*y^2 + Mod(3, 5))*x
 + Mod(Mod(2, 5), Mod(1, 5)*y^2 + Mod(3, 5)) 1]

[Mod(Mod(1, 5), Mod(1, 5)*y^2 + Mod(3, 5))*x
 + Mod(Mod(3, 5), Mod(1, 5)*y^2 + Mod(3, 5)) 1]
? t = ffgen(y^2 + Mod(3,5), &#39;t); \\ a generator for F_25 as a t_FFELT
? factorff(x^2 + 1) \\ not enough information to determine the base field
 *** at top-level: factorff(x^2+1)
 *** ^---------------
 *** factorff: incorrect type in factorff.
? factorff(x^2 + t^0) \\ make sure a coeff. is a t_FFELT
%3 =
[x + 2 1]

[x + 3 1]
? factorff(x^2 + t + 1)
%11 =
[x + (2*t + 1) 1]

[x + (3*t + 4) 1]
</pre></div>
</div>
<p>Notice that the second syntax is easier to use and much more readable.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.factorint">
<tt class="descname">factorint</tt><big>(</big><em>x</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.factorint" title="Permalink to this definition">¶</a></dt>
<dd><p>Factors the integer <span class="math">\(n\)</span> into a product of
pseudoprimes (see <tt class="docutils literal"><span class="pre">ispseudoprime</span></tt>), using a combination of the
Shanks SQUFOF and Pollard Rho method (with modifications due to
Brent), Lenstra&#8217;s ECM (with modifications by Montgomery), and
MPQS (the latter adapted from the LiDIA code with the kind
permission of the LiDIA maintainers), as well as a search for pure powers.
The output is a two-column matrix as for <tt class="docutils literal"><span class="pre">factor</span></tt>: the first column
contains the &#8220;prime&#8221; divisors of <span class="math">\(n\)</span>, the second one contains the
(positive) exponents.</p>
<p>By convention <span class="math">\(0\)</span> is factored as <span class="math">\(0^1\)</span>, and <span class="math">\(1\)</span> as the empty factorization;
also the divisors are by default not proven primes is they are larger than
<span class="math">\(2^{64}\)</span>, they only failed the BPSW compositeness test (see
<tt class="docutils literal"><span class="pre">ispseudoprime</span></tt>). Use <tt class="docutils literal"><span class="pre">isprime</span></tt> on the result if you want to
guarantee primality or set the <tt class="docutils literal"><span class="pre">factor_proven</span></tt> default to <span class="math">\(1\)</span>.
Entries of the private prime tables (see <tt class="docutils literal"><span class="pre">addprimes</span></tt>) are also included
as is.</p>
<p>This gives direct access to the integer factoring engine called by most
arithmetical functions. <em>flag</em> is optional; its binary digits mean 1: avoid
MPQS, 2: skip first stage ECM (we may still fall back to it later), 4: avoid
Rho and SQUFOF, 8: don&#8217;t run final ECM (as a result, a huge composite may be
declared to be prime). Note that a (strong) probabilistic primality test is
used; thus composites might not be detected, although no example is known.</p>
<p>You are invited to play with the flag settings and watch the internals at
work by using <tt class="docutils literal"><span class="pre">gp</span></tt>&#8216;s <tt class="docutils literal"><span class="pre">debug</span></tt> default parameter (level 3 shows
just the outline, 4 turns on time keeping, 5 and above show an increasing
amount of internal details).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.factormod">
<tt class="descname">factormod</tt><big>(</big><em>x</em>, <em>p</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.factormod" title="Permalink to this definition">¶</a></dt>
<dd><p>Factors the polynomial <span class="math">\(x\)</span> modulo the prime integer <span class="math">\(p\)</span>, using
Berlekamp. The coefficients of <span class="math">\(x\)</span> must be operation-compatible with
<span class="math">\(\mathbb{Z}/p\mathbb{Z}\)</span>. The result is a two-column matrix, the first column being the
irreducible polynomials dividing <span class="math">\(x\)</span>, and the second the exponents. If <span class="math">\(flag\)</span>
is non-zero, outputs only the <em>degrees</em> of the irreducible polynomials
(for example, for computing an <span class="math">\(L\)</span>-function). A different algorithm for
computing the mod <span class="math">\(p\)</span> factorization is <tt class="docutils literal"><span class="pre">factorcantor</span></tt> which is sometimes
faster.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.factornf">
<tt class="descname">factornf</tt><big>(</big><em>x</em>, <em>t</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.factornf" title="Permalink to this definition">¶</a></dt>
<dd><p>Factorization of the univariate polynomial <span class="math">\(x\)</span>
over the number field defined by the (univariate) polynomial <span class="math">\(t\)</span>. <span class="math">\(x\)</span> may
have coefficients in <span class="math">\(\mathbb{Q}\)</span> or in the number field. The algorithm reduces to
factorization over <span class="math">\(\mathbb{Q}\)</span> (Trager&#8217;s trick). The direct approach of
<tt class="docutils literal"><span class="pre">nffactor</span></tt>, which uses van Hoeij&#8217;s method in a relative setting, is
in general faster.</p>
<p>The main variable of <span class="math">\(t\)</span> must be of <em>lower</em> priority than that of <span class="math">\(x\)</span>
(see <tt class="docutils literal"><span class="pre">priority</span></tt> (in the PARI manual)). However if non-rational number field elements
occur (as polmods or polynomials) as coefficients of <span class="math">\(x\)</span>, the variable of
these polmods <em>must</em> be the same as the main variable of <span class="math">\(t\)</span>. For
example</p>
<div class="highlight-python"><div class="highlight"><pre>? factornf(x^2 + Mod(y, y^2+1), y^2+1);
? factornf(x^2 + y, y^2+1); \\ these two are OK
? factornf(x^2 + Mod(z,z^2+1), y^2+1)
 *** at top-level: factornf(x^2+Mod(z,z
 *** ^--------------------
 *** factornf: inconsistent data in rnf function.
? factornf(x^2 + z, y^2+1)
 *** at top-level: factornf(x^2+z,y^2+1
 *** ^--------------------
 *** factornf: incorrect variable in rnf function.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.factorpadic">
<tt class="descname">factorpadic</tt><big>(</big><em>pol</em>, <em>p</em>, <em>r</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.factorpadic" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(p\)</span>-adic factorization
of the polynomial <em>pol</em> to precision <span class="math">\(r\)</span>, the result being a
two-column matrix as in <tt class="docutils literal"><span class="pre">factor</span></tt>. Note that this is not the same
as a factorization over <span class="math">\(\mathbb{Z}/p^r\mathbb{Z}\)</span> (polynomials over that ring do not form a
unique factorization domain, anyway), but approximations in <span class="math">\(\mathbb{Q}/p^r\mathbb{Z}\)</span> of
the true factorization in <span class="math">\(\mathbb{Q}_p[X]\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? factorpadic(x^2 + 9, 3,5)
%1 =
[(1 + O(3^5))*x^2 + O(3^5)*x + (3^2 + O(3^5)) 1]
? factorpadic(x^2 + 1, 5,3)
%2 =
[ (1 + O(5^3))*x + (2 + 5 + 2*5^2 + O(5^3)) 1]

[(1 + O(5^3))*x + (3 + 3*5 + 2*5^2 + O(5^3)) 1]
</pre></div>
</div>
<p>The factors are normalized so that their leading coefficient is a power of
<span class="math">\(p\)</span>. The method used is a modified version of the round 4 algorithm of
Zassenhaus.</p>
<p>If <em>pol</em> has inexact <tt class="docutils literal"><span class="pre">t_PADIC</span></tt> coefficients, this is not always
well-defined; in this case, the polynomial is first made integral by dividing
out the <span class="math">\(p\)</span>-adic content, then lifted to <span class="math">\(\mathbb{Z}\)</span> using <tt class="docutils literal"><span class="pre">truncate</span></tt>
coefficientwise.
Hence we actually factor exactly a polynomial which is only <span class="math">\(p\)</span>-adically
close to the input. To avoid pitfalls, we advise to only factor polynomials
with exact rational coefficients.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ffgen">
<tt class="descname">ffgen</tt><big>(</big><em>q</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ffgen" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <tt class="docutils literal"><span class="pre">t_FFELT</span></tt> generator for the finite field with <span class="math">\(q\)</span> elements;
<span class="math">\(q = p^f\)</span> must be a prime power. This functions computes an irreducible
monic polynomial <span class="math">\(P belongs to \mathbb{F}_p[X]\)</span> of degree&nbsp;<span class="math">\(f\)</span> (via <tt class="docutils literal"><span class="pre">ffinit</span></tt>) and
returns <span class="math">\(g = X (mod P(X))\)</span>. If <tt class="docutils literal"><span class="pre">v</span></tt> is given, the variable name is used
to display <span class="math">\(g\)</span>, else the variable <span class="math">\(x\)</span> is used.</p>
<div class="highlight-python"><div class="highlight"><pre>? g = ffgen(8, &#39;t);
? g.mod
%2 = t^3 + t^2 + 1
? g.p
%3 = 2
? g.f
%4 = 3
? ffgen(6)
 *** at top-level: ffgen(6)
 *** ^--------
 *** ffgen: not a prime number in ffgen: 6.
</pre></div>
</div>
<p>Alternative syntax: instead of a prime power <span class="math">\(q = p^f\)</span>, one may
input the pair <span class="math">\([p,f]\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>? g = ffgen([2,4], &#39;t);
? g.p
%2 = 2
? g.mod
%3 = t^4 + t^3 + t^2 + t + 1
</pre></div>
</div>
<p>Finally, one may input
directly the polynomial <span class="math">\(P\)</span> (monic, irreducible, with <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt>
coefficients), and the function returns the generator <span class="math">\(g = X (mod P(X))\)</span>,
inferring <span class="math">\(p\)</span> from the coefficients of <span class="math">\(P\)</span>. If <tt class="docutils literal"><span class="pre">v</span></tt> is given, the
variable name is used to display <span class="math">\(g\)</span>, else the variable of the polynomial
<span class="math">\(P\)</span> is used. If <span class="math">\(P\)</span> is not irreducible, we create an invalid object and
behaviour of functions dealing with the resulting <tt class="docutils literal"><span class="pre">t_FFELT</span></tt>
is undefined; in fact, it is much more costly to test <span class="math">\(P\)</span> for
irreducibility than it would be to produce it via <tt class="docutils literal"><span class="pre">ffinit</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ffinit">
<tt class="descname">ffinit</tt><big>(</big><em>p</em>, <em>n</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ffinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a monic polynomial of degree <span class="math">\(n\)</span> which is irreducible over
<span class="math">\(\mathbb{F}_p\)</span>, where <span class="math">\(p\)</span> is assumed to be prime. This function uses a fast variant
of Adleman and Lenstra&#8217;s algorithm.</p>
<p>It is useful in conjunction with <tt class="docutils literal"><span class="pre">ffgen</span></tt>; for instance if
<tt class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">ffinit(3,2)</span></tt>, you can represent elements in <span class="math">\(\mathbb{F}_{3^2}\)</span> in term of
<tt class="docutils literal"><span class="pre">g</span> <span class="pre">=</span> <span class="pre">ffgen(P,'t)</span></tt>. This can be abbreviated as
<tt class="docutils literal"><span class="pre">g</span> <span class="pre">=</span> <span class="pre">ffgen(3^2,</span> <span class="pre">'t)</span></tt>, where the defining polynomial <span class="math">\(P\)</span> can be later
recovered as <tt class="docutils literal"><span class="pre">g.mod</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.fflog">
<tt class="descname">fflog</tt><big>(</big><em>x</em>, <em>g</em>, <em>o=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.fflog" title="Permalink to this definition">¶</a></dt>
<dd><p>Discrete logarithm of the finite field element <span class="math">\(x\)</span> in base <span class="math">\(g\)</span>, i.e.&nbsp;
an <span class="math">\(e\)</span> in <span class="math">\(\mathbb{Z}\)</span> such that <span class="math">\(g^e = o\)</span>. If
present, <span class="math">\(o\)</span> represents the multiplicative order of <span class="math">\(g\)</span>, see
<tt class="docutils literal"><span class="pre">DLfun</span></tt> (in the PARI manual); the preferred format for
this parameter is <tt class="docutils literal"><span class="pre">[ord,</span> <span class="pre">factor(ord)]</span></tt>, where <tt class="docutils literal"><span class="pre">ord</span></tt> is the
order of <span class="math">\(g\)</span>. It may be set as a side effect of calling <tt class="docutils literal"><span class="pre">ffprimroot</span></tt>.</p>
<p>If no <span class="math">\(o\)</span> is given, assume that <span class="math">\(g\)</span> is a primitive root. The result is
undefined if <span class="math">\(e\)</span> does not exist. This function uses</p>
<ul class="simple">
<li>a combination of generic discrete log algorithms (see <tt class="docutils literal"><span class="pre">znlog</span></tt>)</li>
<li>a cubic sieve index calculus algorithm for large fields of degree at
least <span class="math">\(5\)</span>.</li>
<li>Coppersmith&#8217;s algorithm for fields of characteristic at most <span class="math">\(5\)</span>.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? t = ffgen(ffinit(7,5));
? o = fforder(t)
%2 = 5602 \\ not a primitive root.
? fflog(t^10,t)
%3 = 10
? fflog(t^10,t, o)
%4 = 10
? g = ffprimroot(t, &amp;o);
? o \\ order is 16806, bundled with its factorization matrix
%6 = [16806, [2, 1; 3, 1; 2801, 1]]
? fforder(g, o)
%7 = 16806
? fflog(g^10000, g, o)
%8 = 10000
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ffnbirred">
<tt class="descname">ffnbirred</tt><big>(</big><em>q</em>, <em>n</em>, <em>fl=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ffnbirred" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the number of monic irreducible polynomials over <span class="math">\(\mathbb{F}_q\)</span> of degree exactly <span class="math">\(n\)</span>,
(<span class="math">\(flag = 0\)</span> or omitted) or at most <span class="math">\(n\)</span> (<span class="math">\(flag = 1\)</span>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.fforder">
<tt class="descname">fforder</tt><big>(</big><em>x</em>, <em>o=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.fforder" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplicative order of the finite field element <span class="math">\(x\)</span>. If <span class="math">\(o\)</span> is
present, it represents a multiple of the order of the element,
see <tt class="docutils literal"><span class="pre">DLfun</span></tt> (in the PARI manual); the preferred format for
this parameter is <tt class="docutils literal"><span class="pre">[N,</span> <span class="pre">factor(N)]</span></tt>, where <tt class="docutils literal"><span class="pre">N</span></tt> is the cardinality
of the multiplicative group of the underlying finite field.</p>
<div class="highlight-python"><div class="highlight"><pre>? t = ffgen(ffinit(nextprime(10^8), 5));
? g = ffprimroot(t, &amp;o); \\ o will be useful!
? fforder(g^1000000, o)
time = 0 ms.
%5 = 5000001750000245000017150000600250008403
? fforder(g^1000000)
time = 16 ms. \\ noticeably slower, same result of course
%6 = 5000001750000245000017150000600250008403
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.floor">
<tt class="descname">floor</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Floor of <span class="math">\(x\)</span>. When <span class="math">\(x\)</span> is in <span class="math">\(\mathbb{R}\)</span>, the result is the
largest integer smaller than or equal to <span class="math">\(x\)</span>. Applied to a rational function,
<span class="math">\(floor(x)\)</span> returns the Euclidean quotient of the numerator by the
denominator.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.fold">
<tt class="descname">fold</tt><big>(</big><em>f</em>, <em>A</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.fold" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the <tt class="docutils literal"><span class="pre">t_CLOSURE</span></tt> <tt class="docutils literal"><span class="pre">f</span></tt> of arity <span class="math">\(2\)</span> to the entries of <tt class="docutils literal"><span class="pre">A</span></tt>
to return <tt class="docutils literal"><span class="pre">f(...f(f(A[1],A[2]),A[3])...,A[#A])</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>? fold((x,y)-&gt;x*y, [1,2,3,4])
%1 = 24
? fold((x,y)-&gt;[x,y], [1,2,3,4])
%2 = [[[1, 2], 3], 4]
? fold((x,f)-&gt;f(x), [2,sqr,sqr,sqr])
%3 = 256
? fold((x,y)-&gt;(x+y)/(1-x*y),[1..5])
%4 = -9/19
? bestappr(tan(sum(i=1,5,atan(i))))
%5 = -9/19
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.frac">
<tt class="descname">frac</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.frac" title="Permalink to this definition">¶</a></dt>
<dd><p>Fractional part of <span class="math">\(x\)</span>. Identical to
<span class="math">\(x-{floor}(x)\)</span>. If <span class="math">\(x\)</span> is real, the result is in <span class="math">\([0,1[\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.fromdigits">
<tt class="descname">fromdigits</tt><big>(</big><em>x</em>, <em>b=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.fromdigits" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the integer formed by the elements of <span class="math">\(x\)</span> seen as the digits of a
number in base <span class="math">\(b\)</span>. This is the reverse of <tt class="docutils literal"><span class="pre">digits</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>? digits(1234,5)
%1 = [1,4,4,1,4]
? fromdigits([1,4,4,1,4],5)
%2 = 1234
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoisexport">
<tt class="descname">galoisexport</tt><big>(</big><em>gal</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoisexport" title="Permalink to this definition">¶</a></dt>
<dd><p><em>gal</em> being be a Galois group as output by <tt class="docutils literal"><span class="pre">galoisinit</span></tt>,
export the underlying permutation group as a string suitable
for (no flags or <span class="math">\(flag = 0\)</span>) GAP or (<span class="math">\(flag = 1\)</span>) Magma. The following example
compute the index of the underlying abstract group in the GAP library:</p>
<div class="highlight-python"><div class="highlight"><pre>? G = galoisinit(x^6+108);
? s = galoisexport(G)
%2 = &quot;Group((1, 2, 3)(4, 5, 6), (1, 4)(2, 6)(3, 5))&quot;
? extern(&quot;echo \&quot;IdGroup(&quot;s&quot;);\&quot; | gap -q&quot;)
%3 = [6, 1]
? galoisidentify(G)
%4 = [6, 1]
</pre></div>
</div>
<p>This command also accepts subgroups returned by <tt class="docutils literal"><span class="pre">galoissubgroups</span></tt>.</p>
<p>To <em>import</em> a GAP permutation into gp (for <tt class="docutils literal"><span class="pre">galoissubfields</span></tt> for
instance), the following GAP function may be useful:</p>
<div class="highlight-python"><div class="highlight"><pre>PermToGP := function(p, n)
 return Permuted([1..n],p);
end;

gap&gt; p:= (1,26)(2,5)(3,17)(4,32)(6,9)(7,11)(8,24)(10,13)(12,15)(14,27)
 (16,22)(18,28)(19,20)(21,29)(23,31)(25,30)
gap&gt; PermToGP(p,32);
[ 26, 5, 17, 32, 2, 9, 11, 24, 6, 13, 7, 15, 10, 27, 12, 22, 3, 28, 20, 19,
 29, 16, 31, 8, 30, 1, 14, 18, 21, 25, 23, 4 ]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoisfixedfield">
<tt class="descname">galoisfixedfield</tt><big>(</big><em>gal</em>, <em>perm</em>, <em>flag=0</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoisfixedfield" title="Permalink to this definition">¶</a></dt>
<dd><p><em>gal</em> being be a Galois group as output by <tt class="docutils literal"><span class="pre">galoisinit</span></tt> and
<em>perm</em> an element of <span class="math">\(gal.group\)</span>, a vector of such elements
or a subgroup of <em>gal</em> as returned by galoissubgroups,
computes the fixed field of <em>gal</em> by the automorphism defined by the
permutations <em>perm</em> of the roots <span class="math">\(gal.roots\)</span>. <span class="math">\(P\)</span> is guaranteed to
be squarefree modulo <span class="math">\(gal.p\)</span>.</p>
<p>If no flags or <span class="math">\(flag = 0\)</span>, output format is the same as for <tt class="docutils literal"><span class="pre">nfsubfield</span></tt>,
returning <span class="math">\([P,x]\)</span> such that <span class="math">\(P\)</span> is a polynomial defining the fixed field, and
<span class="math">\(x\)</span> is a root of <span class="math">\(P\)</span> expressed as a polmod in <span class="math">\(gal.pol\)</span>.</p>
<p>If <span class="math">\(flag = 1\)</span> return only the polynomial <span class="math">\(P\)</span>.</p>
<p>If <span class="math">\(flag = 2\)</span> return <span class="math">\([P,x,F]\)</span> where <span class="math">\(P\)</span> and <span class="math">\(x\)</span> are as above and <span class="math">\(F\)</span> is the
factorization of <span class="math">\(gal.pol\)</span> over the field defined by <span class="math">\(P\)</span>, where
variable <span class="math">\(v\)</span> (<span class="math">\(y\)</span> by default) stands for a root of <span class="math">\(P\)</span>. The priority of <span class="math">\(v\)</span>
must be less than the priority of the variable of <span class="math">\(gal.pol\)</span> (see
<tt class="docutils literal"><span class="pre">priority</span></tt> (in the PARI manual)). Example:</p>
<div class="highlight-python"><div class="highlight"><pre>? G = galoisinit(x^4+1);
? galoisfixedfield(G,G.group[2],2)
%2 = [x^2 + 2, Mod(x^3 + x, x^4 + 1), [x^2 - y*x - 1, x^2 + y*x - 1]]
</pre></div>
</div>
<p>computes the factorization <span class="math">\(x^4+1 = (x^2-\sqrt{-2}x-1)(x^2+\sqrt{-2}x-1)\)</span></p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoisidentify">
<tt class="descname">galoisidentify</tt><big>(</big><em>gal</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoisidentify" title="Permalink to this definition">¶</a></dt>
<dd><p><em>gal</em> being be a Galois group as output by <tt class="docutils literal"><span class="pre">galoisinit</span></tt>,
output the isomorphism class of the underlying abstract group as a
two-components vector <span class="math">\([o,i]\)</span>, where <span class="math">\(o\)</span> is the group order, and <span class="math">\(i\)</span> is the
group index in the GAP4 Small Group library, by Hans Ulrich Besche, Bettina
Eick and Eamonn O&#8217;Brien.</p>
<p>This command also accepts subgroups returned by <tt class="docutils literal"><span class="pre">galoissubgroups</span></tt>.</p>
<p>The current implementation is limited to degree less or equal to <span class="math">\(127\)</span>.
Some larger &#8220;easy&#8221; orders are also supported.</p>
<p>The output is similar to the output of the function <tt class="docutils literal"><span class="pre">IdGroup</span></tt> in GAP4.
Note that GAP4 <tt class="docutils literal"><span class="pre">IdGroup</span></tt> handles all groups of order less than <span class="math">\(2000\)</span>
except <span class="math">\(1024\)</span>, so you can use <tt class="docutils literal"><span class="pre">galoisexport</span></tt> and GAP4 to identify large
Galois groups.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoisinit">
<tt class="descname">galoisinit</tt><big>(</big><em>pol</em>, <em>den=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoisinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Galois group
and all necessary information for computing the fixed fields of the
Galois extension <span class="math">\(K/\mathbb{Q}\)</span> where <span class="math">\(K\)</span> is the number field defined by
<span class="math">\(pol\)</span> (monic irreducible polynomial in <span class="math">\(\mathbb{Z}[X]\)</span> or
a number field as output by <tt class="docutils literal"><span class="pre">nfinit</span></tt>). The extension <span class="math">\(K/\mathbb{Q}\)</span> must be
Galois with Galois group &#8220;weakly&#8221; super-solvable, see below;
returns 0 otherwise. Hence this permits to quickly check whether a polynomial
of order strictly less than <span class="math">\(36\)</span> is Galois or not.</p>
<p>The algorithm used is an improved version of the paper
&#8220;An efficient algorithm for the computation of Galois automorphisms&#8221;,
Bill Allombert, Math.&nbsp;Comp, vol.&nbsp;73, 245, 2001, pp.&nbsp;359&#8211;375.</p>
<p>A group <span class="math">\(G\)</span> is said to be &#8220;weakly&#8221; super-solvable if there exists a
normal series</p>
<p><span class="math">\({1} = H_0 \\triangleleft H_1 \\triangleleft...\\triangleleft H_{n-1}
\triangleleft H_n\)</span></p>
<p>such that each <span class="math">\(H_i\)</span> is normal in <span class="math">\(G\)</span> and for <span class="math">\(i &lt; n\)</span>, each quotient group
<span class="math">\(H_{i+1}/H_i\)</span> is cyclic, and either <span class="math">\(H_n = G\)</span> (then <span class="math">\(G\)</span> is super-solvable) or
<span class="math">\(G/H_n\)</span> is isomorphic to either <span class="math">\(A_4\)</span> or <span class="math">\(S_4\)</span>.</p>
<p>In practice, almost all small groups are WKSS, the exceptions having order
36(1 exception), 48(2), 56(1), 60(1), 72(5), 75(1), 80(1), 96(10) and <span class="math">\(\\geq
108\)</span>.</p>
<p>This function is a prerequisite for most of the <tt class="docutils literal"><span class="pre">galois</span></tt><span class="math">\(xxx\)</span> routines.
For instance:</p>
<div class="highlight-python"><div class="highlight"><pre>P = x^6 + 108;
G = galoisinit(P);
L = galoissubgroups(G);
vector(#L, i, galoisisabelian(L[i],1))
vector(#L, i, galoisidentify(L[i]))
</pre></div>
</div>
<p>The output is an 8-component vector <em>gal</em>.</p>
<p><span class="math">\(gal[1]\)</span> contains the polynomial <em>pol</em>
(<tt class="docutils literal"><span class="pre">:emphasis:`gal</span></tt>.pol`).</p>
<p><span class="math">\(gal[2]\)</span> is a three-components vector <span class="math">\([p,e,q]\)</span> where <span class="math">\(p\)</span> is a
prime number (<tt class="docutils literal"><span class="pre">:emphasis:`gal</span></tt>.p`) such that <em>pol</em> totally split
modulo <span class="math">\(p\)</span> , <span class="math">\(e\)</span> is an integer and <span class="math">\(q = p^e\)</span> (<tt class="docutils literal"><span class="pre">:emphasis:`gal</span></tt>.mod`) is the
modulus of the roots in <tt class="docutils literal"><span class="pre">:emphasis:`gal</span></tt>.roots`.</p>
<p><span class="math">\(gal[3]\)</span> is a vector <span class="math">\(L\)</span> containing the <span class="math">\(p\)</span>-adic roots of
<em>pol</em> as integers implicitly modulo <tt class="docutils literal"><span class="pre">:emphasis:`gal</span></tt>.mod`.
(<tt class="docutils literal"><span class="pre">:emphasis:`gal</span></tt>.roots`).</p>
<p><span class="math">\(gal[4]\)</span> is the inverse of the Vandermonde matrix of the
<span class="math">\(p\)</span>-adic roots of <em>pol</em>, multiplied by <span class="math">\(gal[5]\)</span>.</p>
<p><span class="math">\(gal[5]\)</span> is a multiple of the least common denominator of the
automorphisms expressed as polynomial in a root of <em>pol</em>.</p>
<p><span class="math">\(gal[6]\)</span> is the Galois group <span class="math">\(G\)</span> expressed as a vector of
permutations of <span class="math">\(L\)</span> (<tt class="docutils literal"><span class="pre">:emphasis:`gal</span></tt>.group`).</p>
<p><span class="math">\(gal[7]\)</span> is a generating subset <span class="math">\(S = [s_1,...,s_g]\)</span> of <span class="math">\(G\)</span>
expressed as a vector of permutations of <span class="math">\(L\)</span> (<tt class="docutils literal"><span class="pre">:emphasis:`gal</span></tt>.gen`).</p>
<p><span class="math">\(gal[8]\)</span> contains the relative orders <span class="math">\([o_1,...,o_g]\)</span> of
the generators of <span class="math">\(S\)</span> (<tt class="docutils literal"><span class="pre">:emphasis:`gal</span></tt>.orders`).</p>
<p>Let <span class="math">\(H_n\)</span> be as above, we have the following properties:</p>
<p>&nbsp;&nbsp;<strong>*</strong> if <span class="math">\(G/H_n ~ A_4\)</span> then <span class="math">\([o_1,...,o_g]\)</span> ends by
<span class="math">\([2,2,3]\)</span>.</p>
<p>&nbsp;&nbsp;<strong>*</strong> if <span class="math">\(G/H_n ~ S_4\)</span> then <span class="math">\([o_1,...,o_g]\)</span> ends by
<span class="math">\([2,2,3,2]\)</span>.</p>
<p>&nbsp;&nbsp;<strong>*</strong> for <span class="math">\(1 &lt;= i &lt;= g\)</span> the subgroup of <span class="math">\(G\)</span> generated by
<span class="math">\([s_1,...,s_g]\)</span> is normal, with the exception of <span class="math">\(i = g-2\)</span> in the
<span class="math">\(A_4\)</span> case and of <span class="math">\(i = g-3\)</span> in the <span class="math">\(S_A\)</span> case.</p>
<p>&nbsp;&nbsp;<strong>*</strong> the relative order <span class="math">\(o_i\)</span> of <span class="math">\(s_i\)</span> is its order in the
quotient group <span class="math">\(G/&lt;&nbsp;s_1,...,s_{i-1}&gt;\)</span>, with the same
exceptions.</p>
<p>&nbsp;&nbsp;<strong>*</strong> for any <span class="math">\(x belongs to G\)</span> there exists a unique family
<span class="math">\([e_1,...,e_g]\)</span> such that (no exceptions):</p>
<p>&#8211; for <span class="math">\(1 &lt;= i &lt;= g\)</span> we have <span class="math">\(0 &lt;= e_i &lt; o_i\)</span></p>
<p>&#8211; <span class="math">\(x = g_1^{e_1}g_2^{e_2}...g_n^{e_n}\)</span></p>
<p>If present <span class="math">\(den\)</span> must be a suitable value for <span class="math">\(gal[5]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoisisabelian">
<tt class="descname">galoisisabelian</tt><big>(</big><em>gal</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoisisabelian" title="Permalink to this definition">¶</a></dt>
<dd><p><em>gal</em> being as output by <tt class="docutils literal"><span class="pre">galoisinit</span></tt>, return <span class="math">\(0\)</span> if
<em>gal</em> is not an abelian group, and the HNF matrix of <em>gal</em> over
<tt class="docutils literal"><span class="pre">gal.gen</span></tt> if <span class="math">\(fl = 0\)</span>, <span class="math">\(1\)</span> if <span class="math">\(fl = 1\)</span>.</p>
<p>This command also accepts subgroups returned by <tt class="docutils literal"><span class="pre">galoissubgroups</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoisisnormal">
<tt class="descname">galoisisnormal</tt><big>(</big><em>gal</em>, <em>subgrp</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoisisnormal" title="Permalink to this definition">¶</a></dt>
<dd><p><em>gal</em> being as output by <tt class="docutils literal"><span class="pre">galoisinit</span></tt>, and <em>subgrp</em> a subgroup
of <em>gal</em> as output by <tt class="docutils literal"><span class="pre">galoissubgroups</span></tt>,return <span class="math">\(1\)</span> if <em>subgrp</em> is a
normal subgroup of <em>gal</em>, else return 0.</p>
<p>This command also accepts subgroups returned by <tt class="docutils literal"><span class="pre">galoissubgroups</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoispermtopol">
<tt class="descname">galoispermtopol</tt><big>(</big><em>gal</em>, <em>perm</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoispermtopol" title="Permalink to this definition">¶</a></dt>
<dd><p><em>gal</em> being a
Galois group as output by <tt class="docutils literal"><span class="pre">galoisinit</span></tt> and <em>perm</em> a element of
<span class="math">\(gal.group\)</span>, return the polynomial defining the Galois
automorphism, as output by <tt class="docutils literal"><span class="pre">nfgaloisconj</span></tt>, associated with the
permutation <em>perm</em> of the roots <span class="math">\(gal.roots\)</span>. <em>perm</em> can
also be a vector or matrix, in this case, <tt class="docutils literal"><span class="pre">galoispermtopol</span></tt> is
applied to all components recursively.</p>
<p>Note that</p>
<div class="highlight-python"><div class="highlight"><pre>G = galoisinit(pol);
galoispermtopol(G, G[6])~
</pre></div>
</div>
<p>is equivalent to <tt class="docutils literal"><span class="pre">nfgaloisconj(pol)</span></tt>, if degree of <em>pol</em> is greater
or equal to <span class="math">\(2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoissubcyclo">
<tt class="descname">galoissubcyclo</tt><big>(</big><em>N</em>, <em>H=None</em>, <em>fl=0</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoissubcyclo" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the subextension
of <span class="math">\(\mathbb{Q}(\zeta_n)\)</span> fixed by the subgroup <span class="math">\(H \\subset (\mathbb{Z}/n\mathbb{Z})^*\)</span>. By the
Kronecker-Weber theorem, all abelian number fields can be generated in this
way (uniquely if <span class="math">\(n\)</span> is taken to be minimal).</p>
<p>The pair <span class="math">\((n, H)\)</span> is deduced from the parameters <span class="math">\((N, H)\)</span> as follows</p>
<ul class="simple">
<li><span class="math">\(N\)</span> an integer: then <span class="math">\(n = N\)</span>; <span class="math">\(H\)</span> is a generator, i.e. an
integer or an integer modulo <span class="math">\(n\)</span>; or a vector of generators.</li>
<li><span class="math">\(N\)</span> the output of <tt class="docutils literal"><span class="pre">znstar(:math:`n</span></tt>)`. <span class="math">\(H\)</span> as in the first case
above, or a matrix, taken to be a HNF left divisor of the SNF for <span class="math">\((\mathbb{Z}/n\mathbb{Z})^*\)</span>
(of type <tt class="docutils literal"><span class="pre">:math:`N</span></tt>.cyc`), giving the generators of <span class="math">\(H\)</span> in terms of <tt class="docutils literal"><span class="pre">:math:`N</span></tt>.gen`.</li>
<li><span class="math">\(N\)</span> the output of <tt class="docutils literal"><span class="pre">bnrinit(bnfinit(y),</span> <span class="pre">:math:`m</span></tt>, 1)` where <span class="math">\(m\)</span> is a
module. <span class="math">\(H\)</span> as in the first case, or a matrix taken to be a HNF left
divisor of the SNF for the ray class group modulo <span class="math">\(m\)</span>
(of type <tt class="docutils literal"><span class="pre">:math:`N</span></tt>.cyc`), giving the generators of <span class="math">\(H\)</span> in terms of <tt class="docutils literal"><span class="pre">:math:`N</span></tt>.gen`.</li>
</ul>
<p>In this last case, beware that <span class="math">\(H\)</span> is understood relatively to <span class="math">\(N\)</span>; in
particular, if the infinite place does not divide the module, e.g if <span class="math">\(m\)</span> is
an integer, then it is not a subgroup of <span class="math">\((\mathbb{Z}/n\mathbb{Z})^*\)</span>, but of its quotient by
<span class="math">\({± 1}\)</span>.</p>
<p>If <span class="math">\(fl = 0\)</span>, compute a polynomial (in the variable <em>v</em>) defining the
the subfield of <span class="math">\(\mathbb{Q}(\zeta_n)\)</span> fixed by the subgroup <em>H</em> of <span class="math">\((\mathbb{Z}/n\mathbb{Z})^*\)</span>.</p>
<p>If <span class="math">\(fl = 1\)</span>, compute only the conductor of the abelian extension, as a module.</p>
<p>If <span class="math">\(fl = 2\)</span>, output <span class="math">\([pol, N]\)</span>, where <span class="math">\(pol\)</span> is the polynomial as output when
<span class="math">\(fl = 0\)</span> and <span class="math">\(N\)</span> the conductor as output when <span class="math">\(fl = 1\)</span>.</p>
<p>The following function can be used to compute all subfields of
<span class="math">\(\mathbb{Q}(\zeta_n)\)</span> (of exact degree <tt class="docutils literal"><span class="pre">d</span></tt>, if <tt class="docutils literal"><span class="pre">d</span></tt> is set):</p>
<div class="highlight-python"><div class="highlight"><pre>polsubcyclo(n, d = -1)=
{ my(bnr,L,IndexBound);
 IndexBound = if (d &lt; 0, n, [d]);
 bnr = bnrinit(bnfinit(y), [n,[1]], 1);
 L = subgrouplist(bnr, IndexBound, 1);
 vector(#L,i, galoissubcyclo(bnr,L[i]));
}
</pre></div>
</div>
<p>Setting <tt class="docutils literal"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">subgrouplist(bnr,</span> <span class="pre">IndexBound)</span></tt> would produce subfields of exact
conductor <span class="math">\(n oo\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoissubfields">
<tt class="descname">galoissubfields</tt><big>(</big><em>G</em>, <em>flags=0</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoissubfields" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs all the subfields of the Galois group <em>G</em>, as a vector.
This works by applying <tt class="docutils literal"><span class="pre">galoisfixedfield</span></tt> to all subgroups. The meaning of
the flag <em>fl</em> is the same as for <tt class="docutils literal"><span class="pre">galoisfixedfield</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoissubgroups">
<tt class="descname">galoissubgroups</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoissubgroups" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs all the subgroups of the Galois group <tt class="docutils literal"><span class="pre">gal</span></tt>. A subgroup is a
vector [<em>gen</em>, <em>orders</em>], with the same meaning
as for <span class="math">\(gal.gen\)</span> and <span class="math">\(gal.orders\)</span>. Hence <em>gen</em> is a vector of
permutations generating the subgroup, and <em>orders</em> is the relatives
orders of the generators. The cardinality of a subgroup is the product of the
relative orders. Such subgroup can be used instead of a Galois group in the
following command: <tt class="docutils literal"><span class="pre">galoisisabelian</span></tt>, <tt class="docutils literal"><span class="pre">galoissubgroups</span></tt>,
<tt class="docutils literal"><span class="pre">galoisexport</span></tt> and <tt class="docutils literal"><span class="pre">galoisidentify</span></tt>.</p>
<p>To get the subfield fixed by a subgroup <em>sub</em> of <em>gal</em>, use</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">galoisfixedfield</span><span class="p">(</span><span class="n">gal</span><span class="p">,</span><span class="n">sub</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.gamma">
<tt class="descname">gamma</tt><big>(</big><em>s</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>For <span class="math">\(s\)</span> a complex number, evaluates Euler&#8217;s gamma
function</p>
<div class="math">
\[\Gamma(s) = \int_0^ oo t^{s-1}\exp(-t)dt.\]</div>
<p>Error if <span class="math">\(s\)</span> is a non-positive integer, where <span class="math">\(\Gamma\)</span> has a pole.</p>
<p>For <span class="math">\(s\)</span> a <tt class="docutils literal"><span class="pre">t_PADIC</span></tt>, evaluates the Morita gamma function at <span class="math">\(s\)</span>, that
is the unique continuous <span class="math">\(p\)</span>-adic function on the <span class="math">\(p\)</span>-adic integers
extending <span class="math">\(\Gamma_p(k) = (-1)^k \prod_{j &lt; k}'j\)</span>, where the prime means that <span class="math">\(p\)</span>
does not divide <span class="math">\(j\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? gamma(1/4 + O(5^10))
%1= 1 + 4*5 + 3*5^4 + 5^6 + 5^7 + 4*5^9 + O(5^10)
? algdep(%,4)
%2 = x^4 + 4*x^2 + 5
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.gammah">
<tt class="descname">gammah</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.gammah" title="Permalink to this definition">¶</a></dt>
<dd><p>Gamma function evaluated at the argument <span class="math">\(x+1/2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.gammamellininv">
<tt class="descname">gammamellininv</tt><big>(</big><em>G</em>, <em>t</em>, <em>m=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.gammamellininv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value at <span class="math">\(t\)</span> of the inverse Mellin transform
<span class="math">\(G\)</span> initialized by <tt class="docutils literal"><span class="pre">gammamellininvinit</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>? G = gammamellininvinit([0]);
? gammamellininv(G, 2) - 2*exp(-Pi*2^2)
%2 = -4.484155085839414627 E-44
</pre></div>
</div>
<p>The alternative shortcut</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">gammamellininv</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>for</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">gammamellininv</span><span class="p">(</span><span class="n">gammamellininvinit</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">m</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>is available.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.gammamellininvasymp">
<tt class="descname">gammamellininvasymp</tt><big>(</big><em>A</em>, <em>serprec=-1</em>, <em>n=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.gammamellininvasymp" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the first <span class="math">\(n\)</span> terms of the asymptotic expansion at infinity
of the <span class="math">\(m\)</span>-th derivative <span class="math">\(K^{(m)}(t)\)</span> of the inverse Mellin transform of the
function</p>
<div class="math">
\[f(s) = \Gamma_\mathbb{R}(s+a_1)...\Gamma_\mathbb{R}(s+a_d) ,\]</div>
<p>where <tt class="docutils literal"><span class="pre">A</span></tt> is the vector <span class="math">\([a_1,...,a_d]\)</span> and
<span class="math">\(\Gamma_\mathbb{R}(s) = \Pi^{-s/2} \Gamma(s/2)\)</span>.
The result is a vector
<span class="math">\([M[1]...M[n]]\)</span> with M[1] = 1, such that</p>
<div class="math">
\[\begin{split}K^{(m)}(t) = \sqrt(2^{d+1}/d)t^{1-d+a+m(2/d-1)}e^{-d\Pi t^{2/d}}
\sum_{n &gt;= 0} M[n+1]t^{-2n/d}\end{split}\]</div>
<p>with <span class="math">\(a = (1-d+\sum_{1 &lt;= j &lt;= d}a_j)/d\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.gammamellininvinit">
<tt class="descname">gammamellininvinit</tt><big>(</big><em>A</em>, <em>m=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.gammamellininvinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize data for the computation by <tt class="docutils literal"><span class="pre">gammamellininv</span></tt> of
the <span class="math">\(m\)</span>-th derivative of the inverse Mellin transform of the function</p>
<div class="math">
\[f(s) = \Gamma_\mathbb{R}(s+a_1)...\Gamma_\mathbb{R}(s+a_d)\]</div>
<p>where <tt class="docutils literal"><span class="pre">A</span></tt> is the vector <span class="math">\([a_1,...,a_d]\)</span> and
<span class="math">\(\Gamma_\mathbb{R}(s) = \Pi^{-s/2} \Gamma(s/2)\)</span>. This is the special case of Meijer&#8217;s
<span class="math">\(G\)</span> functions used to compute <span class="math">\(L\)</span>-values via the approximate functional
equation.</p>
<p><strong>Caveat.</strong> Contrary to the PARI convention, this function
guarantees an <em>absolute</em> (rather than relative) error bound.</p>
<p>For instance, the inverse Mellin transform of <span class="math">\(\Gamma_\mathbb{R}(s)\)</span> is
<span class="math">\(2\exp(-\Pi z^2)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>? G = gammamellininvinit([0]);
? gammamellininv(G, 2) - 2*exp(-Pi*2^2)
%2 = -4.484155085839414627 E-44
</pre></div>
</div>
<p>The inverse Mellin transform of <span class="math">\(\Gamma_\mathbb{R}(s+1)\)</span> is
<span class="math">\(2 z\exp(-\Pi z^2)\)</span>, and its second derivative is
<span class="math">\(4\Pi z \exp(-\Pi z^2)(2\Pi z^2 - 3)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>? G = gammamellininvinit([1], 2);
? a(z) = 4*Pi*z*exp(-Pi*z^2)*(2*Pi*z^2-3);
? b(z) = gammamellininv(G,z);
? t(z) = b(z) - a(z);
? t(3/2)
%3 = -1.4693679385278593850 E-39
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.gcd">
<tt class="descname">gcd</tt><big>(</big><em>x</em>, <em>y=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.gcd" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the greatest common divisor of <span class="math">\(x\)</span> and <span class="math">\(y\)</span>.
If you also need the <span class="math">\(u\)</span> and <span class="math">\(v\)</span> such that <span class="math">\(x*u + y*v = \mathrm{gcd}(x,y)\)</span>,
use the <tt class="docutils literal"><span class="pre">bezout</span></tt> function. <span class="math">\(x\)</span> and <span class="math">\(y\)</span> can have rather quite general
types, for instance both rational numbers. If <span class="math">\(y\)</span> is omitted and <span class="math">\(x\)</span> is a
vector, returns the <span class="math">\({gcd}\)</span> of all components of <span class="math">\(x\)</span>, i.e.&nbsp;this is
equivalent to <tt class="docutils literal"><span class="pre">content(x)</span></tt>.</p>
<p>When <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are both given and one of them is a vector/matrix type,
the GCD is again taken recursively on each component, but in a different way.
If <span class="math">\(y\)</span> is a vector, resp.&nbsp;matrix, then the result has the same type as <span class="math">\(y\)</span>,
and components equal to <tt class="docutils literal"><span class="pre">gcd(x,</span> <span class="pre">y[i])</span></tt>, resp.&nbsp;<tt class="docutils literal"><span class="pre">gcd(x,</span> <span class="pre">y[,i])</span></tt>. Else
if <span class="math">\(x\)</span> is a vector/matrix the result has the same type as <span class="math">\(x\)</span> and an
analogous definition. Note that for these types, <tt class="docutils literal"><span class="pre">gcd</span></tt> is not
commutative.</p>
<p>The algorithm used is a naive Euclid except for the following inputs:</p>
<ul class="simple">
<li>integers: use modified right-shift binary (&#8220;plus-minus&#8221;
variant).</li>
<li>univariate polynomials with coefficients in the same number
field (in particular rational): use modular gcd algorithm.</li>
<li>general polynomials: use the subresultant algorithm if
coefficient explosion is likely (non modular coefficients).</li>
</ul>
<p>If <span class="math">\(u\)</span> and <span class="math">\(v\)</span> are polynomials in the same variable with <em>inexact</em>
coefficients, their gcd is defined to be scalar, so that</p>
<div class="highlight-python"><div class="highlight"><pre>? a = x + 0.0; gcd(a,a)
%1 = 1
? b = y*x + O(y); gcd(b,b)
%2 = y
? c = 4*x + O(2^3); gcd(c,c)
%3 = 4
</pre></div>
</div>
<p>A good quantitative check to decide whether such a
gcd &#8220;should be&#8221; non-trivial, is to use <tt class="docutils literal"><span class="pre">polresultant</span></tt>: a value
close to <span class="math">\(0\)</span> means that a small deformation of the inputs has non-trivial gcd.
You may also use <tt class="docutils literal"><span class="pre">gcdext</span></tt>, which does try to compute an approximate gcd
<span class="math">\(d\)</span> and provides <span class="math">\(u\)</span>, <span class="math">\(v\)</span> to check whether <span class="math">\(u x + v y\)</span> is close to <span class="math">\(d\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.gcdext">
<tt class="descname">gcdext</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.gcdext" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <span class="math">\([u,v,d]\)</span> such that <span class="math">\(d\)</span> is the gcd of <span class="math">\(x,y\)</span>,
<span class="math">\(x*u+y*v = \mathrm{gcd}(x,y)\)</span>, and <span class="math">\(u\)</span> and <span class="math">\(v\)</span> minimal in a natural sense.
The arguments must be integers or polynomials.</p>
<div class="highlight-python"><div class="highlight"><pre>? [u, v, d] = gcdext(32,102)
%1 = [16, -5, 2]
? d
%2 = 2
? gcdext(x^2-x, x^2+x-2)
%3 = [-1/2, 1/2, x - 1]
</pre></div>
</div>
<p>If <span class="math">\(x,y\)</span> are polynomials in the same variable and <em>inexact</em>
coefficients, then compute <span class="math">\(u,v,d\)</span> such that <span class="math">\(x*u+y*v = d\)</span>, where <span class="math">\(d\)</span>
approximately divides both and <span class="math">\(x\)</span> and <span class="math">\(y\)</span>; in particular, we do not obtain
<tt class="docutils literal"><span class="pre">gcd(x,y)</span></tt> which is <em>defined</em> to be a scalar in this case:</p>
<div class="highlight-python"><div class="highlight"><pre>? a = x + 0.0; gcd(a,a)
%1 = 1

? gcdext(a,a)
%2 = [0, 1, x + 0.E-28]

? gcdext(x-Pi, 6*x^2-zeta(2))
%3 = [-6*x - 18.8495559, 1, 57.5726923]
</pre></div>
</div>
<p>For inexact inputs, the output is thus not well defined
mathematically, but you obtain explicit polynomials to check whether the
approximation is close enough for your needs.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.genus2red">
<tt class="descname">genus2red</tt><big>(</big><em>P</em>, <em>p=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.genus2red" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(P\)</span> be a polynomial with integer coefficients.
Determines the reduction at <span class="math">\(p &gt; 2\)</span> of the (proper, smooth) genus&nbsp;2
curve <span class="math">\(C/\mathbb{Q}\)</span>, defined by the hyperelliptic equation <span class="math">\(y^2 = P\)</span>. (The
special fiber <span class="math">\(X_p\)</span> of the minimal regular model <span class="math">\(X\)</span> of <span class="math">\(C\)</span> over <span class="math">\(\mathbb{Z}\)</span>.)
The special syntax <tt class="docutils literal"><span class="pre">genus2red</span></tt><span class="math">\(([P,Q])\)</span> is also allowed, where the
polynomials <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> have integer coefficients, to represent the model
<span class="math">\(y^2 + Q(x)y = P(x)\)</span>.</p>
<p>If <span class="math">\(p\)</span> is omitted, determines the reduction type for all (odd) prime
divisors of the discriminant.</p>
<p>This function was rewritten from an implementation of Liu&#8217;s
algorithm by Cohen and Liu (1994), <tt class="docutils literal"><span class="pre">genus2reduction-0.3</span></tt>, see
<tt class="docutils literal"><span class="pre">http://www.math.u-bordeaux1.fr/~liu/G2R/</span></tt>.</p>
<p><strong>CAVEAT.</strong> The function interface may change: for the
time being, it returns <span class="math">\([N,FaN, T, V]\)</span>
where <span class="math">\(N\)</span> is either the local conductor at <span class="math">\(p\)</span> or the
global conductor, <em>FaN</em> is its factorization, <span class="math">\(y^2 = T\)</span> defines a
minimal model over <span class="math">\(\mathbb{Z}[1/2]\)</span> and <span class="math">\(V\)</span> describes the reduction type at the
various considered&nbsp;<span class="math">\(p\)</span>. Unfortunately, the program is not complete for
<span class="math">\(p = 2\)</span>, and we may return the odd part of the conductor only: this is the
case if the factorization includes the (impossible) term <span class="math">\(2^{-1}\)</span>; if the
factorization contains another power of <span class="math">\(2\)</span>, then this is the exact local
conductor at <span class="math">\(2\)</span> and <span class="math">\(N\)</span> is the global conductor.</p>
<div class="highlight-python"><div class="highlight"><pre>? default(debuglevel, 1);
? genus2red(x^6 + 3*x^3 + 63, 3)
(potential) stable reduction: [1, []]
reduction at p: [III{9}] page 184, [3, 3], f = 10
%1 = [59049, Mat([3, 10]), x^6 + 3*x^3 + 63, [3, [1, []],
 [&quot;[III{9}] page 184&quot;, [3, 3]]]]
? [N, FaN, T, V] = genus2red(x^3-x^2-1, x^2-x); \\ X_1(13), global reduction
p = 13
(potential) stable reduction: [5, [Mod(0, 13), Mod(0, 13)]]
reduction at p: [I{0}-II-0] page 159, [], f = 2
? N
%3 = 169
? FaN
%4 = Mat([13, 2]) \\ in particular, good reduction at 2 !
? T
%5 = x^6 + 58*x^5 + 1401*x^4 + 18038*x^3 + 130546*x^2 + 503516*x + 808561
? V
%6 = [[13, [5, [Mod(0, 13), Mod(0, 13)]], [&quot;[I{0}-II-0] page 159&quot;, []]]]
</pre></div>
</div>
<p>We now first describe the format of the vector <span class="math">\(V = V_p\)</span> in the case where
<span class="math">\(p\)</span> was specified (local reduction at&nbsp;<span class="math">\(p\)</span>): it is a triple <span class="math">\([p, stable,
red]\)</span>. The component <span class="math">\(stable = [type, vecj]\)</span> contains
information about the stable reduction after a field extension;
depending on <em>type</em>&nbsp;s, the stable reduction is</p>
<ul class="simple">
<li>1: smooth (i.e. the curve has potentially good reduction). The
Jacobian <span class="math">\(J(C)\)</span> has potentially good reduction.</li>
<li>2: an elliptic curve <span class="math">\(E\)</span> with an ordinary double point; <em>vecj</em>
contains <span class="math">\(j\)</span> mod <span class="math">\(p\)</span>, the modular invariant of <span class="math">\(E\)</span>. The (potential)
semi-abelian reduction of <span class="math">\(J(C)\)</span> is the extension of an elliptic curve (with
modular invariant <span class="math">\(j\)</span> mod <span class="math">\(p\)</span>) by a torus.</li>
<li>3: a projective line with two ordinary double points. The Jacobian
<span class="math">\(J(C)\)</span> has potentially multiplicative reduction.</li>
<li>4: the union of two projective lines crossing transversally at three
points. The Jacobian <span class="math">\(J(C)\)</span> has potentially multiplicative reduction.</li>
<li>5: the union of two elliptic curves <span class="math">\(E_1\)</span> and <span class="math">\(E_2\)</span> intersecting
transversally at one point; <em>vecj</em> contains their modular invariants
<span class="math">\(j_1\)</span> and <span class="math">\(j_2\)</span>, which may live in a quadratic extension of <span class="math">\(\mathbb{F}_p\)</span> are need
not be distinct. The Jacobian <span class="math">\(J(C)\)</span> has potentially good reduction,
isomorphic to the product of the reductions of <span class="math">\(E_1\)</span> and <span class="math">\(E_2\)</span>.</li>
<li>6: the union of an elliptic curve <span class="math">\(E\)</span> and a projective line which has
an ordinary double point, and these two components intersect transversally
at one point; <em>vecj</em> contains <span class="math">\(j\)</span> mod <span class="math">\(p\)</span>, the modular invariant of <span class="math">\(E\)</span>.
The (potential) semi-abelian reduction of <span class="math">\(J(C)\)</span> is the extension of an
elliptic curve (with modular invariant <span class="math">\(j\)</span> mod <span class="math">\(p\)</span>) by a torus.</li>
<li>7: as in type 6, but the two components are both singular. The
Jacobian <span class="math">\(J(C)\)</span> has potentially multiplicative reduction.</li>
</ul>
<p>The component <span class="math">\(red = [NUtype, neron]\)</span> contains two data
concerning the reduction at <span class="math">\(p\)</span> without any ramified field extension.</p>
<p>The <em>NUtype</em> is a <tt class="docutils literal"><span class="pre">t_STR</span></tt> describing the reduction at <span class="math">\(p\)</span> of <span class="math">\(C\)</span>,
following Namikawa-Ueno, <em>The complete classification of fibers in
pencils of curves of genus two</em>, Manuscripta Math., vol. 9, (1973), pages
143-186. The reduction symbol is followed by the corresponding page number in
this article.</p>
<p>The second datum <em>neron</em> is the group of connected components (over an
algebraic closure of <span class="math">\(\mathbb{F}_p\)</span>) of the Néron model of <span class="math">\(J(C)\)</span>, given as a
finite abelian group (vector of elementary divisors).</p>
<p>If <span class="math">\(p = 2\)</span>, the <em>red</em> component may be omitted altogether (and
replaced by <tt class="docutils literal"><span class="pre">[]</span></tt>, in the case where the program could not compute it.
When <span class="math">\(p\)</span> was not specified, <span class="math">\(V\)</span> is the vector of all <span class="math">\(V_p\)</span>, for all
considered <span class="math">\(p\)</span>.</p>
<p><strong>Notes about Namikawa-Ueno types.</strong></p>
<ul class="simple">
<li>A lower index is denoted between braces: for instance, \kbd{[I{
2}-II-5]} means <tt class="docutils literal"><span class="pre">[I_2-II-5]</span></tt>.</li>
<li>If <span class="math">\(K\)</span> and <span class="math">\(K'\)</span> are Kodaira symbols for singular fibers of elliptic
curves, <tt class="docutils literal"><span class="pre">[:math:`K</span></tt>-<span class="math">\(K'\)</span>-m]` and <tt class="docutils literal"><span class="pre">[:math:`K'</span></tt>-<span class="math">\(K\)</span>-m]` are the same.</li>
<li><tt class="docutils literal"><span class="pre">[:math:`K</span></tt>-<span class="math">\(K'\)</span>-<span class="math">\(-1\)</span>]` is <tt class="docutils literal"><span class="pre">[:math:`K'</span></tt>-<span class="math">\(K\)</span>-<span class="math">\(\alpha\)</span>]` in the notation of
Namikawa-Ueno.</li>
<li>The figure <tt class="docutils literal"><span class="pre">[2I_0-m]</span></tt> in Namikawa-Ueno, page 159, must be denoted
by <tt class="docutils literal"><span class="pre">[2I_0-(m+1)]</span></tt>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.hammingweight">
<tt class="descname">hammingweight</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.hammingweight" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(x\)</span> is a <tt class="docutils literal"><span class="pre">t_INT</span></tt>, return the binary Hamming weight of <span class="math">\(\|x\|\)</span>. Otherwise
<span class="math">\(x\)</span> must be of type <tt class="docutils literal"><span class="pre">t_POL</span></tt>, <tt class="docutils literal"><span class="pre">t_VEC</span></tt>, <tt class="docutils literal"><span class="pre">t_COL</span></tt>, <tt class="docutils literal"><span class="pre">t_VECSMALL</span></tt>, or
<tt class="docutils literal"><span class="pre">t_MAT</span></tt> and the function returns the number of non-zero coefficients of
<span class="math">\(x\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? hammingweight(15)
%1 = 4
? hammingweight(x^100 + 2*x + 1)
%2 = 3
? hammingweight([Mod(1,2), 2, Mod(0,3)])
%3 = 2
? hammingweight(matid(100))
%4 = 100
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.hilbert">
<tt class="descname">hilbert</tt><big>(</big><em>x</em>, <em>y</em>, <em>p=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.hilbert" title="Permalink to this definition">¶</a></dt>
<dd><p>Hilbert symbol of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> modulo the prime <span class="math">\(p\)</span>, <span class="math">\(p = 0\)</span> meaning
the place at infinity (the result is undefined if <span class="math">\(p != 0\)</span> is not prime).</p>
<p>It is possible to omit <span class="math">\(p\)</span>, in which case we take <span class="math">\(p = 0\)</span> if both <span class="math">\(x\)</span>
and <span class="math">\(y\)</span> are rational, or one of them is a real number. And take <span class="math">\(p = q\)</span>
if one of <span class="math">\(x\)</span>, <span class="math">\(y\)</span> is a <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt> modulo <span class="math">\(q\)</span> or a <span class="math">\(q\)</span>-adic. (Incompatible
types will raise an error.)</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.hyperellcharpoly">
<tt class="descname">hyperellcharpoly</tt><big>(</big><em>X</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.hyperellcharpoly" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(X\)</span> being a non-singular hyperelliptic curve defined over a finite field,
return the characteristic polynomial of the Frobenius automorphism.
<span class="math">\(X\)</span> can be given either by a squarefree polynomial <span class="math">\(P\)</span> such that
<span class="math">\(X: y^2 = P(x)\)</span> or by a vector <span class="math">\([P,Q]\)</span> such that
<span class="math">\(X: y^2 + Q(x) y = P(x)\)</span> and <span class="math">\(Q^2+4 P\)</span> is squarefree.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.hyperellpadicfrobenius">
<tt class="descname">hyperellpadicfrobenius</tt><big>(</big><em>Q</em>, <em>p</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.hyperellpadicfrobenius" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(X\)</span> be the curve defined by <span class="math">\(y^2 = Q(x)\)</span>, where <span class="math">\(Q\)</span> is a polynomial of
degree <span class="math">\(d\)</span> over <span class="math">\(\mathbb{Q}\)</span> and <span class="math">\(p &gt;= d\)</span> a prime such that <span class="math">\(X\)</span> has good reduction
at <span class="math">\(p\)</span> return the matrix of the Frobenius endomorphism <span class="math">\(\varphi\)</span> on the
crystalline module <span class="math">\(D_p(E) = \mathbb{Q}_p \\otimes H^1_{dR}(E/\mathbb{Q})\)</span> with respect to the
basis of the given model <span class="math">\((\omega, x \omega,...,x^{g-1} \omega)\)</span>, where
<span class="math">\(\omega = dx/(2 y)\)</span> is the invariant differential, where <span class="math">\(g\)</span> is the genus of
<span class="math">\(X\)</span> (either <span class="math">\(d = 2 g+1\)</span> or <span class="math">\(d = 2 g+2\)</span>). The characteristic polynomial of
<span class="math">\(\varphi\)</span> is the numerator of the zeta-function of the reduction of the curve
<span class="math">\(X\)</span> modlo <span class="math">\(p\)</span>. The matrix is computed to absolute <span class="math">\(p\)</span>-adic precision <span class="math">\(p^n\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.hyperu">
<tt class="descname">hyperu</tt><big>(</big><em>a</em>, <em>b</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.hyperu" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(U\)</span>-confluent hypergeometric function with
parameters <span class="math">\(a\)</span> and <span class="math">\(b\)</span>. The parameters <span class="math">\(a\)</span> and <span class="math">\(b\)</span> can be complex but
the present implementation requires <span class="math">\(x\)</span> to be positive.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealadd">
<tt class="descname">idealadd</tt><big>(</big><em>nf</em>, <em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealadd" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of the two ideals <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in the number field <span class="math">\(nf\)</span>. The
result is given in HNF.</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(x^2 + 1);
? a = idealadd(K, 2, x + 1) \\ ideal generated by 2 and 1+I
%2 =
[2 1]

[0 1]
? pr = idealprimedec(K, 5)[1]; \\ a prime ideal above 5
? idealadd(K, a, pr) \\ coprime, as expected
%4 =
[1 0]

[0 1]
</pre></div>
</div>
<p>This function cannot be used to add arbitrary <span class="math">\(\mathbb{Z}\)</span>-modules, since it assumes
that its arguments are ideals:</p>
<div class="highlight-python"><div class="highlight"><pre>? b = Mat([1,0]~);
? idealadd(K, b, b) \\ only square t_MATs represent ideals
*** idealadd: non-square t_MAT in idealtyp.
? c = [2, 0; 2, 0]; idealadd(K, c, c) \\ non-sense
%6 =
[2 0]

[0 2]
? d = [1, 0; 0, 2]; idealadd(K, d, d) \\ non-sense
%7 =
[1 0]

[0 1]
</pre></div>
</div>
<p>In the last two examples, we get wrong results since the
matrices <span class="math">\(c\)</span> and <span class="math">\(d\)</span> do not correspond to an ideal: the <span class="math">\(\mathbb{Z}\)</span>-span of their
columns (as usual interpreted as coordinates with respect to the integer basis
<tt class="docutils literal"><span class="pre">K.zk</span></tt>) is not an <span class="math">\(O_K\)</span>-module. To add arbitrary <span class="math">\(\mathbb{Z}\)</span>-modules generated
by the columns of matrices <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, use <tt class="docutils literal"><span class="pre">mathnf(concat(A,B))</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealaddtoone">
<tt class="descname">idealaddtoone</tt><big>(</big><em>nf</em>, <em>x</em>, <em>y=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealaddtoone" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> and <span class="math">\(y\)</span> being two co-prime
integral ideals (given in any form), this gives a two-component row vector
<span class="math">\([a,b]\)</span> such that <span class="math">\(a belongs to x\)</span>, <span class="math">\(b belongs to y\)</span> and <span class="math">\(a+b = 1\)</span>.</p>
<p>The alternative syntax <span class="math">\(idealaddtoone(nf,v)\)</span>, is supported, where
<span class="math">\(v\)</span> is a <span class="math">\(k\)</span>-component vector of ideals (given in any form) which sum to
<span class="math">\(\mathbb{Z}_K\)</span>. This outputs a <span class="math">\(k\)</span>-component vector <span class="math">\(e\)</span> such that <span class="math">\(e[i] belongs to x[i]\)</span> for
<span class="math">\(1 &lt;= i &lt;= k\)</span> and <span class="math">\(\sum_{1 &lt;= i &lt;= k}e[i] = 1\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealappr">
<tt class="descname">idealappr</tt><big>(</big><em>nf</em>, <em>x</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealappr" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(x\)</span> is a fractional ideal
(given in any form), gives an element <span class="math">\(\alpha\)</span> in <span class="math">\(nf\)</span> such that for
all prime ideals <span class="math">\(p\)</span> such that the valuation of <span class="math">\(x\)</span> at <span class="math">\(p\)</span> is
non-zero, we have <span class="math">\(v_{p}(\alpha) = v_{p}(x)\)</span>, and
<span class="math">\(v_{p}(\alpha) &gt;= 0\)</span> for all other <span class="math">\(p\)</span>.</p>
<p>If <span class="math">\(flag\)</span> is non-zero, <span class="math">\(x\)</span> must be given as a prime ideal factorization, as
output by <tt class="docutils literal"><span class="pre">idealfactor</span></tt>, but possibly with zero or negative exponents.
This yields an element <span class="math">\(\alpha\)</span> such that for all prime ideals <span class="math">\(p\)</span>
occurring in <span class="math">\(x\)</span>, <span class="math">\(v_{p}(\alpha)\)</span> is equal to the exponent of
<span class="math">\(p\)</span> in <span class="math">\(x\)</span>, and for all other prime ideals,
<span class="math">\(v_{p}(\alpha) &gt;= 0\)</span>. This generalizes <span class="math">\(idealappr(nf,x,0)\)</span>
since zero exponents are allowed. Note that the algorithm used is slightly
different, so that</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">idealappr</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">idealfactor</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>may not be the same as <tt class="docutils literal"><span class="pre">idealappr(nf,x,1)</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealchinese">
<tt class="descname">idealchinese</tt><big>(</big><em>nf</em>, <em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealchinese" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> being a prime ideal factorization
(i.e.&nbsp;a 2 by 2 matrix whose first column contains prime ideals, and the second
column integral exponents), <span class="math">\(y\)</span> a vector of elements in <span class="math">\(nf\)</span> indexed by
the ideals in <span class="math">\(x\)</span>, computes an element <span class="math">\(b\)</span> such that</p>
<p><span class="math">\(v_{p}(b - y_{p}) &gt;= v_{p}(x)\)</span> for all prime ideals
in <span class="math">\(x\)</span> and <span class="math">\(v_{p}(b) &gt;= 0\)</span> for all other <span class="math">\(p\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealcoprime">
<tt class="descname">idealcoprime</tt><big>(</big><em>nf</em>, <em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealcoprime" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two integral ideals <span class="math">\(x\)</span> and <span class="math">\(y\)</span>
in the number field <span class="math">\(nf\)</span>, returns a <span class="math">\(\beta\)</span> in the field,
such that <span class="math">\(\beta.x\)</span> is an integral ideal coprime to <span class="math">\(y\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealdiv">
<tt class="descname">idealdiv</tt><big>(</big><em>nf</em>, <em>x</em>, <em>y</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Quotient <span class="math">\(x.y^{-1}\)</span> of the two ideals <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in the number
field <span class="math">\(nf\)</span>. The result is given in HNF.</p>
<p>If <span class="math">\(flag\)</span> is non-zero, the quotient <span class="math">\(x.y^{-1}\)</span> is assumed to be an
integral ideal. This can be much faster when the norm of the quotient is
small even though the norms of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are large.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealfactor">
<tt class="descname">idealfactor</tt><big>(</big><em>nf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealfactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Factors into prime ideal powers the
ideal <span class="math">\(x\)</span> in the number field <span class="math">\(nf\)</span>. The output format is similar to the
<tt class="docutils literal"><span class="pre">factor</span></tt> function, and the prime ideals are represented in the form
output by the <tt class="docutils literal"><span class="pre">idealprimedec</span></tt> function, i.e.&nbsp;as 5-element vectors.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealfactorback">
<tt class="descname">idealfactorback</tt><big>(</big><em>nf</em>, <em>f</em>, <em>e=None</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealfactorback" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives back the ideal corresponding to a factorization. The integer <span class="math">\(1\)</span>
corresponds to the empty factorization.
If <span class="math">\(e\)</span> is present, <span class="math">\(e\)</span> and <span class="math">\(f\)</span> must be vectors of the same length (<span class="math">\(e\)</span> being
integral), and the corresponding factorization is the product of the
<span class="math">\(f[i]^{e[i]}\)</span>.</p>
<p>If not, and <span class="math">\(f\)</span> is vector, it is understood as in the preceding case with <span class="math">\(e\)</span>
a vector of 1s: we return the product of the <span class="math">\(f[i]\)</span>. Finally, <span class="math">\(f\)</span> can be a
regular factorization, as produced by <tt class="docutils literal"><span class="pre">idealfactor</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2+1); idealfactor(nf, 4 + 2*y)
%1 =
[[2, [1, 1]~, 2, 1, [1, 1]~] 2]

[[5, [2, 1]~, 1, 1, [-2, 1]~] 1]

? idealfactorback(nf, %)
%2 =
[10 4]

[0 2]

? f = %1[,1]; e = %1[,2]; idealfactorback(nf, f, e)
%3 =
[10 4]

[0 2]

? % == idealhnf(nf, 4 + 2*y)
%4 = 1
</pre></div>
</div>
<p>If <tt class="docutils literal"><span class="pre">flag</span></tt> is non-zero, perform ideal reductions (<tt class="docutils literal"><span class="pre">idealred</span></tt>) along the
way. This is most useful if the ideals involved are all <em>extended</em>
ideals (for instance with trivial principal part), so that the principal parts
extracted by <tt class="docutils literal"><span class="pre">idealred</span></tt> are not lost. Here is an example:</p>
<div class="highlight-python"><div class="highlight"><pre>? f = vector(#f, i, [f[i], [;]]); \\ transform to extended ideals
? idealfactorback(nf, f, e, 1)
%6 = [[1, 0; 0, 1], [2, 1; [2, 1]~, 1]]
? nffactorback(nf, %[2])
%7 = [4, 2]~
</pre></div>
</div>
<p>The extended ideal returned in <tt class="docutils literal"><span class="pre">%6</span></tt> is the trivial ideal <span class="math">\(1\)</span>, extended
with a principal generator given in factored form. We use <tt class="docutils literal"><span class="pre">nffactorback</span></tt>
to recover it in standard form.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealfrobenius">
<tt class="descname">idealfrobenius</tt><big>(</big><em>nf</em>, <em>gal</em>, <em>pr</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealfrobenius" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(K\)</span> be the number field defined by <span class="math">\(nf\)</span> and assume <span class="math">\(K/\mathbb{Q}\)</span> be a
Galois extension with Galois group given <tt class="docutils literal"><span class="pre">gal</span> <span class="pre">=</span> <span class="pre">galoisinit(nf)</span></tt>,
and that <span class="math">\(pr\)</span> is the prime ideal <span class="math">\(P\)</span> in prid format, and that
<span class="math">\(P\)</span> is unramified.
This function returns a permutation of <tt class="docutils literal"><span class="pre">gal.group</span></tt> which defines the
automorphism <span class="math">\(\sigma = (P\\over K/\mathbb{Q} )\)</span>, i.e the Frobenius
element associated to <span class="math">\(P\)</span>. If <span class="math">\(p\)</span> is the unique prime number
in <span class="math">\(P\)</span>, then <span class="math">\(\sigma(x) = x^p mod \\P\)</span> for all <span class="math">\(x belongs to \mathbb{Z}_K\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(polcyclo(31));
? gal = galoisinit(nf);
? pr = idealprimedec(nf,101)[1];
? g = idealfrobenius(nf,gal,pr);
? galoispermtopol(gal,g)
%5 = x^8
</pre></div>
</div>
<p>This is correct since <span class="math">\(101 = 8 mod 31\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealhnf">
<tt class="descname">idealhnf</tt><big>(</big><em>nf</em>, <em>u</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealhnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the Hermite normal form of the ideal <span class="math">\(u\mathbb{Z}_K+v\mathbb{Z}_K\)</span>, where <span class="math">\(u\)</span>
and <span class="math">\(v\)</span> are elements of the number field <span class="math">\(K\)</span> defined by <tt class="docutils literal"><span class="pre">nf</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^3 - 2);
? idealhnf(nf, 2, y+1)
%2 =
[1 0 0]

[0 1 0]

[0 0 1]
? idealhnf(nf, y/2, [0,0,1/3]~)
%3 =
[1/3 0 0]

[0 1/6 0]

[0 0 1/6]
</pre></div>
</div>
<p>If <span class="math">\(b\)</span> is omitted, returns the HNF of the ideal defined by <span class="math">\(u\)</span>: <span class="math">\(u\)</span> may be an
algebraic number (defining a principal ideal), a maximal ideal (as given by
<tt class="docutils literal"><span class="pre">idealprimedec</span></tt> or <tt class="docutils literal"><span class="pre">idealfactor</span></tt>), or a matrix whose columns give
generators for the ideal. This last format is a little complicated, but
useful to reduce general modules to the canonical form once in a while:</p>
<ul class="simple">
<li>if strictly less than <span class="math">\(N = [K:\mathbb{Q}]\)</span> generators are given, <span class="math">\(u\)</span>
is the <span class="math">\(\mathbb{Z}_K\)</span>-module they generate,</li>
<li>if <span class="math">\(N\)</span> or more are given, it is <em>assumed</em> that they form a
<span class="math">\(\mathbb{Z}\)</span>-basis of the ideal, in particular that the matrix has maximal rank <span class="math">\(N\)</span>.
This acts as <tt class="docutils literal"><span class="pre">mathnf</span></tt> since the <span class="math">\(\mathbb{Z}_K\)</span>-module structure is (taken for
granted hence) not taken into account in this case.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? idealhnf(nf, idealprimedec(nf,2)[1])
%4 =
[2 0 0]

[0 1 0]

[0 0 1]
? idealhnf(nf, [1,2;2,3;3,4])
%5 =
[1 0 0]

[0 1 0]

[0 0 1]
</pre></div>
</div>
<p>Finally, when <span class="math">\(K\)</span> is quadratic with discriminant <span class="math">\(D_K\)</span>, we
allow <span class="math">\(u =\)</span> <tt class="docutils literal"><span class="pre">Qfb(a,b,c)</span></tt>, provided <span class="math">\(b^2 - 4ac = D_K\)</span>. As usual,
this represents the ideal <span class="math">\(a \mathbb{Z} + (1/2)(-b + \sqrt{D_K}) \mathbb{Z}\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(x^2 - 60); K.disc
%1 = 60
? idealhnf(K, qfbprimeform(60,2))
%2 =
[2 1]

[0 1]
? idealhnf(K, Qfb(1,2,3))
 *** at top-level: idealhnf(K,Qfb(1,2,3
 *** ^--------------------
 *** idealhnf: Qfb(1, 2, 3) has discriminant != 60 in idealhnf.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealintersect">
<tt class="descname">idealintersect</tt><big>(</big><em>nf</em>, <em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealintersect" title="Permalink to this definition">¶</a></dt>
<dd><p>Intersection of the two ideals
<span class="math">\(A\)</span> and <span class="math">\(B\)</span> in the number field <span class="math">\(nf\)</span>. The result is given in HNF.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(x^2+1);
? idealintersect(nf, 2, x+1)
%2 =
[2 0]

[0 2]
</pre></div>
</div>
<p>This function does not apply to general <span class="math">\(\mathbb{Z}\)</span>-modules, e.g.&nbsp;orders, since its
arguments are replaced by the ideals they generate. The following script
intersects <span class="math">\(\mathbb{Z}\)</span>-modules <span class="math">\(A\)</span> and <span class="math">\(B\)</span> given by matrices of compatible
dimensions with integer coefficients:</p>
<div class="highlight-python"><div class="highlight"><pre>ZM_intersect(A,B) =
{ my(Ker = matkerint(concat(A,B)));
 mathnf( A * Ker[1..#A,] )
}
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealinv">
<tt class="descname">idealinv</tt><big>(</big><em>nf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse of the ideal <span class="math">\(x\)</span> in the
number field <span class="math">\(nf\)</span>, given in HNF. If <span class="math">\(x\)</span> is an extended
ideal, its principal part is suitably
updated: i.e. inverting <span class="math">\([I,t]\)</span>, yields <span class="math">\([I^{-1}, 1/t]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ideallist">
<tt class="descname">ideallist</tt><big>(</big><em>nf</em>, <em>bound</em>, <em>flag=4</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ideallist" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the list
of all ideals of norm less or equal to <em>bound</em> in the number field
<em>nf</em>. The result is a row vector with exactly <em>bound</em> components.
Each component is itself a row vector containing the information about
ideals of a given norm, in no specific order, depending on the value of
<span class="math">\(flag\)</span>:</p>
<p>The possible values of <span class="math">\(flag\)</span> are:</p>
<p>&nbsp;&nbsp;0: give the <em>bid</em> associated to the ideals, without generators.</p>
<p>&nbsp;&nbsp;1: as 0, but include the generators in the <em>bid</em>.</p>
<p>&nbsp;&nbsp;2: in this case, <em>nf</em> must be a <em>bnf</em> with units. Each
component is of the form <span class="math">\([bid,U]\)</span>, where <em>bid</em> is as case 0
and <span class="math">\(U\)</span> is a vector of discrete logarithms of the units. More precisely, it
gives the <tt class="docutils literal"><span class="pre">ideallog</span></tt>&nbsp;s with respect to <em>bid</em> of <tt class="docutils literal"><span class="pre">bnf.tufu</span></tt>.
This structure is technical, and only meant to be used in conjunction with
<tt class="docutils literal"><span class="pre">bnrclassnolist</span></tt> or <tt class="docutils literal"><span class="pre">bnrdisclist</span></tt>.</p>
<p>&nbsp;&nbsp;3: as 2, but include the generators in the <em>bid</em>.</p>
<p>&nbsp;&nbsp;4: give only the HNF of the ideal.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(x^2+1);
? L = ideallist(nf, 100);
? L[1]
%3 = [[1, 0; 0, 1]] \\ A single ideal of norm 1
? #L[65]
%4 = 4 \\ There are 4 ideals of norm 4 in Z[i]
</pre></div>
</div>
<p>If one wants more information, one could do instead:</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(x^2+1);
? L = ideallist(nf, 100, 0);
? l = L[25]; vector(#l, i, l[i].clgp)
%3 = [[20, [20]], [16, [4, 4]], [20, [20]]]
? l[1].mod
%4 = [[25, 18; 0, 1], []]
? l[2].mod
%5 = [[5, 0; 0, 5], []]
? l[3].mod
%6 = [[25, 7; 0, 1], []]
</pre></div>
</div>
<p>where we ask for the structures of the <span class="math">\((\mathbb{Z}[i]/I)^*\)</span> for all
three ideals of norm <span class="math">\(25\)</span>. In fact, for all moduli with finite part of norm
<span class="math">\(25\)</span> and trivial Archimedean part, as the last 3 commands show. See
<tt class="docutils literal"><span class="pre">ideallistarch</span></tt> to treat general moduli.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ideallistarch">
<tt class="descname">ideallistarch</tt><big>(</big><em>nf</em>, <em>list</em>, <em>arch</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ideallistarch" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list</em> is a vector of vectors of bid&#8217;s, as output by <tt class="docutils literal"><span class="pre">ideallist</span></tt> with
flag <span class="math">\(0\)</span> to <span class="math">\(3\)</span>. Return a vector of vectors with the same number of
components as the original <em>list</em>. The leaves give information about
moduli whose finite part is as in original list, in the same order, and
Archimedean part is now <em>arch</em> (it was originally trivial). The
information contained is of the same kind as was present in the input; see
<tt class="docutils literal"><span class="pre">ideallist</span></tt>, in particular the meaning of <em>flag</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? bnf = bnfinit(x^2-2);
? bnf.sign
%2 = [2, 0] \\ two places at infinity
? L = ideallist(bnf, 100, 0);
? l = L[98]; vector(#l, i, l[i].clgp)
%4 = [[42, [42]], [36, [6, 6]], [42, [42]]]
? La = ideallistarch(bnf, L, [1,1]); \\ add them to the modulus
? l = La[98]; vector(#l, i, l[i].clgp)
%6 = [[168, [42, 2, 2]], [144, [6, 6, 2, 2]], [168, [42, 2, 2]]]
</pre></div>
</div>
<p>Of course, the results above are obvious: adding <span class="math">\(t\)</span> places at infinity will
add <span class="math">\(t\)</span> copies of <span class="math">\(\mathbb{Z}/2\mathbb{Z}\)</span> to the ray class group. The following application
is more typical:</p>
<div class="highlight-python"><div class="highlight"><pre>? L = ideallist(bnf, 100, 2); \\ units are required now
? La = ideallistarch(bnf, L, [1,1]);
? H = bnrclassnolist(bnf, La);
? H[98];
%6 = [2, 12, 2]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ideallog">
<tt class="descname">ideallog</tt><big>(</big><em>nf</em>, <em>x</em>, <em>bid</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ideallog" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(nf\)</span> is a number field,
<em>bid</em> is as output by <tt class="docutils literal"><span class="pre">idealstar(nf,</span> <span class="pre">D,...)</span></tt> and <span class="math">\(x\)</span> a
non-necessarily integral element of <em>nf</em> which must have valuation
equal to 0 at all prime ideals in the support of <span class="math">\(D\)</span>. This function
computes the discrete logarithm of <span class="math">\(x\)</span> on the generators given in
<tt class="docutils literal"><span class="pre">:emphasis:`bid</span></tt>.gen`. In other words, if <span class="math">\(g_i\)</span> are these generators, of orders
<span class="math">\(d_i\)</span> respectively, the result is a column vector of integers <span class="math">\((x_i)\)</span> such
that <span class="math">\(0 &lt;= x_i &lt; d_i\)</span> and</p>
<div class="math">
\[x = \prod_i g_i^{x_i} (mod ^*D) .\]</div>
<p>Note that when the support of <tt class="docutils literal"><span class="pre">D</span></tt> contains places at infinity, this
congruence implies also sign conditions on the associated real embeddings.
See <tt class="docutils literal"><span class="pre">znlog</span></tt> for the limitations of the underlying discrete log algorithms.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealmin">
<tt class="descname">idealmin</tt><big>(</big><em>nf</em>, <em>ix</em>, <em>vdir=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealmin" title="Permalink to this definition">¶</a></dt>
<dd><p><em>This function is useless and kept for backward compatibility only,
use :literal:`idealred`</em>. Computes a pseudo-minimum of the ideal <span class="math">\(x\)</span> in the
direction <em>vdir</em> in the number field <em>nf</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealmul">
<tt class="descname">idealmul</tt><big>(</big><em>nf</em>, <em>x</em>, <em>y</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Ideal multiplication of the ideals <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in the number field
<em>nf</em>; the result is the ideal product in HNF. If either <span class="math">\(x\)</span> or <span class="math">\(y\)</span>
are extended ideals, their principal part is suitably
updated: i.e. multiplying <span class="math">\([I,t]\)</span>, <span class="math">\([J,u]\)</span> yields <span class="math">\([IJ, tu]\)</span>; multiplying
<span class="math">\(I\)</span> and <span class="math">\([J, u]\)</span> yields <span class="math">\([IJ, u]\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(x^2 + 1);
? idealmul(nf, 2, x+1)
%2 =
[4 2]

[0 2]
? idealmul(nf, [2, x], x+1) \\ extended ideal * ideal
%4 = [[4, 2; 0, 2], x]
? idealmul(nf, [2, x], [x+1, x]) \\ two extended ideals
%5 = [[4, 2; 0, 2], [-1, 0]~]
</pre></div>
</div>
<p>If <span class="math">\(flag\)</span> is non-zero, reduce the result using <tt class="docutils literal"><span class="pre">idealred</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealnorm">
<tt class="descname">idealnorm</tt><big>(</big><em>nf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the norm of the ideal&nbsp;<span class="math">\(x\)</span> in the number field&nbsp;<span class="math">\(nf\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealnumden">
<tt class="descname">idealnumden</tt><big>(</big><em>nf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealnumden" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <span class="math">\([A,B]\)</span>, where <span class="math">\(A,B\)</span> are coprime integer ideals
such that <span class="math">\(x = A/B\)</span>, in the number field <span class="math">\(nf\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(x^2+1);
? idealnumden(nf, (x+1)/2)
%2 = [[1, 0; 0, 1], [2, 1; 0, 1]]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealpow">
<tt class="descname">idealpow</tt><big>(</big><em>nf</em>, <em>x</em>, <em>k</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the <span class="math">\(k\)</span>-th power of
the ideal <span class="math">\(x\)</span> in the number field <span class="math">\(nf\)</span>; <span class="math">\(k belongs to \mathbb{Z}\)</span>.
If <span class="math">\(x\)</span> is an extended
ideal, its principal part is suitably
updated: i.e. raising <span class="math">\([I,t]\)</span> to the <span class="math">\(k\)</span>-th power, yields <span class="math">\([I^k, t^k]\)</span>.</p>
<p>If <span class="math">\(flag\)</span> is non-zero, reduce the result using <tt class="docutils literal"><span class="pre">idealred</span></tt>, <em>throughout
the (binary) powering process</em>; in particular, this is <em>not</em> the same as
as <span class="math">\(idealpow(nf,x,k)\)</span> followed by reduction.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealprimedec">
<tt class="descname">idealprimedec</tt><big>(</big><em>nf</em>, <em>p</em>, <em>f=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealprimedec" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the prime ideal
decomposition of the (positive) prime number <span class="math">\(p\)</span> in the number field <span class="math">\(K\)</span>
represented by <em>nf</em>. If a non-prime <span class="math">\(p\)</span> is given the result is undefined.
If <span class="math">\(f\)</span> is present and non-zero, restrict the result to primes of residue
degree <span class="math">\(&lt;= f\)</span>.</p>
<p>The result is a vector of <em>prid</em> structures, each representing one of the
prime ideals above <span class="math">\(p\)</span> in the number field <span class="math">\(nf\)</span>. The representation
<span class="math">\(pr = [p,a,e,f,mb]\)</span> of a prime ideal means the following: <span class="math">\(a\)</span> and
is an algebraic integer in the maximal order <span class="math">\(\mathbb{Z}_K\)</span> and the prime ideal is
equal to <span class="math">\(p = p\mathbb{Z}_K + a\mathbb{Z}_K\)</span>;
<span class="math">\(e\)</span> is the ramification index; <span class="math">\(f\)</span> is the residual index;
finally, <em>mb</em> is the multiplication table associated to the algebraic
integer <span class="math">\(b\)</span> is such that <span class="math">\(p^{-1} = \mathbb{Z}_K+ b/ p\mathbb{Z}_K\)</span>, which is used
internally to compute valuations. In other words if <span class="math">\(p\)</span> is inert,
then <em>mb</em> is the integer <span class="math">\(1\)</span>, and otherwise it&#8217;s a square <tt class="docutils literal"><span class="pre">t_MAT</span></tt>
whose <span class="math">\(j\)</span>-th column is <span class="math">\(b.nf.zk[j]\)</span>.</p>
<p>The algebraic number <span class="math">\(a\)</span> is guaranteed to have a
valuation equal to 1 at the prime ideal (this is automatic if <span class="math">\(e &gt; 1\)</span>).</p>
<p>The components of <tt class="docutils literal"><span class="pre">pr</span></tt> should be accessed by member functions: <tt class="docutils literal"><span class="pre">pr.p</span></tt>,
<tt class="docutils literal"><span class="pre">pr.e</span></tt>, <tt class="docutils literal"><span class="pre">pr.f</span></tt>, and <tt class="docutils literal"><span class="pre">pr.gen</span></tt> (returns the vector <span class="math">\([p,a]\)</span>):</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(x^3-2);
? P = idealprimedec(K, 5);
? #P \\ 2 primes above 5 in Q(2^(1/3))
%3 = 2
? [p1,p2] = P;
? [p1.e, p1.f] \\ the first is unramified of degree 1
%4 = [1, 1]
? [p2.e, p2.f] \\ the second is unramified of degree 2
%5 = [1, 2]
? p1.gen
%6 = [5, [2, 1, 0]~]
? nfbasistoalg(K, %[2]) \\ a uniformizer for p1
%7 = Mod(x + 2, x^3 - 2)
? #idealprimedec(K, 5, 1) \\ restrict to f = 1
%8 = 1 \\ now only p1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealprincipalunits">
<tt class="descname">idealprincipalunits</tt><big>(</big><em>nf</em>, <em>pr</em>, <em>k</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealprincipalunits" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a prime ideal in <tt class="docutils literal"><span class="pre">idealprimedec</span></tt> format,
returns the multiplicative group <span class="math">\((1 + pr) / (1 + pr^k)\)</span> as an
abelian group. This function is much faster than <tt class="docutils literal"><span class="pre">idealstar</span></tt> when the
norm of <em>pr</em> is large, since it avoids (useless) work in the
multiplicative group of the residue field.</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(y^2+1);
? P = idealprimedec(K,2)[1];
? G = idealprincipalunits(K, P, 20);
? G.cyc
[512, 256, 4] \\ Z/512 x Z/256 x Z/4
? G.gen
%5 = [[-1, -2]~, 1021, [0, -1]~] \\ minimal generators of given order
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealramgroups">
<tt class="descname">idealramgroups</tt><big>(</big><em>nf</em>, <em>gal</em>, <em>pr</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealramgroups" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(K\)</span> be the number field defined by <em>nf</em> and assume that <span class="math">\(K/\mathbb{Q}\)</span> is
Galois with Galois group <span class="math">\(G\)</span> given by <tt class="docutils literal"><span class="pre">gal</span> <span class="pre">=</span> <span class="pre">galoisinit(nf)</span></tt>.
Let <em>pr</em> be the prime ideal <span class="math">\(P\)</span> in prid format.
This function returns a vector <span class="math">\(g\)</span> of subgroups of <tt class="docutils literal"><span class="pre">gal</span></tt>
as follow:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">g[1]</span></tt> is the decomposition group of <span class="math">\(P\)</span>,</li>
<li><tt class="docutils literal"><span class="pre">g[2]</span></tt> is <span class="math">\(G_0(P)\)</span>, the inertia group of <span class="math">\(P\)</span>,</li>
</ul>
<p>and for <span class="math">\(i &gt;= 2\)</span>,</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">g[i]</span></tt> is <span class="math">\(G_{i-2}(P)\)</span>, the <span class="math">\(i-2\)</span>-th \idx{ramification
group} of <span class="math">\(P\)</span>.</li>
</ul>
<p>The length of <span class="math">\(g\)</span> is the number of non-trivial groups in the
sequence, thus is <span class="math">\(0\)</span> if <span class="math">\(e = 1\)</span> and <span class="math">\(f = 1\)</span>, and <span class="math">\(1\)</span> if <span class="math">\(f &gt; 1\)</span> and <span class="math">\(e = 1\)</span>.
The following function computes the cardinality of a subgroup of <span class="math">\(G\)</span>,
as given by the components of <span class="math">\(g\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>card(H) =my(o=H[2]); prod(i=1,#o,o[i]);
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>? nf=nfinit(x^6+3); gal=galoisinit(nf); pr=idealprimedec(nf,3)[1];
? g = idealramgroups(nf, gal, pr);
? apply(card,g)
%4 = [6, 6, 3, 3, 3] \\ cardinalities of the G_i
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>? nf=nfinit(x^6+108); gal=galoisinit(nf); pr=idealprimedec(nf,2)[1];
? iso=idealramgroups(nf,gal,pr)[2]
%4 = [[Vecsmall([2, 3, 1, 5, 6, 4])], Vecsmall([3])]
? nfdisc(galoisfixedfield(gal,iso,1))
%5 = -3
</pre></div>
</div>
<p>The field fixed by the inertia group of <span class="math">\(2\)</span> is not ramified at
<span class="math">\(2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealred">
<tt class="descname">idealred</tt><big>(</big><em>nf</em>, <em>I</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealred" title="Permalink to this definition">¶</a></dt>
<dd><p>LLL reduction of
the ideal <span class="math">\(I\)</span> in the number field <em>nf</em>, along the direction <span class="math">\(v\)</span>.
The <span class="math">\(v\)</span> parameter is best left omitted, but if it is present, it must
be an <span class="math">\(nf.r1 + nf.r2\)</span>-component vector of <em>non-negative</em>
integers. (What counts is the relative magnitude of the entries: if all
entries are equal, the effect is the same as if the vector had been omitted.)</p>
<p>This function finds a &#8220;small&#8221; <span class="math">\(a\)</span> in <span class="math">\(I\)</span> (see the end for technical details).
The result is the Hermite normal form of
the &#8220;reduced&#8221; ideal <span class="math">\(J = r I/a\)</span>, where <span class="math">\(r\)</span> is the unique rational number such
that <span class="math">\(J\)</span> is integral and primitive. (This is usually not a reduced ideal in
the sense of Buchmann.)</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(y^2+1);
? P = idealprimedec(K,5)[1];
? idealred(K, P)
%3 =
[1 0]

[0 1]
</pre></div>
</div>
<p>More often than not, a principal ideal yields the unit
ideal as above. This is a quick and dirty way to check if ideals are principal,
but it is not a necessary condition: a non-trivial result does not prove that
the ideal is non-principal. For guaranteed results, see <tt class="docutils literal"><span class="pre">bnfisprincipal</span></tt>,
which requires the computation of a full <tt class="docutils literal"><span class="pre">bnf</span></tt> structure.</p>
<p>If the input is an extended ideal <span class="math">\([I,s]\)</span>, the output is <span class="math">\([J,sa/r]\)</span>; this way,
one can keep track of the principal ideal part:</p>
<div class="highlight-python"><div class="highlight"><pre>? idealred(K, [P, 1])
%5 = [[1, 0; 0, 1], [-2, 1]~]
</pre></div>
</div>
<p>meaning that <span class="math">\(P\)</span> is generated by <span class="math">\([-2, 1]&nbsp;\)</span>. The number field element in the
extended part is an algebraic number in any form <em>or</em> a factorization
matrix (in terms of number field elements, not ideals!). In the latter case,
elements stay in factored form, which is a convenient way to avoid
coefficient explosion; see also <tt class="docutils literal"><span class="pre">idealpow</span></tt>.</p>
<p><strong>Technical note.</strong> The routine computes an LLL-reduced
basis for the lattice <span class="math">\(I\)</span> equipped with the quadratic form</p>
<div class="math">
\[\|\| x \|\|_v^2 = \sum_{i = 1}^{r_1+r_2} 2^{v_i}\varepsilon_i\|\sigma_i(x)\|^2,\]</div>
<p>where as usual the <span class="math">\(\sigma_i\)</span> are the (real and) complex embeddings and
<span class="math">\(\varepsilon_i = 1\)</span>, resp.&nbsp;<span class="math">\(2\)</span>, for a real, resp.&nbsp;complex place. The element
<span class="math">\(a\)</span> is simply the first vector in the LLL basis. The only reason you may want
to try to change some directions and set some <span class="math">\(v_i != 0\)</span> is to randomize
the elements found for a fixed ideal, which is heuristically useful in index
calculus algorithms like <tt class="docutils literal"><span class="pre">bnfinit</span></tt> and <tt class="docutils literal"><span class="pre">bnfisprincipal</span></tt>.</p>
<p><strong>Even more technical note.</strong> In fact, the above is a white lie.
We do not use <span class="math">\(\|\|.\|\|_v\)</span> exactly but a rescaled rounded variant which
gets us faster and simpler LLLs. There&#8217;s no harm since we are not using any
theoretical property of <span class="math">\(a\)</span> after all, except that it belongs to <span class="math">\(I\)</span> and is
&#8220;expected to be small&#8221;.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealstar">
<tt class="descname">idealstar</tt><big>(</big><em>nf</em>, <em>I</em>, <em>flag=1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealstar" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs a <em>bid</em> structure,
necessary for computing in the finite abelian group <span class="math">\(G = (\mathbb{Z}_K/I)^*\)</span>. Here,
<em>nf</em> is a number field and <span class="math">\(I\)</span> is a <em>modulus</em>: either an ideal in any
form, or a row vector whose first component is an ideal and whose second
component is a row vector of <span class="math">\(r_1\)</span> 0 or 1. Ideals can also be given
by a factorization into prime ideals, as produced by <tt class="docutils literal"><span class="pre">idealfactor</span></tt>.</p>
<p>This <em>bid</em> is used in <tt class="docutils literal"><span class="pre">ideallog</span></tt> to compute discrete logarithms. It
also contains useful information which can be conveniently retrieved as
<tt class="docutils literal"><span class="pre">:emphasis:`bid</span></tt>.mod` (the modulus),
<tt class="docutils literal"><span class="pre">:emphasis:`bid</span></tt>.clgp` (<span class="math">\(G\)</span> as a finite abelian group),
<tt class="docutils literal"><span class="pre">:emphasis:`bid</span></tt>.no` (the cardinality of <span class="math">\(G\)</span>),
<tt class="docutils literal"><span class="pre">:emphasis:`bid</span></tt>.cyc` (elementary divisors) and
<tt class="docutils literal"><span class="pre">:emphasis:`bid</span></tt>.gen` (generators).</p>
<p>If <span class="math">\(flag = 1\)</span> (default), the result is a <em>bid</em> structure without
generators.</p>
<p>If <span class="math">\(flag = 2\)</span>, as <span class="math">\(flag = 1\)</span>, but including generators, which wastes some time.</p>
<p>If <span class="math">\(flag = 0\)</span>, only outputs <span class="math">\((\mathbb{Z}_K/I)^*\)</span> as an abelian group,
i.e as a 3-component vector <span class="math">\([h,d,g]\)</span>: <span class="math">\(h\)</span> is the order, <span class="math">\(d\)</span> is the vector of
SNF cyclic components and <span class="math">\(g\)</span> the corresponding
generators.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealtwoelt">
<tt class="descname">idealtwoelt</tt><big>(</big><em>nf</em>, <em>x</em>, <em>a=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealtwoelt" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a two-element
representation of the ideal <span class="math">\(x\)</span> in the number field <span class="math">\(nf\)</span>, combining a
random search and an approximation theorem; <span class="math">\(x\)</span> is an ideal
in any form (possibly an extended ideal, whose principal part is ignored)</p>
<ul class="simple">
<li>When called as <tt class="docutils literal"><span class="pre">idealtwoelt(nf,x)</span></tt>, the result is a row vector
<span class="math">\([a,\alpha]\)</span> with two components such that <span class="math">\(x = a\mathbb{Z}_K+\alpha\mathbb{Z}_K\)</span> and <span class="math">\(a\)</span> is
chosen to be the positive generator of <span class="math">\(x\cap\mathbb{Z}\)</span>, unless <span class="math">\(x\)</span> was given as a
principal ideal (in which case we may choose <span class="math">\(a = 0\)</span>). The algorithm
uses a fast lazy factorization of <span class="math">\(x\cap \mathbb{Z}\)</span> and runs in randomized
polynomial time.</li>
<li>When called as <tt class="docutils literal"><span class="pre">idealtwoelt(nf,x,a)</span></tt> with an explicit non-zero <span class="math">\(a\)</span>
supplied as third argument, the function assumes that <span class="math">\(a belongs to x\)</span> and returns
<span class="math">\(\alpha belongs to x\)</span> such that <span class="math">\(x = a\mathbb{Z}_K + \alpha\mathbb{Z}_K\)</span>. Note that we must factor
<span class="math">\(a\)</span> in this case, and the algorithm is generally much slower than the
default variant.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealval">
<tt class="descname">idealval</tt><big>(</big><em>nf</em>, <em>x</em>, <em>pr</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealval" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the valuation of the ideal <span class="math">\(x\)</span> at the prime ideal <em>pr</em> in the
number field <span class="math">\(nf\)</span>, where <em>pr</em> is in <tt class="docutils literal"><span class="pre">idealprimedec</span></tt> format.
The valuation of the <span class="math">\(0\)</span> ideal is <tt class="docutils literal"><span class="pre">+oo</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.imag">
<tt class="descname">imag</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Imaginary part of <span class="math">\(x\)</span>. When <span class="math">\(x\)</span> is a quadratic number, this is the
coefficient of <span class="math">\(\omega\)</span> in the &#8220;canonical&#8221; integral basis <span class="math">\((1,\omega)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.incgam">
<tt class="descname">incgam</tt><big>(</big><em>s</em>, <em>x</em>, <em>g=None</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.incgam" title="Permalink to this definition">¶</a></dt>
<dd><p>Incomplete gamma function <span class="math">\(\int_x^ oo e^{-t}t^{s-1}dt\)</span>, extended by
analytic continuation to all complex <span class="math">\(x, s\)</span> not both <span class="math">\(0\)</span>. The relative error
is bounded in terms of the precision of <span class="math">\(s\)</span> (the accuracy of <span class="math">\(x\)</span> is ignored
when determining the output precision). When <span class="math">\(g\)</span> is given, assume that
<span class="math">\(g = \Gamma(s)\)</span>. For small <span class="math">\(\|x\|\)</span>, this will speed up the computation.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.incgamc">
<tt class="descname">incgamc</tt><big>(</big><em>s</em>, <em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.incgamc" title="Permalink to this definition">¶</a></dt>
<dd><p>Complementary incomplete gamma function.
The arguments <span class="math">\(x\)</span> and <span class="math">\(s\)</span> are complex numbers such that <span class="math">\(s\)</span> is not a pole of
<span class="math">\(\Gamma\)</span> and <span class="math">\(\|x\|/(\|s\|+1)\)</span> is not much larger than 1 (otherwise the
convergence is very slow). The result returned is <span class="math">\(\int_0^x
e^{-t}t^{s-1}dt\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.intformal">
<tt class="descname">intformal</tt><big>(</big><em>x</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.intformal" title="Permalink to this definition">¶</a></dt>
<dd><p>formal integration of <span class="math">\(x\)</span> with respect to the variable <span class="math">\(v\)</span> (wrt.
the main variable if <span class="math">\(v\)</span> is omitted). Since PARI cannot represent
logarithmic or arctangent terms, any such term in the result will yield an
error:</p>
<div class="highlight-python"><div class="highlight"><pre>? intformal(x^2)
%1 = 1/3*x^3
? intformal(x^2, y)
%2 = y*x^2
? intformal(1/x)
*** at top-level: intformal(1/x)
*** ^--------------
*** intformal: domain error in intformal: residue(series, pole) != 0
</pre></div>
</div>
<p>The argument <span class="math">\(x\)</span> can be of any type. When <span class="math">\(x\)</span> is a rational function, we
assume that the base ring is an integral domain of characteristic zero.</p>
<p>By definition, the main variable of a <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> is the main variable
among the coefficients from its two polynomial components
(representative and modulus); in other words, assuming a polmod represents an
element of <span class="math">\(R[X]/(T(X))\)</span>, the variable <span class="math">\(X\)</span> is a mute variable and the
integral is taken with respect to the main variable used in the base ring <span class="math">\(R\)</span>.
In particular, it is meaningless to integrate with respect to the main
variable of <tt class="docutils literal"><span class="pre">x.mod</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>? intformal(Mod(1,x^2+1), &#39;x)
*** intformal: incorrect priority in intformal: variable x = x
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.intnuminit">
<tt class="descname">intnuminit</tt><big>(</big><em>a</em>, <em>b</em>, <em>m=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.intnuminit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize tables for integration from
<span class="math">\(a\)</span> to <span class="math">\(b\)</span>, where <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are coded as in <tt class="docutils literal"><span class="pre">intnum</span></tt>. Only the
compactness, the possible existence of singularities, the speed of decrease
or the oscillations at infinity are taken into account, and not the values.
For instance <tt class="docutils literal"><span class="pre">intnuminit(-1,1)</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">intnuminit(0,Pi)</span></tt>,
and <tt class="docutils literal"><span class="pre">intnuminit([0,-1/2],oo)</span></tt> is equivalent to
<tt class="docutils literal"><span class="pre">intnuminit([-1,-1/2],</span> <span class="pre">-oo)</span></tt>; on the other hand, the order matters
and
<tt class="docutils literal"><span class="pre">intnuminit([0,-1/2],</span> <span class="pre">[1,-1/3])</span></tt> is <em>not</em> equivalent to
<tt class="docutils literal"><span class="pre">intnuminit([0,-1/3],</span> <span class="pre">[1,-1/2])</span></tt> !</p>
<p>If <span class="math">\(m\)</span> is multiply the default number of sampling points by <span class="math">\(2^m\)</span> (increasing
the running time by a similar factor).</p>
<p>The result is technical and liable to change in the future, but we document
it here for completeness. Let <span class="math">\(x = \phi(t)\)</span>, <span class="math">\(t belongs to ]- oo , oo [\)</span> be an
internally chosen change of variable, achieving double exponential decrease of
the integrand at infinity. The integrator <tt class="docutils literal"><span class="pre">intnum</span></tt> will compute</p>
<div class="math">
\[\begin{split}h \sum_{\|n\| &lt; N} \phi'(nh) F(\phi(nh))\end{split}\]</div>
<p>for some integration step <span class="math">\(h\)</span> and truncation parameter <span class="math">\(N\)</span>.
In basic use, let</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">w0</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">wp</span><span class="p">,</span> <span class="n">xm</span><span class="p">,</span> <span class="n">wm</span><span class="p">]</span> <span class="o">=</span> <span class="n">intnuminit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><span class="math">\(h\)</span> is the integration step</li>
<li><span class="math">\(x_0 = \phi(0)\)</span> and <span class="math">\(w_0 = \phi'(0)\)</span>,</li>
<li><em>xp</em> contains the <span class="math">\(\phi(nh)\)</span>, <span class="math">\(0 &lt; n &lt; N\)</span>,</li>
<li><em>xm</em> contains the <span class="math">\(\phi(nh)\)</span>, <span class="math">\(0 &lt; -n &lt; N\)</span>, or is empty.</li>
<li><em>wp</em> contains the <span class="math">\(\phi'(nh)\)</span>, <span class="math">\(0 &lt; n &lt; N\)</span>,</li>
<li><em>wm</em> contains the <span class="math">\(\phi'(nh)\)</span>, <span class="math">\(0 &lt; -n &lt; N\)</span>, or is empty.</li>
</ul>
<p>The arrays <em>xm</em> and <em>wm</em> are left empty when <span class="math">\(\phi\)</span> is an odd
function. In complicated situations when non-default behaviour is specified at
end points, <tt class="docutils literal"><span class="pre">intnuminit</span></tt> may return up to <span class="math">\(3\)</span> such arrays, corresponding
to a splitting of up to <span class="math">\(3\)</span> integrals of basic type.</p>
<p>If the functions to be integrated later are of the form <span class="math">\(F = f(t) k(t,z)\)</span>
for some kernel <span class="math">\(k\)</span> (e.g. Fourier, Laplace, Mellin,...), it is
useful to also precompute the values of <span class="math">\(f(\phi(nh))\)</span>, which is accomplished
by <tt class="docutils literal"><span class="pre">intfuncinit</span></tt>. The hard part is to determine the behaviour
of <span class="math">\(F\)</span> at endpoints, depending on <span class="math">\(z\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.isfundamental">
<tt class="descname">isfundamental</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.isfundamental" title="Permalink to this definition">¶</a></dt>
<dd><p>True (1) if <span class="math">\(x\)</span> is equal to 1 or to the discriminant of a quadratic
field, false (0) otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ispowerful">
<tt class="descname">ispowerful</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ispowerful" title="Permalink to this definition">¶</a></dt>
<dd><p>True (1) if <span class="math">\(x\)</span> is a powerful integer, false (0) if not;
an integer is powerful if and only if its valuation at all primes dividing
<span class="math">\(x\)</span> is greater than 1.</p>
<div class="highlight-python"><div class="highlight"><pre>? ispowerful(50)
%1 = 0
? ispowerful(100)
%2 = 1
? ispowerful(5^3*(10^1000+1)^2)
%3 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.isprime">
<tt class="descname">isprime</tt><big>(</big><em>x</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.isprime" title="Permalink to this definition">¶</a></dt>
<dd><p>True (1) if <span class="math">\(x\)</span> is a prime
number, false (0) otherwise. A prime number is a positive integer having
exactly two distinct divisors among the natural numbers, namely 1 and
itself.</p>
<p>This routine proves or disproves rigorously that a number is prime, which can
be very slow when <span class="math">\(x\)</span> is indeed prime and has more than <span class="math">\(1000\)</span> digits, say.
Use <tt class="docutils literal"><span class="pre">ispseudoprime</span></tt> to quickly check for compositeness. See also
<tt class="docutils literal"><span class="pre">factor</span></tt>. It accepts vector/matrices arguments, and is then applied
componentwise.</p>
<p>If <span class="math">\(flag = 0\)</span>, use a combination of Baillie-PSW pseudo primality test (see
<tt class="docutils literal"><span class="pre">ispseudoprime</span></tt>), Selfridge &#8220;<span class="math">\(p-1\)</span>&#8221; test if <span class="math">\(x-1\)</span> is smooth enough, and
Adleman-Pomerance-Rumely-Cohen-Lenstra (APRCL) for general <span class="math">\(x\)</span>.</p>
<p>If <span class="math">\(flag = 1\)</span>, use Selfridge-Pocklington-Lehmer &#8220;<span class="math">\(p-1\)</span>&#8221; test and output a
primality certificate as follows: return</p>
<ul class="simple">
<li>0 if <span class="math">\(x\)</span> is composite,</li>
<li>1 if <span class="math">\(x\)</span> is small enough that passing Baillie-PSW test guarantees
its primality (currently <span class="math">\(x &lt; 2^{64}\)</span>, as checked by Jan Feitsma),</li>
<li><span class="math">\(2\)</span> if <span class="math">\(x\)</span> is a large prime whose primality could only sensibly be
proven (given the algorithms implemented in PARI) using the APRCL test.</li>
<li>Otherwise (<span class="math">\(x\)</span> is large and <span class="math">\(x-1\)</span> is smooth) output a three column
matrix as a primality certificate. The first column contains prime
divisors <span class="math">\(p\)</span> of <span class="math">\(x-1\)</span> (such that <span class="math">\(\prod p^{v_p(x-1)} &gt; x^{1/3}\)</span>), the second
the corresponding elements <span class="math">\(a_p\)</span> as in Proposition&nbsp;8.3.1 in GTM&nbsp;138 , and the
third the output of isprime(p,1).</li>
</ul>
<p>The algorithm fails if one of the pseudo-prime factors is not prime, which is
exceedingly unlikely and well worth a bug report. Note that if you monitor
<tt class="docutils literal"><span class="pre">isprime</span></tt> at a high enough debug level, you may see warnings about
untested integers being declared primes. This is normal: we ask for partial
factorisations (sufficient to prove primality if the unfactored part is not
too large), and <tt class="docutils literal"><span class="pre">factor</span></tt> warns us that the cofactor hasn&#8217;t been tested.
It may or may not be tested later, and may or may not be prime. This does
not affect the validity of the whole <tt class="docutils literal"><span class="pre">isprime</span></tt> procedure.</p>
<p>If <span class="math">\(flag = 2\)</span>, use APRCL.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ispseudoprime">
<tt class="descname">ispseudoprime</tt><big>(</big><em>x</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ispseudoprime" title="Permalink to this definition">¶</a></dt>
<dd><p>True (1) if <span class="math">\(x\)</span> is a strong pseudo
prime (see below), false (0) otherwise. If this function returns false, <span class="math">\(x\)</span>
is not prime; if, on the other hand it returns true, it is only highly likely
that <span class="math">\(x\)</span> is a prime number. Use <tt class="docutils literal"><span class="pre">isprime</span></tt> (which is of course much
slower) to prove that <span class="math">\(x\)</span> is indeed prime.
The function accepts vector/matrices arguments, and is then applied
componentwise.</p>
<p>If <span class="math">\(flag = 0\)</span>, checks whether <span class="math">\(x\)</span> is a Baillie-Pomerance-Selfridge-Wagstaff
pseudo prime (strong Rabin-Miller pseudo prime for base <span class="math">\(2\)</span>, followed by
strong Lucas test for the sequence <span class="math">\((P,-1)\)</span>, <span class="math">\(P\)</span> smallest positive integer
such that <span class="math">\(P^2 - 4\)</span> is not a square mod <span class="math">\(x\)</span>).</p>
<p>There are no known composite numbers passing this test, although it is
expected that infinitely many such numbers exist. In particular, all
composites <span class="math">\(&lt;= 2^{64}\)</span> are correctly detected (checked using
<tt class="docutils literal"><span class="pre">http://www.cecm.sfu.ca/Pseudoprimes/index-2-to-64.html</span></tt>).</p>
<p>If <span class="math">\(flag &gt; 0\)</span>, checks whether <span class="math">\(x\)</span> is a strong Miller-Rabin pseudo prime for
<span class="math">\(flag\)</span> randomly chosen bases (with end-matching to catch square roots of <span class="math">\(-1\)</span>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.issquarefree">
<tt class="descname">issquarefree</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.issquarefree" title="Permalink to this definition">¶</a></dt>
<dd><p>True (1) if <span class="math">\(x\)</span> is squarefree, false (0) if not. Here <span class="math">\(x\)</span> can be an
integer or a polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.kronecker">
<tt class="descname">kronecker</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.kronecker" title="Permalink to this definition">¶</a></dt>
<dd><p>Kronecker symbol <span class="math">\((x\|y)\)</span>, where <span class="math">\(x\)</span> and <span class="math">\(y\)</span> must be of type integer. By
definition, this is the extension of Legendre symbol to <span class="math">\(\mathbb{Z} x \mathbb{Z}\)</span>
by total multiplicativity in both arguments with the following special rules
for <span class="math">\(y = 0, -1\)</span> or <span class="math">\(2\)</span>:</p>
<ul class="simple">
<li><span class="math">\((x\|0) = 1\)</span> if <span class="math">\(\|x \|= 1\)</span> and <span class="math">\(0\)</span> otherwise.</li>
<li><span class="math">\((x\|-1) = 1\)</span> if <span class="math">\(x &gt;= 0\)</span> and <span class="math">\(-1\)</span> otherwise.</li>
<li><span class="math">\((x\|2) = 0\)</span> if <span class="math">\(x\)</span> is even and <span class="math">\(1\)</span> if <span class="math">\(x = 1,-1 mod 8\)</span> and <span class="math">\(-1\)</span>
if <span class="math">\(x = 3,-3 mod 8\)</span>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lambertw">
<tt class="descname">lambertw</tt><big>(</big><em>y</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lambertw" title="Permalink to this definition">¶</a></dt>
<dd><p>Lambert <span class="math">\(W\)</span> function, solution of the implicit equation <span class="math">\(xe^x = y\)</span>,
for <span class="math">\(y &gt; 0\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lcm">
<tt class="descname">lcm</tt><big>(</big><em>x</em>, <em>y=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lcm" title="Permalink to this definition">¶</a></dt>
<dd><p>Least common multiple of <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, i.e.&nbsp;such
that <span class="math">\(\mathrm{lcm}(x,y)*\mathrm{gcd}(x,y) = x*y\)</span>, up to units. If <span class="math">\(y\)</span> is omitted and <span class="math">\(x\)</span>
is a vector, returns the <span class="math">\({lcm}\)</span> of all components of <span class="math">\(x\)</span>.
For integer arguments, return the non-negative {lcm}.</p>
<p>When <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are both given and one of them is a vector/matrix type,
the LCM is again taken recursively on each component, but in a different way.
If <span class="math">\(y\)</span> is a vector, resp.&nbsp;matrix, then the result has the same type as <span class="math">\(y\)</span>,
and components equal to <tt class="docutils literal"><span class="pre">lcm(x,</span> <span class="pre">y[i])</span></tt>, resp.&nbsp;<tt class="docutils literal"><span class="pre">lcm(x,</span> <span class="pre">y[,i])</span></tt>. Else
if <span class="math">\(x\)</span> is a vector/matrix the result has the same type as <span class="math">\(x\)</span> and an
analogous definition. Note that for these types, <tt class="docutils literal"><span class="pre">lcm</span></tt> is not
commutative.</p>
<p>Note that <tt class="docutils literal"><span class="pre">lcm(v)</span></tt> is quite different from</p>
<div class="highlight-python"><div class="highlight"><pre>l = v[1]; for (i = 1, #v, l = lcm(l, v[i]))
</pre></div>
</div>
<p>Indeed, <tt class="docutils literal"><span class="pre">lcm(v)</span></tt> is a scalar, but <tt class="docutils literal"><span class="pre">l</span></tt> may not be (if one of
the <tt class="docutils literal"><span class="pre">v[i]</span></tt> is a vector/matrix). The computation uses a divide-conquer tree
and should be much more efficient, especially when using the GMP
multiprecision kernel (and more subquadratic algorithms become available):</p>
<div class="highlight-python"><div class="highlight"><pre>? v = vector(10^5, i, random);
? lcm(v);
time = 546 ms.
? l = v[1]; for (i = 1, #v, l = lcm(l, v[i]))
time = 4,561 ms.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.length">
<tt class="descname">length</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Length of <span class="math">\(x\)</span>; <tt class="docutils literal"><span class="pre">#</span></tt><span class="math">\(x\)</span> is a shortcut for <tt class="docutils literal"><span class="pre">length</span></tt><span class="math">\((x)\)</span>.
This is mostly useful for</p>
<ul class="simple">
<li>vectors: dimension (0 for empty vectors),</li>
<li>lists: number of entries (0 for empty lists),</li>
<li>matrices: number of columns,</li>
<li>character strings: number of actual characters (without
trailing <tt class="docutils literal"><span class="pre">0</span></tt>, should you expect it from <span class="math">\(C\)</span> <tt class="docutils literal"><span class="pre">char*</span></tt>).</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? #&quot;a string&quot;
%1 = 8
? #[3,2,1]
%2 = 3
? #[]
%3 = 0
? #matrix(2,5)
%4 = 5
? L = List([1,2,3,4]); #L
%5 = 4
</pre></div>
</div>
<p>The routine is in fact defined for arbitrary GP types, but is awkward and
useless in other cases: it returns the number of non-code words in <span class="math">\(x\)</span>, e.g.
the effective length minus 2 for integers since the <tt class="docutils literal"><span class="pre">t_INT</span></tt> type has two code
words.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lex">
<tt class="descname">lex</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lex" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the result of a lexicographic comparison
between <span class="math">\(x\)</span> and <span class="math">\(y\)</span> (as <span class="math">\(-1\)</span>, <span class="math">\(0\)</span> or <span class="math">\(1\)</span>). This is to be interpreted in quite
a wide sense: It is admissible to compare objects of different types
(scalars, vectors, matrices), provided the scalars can be compared, as well
as vectors/matrices of different lengths. The comparison is recursive.</p>
<p>In case all components are equal up to the smallest length of the operands,
the more complex is considered to be larger. More precisely, the longest is
the largest; when lengths are equal, we have matrix <span class="math">\(&gt;\)</span> vector <span class="math">\(&gt;\)</span> scalar.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre>? lex([1,3], [1,2,5])
%1 = 1
? lex([1,3], [1,3,-1])
%2 = -1
? lex([1], [[1]])
%3 = -1
? lex([1], [1]~)
%4 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lift">
<tt class="descname">lift</tt><big>(</big><em>x</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lift" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(v\)</span> is omitted, lifts intmods from <span class="math">\(\mathbb{Z}/n\mathbb{Z}\)</span> in <span class="math">\(\mathbb{Z}\)</span>,
<span class="math">\(p\)</span>-adics from <span class="math">\(\mathbb{Q}_p\)</span> to <span class="math">\(\mathbb{Q}\)</span> (as <tt class="docutils literal"><span class="pre">truncate</span></tt>), and polmods to
polynomials. Otherwise, lifts only polmods whose modulus has main
variable&nbsp;<span class="math">\(v\)</span>. <tt class="docutils literal"><span class="pre">t_FFELT</span></tt> are not lifted, nor are List elements: you may
convert the latter to vectors first, or use <tt class="docutils literal"><span class="pre">apply(lift,L)</span></tt>. More
generally, components for which such lifts are meaningless (e.g. character
strings) are copied verbatim.</p>
<div class="highlight-python"><div class="highlight"><pre>? lift(Mod(5,3))
%1 = 2
? lift(3 + O(3^9))
%2 = 3
? lift(Mod(x,x^2+1))
%3 = x
? lift(Mod(x,x^2+1))
%4 = x
</pre></div>
</div>
<p>Lifts are performed recursively on an object components, but only
by <em>one level</em>: once a <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> is lifted, the components of
the result are <em>not</em> lifted further.</p>
<div class="highlight-python"><div class="highlight"><pre>? lift(x * Mod(1,3) + Mod(2,3))
%4 = x + 2
? lift(x * Mod(y,y^2+1) + Mod(2,3))
%5 = y*x + Mod(2, 3) \\ do you understand this one?
? lift(x * Mod(y,y^2+1) + Mod(2,3), &#39;x)
%6 = Mod(y, y^2 + 1)*x + Mod(Mod(2, 3), y^2 + 1)
? lift(%, y)
%7 = y*x + Mod(2, 3)
</pre></div>
</div>
<p>To recursively lift all components not only by one level,
but as long as possible, use <tt class="docutils literal"><span class="pre">liftall</span></tt>. To lift only <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt>&nbsp;s and
<tt class="docutils literal"><span class="pre">t_PADIC</span></tt>&nbsp;s components, use <tt class="docutils literal"><span class="pre">liftint</span></tt>. To lift only <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt>&nbsp;s
components, use <tt class="docutils literal"><span class="pre">liftpol</span></tt>. Finally, <tt class="docutils literal"><span class="pre">centerlift</span></tt> allows to lift
<tt class="docutils literal"><span class="pre">t_INTMOD</span></tt>&nbsp;s and <tt class="docutils literal"><span class="pre">t_PADIC</span></tt>&nbsp;s using centered residues (lift of smallest
absolute value).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.liftall">
<tt class="descname">liftall</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.liftall" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively lift all components of <span class="math">\(x\)</span> from <span class="math">\(\mathbb{Z}/n\mathbb{Z}\)</span> to <span class="math">\(\mathbb{Z}\)</span>,
from <span class="math">\(\mathbb{Q}_p\)</span> to <span class="math">\(\mathbb{Q}\)</span> (as <tt class="docutils literal"><span class="pre">truncate</span></tt>), and polmods to
polynomials. <tt class="docutils literal"><span class="pre">t_FFELT</span></tt> are not lifted, nor are List elements: you may
convert the latter to vectors first, or use <tt class="docutils literal"><span class="pre">apply(liftall,L)</span></tt>. More
generally, components for which such lifts are meaningless (e.g. character
strings) are copied verbatim.</p>
<div class="highlight-python"><div class="highlight"><pre>? liftall(x * (1 + O(3)) + Mod(2,3))
%1 = x + 2
? liftall(x * Mod(y,y^2+1) + Mod(2,3)*Mod(z,z^2))
%2 = y*x + 2*z
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.liftint">
<tt class="descname">liftint</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.liftint" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively lift all components of <span class="math">\(x\)</span> from <span class="math">\(\mathbb{Z}/n\mathbb{Z}\)</span> to <span class="math">\(\mathbb{Z}\)</span> and
from <span class="math">\(\mathbb{Q}_p\)</span> to <span class="math">\(\mathbb{Q}\)</span> (as <tt class="docutils literal"><span class="pre">truncate</span></tt>).
<tt class="docutils literal"><span class="pre">t_FFELT</span></tt> are not lifted, nor are List elements: you may
convert the latter to vectors first, or use <tt class="docutils literal"><span class="pre">apply(liftint,L)</span></tt>. More
generally, components for which such lifts are meaningless (e.g. character
strings) are copied verbatim.</p>
<div class="highlight-python"><div class="highlight"><pre>? liftint(x * (1 + O(3)) + Mod(2,3))
%1 = x + 2
? liftint(x * Mod(y,y^2+1) + Mod(2,3)*Mod(z,z^2))
%2 = Mod(y, y^2 + 1)*x + Mod(Mod(2*z, z^2), y^2 + 1)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.liftpol">
<tt class="descname">liftpol</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.liftpol" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively lift all components of <span class="math">\(x\)</span> which are polmods to
polynomials. <tt class="docutils literal"><span class="pre">t_FFELT</span></tt> are not lifted, nor are List elements: you may
convert the latter to vectors first, or use <tt class="docutils literal"><span class="pre">apply(liftpol,L)</span></tt>. More
generally, components for which such lifts are meaningless (e.g. character
strings) are copied verbatim.</p>
<div class="highlight-python"><div class="highlight"><pre>? liftpol(x * (1 + O(3)) + Mod(2,3))
%1 = (1 + O(3))*x + Mod(2, 3)
? liftpol(x * Mod(y,y^2+1) + Mod(2,3)*Mod(z,z^2))
%2 = y*x + Mod(2, 3)*z
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lindep">
<tt class="descname">lindep</tt><big>(</big><em>v</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lindep" title="Permalink to this definition">¶</a></dt>
<dd><p>finds a small non-trivial integral linear
combination between components of <span class="math">\(v\)</span>. If none can be found return an empty
vector.</p>
<p>If <span class="math">\(v\)</span> is a vector with real/complex entries we use a floating point
(variable precision) LLL algorithm. If <span class="math">\(flag = 0\)</span> the accuracy is chosen
internally using a crude heuristic. If <span class="math">\(flag &gt; 0\)</span> the computation is done with
an accuracy of <span class="math">\(flag\)</span> decimal digits. To get meaningful results in the latter
case, the parameter <span class="math">\(flag\)</span> should be smaller than the number of correct
decimal digits in the input.</p>
<div class="highlight-python"><div class="highlight"><pre>? lindep([sqrt(2), sqrt(3), sqrt(2)+sqrt(3)])
%1 = [-1, -1, 1]~
</pre></div>
</div>
<p>If <span class="math">\(v\)</span> is <span class="math">\(p\)</span>-adic, <span class="math">\(flag\)</span> is ignored and the algorithm LLL-reduces a
suitable (dual) lattice.</p>
<div class="highlight-python"><div class="highlight"><pre>? lindep([1, 2 + 3 + 3^2 + 3^3 + 3^4 + O(3^5)])
%2 = [1, -2]~
</pre></div>
</div>
<p>If <span class="math">\(v\)</span> is a matrix, <span class="math">\(flag\)</span> is ignored and the function returns a non trivial
kernel vector (combination of the columns).</p>
<div class="highlight-python"><div class="highlight"><pre>? lindep([1,2,3;4,5,6;7,8,9])
%3 = [1, -2, 1]~
</pre></div>
</div>
<p>If <span class="math">\(v\)</span> contains polynomials or power series over some base field, finds a
linear relation with coefficients in the field.</p>
<div class="highlight-python"><div class="highlight"><pre>? lindep([x*y, x^2 + y, x^2*y + x*y^2, 1])
%4 = [y, y, -1, -y^2]~
</pre></div>
</div>
<p>For better control, it is preferable to use <tt class="docutils literal"><span class="pre">t_POL</span></tt> rather
than <tt class="docutils literal"><span class="pre">t_SER</span></tt> in the input, otherwise one gets a linear combination which is
<span class="math">\(t\)</span>-adically small, but not necessarily <span class="math">\(0\)</span>. Indeed, power series are first
converted to the minimal absolute accuracy occurring among the entries of <span class="math">\(v\)</span>
(which can cause some coefficients to be ignored), then truncated to
polynomials:</p>
<div class="highlight-python"><div class="highlight"><pre>? v = [t^2+O(t^4), 1+O(t^2)]; L=lindep(v)
%1 = [1, 0]~
? v*L
%2 = t^2+O(t^4) \\ small but not 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lngamma">
<tt class="descname">lngamma</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lngamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of the logarithm of the gamma function of <span class="math">\(x\)</span>. This
function is analytic on the complex plane with non-positive integers
removed, and can have much larger arguments than <tt class="docutils literal"><span class="pre">gamma</span></tt> itself.</p>
<p>For <span class="math">\(x\)</span> a power series such that <span class="math">\(x(0)\)</span> is not a pole of <tt class="docutils literal"><span class="pre">gamma</span></tt>,
compute the Taylor expansion. (PARI only knows about regular power series
and can&#8217;t include logarithmic terms.)</p>
<div class="highlight-python"><div class="highlight"><pre>? lngamma(1+x+O(x^2))
%1 = -0.57721566490153286060651209008240243104*x + O(x^2)
? lngamma(x+O(x^2))
 *** at top-level: lngamma(x+O(x^2))
 *** ^-----------------
 *** lngamma: domain error in lngamma: valuation != 0
? lngamma(-1+x+O(x^2))
 *** lngamma: Warning: normalizing a series with 0 leading term.
 *** at top-level: lngamma(-1+x+O(x^2))
 *** ^--------------------
 *** lngamma: domain error in intformal: residue(series, pole) != 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.log">
<tt class="descname">log</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of the natural logarithm of
<span class="math">\(x belongs to \mathbb{C}^*\)</span>, i.e.&nbsp;such that <span class="math">\({Im(log}(x)) belongs to ]-\Pi,\Pi]\)</span>.
The branch cut lies
along the negative real axis, continuous with quadrant 2, i.e.&nbsp;such that
<span class="math">\(\lim_{b\\to 0^+} \log (a+bi) = \log a\)</span> for <span class="math">\(a belongs to \mathbb{R}^*\)</span>. The result is complex
(with imaginary part equal to <span class="math">\(\Pi\)</span>) if <span class="math">\(x belongs to \mathbb{R}\)</span> and <span class="math">\(x &lt; 0\)</span>. In general,
the algorithm uses the formula</p>
<div class="math">
\[\log(x) ~ (\Pi)/(2{agm}(1, 4/s)) - m \log 2,\]</div>
<p>if <span class="math">\(s = x 2^m\)</span> is large enough. (The result is exact to <span class="math">\(B\)</span> bits provided
<span class="math">\(s &gt; 2^{B/2}\)</span>.) At low accuracies, the series expansion near <span class="math">\(1\)</span> is used.</p>
<p><span class="math">\(p\)</span>-adic arguments are also accepted for <span class="math">\(x\)</span>, with the convention that
<span class="math">\(\log(p) = 0\)</span>. Hence in particular <span class="math">\(\exp(\log(x))/x\)</span> is not in general equal to
1 but to a <span class="math">\((p-1)\)</span>-th root of unity (or <span class="math">\(±1\)</span> if <span class="math">\(p = 2\)</span>) times a power of <span class="math">\(p\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mapdelete">
<tt class="descname">mapdelete</tt><big>(</big><em>M</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mapdelete" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove <span class="math">\(x\)</span> from the domain of the map <span class="math">\(M\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? M = Map([&quot;a&quot;,1; &quot;b&quot;,3; &quot;c&quot;,7]);
? mapdelete(M,&quot;b&quot;);
? Mat(M)
[&quot;a&quot; 1]

[&quot;c&quot; 7]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mapget">
<tt class="descname">mapget</tt><big>(</big><em>M</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mapget" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <span class="math">\(x\)</span> by the map <span class="math">\(M\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? M=Map([&quot;a&quot;,23;&quot;b&quot;,43]);
? mapget(M,&quot;a&quot;)
%2 = 23
? mapget(M,&quot;b&quot;)
%3 = 43
</pre></div>
</div>
<p>Raises an exception when the key <span class="math">\(x\)</span> is not present in <span class="math">\(M\)</span></p>
<div class="highlight-python"><div class="highlight"><pre>? mapget(M,&quot;c&quot;)
 *** at top-level: mapget(M,&quot;c&quot;)
 *** ^-------------
 *** mapget: non-existent component in mapget: index not in map
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matadjoint">
<tt class="descname">matadjoint</tt><big>(</big><em>M</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matadjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>adjoint matrix of <span class="math">\(M\)</span>, i.e.&nbsp;a matrix <span class="math">\(N\)</span>
of cofactors of <span class="math">\(M\)</span>, satisfying <span class="math">\(M*N = \det(M)*\mathrm{Id}\)</span>. <span class="math">\(M\)</span> must be a
(non-necessarily invertible) square matrix of dimension <span class="math">\(n\)</span>.
If <span class="math">\(flag\)</span> is 0 or omitted, we try to use Leverrier-Faddeev&#8217;s algorithm,
which assumes that <span class="math">\(n!\)</span> invertible. If it fails or <span class="math">\(flag = 1\)</span>,
compute <span class="math">\(T = charpoly(M)\)</span> independently first and return
<span class="math">\((-1)^{n-1} (T(x)-T(0))/x\)</span> evaluated at <span class="math">\(M\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? a = [1,2,3;3,4,5;6,7,8] * Mod(1,4);
%2 =
[Mod(1, 4) Mod(2, 4) Mod(3, 4)]

[Mod(3, 4) Mod(0, 4) Mod(1, 4)]

[Mod(2, 4) Mod(3, 4) Mod(0, 4)]
</pre></div>
</div>
<p>Both algorithms use <span class="math">\(O(n^4)\)</span> operations in the base ring, and are usually
slower than computing the characteristic polynomial or the inverse of <span class="math">\(M\)</span>
directly.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matalgtobasis">
<tt class="descname">matalgtobasis</tt><big>(</big><em>nf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matalgtobasis" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(nf\)</span> being a number field in <tt class="docutils literal"><span class="pre">nfinit</span></tt> format, and <span class="math">\(x\)</span> a
(row or column) vector or matrix, apply <tt class="docutils literal"><span class="pre">nfalgtobasis</span></tt> to each entry
of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matbasistoalg">
<tt class="descname">matbasistoalg</tt><big>(</big><em>nf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matbasistoalg" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(nf\)</span> being a number field in <tt class="docutils literal"><span class="pre">nfinit</span></tt> format, and <span class="math">\(x\)</span> a
(row or column) vector or matrix, apply <tt class="docutils literal"><span class="pre">nfbasistoalg</span></tt> to each entry
of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matcompanion">
<tt class="descname">matcompanion</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matcompanion" title="Permalink to this definition">¶</a></dt>
<dd><p>The left companion matrix to the non-zero polynomial <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matconcat">
<tt class="descname">matconcat</tt><big>(</big><em>v</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matconcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <tt class="docutils literal"><span class="pre">t_MAT</span></tt> built from the entries of <span class="math">\(v\)</span>, which may
be a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> (concatenate horizontally), a <tt class="docutils literal"><span class="pre">t_COL</span></tt> (concatenate
vertically), or a <tt class="docutils literal"><span class="pre">t_MAT</span></tt> (concatenate vertically each column, and
concatenate vertically the resulting matrices). The entries of <span class="math">\(v\)</span> are always
considered as matrices: they can themselves be <tt class="docutils literal"><span class="pre">t_VEC</span></tt> (seen as a row
matrix), a <tt class="docutils literal"><span class="pre">t_COL</span></tt> seen as a column matrix), a <tt class="docutils literal"><span class="pre">t_MAT</span></tt>, or a scalar (seen
as an <span class="math">\(1 x 1\)</span> matrix).</p>
<div class="highlight-python"><div class="highlight"><pre>? A=[1,2;3,4]; B=[5,6]~; C=[7,8]; D=9;
? matconcat([A, B]) \\ horizontal
%1 =
[1 2 5]

[3 4 6]
? matconcat([A, C]~) \\ vertical
%2 =
[1 2]

[3 4]

[7 8]
? matconcat([A, B; C, D]) \\ block matrix
%3 =
[1 2 5]

[3 4 6]

[7 8 9]
</pre></div>
</div>
<p>If the dimensions of the entries to concatenate do not match up, the above
rules are extended as follows:</p>
<ul class="simple">
<li>each entry <span class="math">\(v_{i,j}\)</span> of <span class="math">\(v\)</span> has a natural length and height: <span class="math">\(1 x 
1\)</span> for a scalar, <span class="math">\(1 x n\)</span> for a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> of length <span class="math">\(n\)</span>, <span class="math">\(n x 1\)</span>
for a <tt class="docutils literal"><span class="pre">t_COL</span></tt>, <span class="math">\(m x n\)</span> for an <span class="math">\(m x n\)</span> <tt class="docutils literal"><span class="pre">t_MAT</span></tt></li>
<li>let <span class="math">\(H_i\)</span> be the maximum over <span class="math">\(j\)</span> of the lengths of the <span class="math">\(v_{i,j}\)</span>,
let <span class="math">\(L_j\)</span> be the maximum over <span class="math">\(i\)</span> of the heights of the <span class="math">\(v_{i,j}\)</span>.
The dimensions of the <span class="math">\((i,j)\)</span>-th block in the concatenated matrix are
<span class="math">\(H_i x L_j\)</span>.</li>
<li>a scalar <span class="math">\(s = v_{i,j}\)</span> is considered as <span class="math">\(s\)</span> times an identity matrix
of the block dimension <span class="math">\(\min (H_i,L_j)\)</span></li>
<li>blocks are extended by 0 columns on the right and 0 rows at the
bottom, as needed.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? matconcat([1, [2,3]~, [4,5,6]~]) \\ horizontal
%4 =
[1 2 4]

[0 3 5]

[0 0 6]
? matconcat([1, [2,3], [4,5,6]]~) \\ vertical
%5 =
[1 0 0]

[2 3 0]

[4 5 6]
? matconcat([B, C; A, D]) \\ block matrix
%6 =
[5 0 7 8]

[6 0 0 0]

[1 2 9 0]

[3 4 0 9]
? U=[1,2;3,4]; V=[1,2,3;4,5,6;7,8,9];
? matconcat(matdiagonal([U, V])) \\ block diagonal
%7 =
[1 2 0 0 0]

[3 4 0 0 0]

[0 0 1 2 3]

[0 0 4 5 6]

[0 0 7 8 9]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matdet">
<tt class="descname">matdet</tt><big>(</big><em>x</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matdet" title="Permalink to this definition">¶</a></dt>
<dd><p>Determinant of the square matrix <span class="math">\(x\)</span>.</p>
<p>If <span class="math">\(flag = 0\)</span>, uses an appropriate algorithm depending on the coefficients:</p>
<ul class="simple">
<li>integer entries: modular method due to Dixon, Pernet and Stein.</li>
<li>real or <span class="math">\(p\)</span>-adic entries: classical Gaussian elimination using maximal
pivot.</li>
<li>intmod entries: classical Gaussian elimination using first non-zero
pivot.</li>
<li>other cases: Gauss-Bareiss.</li>
</ul>
<p>If <span class="math">\(flag = 1\)</span>, uses classical Gaussian elimination with appropriate pivoting
strategy (maximal pivot for real or <span class="math">\(p\)</span>-adic coefficients). This is usually
worse than the default.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matdetint">
<tt class="descname">matdetint</tt><big>(</big><em>B</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matdetint" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(B\)</span> be an <span class="math">\(m x n\)</span> matrix with integer coefficients. The
<em>determinant</em> <span class="math">\(D\)</span> of the lattice generated by the columns of <span class="math">\(B\)</span> is
the square root of <span class="math">\(\det(B^T B)\)</span> if <span class="math">\(B\)</span> has maximal rank <span class="math">\(m\)</span>, and <span class="math">\(0\)</span>
otherwise.</p>
<p>This function uses the Gauss-Bareiss algorithm to compute a positive
<em>multiple</em> of <span class="math">\(D\)</span>. When <span class="math">\(B\)</span> is square, the function actually returns
<span class="math">\(D = \|\det B\|\)</span>.</p>
<p>This function is useful in conjunction with <tt class="docutils literal"><span class="pre">mathnfmod</span></tt>, which needs to
know such a multiple. If the rank is maximal and the matrix non-square,
you can obtain <span class="math">\(D\)</span> exactly using</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">matdet</span><span class="p">(</span> <span class="n">mathnfmod</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">matdetint</span><span class="p">(</span><span class="n">B</span><span class="p">))</span> <span class="p">)</span>
</pre></div>
</div>
<p>Note that as soon as one of the dimensions gets large (<span class="math">\(m\)</span> or <span class="math">\(n\)</span> is larger
than 20, say), it will often be much faster to use <tt class="docutils literal"><span class="pre">mathnf(B,</span> <span class="pre">1)</span></tt> or
<tt class="docutils literal"><span class="pre">mathnf(B,</span> <span class="pre">4)</span></tt> directly.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matdiagonal">
<tt class="descname">matdiagonal</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matdiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> being a vector, creates the diagonal matrix
whose diagonal entries are those of <span class="math">\(x\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? matdiagonal([1,2,3]);
%1 =
[1 0 0]

[0 2 0]

[0 0 3]
</pre></div>
</div>
<p>Block diagonal matrices are easily created using
<tt class="docutils literal"><span class="pre">matconcat</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>? U=[1,2;3,4]; V=[1,2,3;4,5,6;7,8,9];
? matconcat(matdiagonal([U, V]))
%1 =
[1 2 0 0 0]

[3 4 0 0 0]

[0 0 1 2 3]

[0 0 4 5 6]

[0 0 7 8 9]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mateigen">
<tt class="descname">mateigen</tt><big>(</big><em>x</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mateigen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the (complex) eigenvectors of <span class="math">\(x\)</span> as columns of a matrix.
If <span class="math">\(flag = 1\)</span>, return <span class="math">\([L,H]\)</span>, where <span class="math">\(L\)</span> contains the
eigenvalues and <span class="math">\(H\)</span> the corresponding eigenvectors; multiple eigenvalues are
repeated according to the eigenspace dimension (which may be less
than the eigenvalue multiplicity in the characteristic polynomial).</p>
<p>This function first computes the characteristic polynomial of <span class="math">\(x\)</span> and
approximates its complex roots <span class="math">\((\lambda_i)\)</span>, then tries to compute the
eigenspaces as kernels of the <span class="math">\(x - \lambda_i\)</span>. This algorithm is
ill-conditioned and is likely to miss kernel vectors if some roots of the
characteristic polynomial are close, in particular if it has multiple roots.</p>
<div class="highlight-python"><div class="highlight"><pre>? A = [13,2; 10,14]; mateigen(A)
%1 =
[-1/2 2/5]

[ 1 1]
? [L,H] = mateigen(A, 1);
? L
%3 = [9, 18]
? H
%4 =
[-1/2 2/5]

[ 1 1]
</pre></div>
</div>
<p>For symmetric matrices, use <tt class="docutils literal"><span class="pre">qfjacobi</span></tt> instead; for Hermitian matrices,
compute</p>
<div class="highlight-python"><div class="highlight"><pre>A = real(x);
B = imag(x);
y = matconcat([A, -B; B, A]);
</pre></div>
</div>
<p>and apply <tt class="docutils literal"><span class="pre">qfjacobi</span></tt> to <span class="math">\(y\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matfrobenius">
<tt class="descname">matfrobenius</tt><big>(</big><em>M</em>, <em>flag=0</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matfrobenius" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Frobenius form of
the square matrix <tt class="docutils literal"><span class="pre">M</span></tt>. If <span class="math">\(flag = 1\)</span>, returns only the elementary divisors as
a vector of polynomials in the variable <tt class="docutils literal"><span class="pre">v</span></tt>. If <span class="math">\(flag = 2\)</span>, returns a
two-components vector [F,B] where <tt class="docutils literal"><span class="pre">F</span></tt> is the Frobenius form and <tt class="docutils literal"><span class="pre">B</span></tt> is
the basis change so that <span class="math">\(M = B^{-1}FB\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mathess">
<tt class="descname">mathess</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mathess" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a matrix similar to the square matrix <span class="math">\(x\)</span>, which is in upper Hessenberg
form (zero entries below the first subdiagonal).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mathnf">
<tt class="descname">mathnf</tt><big>(</big><em>M</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mathnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(R\)</span> be a Euclidean ring, equal to <span class="math">\(\mathbb{Z}\)</span> or to <span class="math">\(K[X]\)</span> for some field
<span class="math">\(K\)</span>. If <span class="math">\(M\)</span> is a (not necessarily square) matrix with entries in <span class="math">\(R\)</span>, this
routine finds the <em>upper triangular</em> Hermite normal form of <span class="math">\(M\)</span>.
If the rank of <span class="math">\(M\)</span> is equal to its number of rows, this is a square
matrix. In general, the columns of the result form a basis of the <span class="math">\(R\)</span>-module
spanned by the columns of <span class="math">\(M\)</span>.</p>
<p>The values <span class="math">\(0,1,2,3\)</span> of <span class="math">\(flag\)</span> have a binary meaning, analogous to the one
in <tt class="docutils literal"><span class="pre">matsnf</span></tt>; in this case, binary digits of <span class="math">\(flag\)</span> mean:</p>
<ul class="simple">
<li>1 (complete output): if set, outputs <span class="math">\([H,U]\)</span>, where <span class="math">\(H\)</span> is the Hermite
normal form of <span class="math">\(M\)</span>, and <span class="math">\(U\)</span> is a transformation matrix such that <span class="math">\(MU = [0|H]\)</span>.
The matrix <span class="math">\(U\)</span> belongs to <span class="math">\({GL}(R)\)</span>. When <span class="math">\(M\)</span> has a large kernel, the
entries of <span class="math">\(U\)</span> are in general huge.</li>
<li>2 (generic input): <em>Deprecated</em>. If set, assume that <span class="math">\(R = K[X]\)</span> is
a polynomial ring; otherwise, assume that <span class="math">\(R = \mathbb{Z}\)</span>. This flag is now useless
since the routine always checks whether the matrix has integral entries.</li>
</ul>
<p>For these 4 values, we use a naive algorithm, which behaves well
in small dimension only. Larger values correspond to different algorithms,
are restricted to <em>integer</em> matrices, and all output the unimodular
matrix <span class="math">\(U\)</span>. From now on all matrices have integral entries.</p>
<ul class="simple">
<li><span class="math">\(flag = 4\)</span>, returns <span class="math">\([H,U]\)</span> as in &#8220;complete output&#8221; above, using a
variant of LLL reduction along the way. The matrix <span class="math">\(U\)</span> is provably
small in the <span class="math">\(L_2\)</span> sense, and in general close to optimal; but the
reduction is in general slow, although provably polynomial-time.</li>
</ul>
<p>If <span class="math">\(flag = 5\)</span>, uses Batut&#8217;s algorithm and output <span class="math">\([H,U,P]\)</span>, such that <span class="math">\(H\)</span> and
<span class="math">\(U\)</span> are as before and <span class="math">\(P\)</span> is a permutation of the rows such that <span class="math">\(P\)</span> applied
to <span class="math">\(MU\)</span> gives <span class="math">\(H\)</span>. This is in general faster than <span class="math">\(flag = 4\)</span> but the matrix <span class="math">\(U\)</span>
is usually worse; it is heuristically smaller than with the default algorithm.</p>
<p>When the matrix is dense and the dimension is large (bigger than 100, say),
<span class="math">\(flag = 4\)</span> will be fastest. When <span class="math">\(M\)</span> has maximal rank, then</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">H</span> <span class="o">=</span> <span class="n">mathnfmod</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">matdetint</span><span class="p">(</span><span class="n">M</span><span class="p">))</span>
</pre></div>
</div>
<p>will be even faster. You can then recover <span class="math">\(U\)</span> as <span class="math">\(M^{-1}H\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? M = matrix(3,4,i,j,random([-5,5]))
%1 =
[ 0 2 3 0]

[-5 3 -5 -5]

[ 4 3 -5 4]

? [H,U] = mathnf(M, 1);
? U
%3 =
[-1 0 -1 0]

[ 0 5 3 2]

[ 0 3 1 1]

[ 1 0 0 0]

? H
%5 =
[19 9 7]

[ 0 9 1]

[ 0 0 1]

? M*U
%6 =
[0 19 9 7]

[0 0 9 1]

[0 0 0 1]
</pre></div>
</div>
<p>For convenience, <span class="math">\(M\)</span> is allowed to be a <tt class="docutils literal"><span class="pre">t_VEC</span></tt>, which is then
automatically converted to a <tt class="docutils literal"><span class="pre">t_MAT</span></tt>, as per the <tt class="docutils literal"><span class="pre">Mat</span></tt> function.
For instance to solve the generalized extended gcd problem, one may use</p>
<div class="highlight-python"><div class="highlight"><pre>? v = [116085838, 181081878, 314252913,10346840];
? [H,U] = mathnf(v, 1);
? U
%2 =
[ 103 -603 15 -88]

[-146 13 -1208 352]

[ 58 220 678 -167]

[-362 -144 381 -101]
? v*U
%3 = [0, 0, 0, 1]
</pre></div>
</div>
<p>This also allows to input a matrix as a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> of
<tt class="docutils literal"><span class="pre">t_COL</span></tt>&nbsp;s of the same length (which <tt class="docutils literal"><span class="pre">Mat</span></tt> would concatenate to
the <tt class="docutils literal"><span class="pre">t_MAT</span></tt> having those columns):</p>
<div class="highlight-python"><div class="highlight"><pre>? v = [[1,0,4]~, [3,3,4]~, [0,-4,-5]~]; mathnf(v)
%1 =
[47 32 12]

[ 0 1 0]

[ 0 0 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mathnfmod">
<tt class="descname">mathnfmod</tt><big>(</big><em>x</em>, <em>d</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mathnfmod" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(x\)</span> is a (not necessarily square) matrix of
maximal rank with integer entries, and <span class="math">\(d\)</span> is a multiple of the (non-zero)
determinant of the lattice spanned by the columns of <span class="math">\(x\)</span>, finds the
<em>upper triangular</em> Hermite normal form of <span class="math">\(x\)</span>.</p>
<p>If the rank of <span class="math">\(x\)</span> is equal to its number of rows, the result is a square
matrix. In general, the columns of the result form a basis of the lattice
spanned by the columns of <span class="math">\(x\)</span>. Even when <span class="math">\(d\)</span> is known, this is in general
slower than <tt class="docutils literal"><span class="pre">mathnf</span></tt> but uses much less memory.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mathnfmodid">
<tt class="descname">mathnfmodid</tt><big>(</big><em>x</em>, <em>d</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mathnfmodid" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the (upper triangular)
Hermite normal form of <span class="math">\(x\)</span> concatenated with the diagonal
matrix with diagonal <span class="math">\(d\)</span>. Assumes that <span class="math">\(x\)</span> has integer entries.
Variant: if <span class="math">\(d\)</span> is an integer instead of a vector, concatenate <span class="math">\(d\)</span> times the
identity matrix.</p>
<div class="highlight-python"><div class="highlight"><pre>? m=[0,7;-1,0;-1,-1]
%1 =
[ 0 7]

[-1 0]

[-1 -1]
? mathnfmodid(m, [6,2,2])
%2 =
[2 1 1]

[0 1 0]

[0 0 1]
? mathnfmodid(m, 10)
%3 =
[10 7 3]

[ 0 1 0]

[ 0 0 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mathouseholder">
<tt class="descname">mathouseholder</tt><big>(</big><em>Q</em>, <em>v</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mathouseholder" title="Permalink to this definition">¶</a></dt>
<dd><p>applies a sequence <span class="math">\(Q\)</span> of Householder
transforms, as returned by <tt class="docutils literal"><span class="pre">matqr</span></tt><span class="math">\((M,1)\)</span> to the vector or matrix <span class="math">\(v\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matimage">
<tt class="descname">matimage</tt><big>(</big><em>x</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a basis for the image of the
matrix <span class="math">\(x\)</span> as columns of a matrix. A priori the matrix can have entries of
any type. If <span class="math">\(flag = 0\)</span>, use standard Gauss pivot. If <span class="math">\(flag = 1\)</span>, use
<tt class="docutils literal"><span class="pre">matsupplement</span></tt> (much slower: keep the default flag!).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matimagecompl">
<tt class="descname">matimagecompl</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matimagecompl" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the vector of the column indices which
are not extracted by the function <tt class="docutils literal"><span class="pre">matimage</span></tt>, as a permutation
(<tt class="docutils literal"><span class="pre">t_VECSMALL</span></tt>). Hence the number of
components of <tt class="docutils literal"><span class="pre">matimagecompl(x)</span></tt> plus the number of columns of
<tt class="docutils literal"><span class="pre">matimage(x)</span></tt> is equal to the number of columns of the matrix <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matindexrank">
<tt class="descname">matindexrank</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matindexrank" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> being a matrix of rank <span class="math">\(r\)</span>, returns a vector with two
<tt class="docutils literal"><span class="pre">t_VECSMALL</span></tt> components <span class="math">\(y\)</span> and <span class="math">\(z\)</span> of length <span class="math">\(r\)</span> giving a list of rows
and columns respectively (starting from 1) such that the extracted matrix
obtained from these two vectors using <span class="math">\(vecextract(x,y,z)\)</span> is
invertible.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matintersect">
<tt class="descname">matintersect</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matintersect" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> and <span class="math">\(y\)</span> being two matrices with the same
number of rows each of whose columns are independent, finds a basis of the
<span class="math">\(\mathbb{Q}\)</span>-vector space equal to the intersection of the spaces spanned by the
columns of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> respectively. The faster function
<tt class="docutils literal"><span class="pre">idealintersect</span></tt> can be used to intersect fractional ideals (projective
<span class="math">\(\mathbb{Z}_K\)</span> modules of rank <span class="math">\(1\)</span>); the slower but much more general function
<tt class="docutils literal"><span class="pre">nfhnf</span></tt> can be used to intersect general <span class="math">\(\mathbb{Z}_K\)</span>-modules.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matinverseimage">
<tt class="descname">matinverseimage</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matinverseimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a matrix <span class="math">\(x\)</span> and
a column vector or matrix <span class="math">\(y\)</span>, returns a preimage <span class="math">\(z\)</span> of <span class="math">\(y\)</span> by <span class="math">\(x\)</span> if one
exists (i.e such that <span class="math">\(x z = y\)</span>), an empty vector or matrix otherwise. The
complete inverse image is <span class="math">\(z + {Ker} x\)</span>, where a basis of the kernel of
<span class="math">\(x\)</span> may be obtained by <tt class="docutils literal"><span class="pre">matker</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>? M = [1,2;2,4];
? matinverseimage(M, [1,2]~)
%2 = [1, 0]~
? matinverseimage(M, [3,4]~)
%3 = []~ \\ no solution
? matinverseimage(M, [1,3,6;2,6,12])
%4 =
[1 3 6]

[0 0 0]
? matinverseimage(M, [1,2;3,4])
%5 = [;] \\ no solution
? K = matker(M)
%6 =
[-2]

[1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matisdiagonal">
<tt class="descname">matisdiagonal</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matisdiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true (1) if <span class="math">\(x\)</span> is a diagonal matrix, false (0) if not.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matker">
<tt class="descname">matker</tt><big>(</big><em>x</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matker" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a basis for the kernel of the matrix <span class="math">\(x\)</span> as columns of a matrix.
The matrix can have entries of any type, provided they are compatible with
the generic arithmetic operations (<span class="math">\(+\)</span>, <span class="math">\(x\)</span> and <span class="math">\(/\)</span>).</p>
<p>If <span class="math">\(x\)</span> is known to have integral entries, set <span class="math">\(flag = 1\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matkerint">
<tt class="descname">matkerint</tt><big>(</big><em>x</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matkerint" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives an LLL-reduced <span class="math">\(\mathbb{Z}\)</span>-basis
for the lattice equal to the kernel of the matrix <span class="math">\(x\)</span> with rational entries.</p>
<p><em>flag</em> is deprecated, kept for backward compatibility.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matmuldiagonal">
<tt class="descname">matmuldiagonal</tt><big>(</big><em>x</em>, <em>d</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matmuldiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Product of the matrix <span class="math">\(x\)</span> by the diagonal
matrix whose diagonal entries are those of the vector <span class="math">\(d\)</span>. Equivalent to,
but much faster than <span class="math">\(x*matdiagonal(d)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matmultodiagonal">
<tt class="descname">matmultodiagonal</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matmultodiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Product of the matrices <span class="math">\(x\)</span> and <span class="math">\(y\)</span> assuming that the result is a
diagonal matrix. Much faster than <span class="math">\(x*y\)</span> in that case. The result is
undefined if <span class="math">\(x*y\)</span> is not diagonal.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matqr">
<tt class="descname">matqr</tt><big>(</big><em>M</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <span class="math">\([Q,R]\)</span>, the QR-decomposition of the square invertible
matrix <span class="math">\(M\)</span> with real entries: <span class="math">\(Q\)</span> is orthogonal and <span class="math">\(R\)</span> upper triangular. If
<span class="math">\(flag = 1\)</span>, the orthogonal matrix is returned as a sequence of Householder
transforms: applying such a sequence is stabler and faster than
multiplication by the corresponding <span class="math">\(Q\)</span> matrix.
More precisely, if</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">Q</span><span class="p">,</span><span class="n">R</span><span class="p">]</span> <span class="o">=</span> <span class="n">matqr</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
<span class="p">[</span><span class="n">q</span><span class="p">,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">matqr</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>then <span class="math">\(r = R\)</span> and <tt class="docutils literal"><span class="pre">mathouseholder</span></tt><span class="math">\((q, M)\)</span> is
(close to) <span class="math">\(R\)</span>; furthermore</p>
<div class="highlight-python"><div class="highlight"><pre>mathouseholder(q, matid(#M)) == Q~
</pre></div>
</div>
<p>the inverse of <span class="math">\(Q\)</span>. This function raises an error if the
precision is too low or <span class="math">\(x\)</span> is singular.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matrank">
<tt class="descname">matrank</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matrank" title="Permalink to this definition">¶</a></dt>
<dd><p>Rank of the matrix <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matrixqz">
<tt class="descname">matrixqz</tt><big>(</big><em>A</em>, <em>p=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matrixqz" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(A\)</span> being an <span class="math">\(m x n\)</span> matrix in <span class="math">\(M_{m,n}(\mathbb{Q})\)</span>, let
<span class="math">\({Im}_\mathbb{Q} A\)</span> (resp.&nbsp;<span class="math">\({Im}_\mathbb{Z} A\)</span>) the <span class="math">\(\mathbb{Q}\)</span>-vector space
(resp.&nbsp;the <span class="math">\(\mathbb{Z}\)</span>-module) spanned by the columns of <span class="math">\(A\)</span>. This function has
varying behavior depending on the sign of <span class="math">\(p\)</span>:</p>
<p>If <span class="math">\(p &gt;= 0\)</span>, <span class="math">\(A\)</span> is assumed to have maximal rank <span class="math">\(n &lt;= m\)</span>. The function
returns a matrix <span class="math">\(B belongs to M_{m,n}(\mathbb{Z})\)</span>, with <span class="math">\({Im}_\mathbb{Q} B = {Im}_\mathbb{Q} A\)</span>,
such that the GCD of all its <span class="math">\(n x n\)</span> minors is coprime to
<span class="math">\(p\)</span>; in particular, if <span class="math">\(p = 0\)</span> (default), this GCD is <span class="math">\(1\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? minors(x) = vector(#x[,1], i, matdet(x[^i,]));
? A = [3,1/7; 5,3/7; 7,5/7]; minors(A)
%1 = [4/7, 8/7, 4/7] \\ determinants of all 2x2 minors
? B = matrixqz(A)
%2 =
[3 1]

[5 2]

[7 3]
? minors(%)
%3 = [1, 2, 1] \\ B integral with coprime minors
</pre></div>
</div>
<p>If <span class="math">\(p = -1\)</span>, returns the HNF basis of the lattice <span class="math">\(\mathbb{Z}^n \cap {Im}_\mathbb{Z} A\)</span>.</p>
<p>If <span class="math">\(p = -2\)</span>, returns the HNF basis of the lattice <span class="math">\(\mathbb{Z}^n \cap {Im}_\mathbb{Q} A\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? matrixqz(A,-1)
%4 =
[8 5]

[4 3]

[0 1]

? matrixqz(A,-2)
%5 =
[2 -1]

[1 0]

[0 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matsize">
<tt class="descname">matsize</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matsize" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> being a vector or matrix, returns a row vector
with two components, the first being the number of rows (1 for a row vector),
the second the number of columns (1 for a column vector).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matsnf">
<tt class="descname">matsnf</tt><big>(</big><em>X</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matsnf" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(X\)</span> is a (singular or non-singular) matrix outputs the vector of
elementary divisors of <span class="math">\(X\)</span>, i.e.&nbsp;the diagonal of the
Smith normal form of <span class="math">\(X\)</span>, normalized so that <span class="math">\(d_n \| d_{n-1} \| 
... \| d_1\)</span>.</p>
<p>The binary digits of <em>flag</em> mean:</p>
<p>1 (complete output): if set, outputs <span class="math">\([U,V,D]\)</span>, where <span class="math">\(U\)</span> and <span class="math">\(V\)</span> are two
unimodular matrices such that <span class="math">\(UXV\)</span> is the diagonal matrix <span class="math">\(D\)</span>. Otherwise
output only the diagonal of <span class="math">\(D\)</span>. If <span class="math">\(X\)</span> is not a square matrix, then <span class="math">\(D\)</span>
will be a square diagonal matrix padded with zeros on the left or the top.</p>
<p>2 (generic input): if set, allows polynomial entries, in which case the
input matrix must be square. Otherwise, assume that <span class="math">\(X\)</span> has integer
coefficients with arbitrary shape.</p>
<p>4 (cleanup): if set, cleans up the output. This means that elementary
divisors equal to <span class="math">\(1\)</span> will be deleted, i.e.&nbsp;outputs a shortened vector <span class="math">\(D'\)</span>
instead of <span class="math">\(D\)</span>. If complete output was required, returns <span class="math">\([U',V',D']\)</span> so
that <span class="math">\(U'XV' = D'\)</span> holds. If this flag is set, <span class="math">\(X\)</span> is allowed to be of the
form <span class="math">\(vector of elementary divisors' or :math:`[U,V,D]\)</span> as would normally be output with the cleanup flag
unset.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matsolve">
<tt class="descname">matsolve</tt><big>(</big><em>M</em>, <em>B</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matsolve" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being an invertible matrix and <span class="math">\(B\)</span> a column
vector, finds the solution <span class="math">\(X\)</span> of <span class="math">\(MX = B\)</span>, using Dixon <span class="math">\(p\)</span>-adic lifting method
if <span class="math">\(M\)</span> and <span class="math">\(B\)</span> are integral and Gaussian elimination otherwise. This
has the same effect as, but is faster, than <span class="math">\(M^{-1}*B\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matsolvemod">
<tt class="descname">matsolvemod</tt><big>(</big><em>M</em>, <em>D</em>, <em>B</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matsolvemod" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being any integral matrix,
<span class="math">\(D\)</span> a column vector of non-negative integer moduli, and <span class="math">\(B\)</span> an integral
column vector, gives a small integer solution to the system of congruences
<span class="math">\(\sum_i m_{i,j}x_j = b_i (mod d_i)\)</span> if one exists, otherwise returns
zero. Shorthand notation: <span class="math">\(B\)</span> (resp.&nbsp;<span class="math">\(D\)</span>) can be given as a single integer,
in which case all the <span class="math">\(b_i\)</span> (resp.&nbsp;<span class="math">\(d_i\)</span>) above are taken to be equal to <span class="math">\(B\)</span>
(resp.&nbsp;<span class="math">\(D\)</span>).</p>
<div class="highlight-python"><div class="highlight"><pre>? M = [1,2;3,4];
? matsolvemod(M, [3,4]~, [1,2]~)
%2 = [-2, 0]~
? matsolvemod(M, 3, 1) \\ M X = [1,1]~ over F_3
%3 = [-1, 1]~
? matsolvemod(M, [3,0]~, [1,2]~) \\ x + 2y = 1 (mod 3), 3x + 4y = 2 (in Z)
%4 = [6, -4]~
</pre></div>
</div>
<p>If <span class="math">\(flag = 1\)</span>, all solutions are returned in the form of a two-component row
vector <span class="math">\([x,u]\)</span>, where <span class="math">\(x\)</span> is a small integer solution to the system of
congruences and <span class="math">\(u\)</span> is a matrix whose columns give a basis of the homogeneous
system (so that all solutions can be obtained by adding <span class="math">\(x\)</span> to any linear
combination of columns of <span class="math">\(u\)</span>). If no solution exists, returns zero.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matsupplement">
<tt class="descname">matsupplement</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matsupplement" title="Permalink to this definition">¶</a></dt>
<dd><p>Assuming that the columns of the matrix <span class="math">\(x\)</span>
are linearly independent (if they are not, an error message is issued), finds
a square invertible matrix whose first columns are the columns of <span class="math">\(x\)</span>,
i.e.&nbsp;supplement the columns of <span class="math">\(x\)</span> to a basis of the whole space.</p>
<div class="highlight-python"><div class="highlight"><pre>? matsupplement([1;2])
%1 =
[1 0]

[2 1]
</pre></div>
</div>
<p>Raises an error if <span class="math">\(x\)</span> has 0 columns, since (due to a long standing design
bug), the dimension of the ambient space (the number of rows) is unknown in
this case:</p>
<div class="highlight-python"><div class="highlight"><pre>? matsupplement(matrix(2,0))
 *** at top-level: matsupplement(matrix
 *** ^--------------------
 *** matsupplement: sorry, suppl [empty matrix] is not yet implemented.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mattranspose">
<tt class="descname">mattranspose</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mattranspose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose of <span class="math">\(x\)</span> (also <span class="math">\(x~\)</span>).
This has an effect only on vectors and matrices.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.max">
<tt class="descname">max</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the maximum of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> when they can be compared.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.min">
<tt class="descname">min</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the maximum of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> when they can be compared.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.minpoly">
<tt class="descname">minpoly</tt><big>(</big><em>A</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.minpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>minimal polynomial
of <span class="math">\(A\)</span> with respect to the variable <span class="math">\(v\)</span>., i.e. the monic polynomial <span class="math">\(P\)</span>
of minimal degree (in the variable <span class="math">\(v\)</span>) such that <span class="math">\(P(A) = 0\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.modreverse">
<tt class="descname">modreverse</tt><big>(</big><em>z</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.modreverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(z = Mod(A, T)\)</span> be a polmod, and <span class="math">\(Q\)</span> be its minimal
polynomial, which must satisfy <span class="math">\({deg}(Q) = {deg}(T)\)</span>.
Returns a &#8220;reverse polmod&#8221; <tt class="docutils literal"><span class="pre">Mod(B,</span> <span class="pre">Q)</span></tt>, which is a root of <span class="math">\(T\)</span>.</p>
<p>This is quite useful when one changes the generating element in algebraic
extensions:</p>
<div class="highlight-python"><div class="highlight"><pre>? u = Mod(x, x^3 - x -1); v = u^5;
? w = modreverse(v)
%2 = Mod(x^2 - 4*x + 1, x^3 - 5*x^2 + 4*x - 1)
</pre></div>
</div>
<p>which means that <span class="math">\(x^3 - 5x^2 + 4x -1\)</span> is another defining polynomial for the
cubic field</p>
<div class="math">
\[\mathbb{Q}(u) = \mathbb{Q}[x]/(x^3 - x - 1) = \mathbb{Q}[x]/(x^3 - 5x^2 + 4x - 1) = \mathbb{Q}(v),\]</div>
<p>and that <span class="math">\(u \\to v^2 - 4v + 1\)</span> gives an explicit isomorphism. From this, it is
easy to convert elements between the <span class="math">\(A(u) belongs to \mathbb{Q}(u)\)</span> and <span class="math">\(B(v) belongs to \mathbb{Q}(v)\)</span>
representations:</p>
<div class="highlight-python"><div class="highlight"><pre>? A = u^2 + 2*u + 3; subst(lift(A), &#39;x, w)
%3 = Mod(x^2 - 3*x + 3, x^3 - 5*x^2 + 4*x - 1)
? B = v^2 + v + 1; subst(lift(B), &#39;x, v)
%4 = Mod(26*x^2 + 31*x + 26, x^3 - x - 1)
</pre></div>
</div>
<p>If the minimal polynomial of <span class="math">\(z\)</span> has lower degree than expected, the routine
fails</p>
<div class="highlight-python"><div class="highlight"><pre>? u = Mod(-x^3 + 9*x, x^4 - 10*x^2 + 1)
? modreverse(u)
 *** modreverse: domain error in modreverse: deg(minpoly(z)) &lt; 4
 *** Break loop: type &#39;break&#39; to go back to GP prompt
break&gt; Vec( dbg_err() ) \\ ask for more info
[&quot;e_DOMAIN&quot;, &quot;modreverse&quot;, &quot;deg(minpoly(z))&quot;, &quot;&lt;&quot;, 4,
 Mod(-x^3 + 9*x, x^4 - 10*x^2 + 1)]
break&gt; minpoly(u)
x^2 - 8
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.moebius">
<tt class="descname">moebius</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.moebius" title="Permalink to this definition">¶</a></dt>
<dd><p>Moebius <span class="math">\(\mu\)</span>-function of <span class="math">\(\|x\|\)</span>. <span class="math">\(x\)</span> must be of type integer.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msatkinlehner">
<tt class="descname">msatkinlehner</tt><big>(</big><em>M</em>, <em>Q</em>, <em>H=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msatkinlehner" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(M\)</span> be a full modular symbol space of level <span class="math">\(N\)</span>,
as given by <tt class="docutils literal"><span class="pre">msinit</span></tt>, let <span class="math">\(Q \| N\)</span>, <span class="math">\((Q,N/Q) = 1\)</span>,
and let <span class="math">\(H\)</span> be a subspace stable under the Atkin-Lehner involution <span class="math">\(w_Q\)</span>.
Return the matrix of <span class="math">\(w_Q\)</span> acting on <span class="math">\(H\)</span> (<span class="math">\(M\)</span> if omitted).</p>
<div class="highlight-python"><div class="highlight"><pre>? M = msinit(36,2); \\ M_2(Gamma_0(36))
? w = msatkinlehner(M,4); w^2 == 1
%2 = 1
? #w \\ involution acts on a 13-dimensional space
%3 = 13
? M = msinit(36,2, -1); \\ M_2(Gamma_0(36))^-
? w = msatkinlehner(M,4); w^2 == 1
%5 = 1
? #w
%6 = 4
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mscuspidal">
<tt class="descname">mscuspidal</tt><big>(</big><em>M</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mscuspidal" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <tt class="docutils literal"><span class="pre">msinit</span></tt>,
return its cuspidal part <span class="math">\(S\)</span>. If <span class="math">\(flag = 1\)</span>, return
<span class="math">\([S,E]\)</span> its decomposition into cuspidal and Eisenstein parts.</p>
<p>A subspace is given by a structure allowing quick projection and
restriction of linear operators; its first component is
a matrix with integer coefficients whose columns form a <span class="math">\(\mathbb{Q}\)</span>-basis of
the subspace.</p>
<div class="highlight-python"><div class="highlight"><pre>? M = msinit(2,8, 1); \\ M_8(Gamma_0(2))^+
? [S,E] = mscuspidal(M, 1);
? E[1] \\ 2-dimensional
%3 =
[0 -10]

[0 -15]

[0 -3]

[1 0]

? S[1] \\ 1-dimensional
%4 =
[ 3]

[30]

[ 6]

[-8]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mseisenstein">
<tt class="descname">mseisenstein</tt><big>(</big><em>M</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mseisenstein" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <tt class="docutils literal"><span class="pre">msinit</span></tt>,
return its Eisenstein subspace.
A subspace is given by a structure allowing quick projection and
restriction of linear operators; its first component is
a matrix with integer coefficients whose columns form a <span class="math">\(\mathbb{Q}\)</span>-basis of
the subspace.
This is the same basis as given by the second component of
<tt class="docutils literal"><span class="pre">mscuspidal</span></tt><span class="math">\((M, 1)\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? M = msinit(2,8, 1); \\ M_8(Gamma_0(2))^+
? E = mseisenstein(M);
? E[1] \\ 2-dimensional
%3 =
[0 -10]

[0 -15]

[0 -3]

[1 0]

? E == mscuspidal(M,1)[2]
%4 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mseval">
<tt class="descname">mseval</tt><big>(</big><em>M</em>, <em>s</em>, <em>p=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mseval" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(\Delta := {Div}^0(\\P^1 (\mathbb{Q}))\)</span>.
Let <span class="math">\(M\)</span> be a full modular symbol space, as given by <tt class="docutils literal"><span class="pre">msinit</span></tt>,
let <span class="math">\(s\)</span> be a modular symbol from <span class="math">\(M\)</span>, i.e. an element
of <span class="math">\({Hom}_G(\Delta, V)\)</span>, and let <span class="math">\(p = [a,b] belongs to \Delta\)</span> be a path between
two elements in <span class="math">\(\\P^1(\mathbb{Q})\)</span>, return <span class="math">\(s(p) belongs to V\)</span>. The path extremities <span class="math">\(a\)</span> and
<span class="math">\(b\)</span> may be given as <tt class="docutils literal"><span class="pre">t_INT</span></tt>, <tt class="docutils literal"><span class="pre">t_FRAC</span></tt> or <span class="math">\(oo = (1:0)\)</span>.
The symbol <span class="math">\(s\)</span> is either</p>
<ul class="simple">
<li>a <tt class="docutils literal"><span class="pre">t_COL</span></tt> coding an element of a modular symbol subspace in terms of
the fixed basis of <span class="math">\({Hom}_G(\Delta,V)\)</span> chosen in <span class="math">\(M\)</span>;</li>
<li>a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> <span class="math">\((v_i)\)</span> of elements of <span class="math">\(V\)</span>, where the <span class="math">\(v_i = s(g_i)\)</span> give
the image of the generators <span class="math">\(g_i\)</span> of <span class="math">\(\Delta\)</span>, see <tt class="docutils literal"><span class="pre">mspathgens</span></tt>.
We assume that <span class="math">\(s\)</span> is a proper symbol, i.e.&nbsp;that the <span class="math">\(v_i\)</span> satisfy
the <tt class="docutils literal"><span class="pre">mspathgens</span></tt> relations.</li>
</ul>
<p>If <span class="math">\(p\)</span> is omitted, convert the symbol <span class="math">\(s\)</span> to the second form: a vector of
the <span class="math">\(s(g_i)\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? M = msinit(2,8,1); \\ M_8(Gamma_0(2))^+
? g = mspathgens(M)[1]
%2 = [[+oo, 0], [0, 1]]
? N = msnew(M)[1]; \\ Q-basis of new subspace
? s = N[,1] \\ t_COL representation
%4 = [3, 30, 6, -8]~
? S = mseval(M, s) \\ t_VEC representation
%5 = [64*x^6-272*x^4+136*x^2-8, 384*x^5+960*x^4+192*x^3-672*x^2-432*x-72]
? mseval(M,s, g[1])
%6 = 64*x^6 - 272*x^4 + 136*x^2 - 8
? mseval(M,S, g[1])
%6 = 64*x^6 - 272*x^4 + 136*x^2 - 8
</pre></div>
</div>
<p>Note that the symbol should have values in
<span class="math">\(V = \mathbb{Q}[x,y]_{k-2}\)</span>, we return the de-homogenized values corresponding to <span class="math">\(y
= 1\)</span> instead.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msfromell">
<tt class="descname">msfromell</tt><big>(</big><em>E</em>, <em>sign=1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msfromell" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(E/\mathbb{Q}\)</span> be an elliptic curve of conductor <span class="math">\(N\)</span>. Return the (cuspidal,
new) modular symbol <span class="math">\(x^+\)</span> in <span class="math">\(H^1_c(X_0(N),\mathbb{Q})^+\)</span> (resp.&nbsp;<span class="math">\(x^-\)</span> in
<span class="math">\(H^1_c(X_0(N),\mathbb{Q})^-\)</span> if <span class="math">\(sign = -1\)</span>) associated to
<span class="math">\(E\)</span>. For all primes <span class="math">\(p\)</span> not dividing <span class="math">\(N\)</span> we have
<span class="math">\(T_p(x^±) = a_p x^±\)</span>, where <span class="math">\(a_p = p+1-\#E(\mathbb{F}_p)\)</span>.
This defines a unique symbol up to multiplication by a constant
and we normalize it so that the associated <span class="math">\(p\)</span>-adic measure yields the
<span class="math">\(p\)</span>-adic <span class="math">\(L\)</span>-function. Namely, we have</p>
<div class="math">
\[x^{±}([0]-[ oo ]) = L(E,1) / \Omega,\]</div>
<p>for <span class="math">\(\Omega\)</span> the real period of <span class="math">\(E\)</span> (which fixes <span class="math">\(x^{±}\)</span> unless <span class="math">\(L(E,1) = 0\)</span>).
Furthermore, for all odd fundamental discriminants <span class="math">\(d\)</span> coprime to <span class="math">\(N\)</span> such
that <span class="math">\(sign.d &gt; 0\)</span> and <span class="math">\(L(E^{(d)},1) != 0\)</span>, we also have</p>
<div class="math">
\[\begin{split}\sum_{0 &lt;= a &lt; \|d\|} (d\|a) x^{±}([a/\|d\|]-[ oo ])
= L(E^{(d)},1) / \Omega_d,\end{split}\]</div>
<p>where <span class="math">\((d\|a)\)</span> is the Kronecker symbol and <span class="math">\(\Omega_d\)</span> is the real
period of the twist <span class="math">\(E^{(d)}\)</span>.</p>
<p>This function returns the pair <span class="math">\([M, x]\)</span>, where <span class="math">\(M\)</span> is
<tt class="docutils literal"><span class="pre">msinit</span></tt><span class="math">\((N,2)\)</span> and <span class="math">\(x\)</span> is <span class="math">\(x^±\)</span> as a <tt class="docutils literal"><span class="pre">t_COL</span></tt> (in terms
of the fixed basis of <span class="math">\({Hom}_G(\Delta,\mathbb{Q})\)</span> chosen in <span class="math">\(M\)</span>).</p>
<div class="highlight-python"><div class="highlight"><pre>? E=ellinit([0,-1,1,-10,-20]); \\ X_0(11)
? [M,xpm]= msfromell(E,1);
? xpm
%3 = [1/5, -1/2, -1/2]~
? p = 101; (mshecke(M,p) - ellap(E,p))*xpm
%4 = [0, 0, 0]~ \\ true at all primes
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mshecke">
<tt class="descname">mshecke</tt><big>(</big><em>M</em>, <em>p</em>, <em>H=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mshecke" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <tt class="docutils literal"><span class="pre">msinit</span></tt>,
<span class="math">\(p\)</span> being a prime number, and <span class="math">\(H\)</span> being a Hecke-stable subspace (<span class="math">\(M\)</span> if
omitted) return the matrix of <span class="math">\(T_p\)</span> acting on <span class="math">\(H\)</span>
(<span class="math">\(U_p\)</span> if <span class="math">\(p\)</span> divides <span class="math">\(N\)</span>). Result is undefined if <span class="math">\(H\)</span> is not stable
by <span class="math">\(T_p\)</span> (resp.&nbsp;<span class="math">\(U_p\)</span>).</p>
<div class="highlight-python"><div class="highlight"><pre>? M = msinit(11,2); \\ M_2(Gamma_0(11))
? T2 = mshecke(M,2)
%2 =
[3 0 0]

[1 -2 0]

[1 0 -2]
? M = msinit(11,2, 1); \\ M_2(Gamma_0(11))^+
? T2 = mshecke(M,2)
%4 =
[ 3 0]

[-1 -2]

? N = msnew(M)[1]; \\ Q-basis of new cuspidal subspace
%5 =
[ 0]

[-1]

[-1]
? p = 1009; mshecke(M, p, N) \\ action of T_1009 on N
%6 =
[-10]
? ellap(ellinit(&quot;11a1&quot;), p)
%7 = -10
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msinit">
<tt class="descname">msinit</tt><big>(</big><em>G</em>, <em>V</em>, <em>sign=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <span class="math">\(G\)</span> a finite index subgroup of <span class="math">\({SL}(2,\mathbb{Z})\)</span>
and a finite dimensional representation <span class="math">\(V\)</span> of <span class="math">\({GL}(2,\mathbb{Q})\)</span>, creates a
space of modular symbols, the <span class="math">\(G\)</span>-module <span class="math">\({Hom}_G({Div}^0(\\P^1
(\mathbb{Q})), V)\)</span>. This is canonically isomorphic to <span class="math">\(H^1_c(X(G), V)\)</span>, and allows to
compute modular forms for <span class="math">\(G\)</span>. If <em>sign</em> is present and non-zero, it
must be <span class="math">\(±1\)</span> and we consider the subspace defined by <span class="math">\({Ker} (\sigma -
sign)\)</span>, where <span class="math">\(\sigma\)</span> is induced by <tt class="docutils literal"><span class="pre">[-1,0;0,1]</span></tt>. Currently the
only supported groups are the <span class="math">\(\Gamma_0(N)\)</span>, coded by the integer <span class="math">\(N &gt; 1\)</span>.
The only supported representation is <span class="math">\(V_k = \mathbb{Q}[X,Y]_{k-2}\)</span>, coded by the
integer <span class="math">\(k &gt;= 2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msissymbol">
<tt class="descname">msissymbol</tt><big>(</big><em>M</em>, <em>s</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msissymbol" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <tt class="docutils literal"><span class="pre">msinit</span></tt>,
check whether <span class="math">\(s\)</span> is a modular symbol associated to <span class="math">\(M\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? M = msinit(7,8, 1); \\ M_8(Gamma_0(7))^+
? N = msnew(M)[1];
? s = N[,1];
? msissymbol(M, s)
%4 = 1
? S = mseval(M,s);
? msissymbol(M, S)
%6 = 1
? [g,R] = mspathgens(M); g
%7 = [[+oo, 0], [0, 1/2], [1/2, 1]]
? #R \\ 3 relations among the generators g_i
%8 = 3
? T = S; T[3]++; \\ randomly perturb S(g_3)
? msissymbol(M, T)
%10 = 0 \\ no longer satisfies the relations
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msnew">
<tt class="descname">msnew</tt><big>(</big><em>M</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msnew" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <tt class="docutils literal"><span class="pre">msinit</span></tt>,
return the <em>new</em> part of its cuspidal subspace. A subspace is given by
a structure allowing quick projection and restriction of linear operators;
its first component is a matrix with integer coefficients whose columns form
a <span class="math">\(\mathbb{Q}\)</span>-basis of the subspace.</p>
<div class="highlight-python"><div class="highlight"><pre>? M = msinit(11,8, 1); \\ M_8(Gamma_0(11))^+
? N = msnew(M);
? #N[1] \\ 6-dimensional
%3 = 6
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mspathgens">
<tt class="descname">mspathgens</tt><big>(</big><em>M</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mspathgens" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(\Delta := {Div}^0(\\P^1(\mathbb{Q}))\)</span>.
Let <span class="math">\(M\)</span> being a full modular symbol space, as given by <tt class="docutils literal"><span class="pre">msinit</span></tt>,
return a set of <span class="math">\(\mathbb{Z}[G]\)</span>-generators for <span class="math">\(\Delta\)</span>. The output
is <span class="math">\([g,R]\)</span>, where <span class="math">\(g\)</span> is a minimal system of generators and <span class="math">\(R\)</span>
the vector of <span class="math">\(\mathbb{Z}[G]\)</span>-relations between the given generators. A
relation is coded by a vector of pairs <span class="math">\([a_i,i]\)</span> with <span class="math">\(a_i belongs to \mathbb{Z}[G]\)</span>
and <span class="math">\(i\)</span> the index of a generator, so that <span class="math">\(\sum_i a_i g[i] = 0\)</span>.</p>
<p>An element <span class="math">\([v]-[u]\)</span> in <span class="math">\(\Delta\)</span> is coded by the &#8220;path&#8221; <span class="math">\([u,v]\)</span>,
where <tt class="docutils literal"><span class="pre">oo</span></tt> denotes the point at infinity <span class="math">\((1:0)\)</span> on the projective
line.
An element of <span class="math">\(\mathbb{Z}[G]\)</span> is coded by a &#8220;factorization matrix&#8221;: the first
column contains distinct elements of <span class="math">\(G\)</span>, and the second integers:</p>
<div class="highlight-python"><div class="highlight"><pre>? M = msinit(11,8); \\ M_8(Gamma_0(11))
? [g,R] = mspathgens(M);
? g
%3 = [[+oo, 0], [0, 1/3], [1/3, 1/2]] \\ 3 paths
? #R \\ a single relation
%4 = 1
? r = R[1]; #r \\ ...involving all 3 generators
%5 = 3
? r[1]
%6 = [[1, 1; [1, 1; 0, 1], -1], 1]
? r[2]
%7 = [[1, 1; [7, -2; 11, -3], -1], 2]
? r[3]
%8 = [[1, 1; [8, -3; 11, -4], -1], 3]
</pre></div>
</div>
<p>The given relation is of the form <span class="math">\(\sum_i (1-\gamma_i) g_i = 0\)</span>, with
<span class="math">\(\gamma_i belongs to \Gamma_0(11)\)</span>. There will always be a single relation involving
all generators (corresponding to a round trip along all cusps), then
relations involving a single generator (corresponding to <span class="math">\(2\)</span> and <span class="math">\(3\)</span>-torsion
elements in the group:</p>
<div class="highlight-python"><div class="highlight"><pre>? M = msinit(2,8); \\ M_8(Gamma_0(2))
? [g,R] = mspathgens(M);
? g
%3 = [[+oo, 0], [0, 1]]
</pre></div>
</div>
<p>Note that the output depends only on the group <span class="math">\(G\)</span>, not on the
representation <span class="math">\(V\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mspathlog">
<tt class="descname">mspathlog</tt><big>(</big><em>M</em>, <em>p</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mspathlog" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(\Delta := {Div}^0(\\P^1(\mathbb{Q}))\)</span>.
Let <span class="math">\(M\)</span> being a full modular symbol space, as given by <tt class="docutils literal"><span class="pre">msinit</span></tt>,
encoding fixed <span class="math">\(\mathbb{Z}[G]\)</span>-generators <span class="math">\((g_i)\)</span> of <span class="math">\(\Delta\)</span> (see <tt class="docutils literal"><span class="pre">mspathgens</span></tt>).
A path <span class="math">\(p = [a,b]\)</span> between two elements in <span class="math">\(\\P^1(\mathbb{Q})\)</span> corresponds to
<span class="math">\([b]-[a] belongs to \Delta\)</span>. The path extremities <span class="math">\(a\)</span> and <span class="math">\(b\)</span> may be given as
<tt class="docutils literal"><span class="pre">t_INT</span></tt>, <tt class="docutils literal"><span class="pre">t_FRAC</span></tt> or <span class="math">\(oo = (1:0)\)</span>.</p>
<p>Returns <span class="math">\((p_i)\)</span> in <span class="math">\(\mathbb{Z}[G]\)</span> such that <span class="math">\(p = \sum_i p_i g_i\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? M = msinit(2,8); \\ M_8(Gamma_0(2))
? [g,R] = mspathgens(M);
? g
%3 = [[+oo, 0], [0, 1]]
? p = mspathlog(M, [1/2,2/3]);
? p[1]
%6 =
[[1, 0; 2, 1] 1]

? p[2]
%7 =
[ [1, 0; 0, 1] 1]

[[3, -1; 4, -1] 1]
</pre></div>
</div>
<p>Note that the output depends only on the group <span class="math">\(G\)</span>, not on the
representation <span class="math">\(V\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msqexpansion">
<tt class="descname">msqexpansion</tt><big>(</big><em>M</em>, <em>projH</em>, <em>serprec=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msqexpansion" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <tt class="docutils literal"><span class="pre">msinit</span></tt>,
and <em>projH</em> being a projector on a Hecke-simple subspace (as given
by <tt class="docutils literal"><span class="pre">mssplit</span></tt>), return the Fourier coefficients <span class="math">\(a_n\)</span>, <span class="math">\(n &lt;= B\)</span> of the
corresponding normalized newform. If <span class="math">\(B\)</span> is omitted, use
<tt class="docutils literal"><span class="pre">seriesprecision</span></tt>.</p>
<p>This function uses a naive <span class="math">\(O(B^2 d^3)\)</span>
algorithm, where <span class="math">\(d = O(kN)\)</span> is the dimension of <span class="math">\(M_k(\Gamma_0(N))\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? M = msinit(11,2, 1); \\ M_2(Gamma_0(11))^+
? L = mssplit(M, msnew(M));
? msqexpansion(M,L[1], 20)
%3 = [1, -2, -1, 2, 1, 2, -2, 0, -2, -2, 1, -2, 4, 4, -1, -4, -2, 4, 0, 2]
? ellan(ellinit(&quot;11a1&quot;), 20)
%4 = [1, -2, -1, 2, 1, 2, -2, 0, -2, -2, 1, -2, 4, 4, -1, -4, -2, 4, 0, 2]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mssplit">
<tt class="descname">mssplit</tt><big>(</big><em>M</em>, <em>H</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mssplit" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <tt class="docutils literal"><span class="pre">msinit</span></tt><span class="math">\((N,k,1)\)</span>
or <span class="math">\(msinit(N,k,-1)\)</span>
and <span class="math">\(H\)</span> being a Hecke-stable subspace of <tt class="docutils literal"><span class="pre">msnew</span></tt><span class="math">\((M)\)</span>, split <span class="math">\(H\)</span> into
Hecke-simple subspaces.
A subspace is given by a structure allowing quick projection and restriction
of linear operators; its first component is a matrix with integer
coefficients whose columns form a <span class="math">\(\mathbb{Q}\)</span>-basis of the subspace.</p>
<div class="highlight-python"><div class="highlight"><pre>? M = msinit(11,8, 1); \\ M_8(Gamma_0(11))^+
? L = mssplit(M, msnew(M));
? #L
%3 = 2
? f = msqexpansion(M,L[1],5); f[1].mod
%4 = x^2 + 8*x - 44
? lift(f)
%5 = [1, x, -6*x - 27, -8*x - 84, 20*x - 155]
? g = msqexpansion(M,L[2],5); g[1].mod
%6 = x^4 - 558*x^2 + 140*x + 51744
</pre></div>
</div>
<p>To a Hecke-simple subspace corresponds an orbit of
(normalized) newforms, defined over a number field. In the above example,
we printed the polynomials defining the said fields, as well as the first
5 Fourier coefficients (at the infinite cusp) of one such form.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msstar">
<tt class="descname">msstar</tt><big>(</big><em>M</em>, <em>H=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msstar" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <tt class="docutils literal"><span class="pre">msinit</span></tt>,
return the matrix of the <tt class="docutils literal"><span class="pre">*</span></tt> involution, induced by complex conjugation,
acting on the (stable) subspace <span class="math">\(H\)</span> (<span class="math">\(M\)</span> if omitted).</p>
<div class="highlight-python"><div class="highlight"><pre>? M = msinit(11,2); \\ M_2(Gamma_0(11))
? w = msstar(M);
? w^2 == 1
%3 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.newtonpoly">
<tt class="descname">newtonpoly</tt><big>(</big><em>x</em>, <em>p</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.newtonpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the vector of the slopes of the Newton
polygon of the polynomial <span class="math">\(x\)</span> with respect to the prime number <span class="math">\(p\)</span>. The <span class="math">\(n\)</span>
components of the vector are in decreasing order, where <span class="math">\(n\)</span> is equal to the
degree of <span class="math">\(x\)</span>. Vertical slopes occur iff the constant coefficient of <span class="math">\(x\)</span> is
zero and are denoted by <tt class="docutils literal"><span class="pre">LONG_MAX</span></tt>, the biggest single precision
integer representable on the machine (<span class="math">\(2^{31}-1\)</span> (resp.&nbsp;<span class="math">\(2^{63}-1\)</span>) on 32-bit
(resp.&nbsp;64-bit) machines), see <tt class="docutils literal"><span class="pre">valuation</span></tt> (in the PARI manual).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nextprime">
<tt class="descname">nextprime</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nextprime" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the smallest pseudoprime (see
<tt class="docutils literal"><span class="pre">ispseudoprime</span></tt>) greater than or equal to <span class="math">\(x\)</span>. <span class="math">\(x\)</span> can be of any real
type. Note that if <span class="math">\(x\)</span> is a pseudoprime, this function returns <span class="math">\(x\)</span> and not
the smallest pseudoprime strictly larger than <span class="math">\(x\)</span>. To rigorously prove that
the result is prime, use <tt class="docutils literal"><span class="pre">isprime</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfalgtobasis">
<tt class="descname">nfalgtobasis</tt><big>(</big><em>nf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfalgtobasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an algebraic number <span class="math">\(x\)</span> in the number field <span class="math">\(nf\)</span>,
transforms it to a column vector on the integral basis <tt class="docutils literal"><span class="pre">:emphasis:`nf</span></tt>.zk`.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2 + 4);
? nf.zk
%2 = [1, 1/2*y]
? nfalgtobasis(nf, [1,1]~)
%3 = [1, 1]~
? nfalgtobasis(nf, y)
%4 = [0, 2]~
? nfalgtobasis(nf, Mod(y, y^2+4))
%4 = [0, 2]~
</pre></div>
</div>
<p>This is the inverse function of <tt class="docutils literal"><span class="pre">nfbasistoalg</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfbasistoalg">
<tt class="descname">nfbasistoalg</tt><big>(</big><em>nf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfbasistoalg" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an algebraic number <span class="math">\(x\)</span> in the number field <tt class="docutils literal"><span class="pre">nf</span></tt>, transforms it
into <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> form.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2 + 4);
? nf.zk
%2 = [1, 1/2*y]
? nfbasistoalg(nf, [1,1]~)
%3 = Mod(1/2*y + 1, y^2 + 4)
? nfbasistoalg(nf, y)
%4 = Mod(y, y^2 + 4)
? nfbasistoalg(nf, Mod(y, y^2+4))
%4 = Mod(y, y^2 + 4)
</pre></div>
</div>
<p>This is the inverse function of <tt class="docutils literal"><span class="pre">nfalgtobasis</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfcertify">
<tt class="descname">nfcertify</tt><big>(</big><em>nf</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfcertify" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(nf\)</span> being as output by
<tt class="docutils literal"><span class="pre">nfinit</span></tt>, checks whether the integer basis is known unconditionally.
This is in particular useful when the argument to <tt class="docutils literal"><span class="pre">nfinit</span></tt> was of the
form <span class="math">\([T, listP]\)</span>, specifying a finite list of primes when
<span class="math">\(p\)</span>-maximality had to be proven.</p>
<p>The function returns a vector of composite integers. If this vector is
empty, then <tt class="docutils literal"><span class="pre">nf.zk</span></tt> and <tt class="docutils literal"><span class="pre">nf.disc</span></tt> are correct. Otherwise, the
result is dubious. In order to obtain a certified result, one must
completely factor each of the given integers, then <tt class="docutils literal"><span class="pre">addprime</span></tt> each of
them, then check whether <tt class="docutils literal"><span class="pre">nfdisc(nf.pol)</span></tt> is equal to <tt class="docutils literal"><span class="pre">nf.disc</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfcompositum">
<tt class="descname">nfcompositum</tt><big>(</big><em>nf</em>, <em>P</em>, <em>Q</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfcompositum" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <em>nf</em> be a number field structure associated to the field <span class="math">\(K\)</span>
and let <span class="math">\(P\)</span> and <span class="math">\(Q\)</span>
be squarefree polynomials in <span class="math">\(K[X]\)</span> in the same variable. Outputs
the simple factors of the étale <span class="math">\(K\)</span>-algebra <span class="math">\(A = K(X, Y) / (P(X), Q(Y))\)</span>.
The factors are given by a list of polynomials <span class="math">\(R\)</span> in <span class="math">\(K[X]\)</span>, associated to
the number field <span class="math">\(K(X)/ (R)\)</span>, and sorted by increasing degree (with respect
to lexicographic ordering for factors of equal degrees). Returns an error if
one of the polynomials is not squarefree.</p>
<p>Note that it is more efficient to reduce to the case where <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are
irreducible first. The routine will not perform this for you, since it may be
expensive, and the inputs are irreducible in most applications anyway. In
this case, there will be a single factor <span class="math">\(R\)</span> if and only if the number
fields defined by <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are linearly disjoint (their intersection is
<span class="math">\(K\)</span>).</p>
<p>The binary digits of <span class="math">\(flag\)</span> mean</p>
<p>1: outputs a vector of 4-component vectors <span class="math">\([R,a,b,k]\)</span>, where <span class="math">\(R\)</span>
ranges through the list of all possible compositums as above, and <span class="math">\(a\)</span>
(resp. <span class="math">\(b\)</span>) expresses the root of <span class="math">\(P\)</span> (resp. <span class="math">\(Q\)</span>) as an element of
<span class="math">\(K(X)/(R)\)</span>. Finally, <span class="math">\(k\)</span> is a small integer such that <span class="math">\(b + ka = X\)</span> modulo
<span class="math">\(R\)</span>.</p>
<p>2: assume that <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> define number fields which are linearly disjoint:
both polynomials are irreducible and the corresponding number fields
have no common subfield besides <span class="math">\(K\)</span>. This allows to save a costly
factorization over <span class="math">\(K\)</span>. In this case return the single simple factor
instead of a vector with one element.</p>
<p>A compositum is often defined by a complicated polynomial, which it is
advisable to reduce before further work. Here is an example involving
the field <span class="math">\(K(\zeta_5, 5^{1/5})\)</span>, <span class="math">\(K = \mathbb{Q}(\sqrt{5})\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(y^2-5);
? L = nfcompositum(K, x^5 - y, polcyclo(5), 1); \\ list of [R,a,b,k]
? [R, a] = L[1]; \\ pick the single factor, extract R,a (ignore b,k)
? lift(R) \\ defines the compositum
%3 = x^10 + (-5/2*y + 5/2)*x^9 + (-5*y + 20)*x^8 + (-20*y + 30)*x^7 + \
(-45/2*y + 145/2)*x^6 + (-71/2*y + 121/2)*x^5 + (-20*y + 60)*x^4 + \
(-25*y + 5)*x^3 + 45*x^2 + (-5*y + 15)*x + (-2*y + 6)
? a^5 - y \\ a fifth root of y
%4 = 0
? [T, X] = rnfpolredbest(K, R, 1);
? lift(T) \\ simpler defining polynomial for K[x]/(R)
%6 = x^10 + (-11/2*y + 25/2)
? liftall(X) \\  root of R in K[x]/(T(x))
%7 = (3/4*y + 7/4)*x^7 + (-1/2*y - 1)*x^5 + 1/2*x^2 + (1/4*y - 1/4)
? a = subst(a.pol, &#39;x, X); \\ a in the new coordinates
? liftall(a)
%8 = (-3/4*y - 7/4)*x^7 - 1/2*x^2
? a^5 - y
%9 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfdetint">
<tt class="descname">nfdetint</tt><big>(</big><em>nf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfdetint" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a pseudo-matrix <span class="math">\(x\)</span>, computes a
non-zero ideal contained in (i.e.&nbsp;multiple of) the determinant of <span class="math">\(x\)</span>. This
is particularly useful in conjunction with <tt class="docutils literal"><span class="pre">nfhnfmod</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfdisc">
<tt class="descname">nfdisc</tt><big>(</big><em>T</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfdisc" title="Permalink to this definition">¶</a></dt>
<dd><p>field discriminant of the number field defined by the integral,
preferably monic, irreducible polynomial <span class="math">\(T(X)\)</span>. Returns the discriminant of
the number field <span class="math">\(\mathbb{Q}[X]/(T)\)</span>, using the Round <span class="math">\(4\)</span> algorithm.</p>
<p><strong>Local discriminants, valuations at certain primes.</strong></p>
<p>As in <tt class="docutils literal"><span class="pre">nfbasis</span></tt>, the argument <span class="math">\(T\)</span> can be replaced by <span class="math">\([T,listP]\)</span>,
where <tt class="docutils literal"><span class="pre">listP</span></tt> is as in <tt class="docutils literal"><span class="pre">nfbasis</span></tt>: a vector of
pairwise coprime integers (usually distinct primes), a factorization matrix,
or a single integer. In that case, the function returns the discriminant of
an order whose basis is given by <tt class="docutils literal"><span class="pre">nfbasis(T,listP)</span></tt>, which need not be
the maximal order, and whose valuation at a prime entry in <tt class="docutils literal"><span class="pre">listP</span></tt> is the
same as the valuation of the field discriminant.</p>
<p>In particular, if <tt class="docutils literal"><span class="pre">listP</span></tt> is <span class="math">\([p]\)</span> for a prime <span class="math">\(p\)</span>, we can
return the <span class="math">\(p\)</span>-adic discriminant of the maximal order of <span class="math">\(\mathbb{Z}_p[X]/(T)\)</span>,
as a power of <span class="math">\(p\)</span>, as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>? padicdisc(T,p) = p^valuation(nfdisc(T,[p]), p);
? nfdisc(x^2 + 6)
%1 = -24
? padicdisc(x^2 + 6, 2)
%2 = 8
? padicdisc(x^2 + 6, 3)
%3 = 3
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltadd">
<tt class="descname">nfeltadd</tt><big>(</big><em>nf</em>, <em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltadd" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in
<em>nf</em>, computes their sum <span class="math">\(x+y\)</span> in the number field <span class="math">\(nf\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltdiv">
<tt class="descname">nfeltdiv</tt><big>(</big><em>nf</em>, <em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in
<em>nf</em>, computes their quotient <span class="math">\(x/y\)</span> in the number field <span class="math">\(nf\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltdiveuc">
<tt class="descname">nfeltdiveuc</tt><big>(</big><em>nf</em>, <em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltdiveuc" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in
<em>nf</em>, computes an algebraic integer <span class="math">\(q\)</span> in the number field <span class="math">\(nf\)</span>
such that the components of <span class="math">\(x-qy\)</span> are reasonably small. In fact, this is
functionally identical to <tt class="docutils literal"><span class="pre">round(nfdiv(:emphasis:`nf</span></tt>,x,y))`.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltdivmodpr">
<tt class="descname">nfeltdivmodpr</tt><big>(</big><em>nf</em>, <em>x</em>, <em>y</em>, <em>pr</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltdivmodpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span>
and <span class="math">\(y\)</span> in <em>nf</em> and <em>pr</em> a prime ideal in <tt class="docutils literal"><span class="pre">modpr</span></tt> format (see
<tt class="docutils literal"><span class="pre">nfmodprinit</span></tt>), computes their quotient <span class="math">\(x / y\)</span> modulo the prime ideal
<em>pr</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltdivrem">
<tt class="descname">nfeltdivrem</tt><big>(</big><em>nf</em>, <em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltdivrem" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in
<em>nf</em>, gives a two-element row vector <span class="math">\([q,r]\)</span> such that <span class="math">\(x = qy+r\)</span>, <span class="math">\(q\)</span> is
an algebraic integer in <span class="math">\(nf\)</span>, and the components of <span class="math">\(r\)</span> are
reasonably small.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltmod">
<tt class="descname">nfeltmod</tt><big>(</big><em>nf</em>, <em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in
<em>nf</em>, computes an element <span class="math">\(r\)</span> of <span class="math">\(nf\)</span> of the form <span class="math">\(r = x-qy\)</span> with
<span class="math">\(q\)</span> and algebraic integer, and such that <span class="math">\(r\)</span> is small. This is functionally
identical to</p>
<div class="math">
\[x - nfmul(nf,round(nfdiv(nf,x,y)),y).\]</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltmul">
<tt class="descname">nfeltmul</tt><big>(</big><em>nf</em>, <em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in
<em>nf</em>, computes their product <span class="math">\(x*y\)</span> in the number field <span class="math">\(nf\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltmulmodpr">
<tt class="descname">nfeltmulmodpr</tt><big>(</big><em>nf</em>, <em>x</em>, <em>y</em>, <em>pr</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltmulmodpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and
<span class="math">\(y\)</span> in <em>nf</em> and <em>pr</em> a prime ideal in <tt class="docutils literal"><span class="pre">modpr</span></tt> format (see
<tt class="docutils literal"><span class="pre">nfmodprinit</span></tt>), computes their product <span class="math">\(x*y\)</span> modulo the prime ideal
<em>pr</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltnorm">
<tt class="descname">nfeltnorm</tt><big>(</big><em>nf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the absolute norm of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltpow">
<tt class="descname">nfeltpow</tt><big>(</big><em>nf</em>, <em>x</em>, <em>k</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(x\)</span> in <em>nf</em>, and a positive or negative integer <span class="math">\(k\)</span>,
computes <span class="math">\(x^k\)</span> in the number field <span class="math">\(nf\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltpowmodpr">
<tt class="descname">nfeltpowmodpr</tt><big>(</big><em>nf</em>, <em>x</em>, <em>k</em>, <em>pr</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltpowmodpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(x\)</span> in <em>nf</em>, an integer <span class="math">\(k\)</span> and a prime ideal
<em>pr</em> in <tt class="docutils literal"><span class="pre">modpr</span></tt> format
(see <tt class="docutils literal"><span class="pre">nfmodprinit</span></tt>), computes <span class="math">\(x^k\)</span> modulo the prime ideal <em>pr</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltreduce">
<tt class="descname">nfeltreduce</tt><big>(</big><em>nf</em>, <em>a</em>, <em>id</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltreduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an ideal <em>id</em> in
Hermite normal form and an element <span class="math">\(a\)</span> of the number field <span class="math">\(nf\)</span>,
finds an element <span class="math">\(r\)</span> in <span class="math">\(nf\)</span> such that <span class="math">\(a-r\)</span> belongs to the ideal
and <span class="math">\(r\)</span> is small.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltreducemodpr">
<tt class="descname">nfeltreducemodpr</tt><big>(</big><em>nf</em>, <em>x</em>, <em>pr</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltreducemodpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(x\)</span> of the number field <span class="math">\(nf\)</span> and a prime ideal
<em>pr</em> in <tt class="docutils literal"><span class="pre">modpr</span></tt> format compute a canonical representative for the
class of <span class="math">\(x\)</span> modulo <em>pr</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfelttrace">
<tt class="descname">nfelttrace</tt><big>(</big><em>nf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfelttrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the absolute trace of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nffactor">
<tt class="descname">nffactor</tt><big>(</big><em>nf</em>, <em>T</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nffactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Factorization of the univariate
polynomial <span class="math">\(T\)</span> over the number field <span class="math">\(nf\)</span> given by <tt class="docutils literal"><span class="pre">nfinit</span></tt>; <span class="math">\(T\)</span>
has coefficients in <span class="math">\(nf\)</span> (i.e.&nbsp;either scalar, polmod, polynomial or
column vector). The factors are sorted by increasing degree.</p>
<p>The main variable of <span class="math">\(nf\)</span> must be of <em>lower</em>
priority than that of <span class="math">\(T\)</span>, see <tt class="docutils literal"><span class="pre">priority</span></tt> (in the PARI manual). However if
the polynomial defining the number field occurs explicitly in the
coefficients of <span class="math">\(T\)</span> as modulus of a <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> or as a <tt class="docutils literal"><span class="pre">t_POL</span></tt>
coefficient, its main variable must be <em>the same</em> as the main variable
of <span class="math">\(T\)</span>. For example,</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2 + 1);
? nffactor(nf, x^2 + y); \\ OK
? nffactor(nf, x^2 + Mod(y, y^2+1)); \\  OK
? nffactor(nf, x^2 + Mod(z, z^2+1)); \\  WRONG
</pre></div>
</div>
<p>It is possible to input a defining polynomial for <em>nf</em>
instead, but this is in general less efficient since parts of an <tt class="docutils literal"><span class="pre">nf</span></tt>
structure will then be computed internally. This is useful in two
situations: when you do not need the <tt class="docutils literal"><span class="pre">nf</span></tt> elsewhere, or when you cannot
compute the field discriminant due to integer factorization difficulties. In
the latter case, if you must use a partial discriminant factorization (as
allowed by both <tt class="docutils literal"><span class="pre">nfdisc</span></tt> or <tt class="docutils literal"><span class="pre">nfbasis</span></tt>) to build a partially correct
<em>nf</em> structure, always input <tt class="docutils literal"><span class="pre">nf.pol</span></tt> to <tt class="docutils literal"><span class="pre">nffactor</span></tt>, and not your
makeshift <em>nf</em>: otherwise factors could be missed.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nffactorback">
<tt class="descname">nffactorback</tt><big>(</big><em>nf</em>, <em>f</em>, <em>e=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nffactorback" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives back the <tt class="docutils literal"><span class="pre">nf</span></tt> element corresponding to a factorization.
The integer <span class="math">\(1\)</span> corresponds to the empty factorization.</p>
<p>If <span class="math">\(e\)</span> is present, <span class="math">\(e\)</span> and <span class="math">\(f\)</span> must be vectors of the same length (<span class="math">\(e\)</span> being
integral), and the corresponding factorization is the product of the
<span class="math">\(f[i]^{e[i]}\)</span>.</p>
<p>If not, and <span class="math">\(f\)</span> is vector, it is understood as in the preceding case with <span class="math">\(e\)</span>
a vector of 1s: we return the product of the <span class="math">\(f[i]\)</span>. Finally, <span class="math">\(f\)</span> can be a
regular factorization matrix.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2+1);
? nffactorback(nf, [3, y+1, [1,2]~], [1, 2, 3])
%2 = [12, -66]~
? 3 * (I+1)^2 * (1+2*I)^3
%3 = 12 - 66*I
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nffactormod">
<tt class="descname">nffactormod</tt><big>(</big><em>nf</em>, <em>Q</em>, <em>pr</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nffactormod" title="Permalink to this definition">¶</a></dt>
<dd><p>Factors the univariate polynomial <span class="math">\(Q\)</span> modulo the prime ideal <em>pr</em> in
the number field <span class="math">\(nf\)</span>. The coefficients of <span class="math">\(Q\)</span> belong to the number
field (scalar, polmod, polynomial, even column vector) and the main variable
of <span class="math">\(nf\)</span> must be of lower priority than that of <span class="math">\(Q\)</span> (see
<tt class="docutils literal"><span class="pre">priority</span></tt> (in the PARI manual)). The prime ideal <em>pr</em> is either in
<tt class="docutils literal"><span class="pre">idealprimedec</span></tt> or (preferred) <tt class="docutils literal"><span class="pre">modprinit</span></tt> format. The coefficients
of the polynomial factors are lifted to elements of <em>nf</em>:</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(y^2+1);
? P = idealprimedec(K, 3)[1];
? nffactormod(K, x^2 + y*x + 18*y+1, P)
%3 =
[x + (2*y + 1) 1]

[x + (2*y + 2) 1]
? P = nfmodprinit(K, P); \\ convert to nfmodprinit format
? nffactormod(K, x^2 + y*x + 18*y+1)
[x + (2*y + 1) 1]

[x + (2*y + 2) 1]
</pre></div>
</div>
<p>Same result, of course, here about 10% faster due to the
precomputation.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfgaloisapply">
<tt class="descname">nfgaloisapply</tt><big>(</big><em>nf</em>, <em>aut</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfgaloisapply" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(nf\)</span> be a
number field as output by <tt class="docutils literal"><span class="pre">nfinit</span></tt>, and let <em>aut</em> be a Galois
automorphism of <span class="math">\(nf\)</span> expressed by its image on the field generator
(such automorphisms can be found using <tt class="docutils literal"><span class="pre">nfgaloisconj</span></tt>). The function
computes the action of the automorphism <em>aut</em> on the object <span class="math">\(x\)</span> in the
number field; <span class="math">\(x\)</span> can be a number field element, or an ideal (possibly
extended). Because of possible confusion with elements and ideals, other
vector or matrix arguments are forbidden.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(x^2+1);
? L = nfgaloisconj(nf)
%2 = [-x, x]~
? aut = L[1]; /* the non-trivial automorphism */
? nfgaloisapply(nf, aut, x)
%4 = Mod(-x, x^2 + 1)
? P = idealprimedec(nf,5); /* prime ideals above 5 */
? nfgaloisapply(nf, aut, P[2]) == P[1]
%7 = 0 \\ !!!!
? idealval(nf, nfgaloisapply(nf, aut, P[2]), P[1])
%8 = 1
</pre></div>
</div>
<p>The surprising failure of the equality test (<tt class="docutils literal"><span class="pre">%7</span></tt>) is
due to the fact that although the corresponding prime ideals are equal, their
representations are not. (A prime ideal is specified by a uniformizer, and
there is no guarantee that applying automorphisms yields the same elements
as a direct <tt class="docutils literal"><span class="pre">idealprimedec</span></tt> call.)</p>
<p>The automorphism can also be given as a column vector, representing the
image of <tt class="docutils literal"><span class="pre">Mod(x,</span> <span class="pre">nf.pol)</span></tt> as an algebraic number. This last
representation is more efficient and should be preferred if a given
automorphism must be used in many such calls.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(x^3 - 37*x^2 + 74*x - 37);
? l = nfgaloisconj(nf); aut = l[2] \\  automorphisms in basistoalg form
%2 = -31/11*x^2 + 1109/11*x - 925/11
? L = matalgtobasis(nf, l); AUT = L[2] \\  same in algtobasis form
%3 = [16, -6, 5]~
? v = [1, 2, 3]~; nfgaloisapply(nf, aut, v) == nfgaloisapply(nf, AUT, v)
%4 = 1 \\  same result...
? for (i=1,10^5, nfgaloisapply(nf, aut, v))
time = 1,451 ms.
? for (i=1,10^5, nfgaloisapply(nf, AUT, v))
time = 1,045 ms. \\  but the latter is faster
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfgaloisconj">
<tt class="descname">nfgaloisconj</tt><big>(</big><em>nf</em>, <em>flag=0</em>, <em>d=None</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfgaloisconj" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(nf\)</span> being a number field as output by <tt class="docutils literal"><span class="pre">nfinit</span></tt>, computes the
conjugates of a root <span class="math">\(r\)</span> of the non-constant polynomial <span class="math">\(x = nf[1]\)</span>
expressed as polynomials in <span class="math">\(r\)</span>. This also makes sense when the number field
is not Galois since some conjugates may lie in the field.
<span class="math">\(nf\)</span> can simply be a polynomial.</p>
<p>If no flags or <span class="math">\(flag = 0\)</span>, use a combination of flag <span class="math">\(4\)</span> and <span class="math">\(1\)</span> and the result
is always complete. There is no point whatsoever in using the other flags.</p>
<p>If <span class="math">\(flag = 1\)</span>, use <tt class="docutils literal"><span class="pre">nfroots</span></tt>: a little slow, but guaranteed to work in
polynomial time.</p>
<p>If <span class="math">\(flag = 2\)</span> (OBSOLETE), use complex approximations to the roots and an integral
LLL. The result is not guaranteed to be complete: some
conjugates may be missing (a warning is issued if the result is not proved
complete), especially so if the corresponding polynomial has a huge index,
and increasing the default precision may help. This variant is slow and
unreliable: don&#8217;t use it.</p>
<p>If <span class="math">\(flag = 4\)</span>, use <tt class="docutils literal"><span class="pre">galoisinit</span></tt>: very fast, but only applies to (most) Galois
fields. If the field is Galois with weakly
super-solvable Galois group (see <tt class="docutils literal"><span class="pre">galoisinit</span></tt>), return the complete list
of automorphisms, else only the identity element. If present, <span class="math">\(d\)</span> is assumed to
be a multiple of the least common denominator of the conjugates expressed as
polynomial in a root of <em>pol</em>.</p>
<p>This routine can only compute <span class="math">\(\mathbb{Q}\)</span>-automorphisms, but it may be used to get
<span class="math">\(K\)</span>-automorphism for any base field <span class="math">\(K\)</span> as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>rnfgaloisconj(nfK, R) = \\ K-automorphisms of L = K[X] / (R)
{ my(polabs, N);
 R *= Mod(1, nfK.pol); \\ convert coeffs to polmod elts of K
 polabs = rnfequation(nfK, R);
 N = nfgaloisconj(polabs) % R; \\ Q-automorphisms of L
 \\ select the ones that fix K
 select(s-&gt;subst(R, variable(R), Mod(s,R)) == 0, N);
}
K = nfinit(y^2 + 7);
rnfgaloisconj(K, x^4 - y*x^3 - 3*x^2 + y*x + 1) \\ K-automorphisms of L
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfgrunwaldwang">
<tt class="descname">nfgrunwaldwang</tt><big>(</big><em>nf</em>, <em>Lpr</em>, <em>Ld</em>, <em>pl</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfgrunwaldwang" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <em>nf</em> a number field in <em>nf</em> or <em>bnf</em> format,
a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> <em>Lpr</em> of primes of <em>nf</em> and a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> <em>Ld</em> of
positive integers of the same length, a <tt class="docutils literal"><span class="pre">t_VECSMALL</span></tt> <em>pl</em> of length
<span class="math">\(r_1\)</span> the number of real places of <em>nf</em>, computes a polynomial with
coefficients in <em>nf</em> defining a cyclic extension of <em>nf</em> of
minimal degree satisfying certain local conditions:</p>
<ul class="simple">
<li>at the prime <tt class="docutils literal"><span class="pre">Lpr[i]</span></tt>, the extension has local degree a multiple of
<tt class="docutils literal"><span class="pre">Ld[i]</span></tt>;</li>
<li>at the <span class="math">\(i\)</span>-th real place of <em>nf</em>, it is complex if <span class="math">\(pl[i] = -1\)</span>
(no condition if <span class="math">\(pl[i] = 0\)</span>).</li>
</ul>
<p>The extension has degree the LCM of the local degrees. Currently, the degree
is restricted to be a prime power for the search, and to be prime for the
construction because of the <tt class="docutils literal"><span class="pre">rnfkummer</span></tt> restrictions.</p>
<p>When <em>nf</em> is <span class="math">\(\mathbb{Q}\)</span>, prime integers are accepted instead of <em>prid</em>
structures. However, their primality is not checked and the behaviour is
undefined if you provide a composite number.</p>
<p><strong>Warning.</strong> If the number field <em>nf</em> does not contain the <span class="math">\(n\)</span>-th
roots of unity where <span class="math">\(n\)</span> is the degree of the extension to be computed,
triggers the computation of the <em>bnf</em> of <span class="math">\(nf(\zeta_n)\)</span>, which may be
costly.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2-5);
? pr = idealprimedec(nf,13)[1];
? pol = nfgrunwaldwang(nf, [pr], [2], [0,-1], &#39;x)
%3 = x^2 + Mod(3/2*y + 13/2, y^2 - 5)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfhilbert">
<tt class="descname">nfhilbert</tt><big>(</big><em>nf</em>, <em>a</em>, <em>b</em>, <em>pr=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfhilbert" title="Permalink to this definition">¶</a></dt>
<dd><p>If <em>pr</em> is omitted,
compute the global quadratic Hilbert symbol <span class="math">\((a,b)\)</span> in <span class="math">\(nf\)</span>, that
is <span class="math">\(1\)</span> if <span class="math">\(x^2 - a y^2 - b z^2\)</span> has a non trivial solution <span class="math">\((x,y,z)\)</span> in
<span class="math">\(nf\)</span>, and <span class="math">\(-1\)</span> otherwise. Otherwise compute the local symbol modulo
the prime ideal <em>pr</em>, as output by <tt class="docutils literal"><span class="pre">idealprimedec</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfhnf">
<tt class="descname">nfhnf</tt><big>(</big><em>nf</em>, <em>x</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfhnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a pseudo-matrix <span class="math">\((A,I)\)</span>, finds a
pseudo-basis <span class="math">\((B,J)\)</span> in Hermite normal form of the module it generates.
If <span class="math">\(flag\)</span> is non-zero, also return the transfomation matrix <span class="math">\(U\)</span> such that
<span class="math">\(AU = [0\|B]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfhnfmod">
<tt class="descname">nfhnfmod</tt><big>(</big><em>nf</em>, <em>x</em>, <em>detx</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfhnfmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a pseudo-matrix <span class="math">\((A,I)\)</span>
and an ideal <em>detx</em> which is contained in (read integral multiple of) the
determinant of <span class="math">\((A,I)\)</span>, finds a pseudo-basis in Hermite normal form
of the module generated by <span class="math">\((A,I)\)</span>. This avoids coefficient explosion.
<em>detx</em> can be computed using the function <tt class="docutils literal"><span class="pre">nfdetint</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfinit">
<tt class="descname">nfinit</tt><big>(</big><em>pol</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfinit" title="Permalink to this definition">¶</a></dt>
<dd><p><em>pol</em> being a non-constant,
preferably monic, irreducible polynomial in <span class="math">\(\mathbb{Z}[X]\)</span>, initializes a
<em>number field</em> structure (<tt class="docutils literal"><span class="pre">nf</span></tt>) associated to the field <span class="math">\(K\)</span> defined
by <em>pol</em>. As such, it&#8217;s a technical object passed as the first argument
to most <tt class="docutils literal"><span class="pre">nf</span></tt><em>xxx</em> functions, but it contains some information which
may be directly useful. Access to this information via <em>member
functions</em> is preferred since the specific data organization specified below
may change in the future. Currently, <tt class="docutils literal"><span class="pre">nf</span></tt> is a row vector with 9
components:</p>
<p><span class="math">\(nf[1]\)</span> contains the polynomial <em>pol</em> (<tt class="docutils literal"><span class="pre">:emphasis:`nf</span></tt>.pol`).</p>
<p><span class="math">\(nf[2]\)</span> contains <span class="math">\([r1,r2]\)</span> (<tt class="docutils literal"><span class="pre">:emphasis:`nf</span></tt>.sign`, <tt class="docutils literal"><span class="pre">:emphasis:`nf</span></tt>.r1`,
<tt class="docutils literal"><span class="pre">:emphasis:`nf</span></tt>.r2`), the number of real and complex places of <span class="math">\(K\)</span>.</p>
<p><span class="math">\(nf[3]\)</span> contains the discriminant <span class="math">\(d(K)\)</span> (<tt class="docutils literal"><span class="pre">:emphasis:`nf</span></tt>.disc`) of <span class="math">\(K\)</span>.</p>
<p><span class="math">\(nf[4]\)</span> contains the index of <span class="math">\(nf[1]\)</span> (<tt class="docutils literal"><span class="pre">:emphasis:`nf</span></tt>.index`),
i.e.&nbsp;<span class="math">\([\mathbb{Z}_K : \mathbb{Z}[\theta]]\)</span>, where <span class="math">\(\theta\)</span> is any root of <span class="math">\(nf[1]\)</span>.</p>
<p><span class="math">\(nf[5]\)</span> is a vector containing 7 matrices <span class="math">\(M\)</span>, <span class="math">\(G\)</span>, <em>roundG</em>, <span class="math">\(T\)</span>,
<span class="math">\(MD\)</span>, <span class="math">\(TI\)</span>, <span class="math">\(MDI\)</span> useful for certain computations in the number field <span class="math">\(K\)</span>.</p>
<p>&nbsp;&nbsp;<strong>*</strong> <span class="math">\(M\)</span> is the <span class="math">\((r1+r2) x n\)</span> matrix whose columns represent
the numerical values of the conjugates of the elements of the integral
basis.</p>
<p>&nbsp;&nbsp;<strong>*</strong> <span class="math">\(G\)</span> is an <span class="math">\(n x n\)</span> matrix such that <span class="math">\(T2 = ^t G G\)</span>,
where <span class="math">\(T2\)</span> is the quadratic form <span class="math">\(T_2(x) = \sum \|\sigma(x)\|^2\)</span>, <span class="math">\(\sigma\)</span>
running over the embeddings of <span class="math">\(K\)</span> into <span class="math">\(\mathbb{C}\)</span>.</p>
<p>&nbsp;&nbsp;<strong>*</strong> <em>roundG</em> is a rescaled copy of <span class="math">\(G\)</span>, rounded to nearest
integers.</p>
<p>&nbsp;&nbsp;<strong>*</strong> <span class="math">\(T\)</span> is the <span class="math">\(n x n\)</span> matrix whose coefficients are
<span class="math">\({Tr}(\omega_i\omega_j)\)</span> where the <span class="math">\(\omega_i\)</span> are the elements of the
integral basis. Note also that <span class="math">\(\det(T)\)</span> is equal to the discriminant of the
field <span class="math">\(K\)</span>. Also, when understood as an ideal, the matrix <span class="math">\(T^{-1}\)</span>
generates the codifferent ideal.</p>
<p>&nbsp;&nbsp;<strong>*</strong> The columns of <span class="math">\(MD\)</span> (<tt class="docutils literal"><span class="pre">:emphasis:`nf</span></tt>.diff`) express a <span class="math">\(\mathbb{Z}\)</span>-basis
of the different of <span class="math">\(K\)</span> on the integral basis.</p>
<p>&nbsp;&nbsp;<strong>*</strong> <span class="math">\(TI\)</span> is equal to the primitive part of <span class="math">\(T^{-1}\)</span>, which has integral
coefficients.</p>
<p>&nbsp;&nbsp;<strong>*</strong> Finally, <span class="math">\(MDI\)</span> is a two-element representation (for faster
ideal product) of <span class="math">\(d(K)\)</span> times the codifferent ideal
(<tt class="docutils literal"><span class="pre">:emphasis:`nf</span></tt>.disc:math:<span class="math">\(*\)</span><em>nf</em>.codiff`, which is an integral ideal). <span class="math">\(MDI\)</span>
is only used in <tt class="docutils literal"><span class="pre">idealinv</span></tt>.</p>
<p><span class="math">\(nf[6]\)</span> is the vector containing the <span class="math">\(r1+r2\)</span> roots
(<tt class="docutils literal"><span class="pre">:emphasis:`nf</span></tt>.roots`) of <span class="math">\(nf[1]\)</span> corresponding to the <span class="math">\(r1+r2\)</span>
embeddings of the number field into <span class="math">\(\mathbb{C}\)</span> (the first <span class="math">\(r1\)</span> components are real,
the next <span class="math">\(r2\)</span> have positive imaginary part).</p>
<p><span class="math">\(nf[7]\)</span> is an integral basis for <span class="math">\(\mathbb{Z}_K\)</span> (<tt class="docutils literal"><span class="pre">:emphasis:`nf</span></tt>.zk`) expressed
on the powers of&nbsp;<span class="math">\(\theta\)</span>. Its first element is guaranteed to be <span class="math">\(1\)</span>. This
basis is LLL-reduced with respect to <span class="math">\(T_2\)</span> (strictly speaking, it is a
permutation of such a basis, due to the condition that the first element be
<span class="math">\(1\)</span>).</p>
<p><span class="math">\(nf[8]\)</span> is the <span class="math">\(n x n\)</span> integral matrix expressing the power
basis in terms of the integral basis, and finally</p>
<p><span class="math">\(nf[9]\)</span> is the <span class="math">\(n x n^2\)</span> matrix giving the multiplication table
of the integral basis.</p>
<p>If a non monic polynomial is input, <tt class="docutils literal"><span class="pre">nfinit</span></tt> will transform it into a
monic one, then reduce it (see <span class="math">\(flag = 3\)</span>). It is allowed, though not very
useful given the existence of <tt class="docutils literal"><span class="pre">nfnewprec</span></tt>, to input a <em>nf</em> or a
<em>bnf</em> instead of a polynomial. It is also allowed to
input a <em>rnf</em>, in which case an <em>nf</em> structure associated to the
absolute defining polynomial <tt class="docutils literal"><span class="pre">polabs</span></tt> is returned (<em>flag</em> is then ignored).</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(x^3 - 12); \\ initialize number field Q[X] / (X^3 - 12)
? nf.pol \\ defining polynomial
%2 = x^3 - 12
? nf.disc \\ field discriminant
%3 = -972
? nf.index \\ index of power basis order in maximal order
%4 = 2
? nf.zk \\ integer basis, lifted to Q[X]
%5 = [1, x, 1/2*x^2]
? nf.sign \\ signature
%6 = [1, 1]
? factor(abs(nf.disc )) \\ determines ramified primes
%7 =
[2 2]

[3 5]
? idealfactor(nf, 2)
%8 =
[[2, [0, 0, -1]~, 3, 1, [0, 1, 0]~] 3] \\  p_2^3
</pre></div>
</div>
<p><strong>Huge discriminants, helping nfdisc.</strong></p>
<p>In case <em>pol</em> has a huge discriminant which is difficult to factor,
it is hard to compute from scratch the maximal order. The special input
format <span class="math">\([pol, B]\)</span> is also accepted where <em>pol</em> is a polynomial as
above and <span class="math">\(B\)</span> has one of the following forms</p>
<ul class="simple">
<li>an integer basis, as would be computed by <tt class="docutils literal"><span class="pre">nfbasis</span></tt>: a vector of
polynomials with first element <span class="math">\(1\)</span>. This is useful if the maximal order is
known in advance.</li>
<li>an argument <tt class="docutils literal"><span class="pre">listP</span></tt> which specifies a list of primes (see
<tt class="docutils literal"><span class="pre">nfbasis</span></tt>). Instead of the maximal order, <tt class="docutils literal"><span class="pre">nfinit</span></tt> then computes an
order which is maximal at these particular primes as well as the primes
contained in the private prime table (see <tt class="docutils literal"><span class="pre">addprimes</span></tt>). The result is
unconditionaly correct when the discriminant <tt class="docutils literal"><span class="pre">nf.disc</span></tt> factors
completely over this set of primes. The function <tt class="docutils literal"><span class="pre">nfcertify</span></tt> automates
this:</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? pol = polcompositum(x^5 - 101, polcyclo(7))[1];
? nf = nfinit( [pol, 10^3] );
? nfcertify(nf)
%3 = []
</pre></div>
</div>
<p>A priori, <tt class="docutils literal"><span class="pre">nf.zk</span></tt> defines an order which is only known
to be maximal at all primes <span class="math">\(&lt;= 10^3\)</span> (no prime <span class="math">\(&lt;= 10^3\)</span> divides
<tt class="docutils literal"><span class="pre">nf.index</span></tt>). The certification step proves the correctness of the
computation.</p>
<p>If <span class="math">\(flag = 2\)</span>: <em>pol</em> is changed into another polynomial <span class="math">\(P\)</span> defining the same
number field, which is as simple as can easily be found using the
<tt class="docutils literal"><span class="pre">polredbest</span></tt> algorithm, and all the subsequent computations are done
using this new polynomial. In particular, the first component of the result
is the modified polynomial.</p>
<p>If <span class="math">\(flag = 3\)</span>, apply <tt class="docutils literal"><span class="pre">polredbest</span></tt> as in case 2, but outputs
<span class="math">\([nf,Mod(a,P)]\)</span>, where <span class="math">\(nf\)</span> is as before and
<span class="math">\(Mod(a,P) = Mod(x,pol)\)</span> gives the change of
variables. This is implicit when <em>pol</em> is not monic: first a linear change
of variables is performed, to get a monic polynomial, then <tt class="docutils literal"><span class="pre">polredbest</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfisideal">
<tt class="descname">nfisideal</tt><big>(</big><em>nf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfisideal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if <span class="math">\(x\)</span> is an ideal in the number field <span class="math">\(nf\)</span>, 0 otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfisincl">
<tt class="descname">nfisincl</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfisincl" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the number field <span class="math">\(K\)</span> defined
by the polynomial <span class="math">\(x\)</span> is conjugate to a subfield of the field <span class="math">\(L\)</span> defined
by <span class="math">\(y\)</span> (where <span class="math">\(x\)</span> and <span class="math">\(y\)</span> must be in <span class="math">\(\mathbb{Q}[X]\)</span>). If they are not, the output
is the number 0. If they are, the output is a vector of polynomials, each
polynomial <span class="math">\(a\)</span> representing an embedding of <span class="math">\(K\)</span> into <span class="math">\(L\)</span>, i.e.&nbsp;being such
that <span class="math">\(y \| x o a\)</span>.</p>
<p>If <span class="math">\(y\)</span> is a number field (<em>nf</em>), a much faster algorithm is used
(factoring <span class="math">\(x\)</span> over <span class="math">\(y\)</span> using <tt class="docutils literal"><span class="pre">nffactor</span></tt>). Before version 2.0.14, this
wasn&#8217;t guaranteed to return all the embeddings, hence was triggered by a
special flag. This is no more the case.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfisisom">
<tt class="descname">nfisisom</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfisisom" title="Permalink to this definition">¶</a></dt>
<dd><p>As <tt class="docutils literal"><span class="pre">nfisincl</span></tt>, but tests for isomorphism. If either <span class="math">\(x\)</span> or <span class="math">\(y\)</span> is a
number field, a much faster algorithm will be used.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfkermodpr">
<tt class="descname">nfkermodpr</tt><big>(</big><em>nf</em>, <em>x</em>, <em>pr</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfkermodpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel of the matrix <span class="math">\(a\)</span> in <span class="math">\(\mathbb{Z}_K/pr\)</span>, where <em>pr</em> is in
<strong>modpr</strong> format (see <tt class="docutils literal"><span class="pre">nfmodprinit</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfmodprinit">
<tt class="descname">nfmodprinit</tt><big>(</big><em>nf</em>, <em>pr</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfmodprinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the prime ideal <em>pr</em> into <tt class="docutils literal"><span class="pre">modpr</span></tt> format necessary
for all operations modulo <em>pr</em> in the number field <em>nf</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfnewprec">
<tt class="descname">nfnewprec</tt><big>(</big><em>nf</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfnewprec" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the number field <span class="math">\(nf\)</span>
into the corresponding data using current (usually larger) precision. This
function works as expected if <span class="math">\(nf\)</span> is in fact a <span class="math">\(bnf\)</span> (update
<span class="math">\(bnf\)</span> to current precision) but may be quite slow (many generators of
principal ideals have to be computed).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfroots">
<tt class="descname">nfroots</tt><big>(</big><em>nf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfroots" title="Permalink to this definition">¶</a></dt>
<dd><p>Roots of the polynomial <span class="math">\(x\)</span> in the
number field <span class="math">\(nf\)</span> given by <tt class="docutils literal"><span class="pre">nfinit</span></tt> without multiplicity (in <span class="math">\(\mathbb{Q}\)</span>
if <span class="math">\(nf\)</span> is omitted). <span class="math">\(x\)</span> has coefficients in the number field (scalar,
polmod, polynomial, column vector). The main variable of <span class="math">\(nf\)</span> must be
of lower priority than that of <span class="math">\(x\)</span> (see <tt class="docutils literal"><span class="pre">priority</span></tt> (in the PARI manual)). However if the
coefficients of the number field occur explicitly (as polmods) as
coefficients of <span class="math">\(x\)</span>, the variable of these polmods <em>must</em> be the same as
the main variable of <span class="math">\(t\)</span> (see <tt class="docutils literal"><span class="pre">nffactor</span></tt>).</p>
<p>It is possible to input a defining polynomial for <em>nf</em>
instead, but this is in general less efficient since parts of an <tt class="docutils literal"><span class="pre">nf</span></tt>
structure will be computed internally. This is useful in two situations: when
you don&#8217;t need the <tt class="docutils literal"><span class="pre">nf</span></tt>, or when you can&#8217;t compute its discriminant due
to integer factorization difficulties. In the latter case, <tt class="docutils literal"><span class="pre">addprimes</span></tt> is
a possibility but a dangerous one: roots will probably be missed if the
(true) field discriminant and an <tt class="docutils literal"><span class="pre">addprimes</span></tt> entry are strictly divisible
by some prime. If you have such an unsafe <em>nf</em>, it is safer to input
<tt class="docutils literal"><span class="pre">nf.pol</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfrootsof1">
<tt class="descname">nfrootsof1</tt><big>(</big><em>nf</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfrootsof1" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a two-component vector <span class="math">\([w,z]\)</span> where <span class="math">\(w\)</span> is the number of roots of
unity in the number field <em>nf</em>, and <span class="math">\(z\)</span> is a primitive <span class="math">\(w\)</span>-th root
of unity.</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(polcyclo(11));
? nfrootsof1(K)
%2 = [22, [0, 0, 0, 0, 0, -1, 0, 0, 0, 0]~]
? z = nfbasistoalg(K, %[2]) \\ in algebraic form
%3 = Mod(-x^5, x^10 + x^9 + x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1)
? [lift(z^11), lift(z^2)] \\ proves that the order of z is 22
%4 = [-1, -x^9 - x^8 - x^7 - x^6 - x^5 - x^4 - x^3 - x^2 - x - 1]
</pre></div>
</div>
<p>This function guesses the number <span class="math">\(w\)</span> as the gcd of the <span class="math">\(\#k(v)^*\)</span> for
unramified <span class="math">\(v\)</span> above odd primes, then computes the roots in <em>nf</em>
of the <span class="math">\(w\)</span>-th cyclotomic polynomial: the algorithm is polynomial time with
respect to the field degree and the bitsize of the multiplication table in
<em>nf</em> (both of them polynomially bounded in terms of the size of the
discriminant). Fields of degree up to <span class="math">\(100\)</span> or so should require less than
one minute.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfsnf">
<tt class="descname">nfsnf</tt><big>(</big><em>nf</em>, <em>x</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfsnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a torsion <span class="math">\(\mathbb{Z}_K\)</span>-module <span class="math">\(x\)</span> associated to the square integral
invertible pseudo-matrix <span class="math">\((A,I,J)\)</span>, returns an ideal list
<span class="math">\(D = [d_1,...,d_n]\)</span> which is the Smith normal form of <span class="math">\(x\)</span>. In other
words, <span class="math">\(x\)</span> is isomorphic to <span class="math">\(\mathbb{Z}_K/d_1\oplus...\oplus\mathbb{Z}_K/d_n\)</span> and <span class="math">\(d_i\)</span>
divides <span class="math">\(d_{i-1}\)</span> for <span class="math">\(i &gt;= 2\)</span>. If <span class="math">\(flag\)</span> is non-zero return <span class="math">\([D,U,V]\)</span>, where
<span class="math">\(UAV\)</span> is the identity.</p>
<p>See <tt class="docutils literal"><span class="pre">ZKmodules</span></tt> (in the PARI manual) for the definition of integral pseudo-matrix;
briefly, it is input as a 3-component row vector <span class="math">\([A,I,J]\)</span> where
<span class="math">\(I = [b_1,...,b_n]\)</span> and <span class="math">\(J = [a_1,...,a_n]\)</span> are two ideal lists,
and <span class="math">\(A\)</span> is a square <span class="math">\(n x n\)</span> matrix with columns <span class="math">\((A_1,...,A_n)\)</span>,
seen as elements in <span class="math">\(K^n\)</span> (with canonical basis <span class="math">\((e_1,...,e_n)\)</span>).
This data defines the <span class="math">\(\mathbb{Z}_K\)</span> module <span class="math">\(x\)</span> given by</p>
<div class="math">
\[(b_1e_1\oplus...\oplus b_ne_n) / (a_1A_1\oplus...\oplus a_nA_n)
,\]</div>
<p>The integrality condition is <span class="math">\(a_{i,j} belongs to b_i a_j^{-1}\)</span> for all <span class="math">\(i,j\)</span>. If it
is not satisfied, then the <span class="math">\(d_i\)</span> will not be integral. Note that every
finitely generated torsion module is isomorphic to a module of this form and
even with <span class="math">\(b_i = Z_K\)</span> for all <span class="math">\(i\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfsolvemodpr">
<tt class="descname">nfsolvemodpr</tt><big>(</big><em>nf</em>, <em>a</em>, <em>b</em>, <em>P</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfsolvemodpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(P\)</span> be a prime ideal in <strong>modpr</strong> format (see <tt class="docutils literal"><span class="pre">nfmodprinit</span></tt>),
let <span class="math">\(a\)</span> be a matrix, invertible over the residue field, and let <span class="math">\(b\)</span> be
a column vector or matrix. This function returns a solution of <span class="math">\(a.x = 
b\)</span>; the coefficients of <span class="math">\(x\)</span> are lifted to <em>nf</em> elements.</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(y^2+1);
? P = idealprimedec(K, 3)[1];
? P = nfmodprinit(K, P);
? a = [y+1, y; y, 0]; b = [1, y]~
? nfsolvemodpr(K, a,b, P)
%5 = [1, 2]~
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfsplitting">
<tt class="descname">nfsplitting</tt><big>(</big><em>nf</em>, <em>d=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfsplitting" title="Permalink to this definition">¶</a></dt>
<dd><p>Defining polynomial for the splitting field of <em>nf</em>;
if <span class="math">\(d\)</span> is given, it must be the degree of the splitting field. It
is possible to input a defining polynomial <span class="math">\(T\)</span> instead but this is in
general less efficient.</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(x^3-2);
? nfsplitting(K)
%2 = x^6 + 108
? nfsplitting(x^8-2)
%3 = x^16 + 272*x^8 + 64
</pre></div>
</div>
<p>The complexity of the algorithm is polynomial in the degree <span class="math">\(d\)</span> of the
splitting field and the bitsize of <span class="math">\(T\)</span>; if <span class="math">\(d\)</span> is large the result will
likely be unusable, e.g. <tt class="docutils literal"><span class="pre">nfinit</span></tt> will not be an option:</p>
<div class="highlight-python"><div class="highlight"><pre>? nfsplitting(x^6-x-1)
[... degree 720 polynomial deleted ...]
time = 11,020 ms.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfsubfields">
<tt class="descname">nfsubfields</tt><big>(</big><em>pol</em>, <em>d=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfsubfields" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all subfields of degree
<span class="math">\(d\)</span> of the number field defined by the (monic, integral) polynomial
<em>pol</em> (all subfields if <span class="math">\(d\)</span> is null or omitted). The result is a vector
of subfields, each being given by <span class="math">\([g,h]\)</span>, where <span class="math">\(g\)</span> is an absolute equation
and <span class="math">\(h\)</span> expresses one of the roots of <span class="math">\(g\)</span> in terms of the root <span class="math">\(x\)</span> of the
polynomial defining <span class="math">\(nf\)</span>. This routine uses J.&nbsp;Klüners&#8217;s algorithm
in the general case, and B.&nbsp;Allombert&#8217;s <tt class="docutils literal"><span class="pre">galoissubfields</span></tt> when <em>nf</em>
is Galois (with weakly supersolvable Galois group).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.norm">
<tt class="descname">norm</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebraic norm of <span class="math">\(x\)</span>, i.e.&nbsp;the product of <span class="math">\(x\)</span> with
its conjugate (no square roots are taken), or conjugates for polmods. For
vectors and matrices, the norm is taken componentwise and hence is not the
<span class="math">\(L^2\)</span>-norm (see <tt class="docutils literal"><span class="pre">norml2</span></tt>). Note that the norm of an element of
<span class="math">\(\mathbb{R}\)</span> is its square, so as to be compatible with the complex norm.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.norml2">
<tt class="descname">norml2</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.norml2" title="Permalink to this definition">¶</a></dt>
<dd><p>Square of the <span class="math">\(L^2\)</span>-norm of <span class="math">\(x\)</span>. More precisely,
if <span class="math">\(x\)</span> is a scalar, <span class="math">\(norml2(x)\)</span> is defined to be the square
of the complex modulus of <span class="math">\(x\)</span> (real <tt class="docutils literal"><span class="pre">t_QUAD</span></tt>&nbsp;s are not supported).
If <span class="math">\(x\)</span> is a polynomial, a (row or column) vector or a matrix, <tt class="docutils literal"><span class="pre">norml2(:math:`x</span></tt>)` is
defined recursively as <span class="math">\(\sum_i norml2(x_i)\)</span>, where <span class="math">\((x_i)\)</span> run through
the components of <span class="math">\(x\)</span>. In particular, this yields the usual <span class="math">\(\sum \|x_i\|^2\)</span>
(resp.&nbsp;<span class="math">\(\sum \|x_{i,j}\|^2\)</span>) if <span class="math">\(x\)</span> is a polynomial or vector (resp.&nbsp;matrix) with
complex components.</p>
<div class="highlight-python"><div class="highlight"><pre>? norml2( [ 1, 2, 3 ] ) \\ vector
%1 = 14
? norml2( [ 1, 2; 3, 4] ) \\ matrix
%2 = 30
? norml2( 2*I + x )
%3 = 5
? norml2( [ [1,2], [3,4], 5, 6 ] ) \\ recursively defined
%4 = 91
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.normlp">
<tt class="descname">normlp</tt><big>(</big><em>x</em>, <em>p=None</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.normlp" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(L^p\)</span>-norm of <span class="math">\(x\)</span>; sup norm if <span class="math">\(p\)</span> is omitted. More precisely,
if <span class="math">\(x\)</span> is a scalar, <tt class="docutils literal"><span class="pre">normlp</span></tt><span class="math">\((x, p)\)</span> is defined to be <tt class="docutils literal"><span class="pre">abs</span></tt><span class="math">\((x)\)</span>.
If <span class="math">\(x\)</span> is a polynomial, a (row or column) vector or a matrix:</p>
<ul class="simple">
<li>if <span class="math">\(p\)</span> is omitted, <tt class="docutils literal"><span class="pre">normlp(:math:`x</span></tt>)` is defined recursively as
<span class="math">\(\max_i normlp(x_i))\)</span>, where <span class="math">\((x_i)\)</span> run through the components of&nbsp;<span class="math">\(x\)</span>.
In particular, this yields the usual sup norm if <span class="math">\(x\)</span> is a polynomial or
vector with complex components.</li>
<li>otherwise, <tt class="docutils literal"><span class="pre">normlp(:math:`x</span></tt>, <span class="math">\(p\)</span>)` is defined recursively as <span class="math">\((\sum_i
normlp^p(x_i,p))^{1/p}\)</span>. In particular, this yields the usual <span class="math">\((\sum
|x_i|^p)^{1/p}\)</span> if <span class="math">\(x\)</span> is a polynomial or vector with complex components.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? v = [1,-2,3]; normlp(v) \\ vector
%1 = 3
? M = [1,-2;-3,4]; normlp(M) \\ matrix
%2 = 4
? T = (1+I) + I*x^2; normlp(T)
%3 = 1.4142135623730950488016887242096980786
? normlp([[1,2], [3,4], 5, 6]) \\ recursively defined
%4 = 6

? normlp(v, 1)
%5 = 6
? normlp(M, 1)
%6 = 10
? normlp(T, 1)
%7 = 2.4142135623730950488016887242096980786
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.numbpart">
<tt class="descname">numbpart</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.numbpart" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the number of unrestricted partitions of
<span class="math">\(n\)</span>, usually called <span class="math">\(p(n)\)</span> in the literature; in other words the number of
nonnegative integer solutions to <span class="math">\(a+2b+3c+.. .= n\)</span>. <span class="math">\(n\)</span> must be of type
integer and <span class="math">\(n &lt; 10^{15}\)</span> (with trivial values <span class="math">\(p(n) = 0\)</span> for <span class="math">\(n &lt; 0\)</span> and
<span class="math">\(p(0) = 1\)</span>). The algorithm uses the Hardy-Ramanujan-Rademacher formula.
To explicitly enumerate them, see <tt class="docutils literal"><span class="pre">partitions</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.numdiv">
<tt class="descname">numdiv</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.numdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of divisors of <span class="math">\(\|x\|\)</span>. <span class="math">\(x\)</span> must be of type integer.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.numerator">
<tt class="descname">numerator</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.numerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerator of <span class="math">\(x\)</span>. The meaning of this
is clear when <span class="math">\(x\)</span> is a rational number or function. If <span class="math">\(x\)</span> is an integer
or a polynomial, it is treated as a rational number or function,
respectively, and the result is <span class="math">\(x\)</span> itself. For polynomials, you
probably want to use</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">numerator</span><span class="p">(</span> <span class="n">content</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>instead.</p>
<p>In other cases, <tt class="docutils literal"><span class="pre">numerator(x)</span></tt> is defined to be
<tt class="docutils literal"><span class="pre">denominator(x)*x</span></tt>. This is the case when <span class="math">\(x\)</span> is a vector or a
matrix, but also for <tt class="docutils literal"><span class="pre">t_COMPLEX</span></tt> or <tt class="docutils literal"><span class="pre">t_QUAD</span></tt>. In particular since a
<tt class="docutils literal"><span class="pre">t_PADIC</span></tt> or <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt> has denominator <span class="math">\(1\)</span>, its numerator is
itself.</p>
<p><strong>Warning.</strong> Multivariate objects are created according to variable
priorities, with possibly surprising side effects (<span class="math">\(x/y\)</span> is a polynomial, but
<span class="math">\(y/x\)</span> is a rational function). See <tt class="docutils literal"><span class="pre">priority</span></tt> (in the PARI manual).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.omega">
<tt class="descname">omega</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.omega" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of distinct prime divisors of <span class="math">\(\|x\|\)</span>. <span class="math">\(x\)</span> must be of type integer.</p>
<div class="highlight-python"><div class="highlight"><pre>? factor(392)
%1 =
[2 3]

[7 2]

? omega(392)
%2 = 2; \\ without multiplicity
? bigomega(392)
%3 = 5; \\ = 3+2, with multiplicity
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.padicappr">
<tt class="descname">padicappr</tt><big>(</big><em>pol</em>, <em>a</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.padicappr" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector of <span class="math">\(p\)</span>-adic roots of the
polynomial <span class="math">\(pol\)</span> congruent to the <span class="math">\(p\)</span>-adic number <span class="math">\(a\)</span> modulo <span class="math">\(p\)</span>, and with
the same <span class="math">\(p\)</span>-adic precision as <span class="math">\(a\)</span>. The number <span class="math">\(a\)</span> can be an ordinary
<span class="math">\(p\)</span>-adic number (type <tt class="docutils literal"><span class="pre">t_PADIC</span></tt>, i.e.&nbsp;an element of <span class="math">\(\mathbb{Z}_p\)</span>) or can be an
integral element of a finite extension of <span class="math">\(\mathbb{Q}_p\)</span>, given as a <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt>
at least one of whose coefficients is a <tt class="docutils literal"><span class="pre">t_PADIC</span></tt>. In this case, the result
is the vector of roots belonging to the same extension of <span class="math">\(\mathbb{Q}_p\)</span> as <span class="math">\(a\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.padicfields">
<tt class="descname">padicfields</tt><big>(</big><em>p</em>, <em>N</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.padicfields" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of polynomials generating all the extensions of degree
<span class="math">\(N\)</span> of the field <span class="math">\(\mathbb{Q}_p\)</span> of <span class="math">\(p\)</span>-adic rational numbers; <span class="math">\(N\)</span> is
allowed to be a 2-component vector <span class="math">\([n,d]\)</span>, in which case we return the
extensions of degree <span class="math">\(n\)</span> and discriminant <span class="math">\(p^d\)</span>.</p>
<p>The list is minimal in the sense that two different polynomials generate
non-isomorphic extensions; in particular, the number of polynomials is the
number of classes of non-isomorphic extensions. If <span class="math">\(P\)</span> is a polynomial in this
list, <span class="math">\(\alpha\)</span> is any root of <span class="math">\(P\)</span> and <span class="math">\(K = \mathbb{Q}_p(\alpha)\)</span>, then <span class="math">\(\alpha\)</span>
is the sum of a uniformizer and a (lift of a) generator of the residue field
of <span class="math">\(K\)</span>; in particular, the powers of <span class="math">\(\alpha\)</span> generate the ring of <span class="math">\(p\)</span>-adic
integers of <span class="math">\(K\)</span>.</p>
<p>If <span class="math">\(flag = 1\)</span>, replace each polynomial <span class="math">\(P\)</span> by a vector <span class="math">\([P, e, f, d, c]\)</span>
where <span class="math">\(e\)</span> is the ramification index, <span class="math">\(f\)</span> the residual degree, <span class="math">\(d\)</span> the
valuation of the discriminant, and <span class="math">\(c\)</span> the number of conjugate fields.
If <span class="math">\(flag = 2\)</span>, only return the <em>number</em> of extensions in a fixed
algebraic closure (Krasner&#8217;s formula), which is much faster.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.padicprec">
<tt class="descname">padicprec</tt><big>(</big><em>x</em>, <em>p</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.padicprec" title="Permalink to this definition">¶</a></dt>
<dd><p>Absolute <span class="math">\(p\)</span>-adic precision of the object <span class="math">\(x\)</span>. This is the minimum
precision of the components of <span class="math">\(x\)</span>. The result is <tt class="docutils literal"><span class="pre">LONG_MAX</span></tt>
(<span class="math">\(2^{31}-1\)</span> for 32-bit machines or <span class="math">\(2^{63}-1\)</span> for 64-bit machines) if <span class="math">\(x\)</span> is
an exact object.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.parapply">
<tt class="descname">parapply</tt><big>(</big><em>f</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.parapply" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel evaluation of <tt class="docutils literal"><span class="pre">f</span></tt> on the elements of <tt class="docutils literal"><span class="pre">x</span></tt>.
The function <tt class="docutils literal"><span class="pre">f</span></tt> must not access global variables or variables
declared with local(), and must be free of side effects.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">parapply</span><span class="p">(</span><span class="n">factor</span><span class="p">,[</span><span class="mi">2</span><span class="o">^</span><span class="mi">256</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">^</span><span class="mi">193</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>factors <span class="math">\(2^{256} + 1\)</span> and <span class="math">\(2^{193} - 1\)</span> in parallel.</p>
<div class="highlight-python"><div class="highlight"><pre>{
 my(E = ellinit([1,3]), V = vector(12,i,randomprime(2^200)));
 parapply(p-&gt;ellcard(E,p), V)
}
</pre></div>
</div>
<p>computes the order of <span class="math">\(E(\mathbb{F}_p)\)</span> for <span class="math">\(12\)</span> random primes of <span class="math">\(200\)</span> bits.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.pareval">
<tt class="descname">pareval</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.pareval" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel evaluation of the elements of <tt class="docutils literal"><span class="pre">x</span></tt>, where <tt class="docutils literal"><span class="pre">x</span></tt> is a
vector of closures. The closures must be of arity <span class="math">\(0\)</span>, must not access
global variables or variables declared with <tt class="docutils literal"><span class="pre">local</span></tt> and must be
free of side effects.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.parselect">
<tt class="descname">parselect</tt><big>(</big><em>f</em>, <em>A</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.parselect" title="Permalink to this definition">¶</a></dt>
<dd><p>Selects elements of <span class="math">\(A\)</span> according to the selection function <span class="math">\(f\)</span>, done in
parallel. If <em>flag</em> is <span class="math">\(1\)</span>, return the indices of those elements (indirect
selection) The function <tt class="docutils literal"><span class="pre">f</span></tt> must not access global variables or
variables declared with local(), and must be free of side effects.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.permtonum">
<tt class="descname">permtonum</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.permtonum" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a permutation <span class="math">\(x\)</span> on <span class="math">\(n\)</span> elements, gives the number <span class="math">\(k\)</span> such that
<span class="math">\(x = numtoperm(n,k)\)</span>, i.e.&nbsp;inverse function of <tt class="docutils literal"><span class="pre">numtoperm</span></tt>.
The numbering used is the standard lexicographic ordering, starting at <span class="math">\(0\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polclass">
<tt class="descname">polclass</tt><big>(</big><em>D</em>, <em>x=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polclass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Hilbert class polynomial for the <span class="math">\(j\)</span> function for the imaginary quadratic
discriminant <span class="math">\(D\)</span> in the variable <span class="math">\(x\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? polclass(-163)
%1 = x + 262537412640768000
? polclass(-51, &#39;z)
%2 = z^2 + 5541101568*z + 6262062317568
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polcoeff">
<tt class="descname">polcoeff</tt><big>(</big><em>x</em>, <em>n</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polcoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Coefficient of degree <span class="math">\(n\)</span> of the polynomial <span class="math">\(x\)</span>, with respect to the
main variable if <span class="math">\(v\)</span> is omitted, with respect to <span class="math">\(v\)</span> otherwise. If <span class="math">\(n\)</span>
is greater than the degree, the result is zero.</p>
<p>Naturally applies to scalars (polynomial of degree <span class="math">\(0\)</span>), as well as to
rational functions whose denominator is a monomial.
It also applies to power series: if <span class="math">\(n\)</span> is less than the valuation, the result
is zero. If it is greater than the largest significant degree, then an error
message is issued.</p>
<p>For greater flexibility, <span class="math">\(x\)</span> can be a vector or matrix type and the
function then returns <tt class="docutils literal"><span class="pre">component(x,n)</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polcompositum">
<tt class="descname">polcompositum</tt><big>(</big><em>P</em>, <em>Q</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polcompositum" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(P\)</span> and <span class="math">\(Q\)</span>
being squarefree polynomials in <span class="math">\(\mathbb{Z}[X]\)</span> in the same variable, outputs
the simple factors of the étale <span class="math">\(\mathbb{Q}\)</span>-algebra <span class="math">\(A = \mathbb{Q}(X, Y) / (P(X), Q(Y))\)</span>.
The factors are given by a list of polynomials <span class="math">\(R\)</span> in <span class="math">\(\mathbb{Z}[X]\)</span>, associated to
the number field <span class="math">\(\mathbb{Q}(X)/ (R)\)</span>, and sorted by increasing degree (with respect
to lexicographic ordering for factors of equal degrees). Returns an error if
one of the polynomials is not squarefree.</p>
<p>Note that it is more efficient to reduce to the case where <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are
irreducible first. The routine will not perform this for you, since it may be
expensive, and the inputs are irreducible in most applications anyway. In
this case, there will be a single factor <span class="math">\(R\)</span> if and only if the number
fields defined by <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are linearly disjoint (their intersection is
<span class="math">\(\mathbb{Q}\)</span>).</p>
<p>Assuming <span class="math">\(P\)</span> is irreducible (of smaller degree than <span class="math">\(Q\)</span> for efficiency), it
is in general much faster to proceed as follows</p>
<div class="highlight-python"><div class="highlight"><pre>nf = nfinit(P); L = nffactor(nf, Q)[,1];
vector(#L, i, rnfequation(nf, L[i]))
</pre></div>
</div>
<p>to obtain the same result. If you are only interested in the degrees of the
simple factors, the <tt class="docutils literal"><span class="pre">rnfequation</span></tt> instruction can be replaced by a
trivial <tt class="docutils literal"><span class="pre">poldegree(P)</span> <span class="pre">*</span> <span class="pre">poldegree(L[i])</span></tt>.</p>
<p>The binary digits of <span class="math">\(flag\)</span> mean</p>
<p>1: outputs a vector of 4-component vectors <span class="math">\([R,a,b,k]\)</span>, where <span class="math">\(R\)</span>
ranges through the list of all possible compositums as above, and <span class="math">\(a\)</span>
(resp. <span class="math">\(b\)</span>) expresses the root of <span class="math">\(P\)</span> (resp. <span class="math">\(Q\)</span>) as an element of
<span class="math">\(\mathbb{Q}(X)/(R)\)</span>. Finally, <span class="math">\(k\)</span> is a small integer such that <span class="math">\(b + ka = X\)</span> modulo
<span class="math">\(R\)</span>.</p>
<p>2: assume that <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> define number fields which are linearly disjoint:
both polynomials are irreducible and the corresponding number fields
have no common subfield besides <span class="math">\(\mathbb{Q}\)</span>. This allows to save a costly
factorization over <span class="math">\(\mathbb{Q}\)</span>. In this case return the single simple factor
instead of a vector with one element.</p>
<p>A compositum is often defined by a complicated polynomial, which it is
advisable to reduce before further work. Here is an example involving
the field <span class="math">\(\mathbb{Q}(\zeta_5, 5^{1/5})\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>? L = polcompositum(x^5 - 5, polcyclo(5), 1); \\ list of [R,a,b,k]
? [R, a] = L[1]; \\ pick the single factor, extract R,a (ignore b,k)
? R \\ defines the compositum
%3 = x^20 + 5*x^19 + 15*x^18 + 35*x^17 + 70*x^16 + 141*x^15 + 260*x^14\
+ 355*x^13 + 95*x^12 - 1460*x^11 - 3279*x^10 - 3660*x^9 - 2005*x^8 \
+ 705*x^7 + 9210*x^6 + 13506*x^5 + 7145*x^4 - 2740*x^3 + 1040*x^2 \
- 320*x + 256
? a^5 - 5 \\ a fifth root of 5
%4 = 0
? [T, X] = polredbest(R, 1);
? T \\ simpler defining polynomial for Q[x]/(R)
%6 = x^20 + 25*x^10 + 5
? X \\  root of R in Q[y]/(T(y))
%7 = Mod(-1/11*x^15 - 1/11*x^14 + 1/22*x^10 - 47/22*x^5 - 29/11*x^4 + 7/22,\
x^20 + 25*x^10 + 5)
? a = subst(a.pol, &#39;x, X) \\ a in the new coordinates
%8 = Mod(1/11*x^14 + 29/11*x^4, x^20 + 25*x^10 + 5)
? a^5 - 5
%9 = 0
</pre></div>
</div>
<p>In the above example, <span class="math">\(x^5-5\)</span> and the <span class="math">\(5\)</span>-th cyclotomic
polynomial are irreducible over <span class="math">\(\mathbb{Q}\)</span>; they have coprime degrees so
define linearly disjoint extensions and we could have started by</p>
<div class="highlight-python"><div class="highlight"><pre>? [R,a] = polcompositum(x^5 - 5, polcyclo(5), 3); \\ [R,a,b,k]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polcyclofactors">
<tt class="descname">polcyclofactors</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polcyclofactors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of polynomials, whose product is the product of
distinct cyclotomic polynomials dividing <span class="math">\(f\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? f = x^10+5*x^8-x^7+8*x^6-4*x^5+8*x^4-3*x^3+7*x^2+3;
? v = polcyclofactors(f)
%2 = [x^2 + 1, x^2 + x + 1, x^4 - x^3 + x^2 - x + 1]
? apply(poliscycloprod, v)
%3 = [1, 1, 1]
? apply(poliscyclo, v)
%4 = [4, 3, 10]
</pre></div>
</div>
<p>In general, the polynomials are products of cyclotomic
polynomials and not themselves irreducible:</p>
<div class="highlight-python"><div class="highlight"><pre>? g = x^8+2*x^7+6*x^6+9*x^5+12*x^4+11*x^3+10*x^2+6*x+3;
? polcyclofactors(g)
%2 = [x^6 + 2*x^5 + 3*x^4 + 3*x^3 + 3*x^2 + 2*x + 1]
? factor(%[1])
%3 =
[ x^2 + x + 1 1]

[x^4 + x^3 + x^2 + x + 1 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.poldegree">
<tt class="descname">poldegree</tt><big>(</big><em>x</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.poldegree" title="Permalink to this definition">¶</a></dt>
<dd><p>Degree of the polynomial <span class="math">\(x\)</span> in the main variable if <span class="math">\(v\)</span> is omitted, in
the variable <span class="math">\(v\)</span> otherwise.</p>
<p>The degree of <span class="math">\(0\)</span> is <tt class="docutils literal"><span class="pre">-oo</span></tt>. The degree of a non-zero scalar is <span class="math">\(0\)</span>.
Finally, when <span class="math">\(x\)</span> is a non-zero polynomial or rational function, returns the
ordinary degree of <span class="math">\(x\)</span>. Raise an error otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.poldisc">
<tt class="descname">poldisc</tt><big>(</big><em>pol</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.poldisc" title="Permalink to this definition">¶</a></dt>
<dd><p>Discriminant of the polynomial
<em>pol</em> in the main variable if <span class="math">\(v\)</span> is omitted, in <span class="math">\(v\)</span> otherwise. The
algorithm used is the subresultant algorithm.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.poldiscreduced">
<tt class="descname">poldiscreduced</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.poldiscreduced" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduced discriminant vector of the
(integral, monic) polynomial <span class="math">\(f\)</span>. This is the vector of elementary divisors
of <span class="math">\(\mathbb{Z}[\alpha]/f'(\alpha)\mathbb{Z}[\alpha]\)</span>, where <span class="math">\(\alpha\)</span> is a root of the
polynomial <span class="math">\(f\)</span>. The components of the result are all positive, and their
product is equal to the absolute value of the discriminant of&nbsp;<span class="math">\(f\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polgalois">
<tt class="descname">polgalois</tt><big>(</big><em>T</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polgalois" title="Permalink to this definition">¶</a></dt>
<dd><p>Galois group of the non-constant
polynomial <span class="math">\(T belongs to \mathbb{Q}[X]\)</span>. In the present version <strong>2.8.0</strong>, <span class="math">\(T\)</span> must be irreducible
and the degree <span class="math">\(d\)</span> of <span class="math">\(T\)</span> must be less than or equal to 7. If the
<tt class="docutils literal"><span class="pre">galdata</span></tt> package has been installed, degrees 8, 9, 10 and 11 are also
implemented. By definition, if <span class="math">\(K = \mathbb{Q}[x]/(T)\)</span>, this computes the action of
the Galois group of the Galois closure of <span class="math">\(K\)</span> on the <span class="math">\(d\)</span> distinct roots of
<span class="math">\(T\)</span>, up to conjugacy (corresponding to different root orderings).</p>
<p>The output is a 4-component vector <span class="math">\([n,s,k,name]\)</span> with the
following meaning: <span class="math">\(n\)</span> is the cardinality of the group, <span class="math">\(s\)</span> is its signature
(<span class="math">\(s = 1\)</span> if the group is a subgroup of the alternating group <span class="math">\(A_d\)</span>, <span class="math">\(s = -1\)</span>
otherwise) and name is a character string containing name of the transitive
group according to the GAP 4 transitive groups library by Alexander Hulpke.</p>
<p><span class="math">\(k\)</span> is more arbitrary and the choice made up to version&nbsp;2.2.3 of PARI is rather
unfortunate: for <span class="math">\(d &gt; 7\)</span>, <span class="math">\(k\)</span> is the numbering of the group among all
transitive subgroups of <span class="math">\(S_d\)</span>, as given in &#8220;The transitive groups of degree up
to eleven&#8221;, G.&nbsp;Butler and J.&nbsp;McKay, <em>Communications in Algebra</em>, vol.&nbsp;11,
1983,
pp.&nbsp;863&#8211;911 (group <span class="math">\(k\)</span> is denoted <span class="math">\(T_k\)</span> there). And for <span class="math">\(d &lt;= 7\)</span>, it was ad
hoc, so as to ensure that a given triple would denote a unique group.
Specifically, for polynomials of degree <span class="math">\(d &lt;= 7\)</span>, the groups are coded as
follows, using standard notations</p>
<p>In degree 1: <span class="math">\(S_1 = [1,1,1]\)</span>.</p>
<p>In degree 2: <span class="math">\(S_2 = [2,-1,1]\)</span>.</p>
<p>In degree 3: <span class="math">\(A_3 = C_3 = [3,1,1]\)</span>, <span class="math">\(S_3 = [6,-1,1]\)</span>.</p>
<p>In degree 4: <span class="math">\(C_4 = [4,-1,1]\)</span>, <span class="math">\(V_4 = [4,1,1]\)</span>, <span class="math">\(D_4 = [8,-1,1]\)</span>, <span class="math">\(A_4 = [12,1,1]\)</span>,
<span class="math">\(S_4 = [24,-1,1]\)</span>.</p>
<p>In degree 5: <span class="math">\(C_5 = [5,1,1]\)</span>, <span class="math">\(D_5 = [10,1,1]\)</span>, <span class="math">\(M_{20} = [20,-1,1]\)</span>,
<span class="math">\(A_5 = [60,1,1]\)</span>, <span class="math">\(S_5 = [120,-1,1]\)</span>.</p>
<p>In degree 6: <span class="math">\(C_6 = [6,-1,1]\)</span>, <span class="math">\(S_3 = [6,-1,2]\)</span>, <span class="math">\(D_6 = [12,-1,1]\)</span>, <span class="math">\(A_4 = [12,1,1]\)</span>,
<span class="math">\(G_{18} = [18,-1,1]\)</span>, <span class="math">\(S_4^ -= [24,-1,1]\)</span>, <span class="math">\(A_4 x C_2 = [24,-1,2]\)</span>,
<span class="math">\(S_4^ += [24,1,1]\)</span>, <span class="math">\(G_{36}^ -= [36,-1,1]\)</span>, <span class="math">\(G_{36}^ += [36,1,1]\)</span>,
<span class="math">\(S_4 x C_2 = [48,-1,1]\)</span>, <span class="math">\(A_5 = PSL_2(5) = [60,1,1]\)</span>, <span class="math">\(G_{72} = [72,-1,1]\)</span>,
<span class="math">\(S_5 = PGL_2(5) = [120,-1,1]\)</span>, <span class="math">\(A_6 = [360,1,1]\)</span>, <span class="math">\(S_6 = [720,-1,1]\)</span>.</p>
<p>In degree 7: <span class="math">\(C_7 = [7,1,1]\)</span>, <span class="math">\(D_7 = [14,-1,1]\)</span>, <span class="math">\(M_{21} = [21,1,1]\)</span>,
<span class="math">\(M_{42} = [42,-1,1]\)</span>, <span class="math">\(PSL_2(7) = PSL_3(2) = [168,1,1]\)</span>, <span class="math">\(A_7 = [2520,1,1]\)</span>,
<span class="math">\(S_7 = [5040,-1,1]\)</span>.</p>
<p>This is deprecated and obsolete, but for reasons of backward compatibility,
we cannot change this behavior yet. So you can use the default
<tt class="docutils literal"><span class="pre">new_galois_format</span></tt> to switch to a consistent naming scheme, namely <span class="math">\(k\)</span> is
always the standard numbering of the group among all transitive subgroups of
<span class="math">\(S_n\)</span>. If this default is in effect, the above groups will be coded as:</p>
<p>In degree 1: <span class="math">\(S_1 = [1,1,1]\)</span>.</p>
<p>In degree 2: <span class="math">\(S_2 = [2,-1,1]\)</span>.</p>
<p>In degree 3: <span class="math">\(A_3 = C_3 = [3,1,1]\)</span>, <span class="math">\(S_3 = [6,-1,2]\)</span>.</p>
<p>In degree 4: <span class="math">\(C_4 = [4,-1,1]\)</span>, <span class="math">\(V_4 = [4,1,2]\)</span>, <span class="math">\(D_4 = [8,-1,3]\)</span>, <span class="math">\(A_4 = [12,1,4]\)</span>,
<span class="math">\(S_4 = [24,-1,5]\)</span>.</p>
<p>In degree 5: <span class="math">\(C_5 = [5,1,1]\)</span>, <span class="math">\(D_5 = [10,1,2]\)</span>, <span class="math">\(M_{20} = [20,-1,3]\)</span>,
<span class="math">\(A_5 = [60,1,4]\)</span>, <span class="math">\(S_5 = [120,-1,5]\)</span>.</p>
<p>In degree 6: <span class="math">\(C_6 = [6,-1,1]\)</span>, <span class="math">\(S_3 = [6,-1,2]\)</span>, <span class="math">\(D_6 = [12,-1,3]\)</span>, <span class="math">\(A_4 = [12,1,4]\)</span>,
<span class="math">\(G_{18} = [18,-1,5]\)</span>, <span class="math">\(A_4 x C_2 = [24,-1,6]\)</span>, <span class="math">\(S_4^ += [24,1,7]\)</span>,
<span class="math">\(S_4^ -= [24,-1,8]\)</span>, <span class="math">\(G_{36}^ -= [36,-1,9]\)</span>, <span class="math">\(G_{36}^ += [36,1,10]\)</span>,
<span class="math">\(S_4 x C_2 = [48,-1,11]\)</span>, <span class="math">\(A_5 = PSL_2(5) = [60,1,12]\)</span>, <span class="math">\(G_{72} = [72,-1,13]\)</span>,
<span class="math">\(S_5 = PGL_2(5) = [120,-1,14]\)</span>, <span class="math">\(A_6 = [360,1,15]\)</span>, <span class="math">\(S_6 = [720,-1,16]\)</span>.</p>
<p>In degree 7: <span class="math">\(C_7 = [7,1,1]\)</span>, <span class="math">\(D_7 = [14,-1,2]\)</span>, <span class="math">\(M_{21} = [21,1,3]\)</span>,
<span class="math">\(M_{42} = [42,-1,4]\)</span>, <span class="math">\(PSL_2(7) = PSL_3(2) = [168,1,5]\)</span>, <span class="math">\(A_7 = [2520,1,6]\)</span>,
<span class="math">\(S_7 = [5040,-1,7]\)</span>.</p>
<p><strong>Warning.</strong> The method used is that of resolvent polynomials and is
sensitive to the current precision. The precision is updated internally but,
in very rare cases, a wrong result may be returned if the initial precision
was not sufficient.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polgraeffe">
<tt class="descname">polgraeffe</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polgraeffe" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Graeffe transform <span class="math">\(g\)</span> of <span class="math">\(f\)</span>, such that <span class="math">\(g(x^2) = f(x)
f(-x)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polhensellift">
<tt class="descname">polhensellift</tt><big>(</big><em>A</em>, <em>B</em>, <em>p</em>, <em>e</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polhensellift" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a prime <span class="math">\(p\)</span>, an integral polynomial <span class="math">\(A\)</span> whose leading coefficient
is a <span class="math">\(p\)</span>-unit, a vector <span class="math">\(B\)</span> of integral polynomials that are monic and
pairwise relatively prime modulo <span class="math">\(p\)</span>, and whose product is congruent to
<span class="math">\(A/{lc}(A)\)</span> modulo <span class="math">\(p\)</span>, lift the elements of <span class="math">\(B\)</span> to polynomials whose
product is congruent to <span class="math">\(A\)</span> modulo <span class="math">\(p^e\)</span>.</p>
<p>More generally, if <span class="math">\(T\)</span> is an integral polynomial irreducible mod <span class="math">\(p\)</span>, and
<span class="math">\(B\)</span> is a factorization of <span class="math">\(A\)</span> over the finite field <span class="math">\(\mathbb{F}_p[t]/(T)\)</span>, you can
lift it to <span class="math">\(\mathbb{Z}_p[t]/(T, p^e)\)</span> by replacing the <span class="math">\(p\)</span> argument with <span class="math">\([p,T]\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>? { T = t^3 - 2; p = 7; A = x^2 + t + 1;
 B = [x + (3*t^2 + t + 1), x + (4*t^2 + 6*t + 6)];
 r = polhensellift(A, B, [p, T], 6) }
%1 = [x + (20191*t^2 + 50604*t + 75783), x + (97458*t^2 + 67045*t + 41866)]
? liftall( r[1] * r[2] * Mod(Mod(1,p^6),T) )
%2 = x^2 + (t + 1)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.poliscyclo">
<tt class="descname">poliscyclo</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.poliscyclo" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 0 if <span class="math">\(f\)</span> is not a cyclotomic polynomial, and <span class="math">\(n &gt; 0\)</span> if <span class="math">\(f = 
\Phi_n\)</span>, the <span class="math">\(n\)</span>-th cyclotomic polynomial.</p>
<div class="highlight-python"><div class="highlight"><pre>? poliscyclo(x^4-x^2+1)
%1 = 12
? polcyclo(12)
%2 = x^4 - x^2 + 1
? poliscyclo(x^4-x^2-1)
%3 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.poliscycloprod">
<tt class="descname">poliscycloprod</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.poliscycloprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if <span class="math">\(f\)</span> is a product of cyclotomic polynomial, and <span class="math">\(0\)</span>
otherwise.</p>
<div class="highlight-python"><div class="highlight"><pre>? f = x^6+x^5-x^3+x+1;
? poliscycloprod(f)
%2 = 1
? factor(f)
%3 =
[ x^2 + x + 1 1]

[x^4 - x^2 + 1 1]
? [ poliscyclo(T) | T &lt;- %[,1] ]
%4 = [3, 12]
? polcyclo(3) * polcyclo(12)
%5 = x^6 + x^5 - x^3 + x + 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polisirreducible">
<tt class="descname">polisirreducible</tt><big>(</big><em>pol</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polisirreducible" title="Permalink to this definition">¶</a></dt>
<dd><p><em>pol</em> being a polynomial (univariate in the present version <strong>2.8.0</strong>),
returns 1 if <em>pol</em> is non-constant and irreducible, 0 otherwise.
Irreducibility is checked over the smallest base field over which <em>pol</em>
seems to be defined.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.pollead">
<tt class="descname">pollead</tt><big>(</big><em>x</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.pollead" title="Permalink to this definition">¶</a></dt>
<dd><p>Leading coefficient of the polynomial or power series <span class="math">\(x\)</span>. This is
computed with respect to the main variable of <span class="math">\(x\)</span> if <span class="math">\(v\)</span> is omitted, with
respect to the variable <span class="math">\(v\)</span> otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polrecip">
<tt class="descname">polrecip</tt><big>(</big><em>pol</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polrecip" title="Permalink to this definition">¶</a></dt>
<dd><p>Reciprocal polynomial of <em>pol</em>, i.e.&nbsp;the coefficients are in
reverse order. <em>pol</em> must be a polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polred">
<tt class="descname">polred</tt><big>(</big><em>T</em>, <em>flag=0</em>, <em>_arg2=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polred" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is <em>deprecated</em>, use <tt class="docutils literal"><span class="pre">polredbest</span></tt> instead.
Finds polynomials with reasonably small coefficients defining subfields of
the number field defined by <span class="math">\(T\)</span>. One of the polynomials always defines <span class="math">\(\mathbb{Q}\)</span>
(hence is equal to <span class="math">\(x-1\)</span>), and another always defines the same number field
as <span class="math">\(T\)</span> if <span class="math">\(T\)</span> is irreducible.</p>
<p>All <span class="math">\(T\)</span> accepted by <tt class="docutils literal"><span class="pre">nfinit</span></tt> are also allowed here;
in particular, the format <tt class="docutils literal"><span class="pre">[T,</span> <span class="pre">listP]</span></tt> is recommended, e.g. with
<span class="math">\(listP = 10^5\)</span> or a vector containing all ramified primes. Otherwise,
the maximal order of <span class="math">\(\mathbb{Q}[x]/(T)\)</span> must be computed.</p>
<p>The following binary digits of <span class="math">\(flag\)</span> are significant:</p>
<p>1: Possibly use a suborder of the maximal order. The
primes dividing the index of the order chosen are larger than
<tt class="docutils literal"><span class="pre">primelimit</span></tt> or divide integers stored in the <tt class="docutils literal"><span class="pre">addprimes</span></tt> table.
This flag is <em>deprecated</em>, the <tt class="docutils literal"><span class="pre">[T,</span> <span class="pre">listP]</span></tt> format is more
flexible.</p>
<p>2: gives also elements. The result is a two-column matrix, the first column
giving primitive elements defining these subfields, the second giving the
corresponding minimal polynomials.</p>
<div class="highlight-python"><div class="highlight"><pre>? M = polred(x^4 + 8, 2)
%1 =
[1 x - 1]

[1/2*x^2 x^2 + 2]

[1/4*x^3 x^4 + 2]

[x x^4 + 8]
? minpoly(Mod(M[2,1], x^4+8))
%2 = x^2 + 2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polredabs">
<tt class="descname">polredabs</tt><big>(</big><em>T</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polredabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a canonical defining polynomial <span class="math">\(P\)</span> for the number field
<span class="math">\(\mathbb{Q}[X]/(T)\)</span> defined by <span class="math">\(T\)</span>, such that the sum of the squares of the modulus
of the roots (i.e.&nbsp;the <span class="math">\(T_2\)</span>-norm) is minimal. Different <span class="math">\(T\)</span> defining
isomorphic number fields will yield the same <span class="math">\(P\)</span>. All <span class="math">\(T\)</span> accepted by
<tt class="docutils literal"><span class="pre">nfinit</span></tt> are also allowed here, e.g. non-monic polynomials, or pairs
<tt class="docutils literal"><span class="pre">[T,</span> <span class="pre">listP]</span></tt> specifying that a non-maximal order may be used.</p>
<p><strong>Warning 1.</strong> Using a <tt class="docutils literal"><span class="pre">t_POL</span></tt> <span class="math">\(T\)</span> requires fully factoring the
discriminant of <span class="math">\(T\)</span>, which may be very hard. The format <tt class="docutils literal"><span class="pre">[T,</span> <span class="pre">listP]</span></tt>
computes only a suborder of the maximal order and replaces this part of the
algorithm by a polynomial time computation. In that case the polynomial <span class="math">\(P\)</span>
is a priori no longer canonical, and it may happen that it does not have
minimal <span class="math">\(T_2\)</span> norm. The routine attempts to certify the result independently
of this order computation (as per <tt class="docutils literal"><span class="pre">nfcertify</span></tt>: we try to prove that the
order is maximal); if it fails, the routine returns <span class="math">\(0\)</span> instead of <span class="math">\(P\)</span>.
In order to force an output in that case as well, you may either use
<tt class="docutils literal"><span class="pre">polredbest</span></tt>, or <tt class="docutils literal"><span class="pre">polredabs(,16)</span></tt>, or</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">polredabs</span><span class="p">([</span><span class="n">T</span><span class="p">,</span> <span class="n">nfbasis</span><span class="p">([</span><span class="n">T</span><span class="p">,</span> <span class="n">listP</span><span class="p">])])</span>
</pre></div>
</div>
<p>(In all three cases, the result is no longer canonical.)</p>
<p><strong>Warning 2.</strong> Apart from the factorization of the discriminant of
<span class="math">\(T\)</span>, this routine runs in polynomial time for a <em>fixed</em> degree.
But the complexity is exponential in the degree: this routine
may be exceedingly slow when the number field has many subfields, hence a
lot of elements of small <span class="math">\(T_2\)</span>-norm. If you do not need a canonical
polynomial, the function <tt class="docutils literal"><span class="pre">polredbest</span></tt> is in general much faster (it runs
in polynomial time), and tends to return polynomials with smaller
discriminants.</p>
<p>The binary digits of <span class="math">\(flag\)</span> mean</p>
<p>1: outputs a two-component row vector <span class="math">\([P,a]\)</span>, where <span class="math">\(P\)</span> is the default
output and <tt class="docutils literal"><span class="pre">Mod(a,</span> <span class="pre">P)</span></tt> is a root of the original <span class="math">\(T\)</span>.</p>
<p>4: gives <em>all</em> polynomials of minimal <span class="math">\(T_2\)</span> norm; of the two polynomials
<span class="math">\(P(x)\)</span> and <span class="math">\(± P(-x)\)</span>, only one is given.</p>
<p>16: Possibly use a suborder of the maximal order, <em>without</em> attempting to
certify the result as in Warning 1: we always return a polynomial and never
<span class="math">\(0\)</span>. The result is a priori not canonical.</p>
<div class="highlight-python"><div class="highlight"><pre>? T = x^16 - 136*x^14 + 6476*x^12 - 141912*x^10 + 1513334*x^8 \
 - 7453176*x^6 + 13950764*x^4 - 5596840*x^2 + 46225
? T1 = polredabs(T); T2 = polredbest(T);
? [ norml2(polroots(T1)), norml2(polroots(T2)) ]
%3 = [88.0000000, 120.000000]
? [ sizedigit(poldisc(T1)), sizedigit(poldisc(T2)) ]
%4 = [75, 67]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polredbest">
<tt class="descname">polredbest</tt><big>(</big><em>T</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polredbest" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds a polynomial with reasonably
small coefficients defining the same number field as <span class="math">\(T\)</span>.
All <span class="math">\(T\)</span> accepted by <tt class="docutils literal"><span class="pre">nfinit</span></tt> are also allowed here (e.g. non-monic
polynomials, <tt class="docutils literal"><span class="pre">nf</span></tt>, <tt class="docutils literal"><span class="pre">bnf</span></tt>, <tt class="docutils literal"><span class="pre">[T,Z_K_basis]</span></tt>). Contrary to
<tt class="docutils literal"><span class="pre">polredabs</span></tt>, this routine runs in polynomial time, but it offers no
guarantee as to the minimality of its result.</p>
<p>This routine computes an LLL-reduced basis for the ring of integers of
<span class="math">\(\mathbb{Q}[X]/(T)\)</span>, then examines small linear combinations of the basis vectors,
computing their characteristic polynomials. It returns the <em>separable</em>
<span class="math">\(P\)</span> polynomial of smallest discriminant (the one with lexicographically
smallest <tt class="docutils literal"><span class="pre">abs(Vec(P))</span></tt> in case of ties). This is a good candidate
for subsequent number field computations, since it guarantees that
the denominators of algebraic integers, when expressed in the power basis,
are reasonably small. With no claim of minimality, though.</p>
<p>It can happen that iterating this functions yields better and better
polynomials, until it stabilizes:</p>
<div class="highlight-python"><div class="highlight"><pre>? \p5
? P = X^12+8*X^8-50*X^6+16*X^4-3069*X^2+625;
? poldisc(P)*1.
%2 = 1.2622 E55
? P = polredbest(P);
? poldisc(P)*1.
%4 = 2.9012 E51
? P = polredbest(P);
? poldisc(P)*1.
%6 = 8.8704 E44
</pre></div>
</div>
<p>In this example, the initial polynomial <span class="math">\(P\)</span> is the one
returned by <tt class="docutils literal"><span class="pre">polredabs</span></tt>, and the last one is stable.</p>
<p>If <span class="math">\(flag = 1\)</span>: outputs a two-component row vector <span class="math">\([P,a]\)</span>, where <span class="math">\(P\)</span> is the
default output and <tt class="docutils literal"><span class="pre">Mod(a,</span> <span class="pre">P)</span></tt> is a root of the original <span class="math">\(T\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? [P,a] = polredbest(x^4 + 8, 1)
%1 = [x^4 + 2, Mod(x^3, x^4 + 2)]
? charpoly(a)
%2 = x^4 + 8
</pre></div>
</div>
<p>In particular, the map <span class="math">\(\mathbb{Q}[x]/(T) \\to \mathbb{Q}[x]/(P)\)</span>,
<span class="math">\(x:---&gt;Mod(a,P)\)</span> defines an isomorphism of number fields, which can
be computed as</p>
<div class="highlight-python"><div class="highlight"><pre>subst(lift(Q), &#39;x, a)
</pre></div>
</div>
<p>if <span class="math">\(Q\)</span> is a <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> modulo <span class="math">\(T\)</span>; <tt class="docutils literal"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">modreverse(a)</span></tt>
returns a <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> giving the inverse of the above map (which should be
useless since <span class="math">\(\mathbb{Q}[x]/(P)\)</span> is a priori a better representation for the number
field and its elements).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polredord">
<tt class="descname">polredord</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polredord" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds polynomials with reasonably small
coefficients and of the same degree as that of <span class="math">\(x\)</span> defining suborders of the
order defined by <span class="math">\(x\)</span>. One of the polynomials always defines <span class="math">\(\mathbb{Q}\)</span> (hence
is equal to <span class="math">\((x-1)^n\)</span>, where <span class="math">\(n\)</span> is the degree), and another always defines
the same order as <span class="math">\(x\)</span> if <span class="math">\(x\)</span> is irreducible. Useless function: try
<tt class="docutils literal"><span class="pre">polredbest</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polresultant">
<tt class="descname">polresultant</tt><big>(</big><em>x</em>, <em>y</em>, <em>v=None</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polresultant" title="Permalink to this definition">¶</a></dt>
<dd><p>Resultant of the two
polynomials <span class="math">\(x\)</span> and <span class="math">\(y\)</span> with exact entries, with respect to the main
variables of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> if <span class="math">\(v\)</span> is omitted, with respect to the variable <span class="math">\(v\)</span>
otherwise. The algorithm assumes the base ring is a domain. If you also need
the <span class="math">\(u\)</span> and <span class="math">\(v\)</span> such that <span class="math">\(x*u + y*v = {Res}(x,y)\)</span>, use the
<tt class="docutils literal"><span class="pre">polresultantext</span></tt> function.</p>
<p>If <span class="math">\(flag = 0\)</span> (default), uses the the algorithm best suited to the inputs,
either the subresultant algorithm (Lazard/Ducos variant, generic case),
a modular algorithm (inputs in <span class="math">\(\mathbb{Q}[X]\)</span>) or Sylvester&#8217;s matrix (inexact
inputs).</p>
<p>If <span class="math">\(flag = 1\)</span>, uses the determinant of Sylvester&#8217;s matrix instead; this should
always be slower than the default.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polresultantext">
<tt class="descname">polresultantext</tt><big>(</big><em>A</em>, <em>B</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polresultantext" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds polynomials <span class="math">\(U\)</span> and <span class="math">\(V\)</span> such that <span class="math">\(A*U + B*V = R\)</span>, where <span class="math">\(R\)</span> is
the resultant of <span class="math">\(U\)</span> and <span class="math">\(V\)</span> with respect to the main variables of <span class="math">\(A\)</span> and
<span class="math">\(B\)</span> if <span class="math">\(v\)</span> is omitted, and with respect to <span class="math">\(v\)</span> otherwise. Returns the row
vector <span class="math">\([U,V,R]\)</span>. The algorithm used (subresultant) assumes that the base
ring is a domain.</p>
<div class="highlight-python"><div class="highlight"><pre>? A = x*y; B = (x+y)^2;
? [U,V,R] = polresultantext(A, B)
%2 = [-y*x - 2*y^2, y^2, y^4]
? A*U + B*V
%3 = y^4
? [U,V,R] = polresultantext(A, B, y)
%4 = [-2*x^2 - y*x, x^2, x^4]
? A*U+B*V
%5 = x^4
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polroots">
<tt class="descname">polroots</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polroots" title="Permalink to this definition">¶</a></dt>
<dd><p>Complex roots of the polynomial
<em>x</em>, given as a column vector where each root is repeated according to
its multiplicity. The precision is given as for transcendental functions: in
GP it is kept in the variable <tt class="docutils literal"><span class="pre">realprecision</span></tt> and is transparent to the
user, but it must be explicitly given as a second argument in library mode.</p>
<p>The algorithm used is a modification of A.&nbsp;Schönhage&#8217;s
root-finding algorithm, due to and originally implemented by X.&nbsp;Gourdon.
Barring bugs, it is guaranteed to converge and to give the roots to the
required accuracy.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polrootsff">
<tt class="descname">polrootsff</tt><big>(</big><em>x</em>, <em>p=None</em>, <em>a=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polrootsff" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vector of distinct roots of the polynomial <span class="math">\(x\)</span> in the field
<span class="math">\(\mathbb{F}_q\)</span> defined by the irreducible polynomial <span class="math">\(a\)</span> over <span class="math">\(\mathbb{F}_p\)</span>. The
coefficients of <span class="math">\(x\)</span> must be operation-compatible with <span class="math">\(\mathbb{Z}/p\mathbb{Z}\)</span>.
Either <span class="math">\(a\)</span> or <span class="math">\(p\)</span> can omitted (in which case both are ignored) if x has
<tt class="docutils literal"><span class="pre">t_FFELT</span></tt> coefficients:</p>
<div class="highlight-python"><div class="highlight"><pre>? polrootsff(x^2 + 1, 5, y^2+3) \\ over F_5[y]/(y^2+3) ~ F_25
%1 = [Mod(Mod(3, 5), Mod(1, 5)*y^2 + Mod(3, 5)),
 Mod(Mod(2, 5), Mod(1, 5)*y^2 + Mod(3, 5))]
? t = ffgen(y^2 + Mod(3,5), &#39;t); \\ a generator for F_25 as a t_FFELT
? polrootsff(x^2 + 1) \\ not enough information to determine the base field
 *** at top-level: polrootsff(x^2+1)
 *** ^-----------------
 *** polrootsff: incorrect type in factorff.
? polrootsff(x^2 + t^0) \\ make sure one coeff. is a t_FFELT
%3 = [3, 2]
? polrootsff(x^2 + t + 1)
%4 = [2*t + 1, 3*t + 4]
</pre></div>
</div>
<p>Notice that the second syntax is easier to use and much more readable.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polrootsmod">
<tt class="descname">polrootsmod</tt><big>(</big><em>pol</em>, <em>p</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polrootsmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Row vector of roots modulo <span class="math">\(p\)</span> of the polynomial <em>pol</em>.
Multiple roots are <em>not</em> repeated.</p>
<div class="highlight-python"><div class="highlight"><pre>? polrootsmod(x^2-1,2)
%1 = [Mod(1, 2)]~
</pre></div>
</div>
<p>If <span class="math">\(p\)</span> is very small, you may set <span class="math">\(flag = 1\)</span>, which uses a naive search.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polrootspadic">
<tt class="descname">polrootspadic</tt><big>(</big><em>x</em>, <em>p</em>, <em>r</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polrootspadic" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector of <span class="math">\(p\)</span>-adic roots of the polynomial <em>pol</em>, given to
<span class="math">\(p\)</span>-adic precision <span class="math">\(r\)</span> <span class="math">\(p\)</span> is assumed to be a prime. Multiple roots are
<em>not</em> repeated. Note that this is not the same as the roots in
<span class="math">\(\mathbb{Z}/p^r\mathbb{Z}\)</span>, rather it gives approximations in <span class="math">\(\mathbb{Z}/p^r\mathbb{Z}\)</span> of the true roots
living in <span class="math">\(\mathbb{Q}_p\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? polrootspadic(x^3 - x^2 + 64, 2, 5)
%1 = [2^3 + O(2^5), 2^3 + 2^4 + O(2^5), 1 + O(2^5)]~
</pre></div>
</div>
<p>If <em>pol</em> has inexact <tt class="docutils literal"><span class="pre">t_PADIC</span></tt> coefficients, this is not always
well-defined; in this case, the polynomial is first made integral by dividing
out the <span class="math">\(p\)</span>-adic content, then lifted
to <span class="math">\(\mathbb{Z}\)</span> using <tt class="docutils literal"><span class="pre">truncate</span></tt> coefficientwise. Hence the roots given are
approximations of the roots of an exact polynomial which is <span class="math">\(p\)</span>-adically
close to the input. To avoid pitfalls, we advise to only factor polynomials
with eact rational coefficients.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polrootsreal">
<tt class="descname">polrootsreal</tt><big>(</big><em>T</em>, <em>ab=None</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polrootsreal" title="Permalink to this definition">¶</a></dt>
<dd><p>Real roots of the polynomial <span class="math">\(T\)</span> with rational coefficients, multiple
roots being included according to their multiplicity. The roots are given
to a relative accuracy of <tt class="docutils literal"><span class="pre">realprecision</span></tt>. If argument <em>ab</em> is
present, it must be a vector <span class="math">\([a,b]\)</span> with two components (of type
<tt class="docutils literal"><span class="pre">t_INT</span></tt>, <tt class="docutils literal"><span class="pre">t_FRAC</span></tt> or <tt class="docutils literal"><span class="pre">t_INFINITY</span></tt>) and we restrict to roots belonging
to that closed interval.</p>
<div class="highlight-python"><div class="highlight"><pre>? \p9
? polrootsreal(x^2-2)
%1 = [-1.41421356, 1.41421356]~
? polrootsreal(x^2-2, [1,+oo])
%2 = [1.41421356]~
? polrootsreal(x^2-2, [2,3])
%3 = []~
? polrootsreal((x-1)*(x-2), [2,3])
%4 = [2.00000000]~
</pre></div>
</div>
<p>The algorithm used is a modification of Uspensky&#8217;s method (relying on
Descartes&#8217;s rule of sign), following Rouillier and Zimmerman &#8220;Efficient
isolation of a polynomial real roots&#8221;
(<tt class="docutils literal"><span class="pre">http://hal.inria.fr/inria-00072518/</span></tt>. Barring bugs, it is guaranteed
to converge and to give the roots to the required accuracy.</p>
<p><strong>Remark.</strong> If the polynomial <span class="math">\(T\)</span> is of the
form <span class="math">\(Q(x^h)\)</span> for some <span class="math">\(h &gt;= 2\)</span> and <em>ab</em> is omitted, the routine will
apply the algorithm to <span class="math">\(Q\)</span> (restricting to non-negative roots when <span class="math">\(h\)</span> is
even), then take <span class="math">\(h\)</span>-th roots. On the other hand, if you want to specify
<em>ab</em>, you should apply the routine to <span class="math">\(Q\)</span> yourself and a suitable
interval <span class="math">\([a',b']\)</span> using approximate <span class="math">\(h\)</span>-th roots adapted to your problem:
the function will not perform this change of variables if <em>ab</em> is present.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polsturm">
<tt class="descname">polsturm</tt><big>(</big><em>T</em>, <em>ab=None</em>, <em>_arg2=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polsturm" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of real roots of the real squarefree polynomial <em>T</em>. If
the argument <em>ab</em> is present, it must be a vector <span class="math">\([a,b]\)</span> with
two real components (of type <tt class="docutils literal"><span class="pre">t_INT</span></tt>, <tt class="docutils literal"><span class="pre">t_REAL</span></tt>, <tt class="docutils literal"><span class="pre">t_FRAC</span></tt>
or <tt class="docutils literal"><span class="pre">t_INFINITY</span></tt>) and we count roots belonging to that closed interval.</p>
<p>If possible, you should stick to exact inputs, that is avoid <tt class="docutils literal"><span class="pre">t_REAL</span></tt>&nbsp;s in
<span class="math">\(T\)</span> and the bounds <span class="math">\(a,b\)</span>: the result is then guaranteed and we use a fast
algorithm (Uspensky&#8217;s method, relying on Descartes&#8217;s rule of sign, see
<tt class="docutils literal"><span class="pre">polrootsreal</span></tt>); otherwise, we use Sturm&#8217;s algorithm and the result
may be wrong due to round-off errors.</p>
<div class="highlight-python"><div class="highlight"><pre>? T = (x-1)*(x-2)*(x-3);
? polsturm(T)
%2 = 3
? polsturm(T, [-oo,2])
%3 = 2
? polsturm(T, [1/2,+oo])
%4 = 3
? polsturm(T, [1, Pi]) \\ Pi inexact: not recommended !
%5 = 3
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polsylvestermatrix">
<tt class="descname">polsylvestermatrix</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polsylvestermatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Forms the Sylvester matrix
corresponding to the two polynomials <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, where the coefficients of
the polynomials are put in the columns of the matrix (which is the natural
direction for solving equations afterwards). The use of this matrix can be
essential when dealing with polynomials with inexact entries, since
polynomial Euclidean division doesn&#8217;t make much sense in this case.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polsym">
<tt class="descname">polsym</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polsym" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the column vector of the symmetric powers of the roots of the
polynomial <span class="math">\(x\)</span> up to power <span class="math">\(n\)</span>, using Newton&#8217;s formula.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.poltschirnhaus">
<tt class="descname">poltschirnhaus</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.poltschirnhaus" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a random Tschirnhausen
transformation to the polynomial <span class="math">\(x\)</span>, which is assumed to be non-constant
and separable, so as to obtain a new equation for the étale algebra
defined by <span class="math">\(x\)</span>. This is for instance useful when computing resolvents,
hence is used by the <tt class="docutils literal"><span class="pre">polgalois</span></tt> function.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.powers">
<tt class="descname">powers</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.powers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vector <span class="math">\([1,x,...,x^n]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.precision">
<tt class="descname">precision</tt><big>(</big><em>x</em>, <em>n=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.precision" title="Permalink to this definition">¶</a></dt>
<dd><p>The function has two different behaviors according to whether <span class="math">\(n\)</span> is present or not.</p>
<p>If <span class="math">\(n\)</span> is missing, the function returns the precision in decimal digits of the
PARI object <span class="math">\(x\)</span>. If <span class="math">\(x\)</span> is
an exact object, the largest single precision integer is returned.</p>
<div class="highlight-python"><div class="highlight"><pre>? precision(exp(1e-100))
%1 = 134 \\ 134 significant decimal digits
? precision(2 + x)
%2 = 2147483647 \\ exact object
? precision(0.5 + O(x))
%3 = 28 \\ floating point accuracy, NOT series precision
? precision( [ exp(1e-100), 0.5 ] )
%4 = 28 \\ minimal accuracy among components
</pre></div>
</div>
<p>The return value for exact objects is meaningless since it is not even the
same on 32 and 64-bit machines. The proper way to test whether an object is
exact is</p>
<div class="highlight-python"><div class="highlight"><pre>? isexact(x) = precision(x) == precision(0)
</pre></div>
</div>
<p>If <span class="math">\(n\)</span> is present, the function creates a new object equal to <span class="math">\(x\)</span> with a new
&#8220;precision&#8221; <span class="math">\(n\)</span>. (This never changes the type of the result. In particular
it is not possible to use it to obtain a polynomial from a power series; for
that, see <tt class="docutils literal"><span class="pre">truncate</span></tt>.) Now the meaning of precision is different from the
above (floating point accuracy), and depends on the type of <span class="math">\(x\)</span>:</p>
<p>For exact types, no change. For <span class="math">\(x\)</span> a vector or a matrix, the operation is
done componentwise.</p>
<p>For real <span class="math">\(x\)</span>, <span class="math">\(n\)</span> is the number of desired significant <em>decimal</em>
digits. If <span class="math">\(n\)</span> is smaller than the precision of <span class="math">\(x\)</span>, <span class="math">\(x\)</span> is truncated,
otherwise <span class="math">\(x\)</span> is extended with zeros.</p>
<p>For <span class="math">\(x\)</span> a <span class="math">\(p\)</span>-adic or a power series, <span class="math">\(n\)</span> is the desired number of
<em>significant</em> <span class="math">\(p\)</span>-adic or <span class="math">\(X\)</span>-adic digits, where <span class="math">\(X\)</span> is the main
variable of <span class="math">\(x\)</span>. (Note: yes, this is inconsistent.)
Note that the precision is a priori distinct from the exponent <span class="math">\(k\)</span> appearing
in <span class="math">\(O(*^k)\)</span>; it is indeed equal to <span class="math">\(k\)</span> if and only if <span class="math">\(x\)</span> is a <span class="math">\(p\)</span>-adic
or <span class="math">\(X\)</span>-adic <em>unit</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>? precision(1 + O(x), 10)
%1 = 1 + O(x^10)
? precision(x^2 + O(x^10), 3)
%2 = x^2 + O(x^5)
? precision(7^2 + O(7^10), 3)
%3 = 7^2 + O(7^5)
</pre></div>
</div>
<p>For the last two examples, note that <span class="math">\(x^2 + O(x^5) = x^2(1 + O(x^3))\)</span>
indeed has 3 significant coefficients</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.precprime">
<tt class="descname">precprime</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.precprime" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the largest pseudoprime (see
<tt class="docutils literal"><span class="pre">ispseudoprime</span></tt>) less than or equal to <span class="math">\(x\)</span>. <span class="math">\(x\)</span> can be of any real type.
Returns 0 if <span class="math">\(x &lt;= 1\)</span>. Note that if <span class="math">\(x\)</span> is a prime, this function returns <span class="math">\(x\)</span>
and not the largest prime strictly smaller than <span class="math">\(x\)</span>. To rigorously prove that
the result is prime, use <tt class="docutils literal"><span class="pre">isprime</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.primepi">
<tt class="descname">primepi</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.primepi" title="Permalink to this definition">¶</a></dt>
<dd><p>The prime counting function. Returns the number of
primes <span class="math">\(p\)</span>, <span class="math">\(p &lt;= x\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? primepi(10)
%1 = 4;
? primes(5)
%2 = [2, 3, 5, 7, 11]
? primepi(10^11)
%3 = 4118054813
</pre></div>
</div>
<p>Uses checkpointing and a naive <span class="math">\(O(x)\)</span> algorithm.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.primes">
<tt class="descname">primes</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.primes" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a row vector whose components are the first <span class="math">\(n\)</span> prime numbers.
(Returns the empty vector for <span class="math">\(n &lt;= 0\)</span>.) A <tt class="docutils literal"><span class="pre">t_VEC</span></tt> <span class="math">\(n = [a,b]\)</span> is also
allowed, in which case the primes in <span class="math">\([a,b]\)</span> are returned</p>
<div class="highlight-python"><div class="highlight"><pre>? primes(10) \\ the first 10 primes
%1 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
? primes([0,29]) \\ the primes up to 29
%2 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
? primes([15,30])
%3 = [17, 19, 23, 29]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.psi">
<tt class="descname">psi</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.psi" title="Permalink to this definition">¶</a></dt>
<dd><p>The <span class="math">\(\psi\)</span>-function of <span class="math">\(x\)</span>, i.e.&nbsp;the logarithmic derivative
<span class="math">\(\Gamma'(x)/\Gamma(x)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfauto">
<tt class="descname">qfauto</tt><big>(</big><em>G</em>, <em>fl=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfauto" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(G\)</span> being a square and symmetric matrix with integer entries representing a
positive definite quadratic form, outputs the automorphism group of the
associate lattice.
Since this requires computing the minimal vectors, the computations can
become very lengthy as the dimension grows. <span class="math">\(G\)</span> can also be given by an
<tt class="docutils literal"><span class="pre">qfisominit</span></tt> structure.
See <tt class="docutils literal"><span class="pre">qfisominit</span></tt> for the meaning of <em>fl</em>.</p>
<p>The output is a two-components vector <span class="math">\([o,g]\)</span> where <span class="math">\(o\)</span> is the group order
and <span class="math">\(g\)</span> is the list of generators (as a vector). For each generator <span class="math">\(H\)</span>,
the equality <span class="math">\(G = {^t}H G H\)</span> holds.</p>
<p>The interface of this function is experimental and will likely change in the
future.</p>
<p>This function implements an algorithm of Plesken and Souvignier, following
Souvignier&#8217;s implementation.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfautoexport">
<tt class="descname">qfautoexport</tt><big>(</big><em>qfa</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfautoexport" title="Permalink to this definition">¶</a></dt>
<dd><p><em>qfa</em> being an automorphism group as output by
<tt class="docutils literal"><span class="pre">qfauto</span></tt>, export the underlying matrix group as a string suitable
for (no flags or <span class="math">\(flag = 0\)</span>) GAP or (<span class="math">\(flag = 1\)</span>) Magma. The following example
computes the size of the matrix group using GAP:</p>
<div class="highlight-python"><div class="highlight"><pre>? G = qfauto([2,1;1,2])
%1 = [12, [[-1, 0; 0, -1], [0, -1; 1, 1], [1, 1; 0, -1]]]
? s = qfautoexport(G)
%2 = &quot;Group([[-1, 0], [0, -1]], [[0, -1], [1, 1]], [[1, 1], [0, -1]])&quot;
? extern(&quot;echo \&quot;Order(&quot;s&quot;);\&quot; | gap -q&quot;)
%3 = 12
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbclassno">
<tt class="descname">qfbclassno</tt><big>(</big><em>D</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbclassno" title="Permalink to this definition">¶</a></dt>
<dd><p>Ordinary class number of the quadratic order of discriminant <span class="math">\(D\)</span>, for
&#8220;small&#8221; values of <span class="math">\(D\)</span>.</p>
<ul class="simple">
<li>if <span class="math">\(D &gt; 0\)</span> or <span class="math">\(flag = 1\)</span>, use a <span class="math">\(O(\|D\|^{1/2})\)</span>
algorithm (compute <span class="math">\(L(1,\chi_D)\)</span> with the approximate functional equation).
This is slower than <tt class="docutils literal"><span class="pre">quadclassunit</span></tt> as soon as <span class="math">\(|D| ~ 10^2\)</span> or
so and is not meant to be used for large <span class="math">\(D\)</span>.</li>
<li>if <span class="math">\(D &lt; 0\)</span> and <span class="math">\(flag = 0\)</span> (or omitted), use a <span class="math">\(O(\|D\|^{1/4})\)</span>
algorithm (Shanks&#8217;s baby-step/giant-step method). It should
be faster than <tt class="docutils literal"><span class="pre">quadclassunit</span></tt> for small values of <span class="math">\(D\)</span>, say
<span class="math">\(|D| &lt; 10^{18}\)</span>.</li>
</ul>
<p><strong>Important warning.</strong> In the latter case, this function only
implements part of Shanks&#8217;s method (which allows to speed it up
considerably). It gives unconditionnally correct results for <span class="math">\(\|D\| &lt; 2.
10^{10}\)</span>, but may give incorrect results for larger values if the class
group has many cyclic factors. We thus recommend to double-check results
using the function <tt class="docutils literal"><span class="pre">quadclassunit</span></tt>, which is about 2 to 3 times slower in
the above range, assuming GRH. We currently have no counter-examples but
they should exist: we&#8217;d appreciate a bug report if you find one.</p>
<p><strong>Warning.</strong> Contrary to what its name implies, this routine does not
compute the number of classes of binary primitive forms of discriminant <span class="math">\(D\)</span>,
which is equal to the <em>narrow</em> class number. The two notions are the same
when <span class="math">\(D &lt; 0\)</span> or the fundamental unit <span class="math">\(\varepsilon\)</span> has negative norm; when <span class="math">\(D
&gt; 0\)</span> and <span class="math">\(N\varepsilon &gt; 0\)</span>, the number of classes of forms is twice the
ordinary class number. This is a problem which we cannot fix for backward
compatibility reasons. Use the following routine if you are only interested
in the number of classes of forms:</p>
<div class="highlight-python"><div class="highlight"><pre>QFBclassno(D) =
qfbclassno(D) * if (D &lt; 0 || norm(quadunit(D)) &lt; 0, 1, 2)
</pre></div>
</div>
<p>Here are a few examples:</p>
<div class="highlight-python"><div class="highlight"><pre>? qfbclassno(400000028)
time = 3,140 ms.
%1 = 1
? quadclassunit(400000028).no
time = 20 ms. \\{ much faster}
%2 = 1
? qfbclassno(-400000028)
time = 0 ms.
%3 = 7253 \\{ correct, and fast enough}
? quadclassunit(-400000028).no
time = 0 ms.
%4 = 7253
</pre></div>
</div>
<p>See also <tt class="docutils literal"><span class="pre">qfbhclassno</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbcompraw">
<tt class="descname">qfbcompraw</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbcompraw" title="Permalink to this definition">¶</a></dt>
<dd><p>composition of the binary quadratic forms <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, without
reduction of the result. This is useful e.g.&nbsp;to compute a generating
element of an ideal. The result is undefined if <span class="math">\(x\)</span> and <span class="math">\(y\)</span> do not have the
same discriminant.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbhclassno">
<tt class="descname">qfbhclassno</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbhclassno" title="Permalink to this definition">¶</a></dt>
<dd><p>Hurwitz class number of <span class="math">\(x\)</span>, where
<span class="math">\(x\)</span> is non-negative and congruent to 0 or 3 modulo 4. For <span class="math">\(x &gt; 5.
10^5\)</span>, we assume the GRH, and use <tt class="docutils literal"><span class="pre">quadclassunit</span></tt> with default
parameters.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbil">
<tt class="descname">qfbil</tt><big>(</big><em>x</em>, <em>y</em>, <em>q=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbil" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the bilinear form <span class="math">\(q\)</span> (symmetric matrix)
at the vectors <span class="math">\((x,y)\)</span>; if <span class="math">\(q\)</span> omitted, use the standard Euclidean scalar
product, corresponding to the identity matrix.</p>
<p>Roughly equivalent to <tt class="docutils literal"><span class="pre">x~</span> <span class="pre">*</span> <span class="pre">q</span> <span class="pre">*</span> <span class="pre">y</span></tt>, but a little faster and
more convenient (does not distinguish between column and row vectors):</p>
<div class="highlight-python"><div class="highlight"><pre>? x = [1,2,3]~; y = [-1,0,1]~; qfbil(x,y)
%1 = 2
? q = [1,2,3;2,2,-1;3,-1,0]; qfbil(x,y, q)
%2 = -13
? for(i=1,10^6, qfbil(x,y,q))
%3 = 568ms
? for(i=1,10^6, x~*q*y)
%4 = 717ms
</pre></div>
</div>
<p>The associated quadratic form is also available, as
<tt class="docutils literal"><span class="pre">qfnorm</span></tt>, slightly faster:</p>
<div class="highlight-python"><div class="highlight"><pre>? for(i=1,10^6, qfnorm(x,q))
time = 444ms
? for(i=1,10^6, qfnorm(x))
time = 176 ms.
? for(i=1,10^6, qfbil(x,y))
time = 208 ms.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbnucomp">
<tt class="descname">qfbnucomp</tt><big>(</big><em>x</em>, <em>y</em>, <em>L</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbnucomp" title="Permalink to this definition">¶</a></dt>
<dd><p>composition of the primitive positive
definite binary quadratic forms <span class="math">\(x\)</span> and <span class="math">\(y\)</span> (type <tt class="docutils literal"><span class="pre">t_QFI</span></tt>) using the NUCOMP
and NUDUPL algorithms of Shanks, à la Atkin. <span class="math">\(L\)</span> is any positive
constant, but for optimal speed, one should take <span class="math">\(L = \|D/4\|^{1/4}\)</span>, i.e.
<tt class="docutils literal"><span class="pre">sqrtnint(abs(D)</span> <span class="pre">&gt;&gt;</span> <span class="pre">2,4)</span></tt>, where <span class="math">\(D\)</span> is the common discriminant of <span class="math">\(x\)</span> and
<span class="math">\(y\)</span>. When <span class="math">\(x\)</span> and <span class="math">\(y\)</span> do not have the same discriminant, the result is
undefined.</p>
<p>The current implementation is slower than the generic routine for small <span class="math">\(D\)</span>,
and becomes faster when <span class="math">\(D\)</span> has about <span class="math">\(45\)</span> bits.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbnupow">
<tt class="descname">qfbnupow</tt><big>(</big><em>x</em>, <em>n</em>, <em>L=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbnupow" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(n\)</span>-th power of the primitive positive definite
binary quadratic form <span class="math">\(x\)</span> using Shanks&#8217;s NUCOMP and NUDUPL algorithms;
if set, <span class="math">\(L\)</span> should be equal to <tt class="docutils literal"><span class="pre">sqrtnint(abs(D)</span> <span class="pre">&gt;&gt;</span> <span class="pre">2,4)</span></tt>, where <span class="math">\(D &lt; 0\)</span> is
the discriminant of <span class="math">\(x\)</span>.</p>
<p>The current implementation is slower than the generic routine for small
discriminant <span class="math">\(D\)</span>, and becomes faster for <span class="math">\(D ~ 2^45\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbpowraw">
<tt class="descname">qfbpowraw</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbpowraw" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(n\)</span>-th power of the binary quadratic form
<span class="math">\(x\)</span>, computed without doing any reduction (i.e.&nbsp;using <tt class="docutils literal"><span class="pre">qfbcompraw</span></tt>).
Here <span class="math">\(n\)</span> must be non-negative and <span class="math">\(n &lt; 2^{31}\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbprimeform">
<tt class="descname">qfbprimeform</tt><big>(</big><em>x</em>, <em>p</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbprimeform" title="Permalink to this definition">¶</a></dt>
<dd><p>Prime binary quadratic form of discriminant
<span class="math">\(x\)</span> whose first coefficient is <span class="math">\(p\)</span>, where <span class="math">\(\|p\|\)</span> is a prime number.
By abuse of notation,
<span class="math">\(p = ± 1\)</span> is also valid and returns the unit form. Returns an
error if <span class="math">\(x\)</span> is not a quadratic residue mod <span class="math">\(p\)</span>, or if <span class="math">\(x &lt; 0\)</span> and <span class="math">\(p &lt; 0\)</span>.
(Negative definite <tt class="docutils literal"><span class="pre">t_QFI</span></tt> are not implemented.) In the case where <span class="math">\(x &gt; 0\)</span>,
the &#8220;distance&#8221; component of the form is set equal to zero according to the
current precision.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbred">
<tt class="descname">qfbred</tt><big>(</big><em>x</em>, <em>flag=0</em>, <em>d=None</em>, <em>isd=None</em>, <em>sd=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbred" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces the binary quadratic form <span class="math">\(x\)</span> (updating Shanks&#8217;s distance function
if <span class="math">\(x\)</span> is indefinite). The binary digits of <span class="math">\(flag\)</span> are toggles meaning</p>
<p>&nbsp;&nbsp;1: perform a single reduction step</p>
<p>&nbsp;&nbsp;2: don&#8217;t update Shanks&#8217;s distance</p>
<p>The arguments <span class="math">\(d\)</span>, <em>isd</em>, <em>sd</em>, if present, supply the values of the
discriminant, <span class="math">\(floor{\sqrt{d}}\)</span>, and <span class="math">\(\sqrt{d}\)</span> respectively
(no checking is done of these facts). If <span class="math">\(d &lt; 0\)</span> these values are useless,
and all references to Shanks&#8217;s distance are irrelevant.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbredsl2">
<tt class="descname">qfbredsl2</tt><big>(</big><em>x</em>, <em>data=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbredsl2" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduction of the (real or imaginary) binary quadratic form <span class="math">\(x\)</span>, return
<span class="math">\([y,g]\)</span> where <span class="math">\(y\)</span> is reduced and <span class="math">\(g\)</span> in <span class="math">\({SL}(2,\mathbb{Z})\)</span> is such that
<span class="math">\(g.x = y\)</span>; <em>data</em>, if
present, must be equal to <span class="math">\([D, sqrtint(D)]\)</span>, where <span class="math">\(D &gt; 0\)</span> is the
discriminant of <span class="math">\(x\)</span>. In case <span class="math">\(x\)</span> is <tt class="docutils literal"><span class="pre">t_QFR</span></tt>, the distance component is
unaffected.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbsolve">
<tt class="descname">qfbsolve</tt><big>(</big><em>Q</em>, <em>p</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the equation <span class="math">\(Q(x,y) = p\)</span> over the integers,
where <span class="math">\(Q\)</span> is a binary quadratic form and <span class="math">\(p\)</span> a prime number.</p>
<p>Return <span class="math">\([x,y]\)</span> as a two-components vector, or zero if there is no solution.
Note that this function returns only one solution and not all the solutions.</p>
<p>Let <span class="math">\(D = \mathrm{disc} Q\)</span>. The algorithm used runs in probabilistic polynomial time
in <span class="math">\(p\)</span> (through the computation of a square root of <span class="math">\(D\)</span> modulo <span class="math">\(p\)</span>); it is
polynomial time in <span class="math">\(D\)</span> if <span class="math">\(Q\)</span> is imaginary, but exponential time if <span class="math">\(Q\)</span> is
real (through the computation of a full cycle of reduced forms). In the
latter case, note that <tt class="docutils literal"><span class="pre">bnfisprincipal</span></tt> provides a solution in heuristic
subexponential time in <span class="math">\(D\)</span> assuming the GRH.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfgaussred">
<tt class="descname">qfgaussred</tt><big>(</big><em>q</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfgaussred" title="Permalink to this definition">¶</a></dt>
<dd><p>decomposition into squares of the
quadratic form represented by the symmetric matrix <span class="math">\(q\)</span>. The result is a
matrix whose diagonal entries are the coefficients of the squares, and the
off-diagonal entries on each line represent the bilinear forms. More
precisely, if <span class="math">\((a_{ij})\)</span> denotes the output, one has</p>
<div class="math">
\[q(x) = \sum_i a_{ii} (x_i + \sum_{j != i} a_{ij} x_j)^2\]</div>
<div class="highlight-python"><div class="highlight"><pre>? qfgaussred([0,1;1,0])
%1 =
[1/2 1]

[-1 -1/2]
</pre></div>
</div>
<p>This means that <span class="math">\(2xy = (1/2)(x+y)^2 - (1/2)(x-y)^2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfisom">
<tt class="descname">qfisom</tt><big>(</big><em>G</em>, <em>H</em>, <em>fl=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfisom" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(G\)</span>, <span class="math">\(H\)</span> being square and symmetric matrices with integer entries representing
positive definite quadratic forms, return an invertible matrix <span class="math">\(S\)</span> such that
<span class="math">\(G = {^t}S H S\)</span>. This defines a isomorphism between the corresponding lattices.
Since this requires computing the minimal vectors, the computations can
become very lengthy as the dimension grows.
See <tt class="docutils literal"><span class="pre">qfisominit</span></tt> for the meaning of <em>fl</em>.</p>
<p><span class="math">\(G\)</span> can also be given by an <tt class="docutils literal"><span class="pre">qfisominit</span></tt> structure which is preferable if
several forms <span class="math">\(H\)</span> need to be compared to <span class="math">\(G\)</span>.</p>
<p>This function implements an algorithm of Plesken and Souvignier, following
Souvignier&#8217;s implementation.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfisominit">
<tt class="descname">qfisominit</tt><big>(</big><em>G</em>, <em>fl=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfisominit" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(G\)</span> being a square and symmetric matrix with integer entries representing a
positive definite quadratic form, return an <tt class="docutils literal"><span class="pre">isom</span></tt> structure allowing to
compute isomorphisms between <span class="math">\(G\)</span> and other quadratic forms faster.</p>
<p>The interface of this function is experimental and will likely change in future
release.</p>
<p>If present, the optional parameter <em>fl</em> must be a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> with two
components. It allows to specify the invariants used, which can make the
computation faster or slower. The components are</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">fl[1]</span></tt> Depth of scalar product combination to use.</li>
<li><tt class="docutils literal"><span class="pre">fl[2]</span></tt> Maximum level of Bacher polynomials to use.</li>
</ul>
<p>Since this function computes the minimal vectors, it can become very lengthy
as the dimension of <span class="math">\(G\)</span> grows.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfjacobi">
<tt class="descname">qfjacobi</tt><big>(</big><em>A</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfjacobi" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Jacobi&#8217;s eigenvalue algorithm to the real symmetric matrix <span class="math">\(A\)</span>.
This returns <span class="math">\([L, V]\)</span>, where</p>
<ul class="simple">
<li><span class="math">\(L\)</span> is the vector of (real) eigenvalues of <span class="math">\(A\)</span>, sorted in increasing
order,</li>
<li><span class="math">\(V\)</span> is the corresponding orthogonal matrix of eigenvectors of <span class="math">\(A\)</span>.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? \p19
? A = [1,2;2,1]; mateigen(A)
%1 =
[-1 1]

[ 1 1]
? [L, H] = qfjacobi(A);
? L
%3 = [-1.000000000000000000, 3.000000000000000000]~
? H
%4 =
[ 0.7071067811865475245 0.7071067811865475244]

[-0.7071067811865475244 0.7071067811865475245]
? norml2( (A-L[1])*H[,1] ) \\ approximate eigenvector
%5 = 9.403954806578300064 E-38
? norml2(H*H~ - 1)
%6 = 2.350988701644575016 E-38 \\ close to orthogonal
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qflll">
<tt class="descname">qflll</tt><big>(</big><em>x</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qflll" title="Permalink to this definition">¶</a></dt>
<dd><p>LLL algorithm applied to the
<em>columns</em> of the matrix <span class="math">\(x\)</span>. The columns of <span class="math">\(x\)</span> may be linearly
dependent. The result is a unimodular transformation matrix <span class="math">\(T\)</span> such that <span class="math">\(x
.T\)</span> is an LLL-reduced basis of the lattice generated by the column
vectors of <span class="math">\(x\)</span>. Note that if <span class="math">\(x\)</span> is not of maximal rank <span class="math">\(T\)</span> will not be
square. The LLL parameters are <span class="math">\((0.51,0.99)\)</span>, meaning that the Gram-Schmidt
coefficients for the final basis satisfy <span class="math">\(\mu_{i,j} &lt;= \|0.51\|\)</span>, and the
Lovász&#8217;s constant is <span class="math">\(0.99\)</span>.</p>
<p>If <span class="math">\(flag = 0\)</span> (default), assume that <span class="math">\(x\)</span> has either exact (integral or
rational) or real floating point entries. The matrix is rescaled, converted
to integers and the behavior is then as in <span class="math">\(flag = 1\)</span>.</p>
<p>If <span class="math">\(flag = 1\)</span>, assume that <span class="math">\(x\)</span> is integral. Computations involving Gram-Schmidt
vectors are approximate, with precision varying as needed (Lehmer&#8217;s trick,
as generalized by Schnorr). Adapted from Nguyen and Stehlé&#8217;s algorithm
and Stehlé&#8217;s code (<tt class="docutils literal"><span class="pre">fplll-1.3</span></tt>).</p>
<p>If <span class="math">\(flag = 2\)</span>, <span class="math">\(x\)</span> should be an integer matrix whose columns are linearly
independent. Returns a partially reduced basis for <span class="math">\(x\)</span>, using an unpublished
algorithm by Peter Montgomery: a basis is said to be <em>partially reduced</em>
if <span class="math">\(\|v_i ± v_j\| &gt;= \|v_i\|\)</span> for any two distinct basis vectors <span class="math">\(v_i, 
v_j\)</span>.</p>
<p>This is faster than <span class="math">\(flag = 1\)</span>, esp. when one row is huge compared
to the other rows (knapsack-style), and should quickly produce relatively
short vectors. The resulting basis is <em>not</em> LLL-reduced in general.
If LLL reduction is eventually desired, avoid this partial reduction:
applying LLL to the partially reduced matrix is significantly <em>slower</em>
than starting from a knapsack-type lattice.</p>
<p>If <span class="math">\(flag = 4\)</span>, as <span class="math">\(flag = 1\)</span>, returning a vector <span class="math">\([K, T]\)</span> of matrices: the
columns of <span class="math">\(K\)</span> represent a basis of the integer kernel of <span class="math">\(x\)</span>
(not LLL-reduced in general) and <span class="math">\(T\)</span> is the transformation
matrix such that <span class="math">\(x.T\)</span> is an LLL-reduced <span class="math">\(\mathbb{Z}\)</span>-basis of the image
of the matrix <span class="math">\(x\)</span>.</p>
<p>If <span class="math">\(flag = 5\)</span>, case as case <span class="math">\(4\)</span>, but <span class="math">\(x\)</span> may have polynomial coefficients.</p>
<p>If <span class="math">\(flag = 8\)</span>, same as case <span class="math">\(0\)</span>, but <span class="math">\(x\)</span> may have polynomial coefficients.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qflllgram">
<tt class="descname">qflllgram</tt><big>(</big><em>G</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qflllgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <tt class="docutils literal"><span class="pre">qflll</span></tt>, except that the
matrix <span class="math">\(G = x~ * x\)</span> is the Gram matrix of some lattice vectors <span class="math">\(x\)</span>,
and not the coordinates of the vectors themselves. In particular, <span class="math">\(G\)</span> must
now be a square symmetric real matrix, corresponding to a positive
quadratic form (not necessarily definite: <span class="math">\(x\)</span> needs not have maximal rank).
The result is a unimodular
transformation matrix <span class="math">\(T\)</span> such that <span class="math">\(x.T\)</span> is an LLL-reduced basis of
the lattice generated by the column vectors of <span class="math">\(x\)</span>. See <tt class="docutils literal"><span class="pre">qflll</span></tt> for
further details about the LLL implementation.</p>
<p>If <span class="math">\(flag = 0\)</span> (default), assume that <span class="math">\(G\)</span> has either exact (integral or
rational) or real floating point entries. The matrix is rescaled, converted
to integers and the behavior is then as in <span class="math">\(flag = 1\)</span>.</p>
<p>If <span class="math">\(flag = 1\)</span>, assume that <span class="math">\(G\)</span> is integral. Computations involving Gram-Schmidt
vectors are approximate, with precision varying as needed (Lehmer&#8217;s trick,
as generalized by Schnorr). Adapted from Nguyen and Stehlé&#8217;s algorithm
and Stehlé&#8217;s code (<tt class="docutils literal"><span class="pre">fplll-1.3</span></tt>).</p>
<p><span class="math">\(flag = 4\)</span>: <span class="math">\(G\)</span> has integer entries, gives the kernel and reduced image of <span class="math">\(x\)</span>.</p>
<p><span class="math">\(flag = 5\)</span>: same as <span class="math">\(4\)</span>, but <span class="math">\(G\)</span> may have polynomial coefficients.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfminim">
<tt class="descname">qfminim</tt><big>(</big><em>x</em>, <em>b=None</em>, <em>m=None</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfminim" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> being a square and symmetric matrix representing a positive definite
quadratic form, this function deals with the vectors of <span class="math">\(x\)</span> whose norm is
less than or equal to <span class="math">\(b\)</span>, enumerated using the Fincke-Pohst algorithm,
storing at most <span class="math">\(m\)</span> vectors (no limit if <span class="math">\(m\)</span> is omitted). The function
searches for the minimal non-zero vectors if <span class="math">\(b\)</span> is omitted. The behavior is
undefined if <span class="math">\(x\)</span> is not positive definite (a &#8220;precision too low&#8221; error is
most likely, although more precise error messages are possible). The precise
behavior depends on <span class="math">\(flag\)</span>.</p>
<p>If <span class="math">\(flag = 0\)</span> (default), seeks at most <span class="math">\(2m\)</span> vectors. The result is a
three-component vector, the first component being the number of vectors
found, the second being the maximum norm found, and the last vector is a
matrix whose columns are the vectors found, only one being given for each
pair <span class="math">\(± v\)</span> (at most <span class="math">\(m\)</span> such pairs, unless <span class="math">\(m\)</span> was omitted). The vectors
are returned in no particular order.</p>
<p>If <span class="math">\(flag = 1\)</span>, ignores <span class="math">\(m\)</span> and returns <span class="math">\([N,v]\)</span>, where <span class="math">\(v\)</span> is a non-zero vector
of length <span class="math">\(N &lt;= b\)</span>, or <span class="math">\([]\)</span> if no non-zero vector has length <span class="math">\(&lt;= b\)</span>.
If no explicit <span class="math">\(b\)</span> is provided, return a vector of smallish norm
(smallest vector in an LLL-reduced basis).</p>
<p>In these two cases, <span class="math">\(x\)</span> must have <em>integral</em> entries. The
implementation uses low precision floating point computations for maximal
speed, which gives incorrect result when <span class="math">\(x\)</span> has large entries. (The
condition is checked in the code and the routine raises an error if
large rounding errors occur.) A more robust, but much slower,
implementation is chosen if the following flag is used:</p>
<p>If <span class="math">\(flag = 2\)</span>, <span class="math">\(x\)</span> can have non integral real entries. In this case, if <span class="math">\(b\)</span>
is omitted, the &#8220;minimal&#8221; vectors only have approximately the same norm.
If <span class="math">\(b\)</span> is omitted, <span class="math">\(m\)</span> is an upper bound for the number of vectors that
will be stored and returned, but all minimal vectors are nevertheless
enumerated. If <span class="math">\(m\)</span> is omitted, all vectors found are stored and returned;
note that this may be a huge vector!</p>
<div class="highlight-python"><div class="highlight"><pre>? x = matid(2);
? qfminim(x) \\ 4 minimal vectors of norm 1: ±[0,1], ±[1,0]
%2 = [4, 1, [0, 1; 1, 0]]
? { x =
[4, 2, 0, 0, 0,-2, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 1, 0,-1, 0, 0, 0,-2;
 2, 4,-2,-2, 0,-2, 0, 0, 0, 0, 0, 0, 0,-1, 0, 0, 0, 0, 0,-1, 0, 1,-1,-1;
 0,-2, 4, 0,-2, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 1, 0, 0, 1,-1,-1, 0, 0;
 0,-2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 1,-1, 0, 1,-1, 1, 0;
 0, 0,-2, 0, 4, 0, 0, 0, 1,-1, 0, 0, 1, 0, 0, 0,-2, 0, 0,-1, 1, 1, 0, 0;
-2, -2,0, 0, 0, 4,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,-1, 1, 1;
 0, 0, 0, 0, 0,-2, 4,-2, 0, 0, 0, 0, 0, 1, 0, 0, 0,-1, 0, 0, 0, 1,-1, 0;
 0, 0, 0, 0, 0, 0,-2, 4, 0, 0, 0, 0,-1, 0, 0, 0, 0, 0,-1,-1,-1, 0, 1, 0;
 0, 0, 0, 0, 1,-1, 0, 0, 4, 0,-2, 0, 1, 1, 0,-1, 0, 1, 0, 0, 0, 0, 0, 0;
 0, 0, 0, 0,-1, 0, 0, 0, 0, 4, 0, 0, 1, 1,-1, 1, 0, 0, 0, 1, 0, 0, 1, 0;
 0, 0, 0, 0, 0, 0, 0, 0,-2, 0, 4,-2, 0,-1, 0, 0, 0,-1, 0,-1, 0, 0, 0, 0;
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 4,-1, 1, 0, 0,-1, 1, 0, 1, 1, 1,-1, 0;
 1, 0,-1, 1, 1, 0, 0,-1, 1, 1, 0,-1, 4, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1,-1;
-1,-1, 1,-1, 0, 0, 1, 0, 1, 1,-1, 1, 0, 4, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1;
 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 0, 0, 0, 1, 4, 0, 0, 0, 1, 0, 0, 0, 0, 0;
 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 1, 1, 0, 4, 0, 0, 0, 0, 1, 1, 0, 0;
 0, 0, 1, 0,-2, 0, 0, 0, 0, 0, 0,-1, 0, 0, 0, 0, 4, 1, 1, 1, 0, 0, 1, 1;
 1, 0, 0, 1, 0, 0,-1, 0, 1, 0,-1, 1, 1, 0, 0, 0, 1, 4, 0, 1, 1, 0, 1, 0;
 0, 0, 0,-1, 0, 1, 0,-1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 4, 0, 1, 1, 0, 1;
-1, -1,1, 0,-1, 1, 0,-1, 0, 1,-1, 1, 0, 1, 0, 0, 1, 1, 0, 4, 0, 0, 1, 1;
 0, 0,-1, 1, 1, 0, 0,-1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 4, 1, 0, 1;
 0, 1,-1,-1, 1,-1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 4, 0, 1;
 0,-1, 0, 1, 0, 1,-1, 1, 0, 1, 0,-1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 4, 1;
-2,-1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 4]; }
? qfminim(x,,0) \\ the Leech lattice has 196560 minimal vectors of norm 4
time = 648 ms.
%4 = [196560, 4, [;]]
? qfminim(x,,0,2); \\ safe algorithm. Slower and unnecessary here.
time = 18,161 ms.
%5 = [196560, 4.000061035156250000, [;]]
</pre></div>
</div>
<p>In the last example, we store 0 vectors to limit memory use. All minimal
vectors are nevertheless enumerated. Provided <tt class="docutils literal"><span class="pre">parisize</span></tt> is about 50MB,
<tt class="docutils literal"><span class="pre">qfminim(x)</span></tt> succeeds in 2.5 seconds.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfnorm">
<tt class="descname">qfnorm</tt><big>(</big><em>x</em>, <em>q=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the binary quadratic form <span class="math">\(q\)</span> (symmetric matrix)
at the vector <span class="math">\(x\)</span>. If <span class="math">\(q\)</span> omitted, use the standard Euclidean form,
corresponding to the identity matrix.</p>
<p>Equivalent to <tt class="docutils literal"><span class="pre">x~</span> <span class="pre">*</span> <span class="pre">q</span> <span class="pre">*</span> <span class="pre">x</span></tt>, but about twice faster and
more convenient (does not distinguish between column and row vectors):</p>
<div class="highlight-python"><div class="highlight"><pre>? x = [1,2,3]~; qfnorm(x)
%1 = 14
? q = [1,2,3;2,2,-1;3,-1,0]; qfnorm(x, q)
%2 = 23
? for(i=1,10^6, qfnorm(x,q))
time = 384ms.
? for(i=1,10^6, x~*q*x)
time = 729ms.
</pre></div>
</div>
<p>We also allow <tt class="docutils literal"><span class="pre">t_MAT</span></tt>&nbsp;s of compatible dimensions for <span class="math">\(x\)</span>,
and return <tt class="docutils literal"><span class="pre">x~</span> <span class="pre">*</span> <span class="pre">q</span> <span class="pre">*</span> <span class="pre">x</span></tt> in this case as well:</p>
<div class="highlight-python"><div class="highlight"><pre>? M = [1,2,3;4,5,6;7,8,9]; qfnorm(M) \\ Gram matrix
%5 =
[66 78 90]

[78 93 108]

[90 108 126]

? for(i=1,10^6, qfnorm(M,q))
time = 2,144 ms.
? for(i=1,10^6, M~*q*M)
time = 2,793 ms.
</pre></div>
</div>
<p>The polar form is also available, as <tt class="docutils literal"><span class="pre">qfbil</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfparam">
<tt class="descname">qfparam</tt><big>(</big><em>G</em>, <em>sol</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfparam" title="Permalink to this definition">¶</a></dt>
<dd><p>Coefficients of binary quadratic forms that parametrize the
solutions of the ternary quadratic form <span class="math">\(G\)</span>, using the particular
solution&nbsp;<em>sol</em>.
<em>flag</em> is optional and can be 1, 2, or 3, in which case the <em>flag</em>-th form is
reduced. The default is <em>flag</em> = 0 (no reduction).</p>
<div class="highlight-python"><div class="highlight"><pre>? G = [1,0,0;0,1,0;0,0,-34];
? M = qfparam(G, qfsolve(G))
%2 =
[ 3 -10 -3]

[-5 -6 5]

[ 1 0 1]
</pre></div>
</div>
<p>Indeed, the solutions can be parametrized as</p>
<div class="math">
\[(3x^2 - 10xy - 3y^2)^2 + (-5x^2 - 6xy + 5y^2)^2 -34(x^2 + y^2)^2 = 0.\]</div>
<div class="highlight-python"><div class="highlight"><pre>? v = y^2 * M*[1,x/y,(x/y)^2]~
%3 = [3*x^2 - 10*y*x - 3*y^2, -5*x^2 - 6*y*x + 5*y^2, -x^2 - y^2]~
? v~*G*v
%4 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfperfection">
<tt class="descname">qfperfection</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfperfection" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(G\)</span> being a square and symmetric matrix with
integer entries representing a positive definite quadratic form, outputs the
perfection rank of the form. That is, gives the rank of the family of the <span class="math">\(s\)</span>
symmetric matrices <span class="math">\(v_iv_i^t\)</span>, where <span class="math">\(s\)</span> is half the number of minimal
vectors and the <span class="math">\(v_i\)</span> (<span class="math">\(1 &lt;= i &lt;= s\)</span>) are the minimal vectors.</p>
<p>Since this requires computing the minimal vectors, the computations can
become very lengthy as the dimension of <span class="math">\(x\)</span> grows.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfrep">
<tt class="descname">qfrep</tt><big>(</big><em>q</em>, <em>B</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfrep" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(q\)</span> being a square and symmetric matrix with integer entries representing a
positive definite quadratic form, count the vectors representing successive
integers.</p>
<ul class="simple">
<li>If <span class="math">\(flag = 0\)</span>, count all vectors. Outputs the vector whose <span class="math">\(i\)</span>-th
entry, <span class="math">\(1 &lt;= i &lt;= B\)</span> is half the number of vectors <span class="math">\(v\)</span> such that <span class="math">\(q(v) = i\)</span>.</li>
<li>If <span class="math">\(flag = 1\)</span>, count vectors of even norm. Outputs the vector
whose <span class="math">\(i\)</span>-th entry, <span class="math">\(1 &lt;= i &lt;= B\)</span> is half the number of vectors such
that <span class="math">\(q(v) = 2i\)</span>.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? q = [2, 1; 1, 3];
? qfrep(q, 5)
%2 = Vecsmall([0, 1, 2, 0, 0]) \\ 1 vector of norm 2, 2 of norm 3, etc.
? qfrep(q, 5, 1)
%3 = Vecsmall([1, 0, 0, 1, 0]) \\ 1 vector of norm 2, 0 of norm 4, etc.
</pre></div>
</div>
<p>This routine uses a naive algorithm based on <tt class="docutils literal"><span class="pre">qfminim</span></tt>, and
will fail if any entry becomes larger than <span class="math">\(2^{31}\)</span> (or <span class="math">\(2^{63}\)</span>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfsign">
<tt class="descname">qfsign</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfsign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <span class="math">\([p,m]\)</span> the signature of the quadratic form represented by the
symmetric matrix <span class="math">\(x\)</span>. Namely, <span class="math">\(p\)</span> (resp.&nbsp;<span class="math">\(m\)</span>) is the number of positive
(resp.&nbsp;negative) eigenvalues of <span class="math">\(x\)</span>.The result is computed using Gaussian
reduction.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfsolve">
<tt class="descname">qfsolve</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a square symmetric matrix <span class="math">\(G\)</span> of dimension <span class="math">\(n &gt;= 1\)</span>, solve over
<span class="math">\(\mathbb{Q}\)</span> the quadratic equation <span class="math">\(X^tGX = 0\)</span>. The matrix <span class="math">\(G\)</span> must have rational
coefficients. The solution might be a single non-zero vector (vectorv) or a
matrix (whose columns generate a totally isotropic subspace).</p>
<p>If no solution exists, returns an integer, that can be a prime <span class="math">\(p\)</span> such that
there is no local solution at <span class="math">\(p\)</span>, or <span class="math">\(-1\)</span> if there is no real solution,
or <span class="math">\(-2\)</span> if <span class="math">\(n = 2\)</span> and <span class="math">\(-\det G\)</span> is positive but not a square (which implies
there is a real solution, but no local solution at some <span class="math">\(p\)</span> dividing <span class="math">\(\det G\)</span>).</p>
<div class="highlight-python"><div class="highlight"><pre>? G = [1,0,0;0,1,0;0,0,-34];
? qfsolve(G)
%1 = [-3, -5, 1]~
? qfsolve([1,0; 0,2])
%2 = -1 \\ no real solution
? qfsolve([1,0,0;0,3,0; 0,0,-2])
%3 = 3 \\ no solution in Q_3
? qfsolve([1,0; 0,-2])
%4 = -2 \\ no solution, n = 2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.quadclassunit">
<tt class="descname">quadclassunit</tt><big>(</big><em>D</em>, <em>flag=0</em>, <em>tech=None</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.quadclassunit" title="Permalink to this definition">¶</a></dt>
<dd><p>Buchmann-McCurley&#8217;s sub-exponential algorithm for computing the
class group of a quadratic order of discriminant <span class="math">\(D\)</span>.</p>
<p>This function should be used instead of <tt class="docutils literal"><span class="pre">qfbclassno</span></tt> or <tt class="docutils literal"><span class="pre">quadregula</span></tt>
when <span class="math">\(D &lt; -10^{25}\)</span>, <span class="math">\(D &gt; 10^{10}\)</span>, or when the <em>structure</em> is wanted. It
is a special case of <tt class="docutils literal"><span class="pre">bnfinit</span></tt>, which is slower, but more robust.</p>
<p>The result is a vector <span class="math">\(v\)</span> whose components should be accessed using member
functions:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">:math:`v</span></tt>.no`: the class number</li>
<li><tt class="docutils literal"><span class="pre">:math:`v</span></tt>.cyc`: a vector giving the structure of the class group as a
product of cyclic groups;</li>
<li><tt class="docutils literal"><span class="pre">:math:`v</span></tt>.gen`: a vector giving generators of those cyclic groups (as
binary quadratic forms).</li>
<li><tt class="docutils literal"><span class="pre">:math:`v</span></tt>.reg`: the regulator, computed to an accuracy which is the
maximum of an internal accuracy determined by the program and the current
default (note that once the regulator is known to a small accuracy it is
trivial to compute it to very high accuracy, see the tutorial).</li>
</ul>
<p>The <span class="math">\(flag\)</span> is obsolete and should be left alone. In older versions,
it supposedly computed the narrow class group when <span class="math">\(D &gt; 0\)</span>, but this did not
work at all; use the general function <tt class="docutils literal"><span class="pre">bnfnarrow</span></tt>.</p>
<p>Optional parameter <em>tech</em> is a row vector of the form <span class="math">\([c_1, c_2]\)</span>,
where <span class="math">\(c_1 &lt;= c_2\)</span> are non-negative real numbers which control the execution
time and the stack size, see <tt class="docutils literal"><span class="pre">GRHbnf</span></tt> (in the PARI manual). The parameter is used as a
threshold to balance the relation finding phase against the final linear
algebra. Increasing the default <span class="math">\(c_1\)</span> means that relations are easier
to find, but more relations are needed and the linear algebra will be
harder. The default value for <span class="math">\(c_1\)</span> is <span class="math">\(0\)</span> and means that it is taken equal
to <span class="math">\(c_2\)</span>. The parameter <span class="math">\(c_2\)</span> is mostly obsolete and should not be changed,
but we still document it for completeness: we compute a tentative class
group by generators and relations using a factorbase of prime ideals
<span class="math">\(&lt;= c_1 (\log \|D\|)^2\)</span>, then prove that ideals of norm
<span class="math">\(&lt;= c_2 (\log \|D\|)^2\)</span> do
not generate a larger group. By default an optimal <span class="math">\(c_2\)</span> is chosen, so that
the result is provably correct under the GRH &#8212; a famous result of Bach
states that <span class="math">\(c_2 = 6\)</span> is fine, but it is possible to improve on this
algorithmically. You may provide a smaller <span class="math">\(c_2\)</span>, it will be ignored
(we use the provably correct
one); you may provide a larger <span class="math">\(c_2\)</span> than the default value, which results
in longer computing times for equally correct outputs (under GRH).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.quaddisc">
<tt class="descname">quaddisc</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.quaddisc" title="Permalink to this definition">¶</a></dt>
<dd><p>Discriminant of the étale algebra <span class="math">\(\mathbb{Q}(\sqrt{x})\)</span>, where <span class="math">\(x belongs to \mathbb{Q}^*\)</span>.
This is the same as <tt class="docutils literal"><span class="pre">coredisc</span></tt><span class="math">\((d)\)</span> where <span class="math">\(d\)</span> is the integer square-free
part of <span class="math">\(x\)</span>, so x = <span class="math">\(d f^2\)</span> with <span class="math">\(f belongs to \mathbb{Q}^*\)</span> and <span class="math">\(d belongs to \mathbb{Z}\)</span>.
This returns <span class="math">\(0\)</span> for <span class="math">\(x = 0\)</span>, <span class="math">\(1\)</span> for <span class="math">\(x\)</span> square and the discriminant of the
quadratic field <span class="math">\(\mathbb{Q}(\sqrt{x})\)</span> otherwise.</p>
<div class="highlight-python"><div class="highlight"><pre>? quaddisc(7)
%1 = 28
? quaddisc(-7)
%2 = -7
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.quadgen">
<tt class="descname">quadgen</tt><big>(</big><em>D</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.quadgen" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the quadratic
number <span class="math">\(\omega = (a+\sqrt{D})/2\)</span> where <span class="math">\(a = 0\)</span> if <span class="math">\(D = 0 mod 4\)</span>,
<span class="math">\(a = 1\)</span> if <span class="math">\(D = 1 mod 4\)</span>, so that <span class="math">\((1,\omega)\)</span> is an integral basis for the
quadratic order of discriminant <span class="math">\(D\)</span>. <span class="math">\(D\)</span> must be an integer congruent to 0 or
1 modulo 4, which is not a square.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.quadhilbert">
<tt class="descname">quadhilbert</tt><big>(</big><em>D</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.quadhilbert" title="Permalink to this definition">¶</a></dt>
<dd><p>Relative equation defining the
Hilbert class field of the quadratic field of discriminant <span class="math">\(D\)</span>.</p>
<p>If <span class="math">\(D &lt; 0\)</span>, uses complex multiplication (Schertz&#8217;s variant).</p>
<p>If <span class="math">\(D &gt; 0\)</span> Stark units are used and (in rare cases) a
vector of extensions may be returned whose compositum is the requested class
field. See <tt class="docutils literal"><span class="pre">bnrstark</span></tt> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.quadpoly">
<tt class="descname">quadpoly</tt><big>(</big><em>D</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.quadpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the &#8220;canonical&#8221; quadratic
polynomial (in the variable <span class="math">\(v\)</span>) corresponding to the discriminant <span class="math">\(D\)</span>,
i.e.&nbsp;the minimal polynomial of <span class="math">\(quadgen(D)\)</span>. <span class="math">\(D\)</span> must be an integer
congruent to 0 or 1 modulo 4, which is not a square.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.quadray">
<tt class="descname">quadray</tt><big>(</big><em>D</em>, <em>f</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.quadray" title="Permalink to this definition">¶</a></dt>
<dd><p>Relative equation for the ray
class field of conductor <span class="math">\(f\)</span> for the quadratic field of discriminant <span class="math">\(D\)</span>
using analytic methods. A <tt class="docutils literal"><span class="pre">bnf</span></tt> for <span class="math">\(x^2 - D\)</span> is also accepted in place
of <span class="math">\(D\)</span>.</p>
<p>For <span class="math">\(D &lt; 0\)</span>, uses the <span class="math">\(\sigma\)</span> function and Schertz&#8217;s method.</p>
<p>For <span class="math">\(D &gt; 0\)</span>, uses Stark&#8217;s conjecture, and a vector of relative equations may be
returned. See <tt class="docutils literal"><span class="pre">bnrstark</span></tt> for more details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.quadregulator">
<tt class="descname">quadregulator</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.quadregulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Regulator of the quadratic field of positive discriminant <span class="math">\(x\)</span>. Returns
an error if <span class="math">\(x\)</span> is not a discriminant (fundamental or not) or if <span class="math">\(x\)</span> is a
square. See also <tt class="docutils literal"><span class="pre">quadclassunit</span></tt> if <span class="math">\(x\)</span> is large.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.quadunit">
<tt class="descname">quadunit</tt><big>(</big><em>D</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.quadunit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fundamental unit of the
real quadratic field <span class="math">\(\mathbb{Q}(\sqrt D)\)</span> where <span class="math">\(D\)</span> is the positive discriminant
of the field. If <span class="math">\(D\)</span> is not a fundamental discriminant, this probably gives
the fundamental unit of the corresponding order. <span class="math">\(D\)</span> must be an integer
congruent to 0 or 1 modulo 4, which is not a square; the result is a
quadratic number (see <tt class="docutils literal"><span class="pre">quadgen</span></tt> (in the PARI manual)).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.random">
<tt class="descname">random</tt><big>(</big><em>N</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.random" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random element in various natural sets depending on the
argument <span class="math">\(N\)</span>.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">t_INT</span></tt>: returns an integer
uniformly distributed between <span class="math">\(0\)</span> and <span class="math">\(N-1\)</span>. Omitting the argument
is equivalent to <tt class="docutils literal"><span class="pre">random(2^31)</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">t_REAL</span></tt>: returns a real number in <span class="math">\([0,1[\)</span> with the same accuracy as
<span class="math">\(N\)</span> (whose mantissa has the same number of significant words).</li>
<li><tt class="docutils literal"><span class="pre">t_INTMOD</span></tt>: returns a random intmod for the same modulus.</li>
<li><tt class="docutils literal"><span class="pre">t_FFELT</span></tt>: returns a random element in the same finite field.</li>
<li><tt class="docutils literal"><span class="pre">t_VEC</span></tt> of length <span class="math">\(2\)</span>, <span class="math">\(N = [a,b]\)</span>: returns an integer uniformly
distributed between <span class="math">\(a\)</span> and <span class="math">\(b\)</span>.</li>
<li><tt class="docutils literal"><span class="pre">t_VEC</span></tt> generated by <tt class="docutils literal"><span class="pre">ellinit</span></tt> over a finite field <span class="math">\(k\)</span>
(coefficients are <tt class="docutils literal"><span class="pre">t_INTMOD</span></tt>&nbsp;s modulo a prime or <tt class="docutils literal"><span class="pre">t_FFELT</span></tt>&nbsp;s): returns a
&#8220;random&#8221; <span class="math">\(k\)</span>-rational <em>affine</em> point on the curve. More precisely
if the curve has a single point (at infinity!) we return it; otherwise
we return an affine point by drawing an abscissa uniformly at
random until <tt class="docutils literal"><span class="pre">ellordinate</span></tt> succeeds. Note that this is definitely not a
uniform distribution over <span class="math">\(E(k)\)</span>, but it should be good enough for
applications.</li>
<li><tt class="docutils literal"><span class="pre">t_POL</span></tt> return a random polynomial of degree at most the degree of <span class="math">\(N\)</span>.
The coefficients are drawn by applying <tt class="docutils literal"><span class="pre">random</span></tt> to the leading
coefficient of <span class="math">\(N\)</span>.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? random(10)
%1 = 9
? random(Mod(0,7))
%2 = Mod(1, 7)
? a = ffgen(ffinit(3,7), &#39;a); random(a)
%3 = a^6 + 2*a^5 + a^4 + a^3 + a^2 + 2*a
? E = ellinit([3,7]*Mod(1,109)); random(E)
%4 = [Mod(103, 109), Mod(10, 109)]
? E = ellinit([1,7]*a^0); random(E)
%5 = [a^6 + a^5 + 2*a^4 + 2*a^2, 2*a^6 + 2*a^4 + 2*a^3 + a^2 + 2*a]
? random(Mod(1,7)*x^4)
%6 = Mod(5, 7)*x^4 + Mod(6, 7)*x^3 + Mod(2, 7)*x^2 + Mod(2, 7)*x + Mod(5, 7)
</pre></div>
</div>
<p>These variants all depend on a single internal generator, and are
independent from your operating system&#8217;s random number generators.
A random seed may be obtained via <tt class="docutils literal"><span class="pre">getrand</span></tt>, and reset
using <tt class="docutils literal"><span class="pre">setrand</span></tt>: from a given seed, and given sequence of <tt class="docutils literal"><span class="pre">random</span></tt>&nbsp;s,
the exact same values will be generated. The same seed is used at each
startup, reseed the generator yourself if this is a problem. Note that
internal functions also call the random number generator; adding such a
function call in the middle of your code will change the numbers produced.</p>
<p><strong>Technical note.</strong>
Up to
version 2.4 included, the internal generator produced pseudo-random numbers
by means of linear congruences, which were not well distributed in arithmetic
progressions. We now
use Brent&#8217;s XORGEN algorithm, based on Feedback Shift Registers, see
<tt class="docutils literal"><span class="pre">http://wwwmaths.anu.edu.au/~brent/random.html</span></tt>. The generator has period
<span class="math">\(2^{4096}-1\)</span>, passes the Crush battery of statistical tests of L&#8217;Ecuyer and
Simard, but is not suitable for cryptographic purposes: one can reconstruct
the state vector from a small sample of consecutive values, thus predicting
the entire sequence.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.randomprime">
<tt class="descname">randomprime</tt><big>(</big><em>N</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.randomprime" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a strong pseudo prime (see <tt class="docutils literal"><span class="pre">ispseudoprime</span></tt>) in <span class="math">\([2,N-1]\)</span>.
A <tt class="docutils literal"><span class="pre">t_VEC</span></tt> <span class="math">\(N = [a,b]\)</span> is also allowed, with <span class="math">\(a &lt;= b\)</span> in which case a
pseudo prime <span class="math">\(a &lt;= p &lt;= b\)</span> is returned; if no prime exists in the
interval, the function will run into an infinite loop. If the upper bound
is less than <span class="math">\(2^{64}\)</span> the pseudo prime returned is a proven prime.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.real">
<tt class="descname">real</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.real" title="Permalink to this definition">¶</a></dt>
<dd><p>Real part of <span class="math">\(x\)</span>. In the case where <span class="math">\(x\)</span> is a quadratic number, this is the
coefficient of <span class="math">\(1\)</span> in the &#8220;canonical&#8221; integral basis <span class="math">\((1,\omega)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.removeprimes">
<tt class="descname">removeprimes</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.removeprimes" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the primes listed in <span class="math">\(x\)</span> from
the prime number table. In particular <tt class="docutils literal"><span class="pre">removeprimes(addprimes())</span></tt> empties
the extra prime table. <span class="math">\(x\)</span> can also be a single integer. List the current
extra primes if <span class="math">\(x\)</span> is omitted.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfalgtobasis">
<tt class="descname">rnfalgtobasis</tt><big>(</big><em>rnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfalgtobasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Expresses <span class="math">\(x\)</span> on the relative
integral basis. Here, <span class="math">\(rnf\)</span> is a relative number field extension <span class="math">\(L/K\)</span>
as output by <tt class="docutils literal"><span class="pre">rnfinit</span></tt>, and <span class="math">\(x\)</span> an element of <span class="math">\(L\)</span> in absolute form, i.e.
expressed as a polynomial or polmod with polmod coefficients, <em>not</em> on
the relative integral basis.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfbasis">
<tt class="descname">rnfbasis</tt><big>(</big><em>bnf</em>, <em>M</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(K\)</span> the field represented by
<em>bnf</em>, as output by <tt class="docutils literal"><span class="pre">bnfinit</span></tt>. <span class="math">\(M\)</span> is a projective <span class="math">\(\mathbb{Z}_K\)</span>-module
of rank <span class="math">\(n\)</span> (<span class="math">\(M\\otimes K\)</span> is an <span class="math">\(n\)</span>-dimensional <span class="math">\(K\)</span>-vector space), given by a
pseudo-basis of size <span class="math">\(n\)</span>. The routine returns either a true <span class="math">\(\mathbb{Z}_K\)</span>-basis of
<span class="math">\(M\)</span> (of size <span class="math">\(n\)</span>) if it exists, or an <span class="math">\(n+1\)</span>-element generating set of <span class="math">\(M\)</span> if
not.</p>
<p>It is allowed to use an irreducible polynomial <span class="math">\(P\)</span> in <span class="math">\(K[X]\)</span> instead of <span class="math">\(M\)</span>,
in which case, <span class="math">\(M\)</span> is defined as the ring of integers of <span class="math">\(K[X]/(P)\)</span>, viewed
as a <span class="math">\(\mathbb{Z}_K\)</span>-module.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfbasistoalg">
<tt class="descname">rnfbasistoalg</tt><big>(</big><em>rnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfbasistoalg" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the representation of <span class="math">\(x\)</span>
as a polmod with polmods coefficients. Here, <span class="math">\(rnf\)</span> is a relative number
field extension <span class="math">\(L/K\)</span> as output by <tt class="docutils literal"><span class="pre">rnfinit</span></tt>, and <span class="math">\(x\)</span> an element of
<span class="math">\(L\)</span> expressed on the relative integral basis.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfcharpoly">
<tt class="descname">rnfcharpoly</tt><big>(</big><em>nf</em>, <em>T</em>, <em>a</em>, <em>var=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfcharpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>Characteristic polynomial of
<span class="math">\(a\)</span> over <span class="math">\(nf\)</span>, where <span class="math">\(a\)</span> belongs to the algebra defined by <span class="math">\(T\)</span> over
<span class="math">\(nf\)</span>, i.e.&nbsp;<span class="math">\(nf[X]/(T)\)</span>. Returns a polynomial in variable <span class="math">\(v\)</span>
(<span class="math">\(x\)</span> by default).</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2+1);
? rnfcharpoly(nf, x^2+y*x+1, x+y)
%2 = x^2 + Mod(-y, y^2 + 1)*x + 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfconductor">
<tt class="descname">rnfconductor</tt><big>(</big><em>bnf</em>, <em>pol</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfconductor" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <span class="math">\(bnf\)</span>
as output by <tt class="docutils literal"><span class="pre">bnfinit</span></tt>, and <em>pol</em> a relative polynomial defining an
Abelian extension, computes the class field theory conductor of this
Abelian extension. The result is a 3-component vector
<span class="math">\([conductor,rayclgp,subgroup]\)</span>, where <em>conductor</em> is
the conductor of the extension given as a 2-component row vector
<span class="math">\([f_0,f_ oo ]\)</span>, <em>rayclgp</em> is the full ray class group corresponding to
the conductor given as a 3-component vector [h,cyc,gen] as usual for a group,
and <em>subgroup</em> is a matrix in HNF defining the subgroup of the ray class
group on the given generators gen.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfdedekind">
<tt class="descname">rnfdedekind</tt><big>(</big><em>nf</em>, <em>pol</em>, <em>pr=None</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfdedekind" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a number field <span class="math">\(K\)</span> coded by <span class="math">\(nf\)</span> and a monic
polynomial <span class="math">\(P belongs to \mathbb{Z}_K[X]\)</span>, irreducible over <span class="math">\(K\)</span> and thus defining a relative
extension <span class="math">\(L\)</span> of <span class="math">\(K\)</span>, applies Dedekind&#8217;s criterion to the order
<span class="math">\(\mathbb{Z}_K[X]/(P)\)</span>, at the prime ideal <em>pr</em>. It is possible to set <em>pr</em>
to a vector of prime ideals (test maximality at all primes in the vector),
or to omit altogether, in which case maximality at <em>all</em> primes is tested;
in this situation <em>flag</em> is automatically set to <span class="math">\(1\)</span>.</p>
<p>The default historic behavior (<em>flag</em> is 0 or omitted and <em>pr</em> is a
single prime ideal) is not so useful since
<tt class="docutils literal"><span class="pre">rnfpseudobasis</span></tt> gives more information and is generally not that
much slower. It returns a 3-component vector <span class="math">\([max, basis, v]\)</span>:</p>
<ul class="simple">
<li><em>basis</em> is a pseudo-basis of an enlarged order <span class="math">\(O\)</span> produced by
Dedekind&#8217;s criterion, containing the original order <span class="math">\(\mathbb{Z}_K[X]/(P)\)</span>
with index a power of <em>pr</em>. Possibly equal to the original order.</li>
<li><em>max</em> is a flag equal to 1 if the enlarged order <span class="math">\(O\)</span>
could be proven to be <em>pr</em>-maximal and to 0 otherwise; it may still be
maximal in the latter case if <em>pr</em> is ramified in <span class="math">\(L\)</span>,</li>
<li><span class="math">\(v\)</span> is the valuation at <em>pr</em> of the order discriminant.</li>
</ul>
<p>If <em>flag</em> is non-zero, on the other hand, we just return <span class="math">\(1\)</span> if the order
<span class="math">\(\mathbb{Z}_K[X]/(P)\)</span> is <em>pr</em>-maximal (resp.&nbsp;maximal at all relevant primes, as
described above), and <span class="math">\(0\)</span> if not. This is much faster than the default,
since the enlarged order is not computed.</p>
<div class="highlight-python"><div class="highlight"><pre>? nf = nfinit(y^2-3); P = x^3 - 2*y;
? pr3 = idealprimedec(nf,3)[1];
? rnfdedekind(nf, P, pr3)
%2 = [1, [[1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 1, 1]], 8]
? rnfdedekind(nf, P, pr3, 1)
%3 = 1
</pre></div>
</div>
<p>In this example, <tt class="docutils literal"><span class="pre">pr3</span></tt> is the ramified ideal above <span class="math">\(3\)</span>,
and the order generated by the cube roots of <span class="math">\(y\)</span> is already
<tt class="docutils literal"><span class="pre">pr3</span></tt>-maximal. The order-discriminant has valuation <span class="math">\(8\)</span>. On the other
hand, the order is not maximal at the prime above 2:</p>
<div class="highlight-python"><div class="highlight"><pre>? pr2 = idealprimedec(nf,2)[1];
? rnfdedekind(nf, P, pr2, 1)
%5 = 0
? rnfdedekind(nf, P, pr2)
%6 = [0, [[2, 0, 0; 0, 1, 0; 0, 0, 1], [[1, 0; 0, 1], [1, 0; 0, 1],
 [1, 1/2; 0, 1/2]]], 2]
</pre></div>
</div>
<p>The enlarged order is not proven to be <tt class="docutils literal"><span class="pre">pr2</span></tt>-maximal yet. In fact, it
is; it is in fact the maximal order:</p>
<div class="highlight-python"><div class="highlight"><pre>? B = rnfpseudobasis(nf, P)
%7 = [[1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 1, [1, 1/2; 0, 1/2]],
 [162, 0; 0, 162], -1]
? idealval(nf,B[3], pr2)
%4 = 2
</pre></div>
</div>
<p>It is possible to use this routine with non-monic
<span class="math">\(P = \sum_{i &lt;= n} a_i X^i belongs to \mathbb{Z}_K[X]\)</span> if <span class="math">\(flag = 1\)</span>;
in this case, we test maximality of Dedekind&#8217;s order generated by</p>
<div class="math">
\[1, a_n \alpha, a_n\alpha^2 + a_{n-1}\alpha,...,
a_n\alpha^{n-1} + a_{n-1}\alpha^{n-2} +...+ a_1\alpha.\]</div>
<p>The routine will fail if <span class="math">\(P\)</span> is <span class="math">\(0\)</span> on the projective line over the residue
field <span class="math">\(\mathbb{Z}_K/pr\)</span> (FIXME).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfdet">
<tt class="descname">rnfdet</tt><big>(</big><em>nf</em>, <em>M</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfdet" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a pseudo-matrix <span class="math">\(M\)</span> over the maximal
order of <span class="math">\(nf\)</span>, computes its determinant.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfdisc">
<tt class="descname">rnfdisc</tt><big>(</big><em>nf</em>, <em>pol</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfdisc" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a number field <span class="math">\(nf\)</span> as
output by <tt class="docutils literal"><span class="pre">nfinit</span></tt> and a polynomial <em>pol</em> with coefficients in
<span class="math">\(nf\)</span> defining a relative extension <span class="math">\(L\)</span> of <span class="math">\(nf\)</span>, computes the
relative discriminant of <span class="math">\(L\)</span>. This is a two-element row vector <span class="math">\([D,d]\)</span>, where
<span class="math">\(D\)</span> is the relative ideal discriminant and <span class="math">\(d\)</span> is the relative discriminant
considered as an element of <span class="math">\(nf^*/{nf^*}^2\)</span>. The main variable of
<span class="math">\(nf\)</span> <em>must</em> be of lower priority than that of <em>pol</em>, see
<tt class="docutils literal"><span class="pre">priority</span></tt> (in the PARI manual).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfeltabstorel">
<tt class="descname">rnfeltabstorel</tt><big>(</big><em>rnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfeltabstorel" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative
number field extension <span class="math">\(L/K\)</span> as output by <tt class="docutils literal"><span class="pre">rnfinit</span></tt> and <span class="math">\(x\)</span> being an
element of <span class="math">\(L\)</span> expressed as a polynomial modulo the absolute equation
<tt class="docutils literal"><span class="pre">:emphasis:`rnf</span></tt>.pol`, computes <span class="math">\(x\)</span> as an element of the relative extension
<span class="math">\(L/K\)</span> as a polmod with polmod coefficients.</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? L.pol
%2 = x^4 + 1
? rnfeltabstorel(L, Mod(x, L.pol))
%3 = Mod(x, x^2 + Mod(-y, y^2 + 1))
? rnfeltabstorel(L, Mod(2, L.pol))
%4 = 2
? rnfeltabstorel(L, Mod(x, x^2-y))
 *** at top-level: rnfeltabstorel(L,Mod
 *** ^--------------------
 *** rnfeltabstorel: inconsistent moduli in rnfeltabstorel: x^2-y != x^4+1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfeltdown">
<tt class="descname">rnfeltdown</tt><big>(</big><em>rnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfeltdown" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative number
field extension <span class="math">\(L/K\)</span> as output by <tt class="docutils literal"><span class="pre">rnfinit</span></tt> and <span class="math">\(x\)</span> being an element of
<span class="math">\(L\)</span> expressed as a polynomial or polmod with polmod coefficients, computes
<span class="math">\(x\)</span> as an element of <span class="math">\(K\)</span> as a polmod, assuming <span class="math">\(x\)</span> is in <span class="math">\(K\)</span> (otherwise a
domain error occurs).</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? L.pol
%2 = x^4 + 1
? rnfeltdown(L, Mod(x^2, L.pol))
%3 = Mod(y, y^2 + 1)
? rnfeltdown(L, Mod(y, x^2-y))
%4 = Mod(y, y^2 + 1)
? rnfeltdown(L, Mod(y,K.pol))
%5 = Mod(y, y^2 + 1)
? rnfeltdown(L, Mod(x, L.pol))
 *** at top-level: rnfeltdown(L,Mod(x,x
 *** ^--------------------
 *** rnfeltdown: domain error in rnfeltdown: element not in the base field
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfeltnorm">
<tt class="descname">rnfeltnorm</tt><big>(</big><em>rnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfeltnorm" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative number field extension <span class="math">\(L/K\)</span> as output by
<tt class="docutils literal"><span class="pre">rnfinit</span></tt> and <span class="math">\(x\)</span> being an element of <span class="math">\(L\)</span>, returns the relative norm
<span class="math">\(N_{L/K}(x)\)</span> as an element of <span class="math">\(K\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? rnfeltnorm(L, Mod(x, L.pol))
%2 = Mod(x, x^2 + Mod(-y, y^2 + 1))
? rnfeltnorm(L, 2)
%3 = 4
? rnfeltnorm(L, Mod(x, x^2-y))
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfeltreltoabs">
<tt class="descname">rnfeltreltoabs</tt><big>(</big><em>rnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfeltreltoabs" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative
number field extension <span class="math">\(L/K\)</span> as output by <tt class="docutils literal"><span class="pre">rnfinit</span></tt> and <span class="math">\(x\)</span> being an
element of <span class="math">\(L\)</span> expressed as a polynomial or polmod with polmod
coefficients, computes <span class="math">\(x\)</span> as an element of the absolute extension <span class="math">\(L/\mathbb{Q}\)</span> as
a polynomial modulo the absolute equation <tt class="docutils literal"><span class="pre">:emphasis:`rnf</span></tt>.pol`.</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? L.pol
%2 = x^4 + 1
? rnfeltreltoabs(L, Mod(x, L.pol))
%3 = Mod(x, x^4 + 1)
? rnfeltreltoabs(L, Mod(y, x^2-y))
%4 = Mod(x^2, x^4 + 1)
? rnfeltreltoabs(L, Mod(y,K.pol))
%5 = Mod(x^2, x^4 + 1)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfelttrace">
<tt class="descname">rnfelttrace</tt><big>(</big><em>rnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfelttrace" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative number field extension <span class="math">\(L/K\)</span> as output by
<tt class="docutils literal"><span class="pre">rnfinit</span></tt> and <span class="math">\(x\)</span> being an element of <span class="math">\(L\)</span>, returns the relative trace
<span class="math">\(N_{L/K}(x)\)</span> as an element of <span class="math">\(K\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? rnfelttrace(L, Mod(x, L.pol))
%2 = 0
? rnfelttrace(L, 2)
%3 = 4
? rnfelttrace(L, Mod(x, x^2-y))
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfeltup">
<tt class="descname">rnfeltup</tt><big>(</big><em>rnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfeltup" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative number field extension <span class="math">\(L/K\)</span> as output by
<tt class="docutils literal"><span class="pre">rnfinit</span></tt> and <span class="math">\(x\)</span> being an element of <span class="math">\(K\)</span>, computes <span class="math">\(x\)</span> as an element of
the absolute extension <span class="math">\(L/\mathbb{Q}\)</span> as a polynomial modulo the absolute equation
<tt class="docutils literal"><span class="pre">:emphasis:`rnf</span></tt>.pol`.</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? L.pol
%2 = x^4 + 1
? rnfeltup(L, Mod(y, K.pol))
%4 = Mod(x^2, x^4 + 1)
? rnfeltup(L, y)
%5 = Mod(x^2, x^4 + 1)
? rnfeltup(L, [1,2]~) \\ in terms of K.zk
%6 = Mod(2*x^2 + 1, x^4 + 1)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfequation">
<tt class="descname">rnfequation</tt><big>(</big><em>nf</em>, <em>pol</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfequation" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a number field
<span class="math">\(nf\)</span> as output by <tt class="docutils literal"><span class="pre">nfinit</span></tt> (or simply a polynomial) and a
polynomial <em>pol</em> with coefficients in <span class="math">\(nf\)</span> defining a relative
extension <span class="math">\(L\)</span> of <span class="math">\(nf\)</span>, computes an absolute equation of <span class="math">\(L\)</span> over
<span class="math">\(\mathbb{Q}\)</span>.</p>
<p>The main variable of <span class="math">\(nf\)</span> <em>must</em> be of lower priority than that
of <em>pol</em> (see <tt class="docutils literal"><span class="pre">priority</span></tt> (in the PARI manual)). Note that for efficiency, this does
not check whether the relative equation is irreducible over <span class="math">\(nf\)</span>, but
only if it is squarefree. If it is reducible but squarefree, the result will
be the absolute equation of the étale algebra defined by <em>pol</em>. If
<em>pol</em> is not squarefree, raise an <tt class="docutils literal"><span class="pre">e_DOMAIN</span></tt> exception.</p>
<div class="highlight-python"><div class="highlight"><pre>? rnfequation(y^2+1, x^2 - y)
%1 = x^4 + 1
? T = y^3-2; rnfequation(nfinit(T), (x^3-2)/(x-Mod(y,T)))
%2 = x^6 + 108 \\ Galois closure of Q(2^(1/3))
</pre></div>
</div>
<p>If <span class="math">\(flag\)</span> is non-zero, outputs a 3-component row vector <span class="math">\([z,a,k]\)</span>, where</p>
<ul class="simple">
<li><span class="math">\(z\)</span> is the absolute equation of <span class="math">\(L\)</span> over <span class="math">\(\mathbb{Q}\)</span>, as in the default
behavior,</li>
<li><span class="math">\(a\)</span> expresses as a <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> modulo <span class="math">\(z\)</span> a root <span class="math">\(\alpha\)</span> of the
polynomial defining the base field <span class="math">\(nf\)</span>,</li>
<li><span class="math">\(k\)</span> is a small integer such that <span class="math">\(\theta = \beta+k\alpha\)</span>
is a root of <span class="math">\(z\)</span>, where <span class="math">\(\beta\)</span> is a root of <span class="math">\(pol\)</span>.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? T = y^3-2; pol = x^2 +x*y + y^2;
? [z,a,k] = rnfequation(T, pol, 1);
? z
%4 = x^6 + 108
? subst(T, y, a)
%5 = 0
? alpha= Mod(y, T);
? beta = Mod(x*Mod(1,T), pol);
? subst(z, x, beta + k*alpha)
%8 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfhnfbasis">
<tt class="descname">rnfhnfbasis</tt><big>(</big><em>bnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfhnfbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <span class="math">\(bnf\)</span> as output by
<tt class="docutils literal"><span class="pre">bnfinit</span></tt>, and either a polynomial <span class="math">\(x\)</span> with coefficients in <span class="math">\(bnf\)</span>
defining a relative extension <span class="math">\(L\)</span> of <span class="math">\(bnf\)</span>, or a pseudo-basis <span class="math">\(x\)</span> of
such an extension, gives either a true <span class="math">\(bnf\)</span>-basis of <span class="math">\(L\)</span> in upper
triangular Hermite normal form, if it exists, and returns <span class="math">\(0\)</span> otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealabstorel">
<tt class="descname">rnfidealabstorel</tt><big>(</big><em>rnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealabstorel" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(rnf\)</span> be a relative
number field extension <span class="math">\(L/K\)</span> as output by <tt class="docutils literal"><span class="pre">rnfinit</span></tt> and <span class="math">\(x\)</span> be an ideal of
the absolute extension <span class="math">\(L/\mathbb{Q}\)</span> given by a <span class="math">\(\mathbb{Z}\)</span>-basis of elements of <span class="math">\(L\)</span>.
Returns the relative pseudo-matrix in HNF giving the ideal <span class="math">\(x\)</span> considered as
an ideal of the relative extension <span class="math">\(L/K\)</span>, i.e.&nbsp;as a <span class="math">\(\mathbb{Z}_K\)</span>-module.</p>
<p>The reason why the input does not use the customary HNF in terms of a fixed
<span class="math">\(\mathbb{Z}\)</span>-basis for <span class="math">\(\mathbb{Z}_L\)</span> is precisely that no such basis has been explicitly
specified. On the other hand, if you already computed an (absolute) <em>nf</em>
structure <tt class="docutils literal"><span class="pre">Labs</span></tt> associated to <span class="math">\(L\)</span>, and <span class="math">\(m\)</span> is in HNF, defining
an (absolute) ideal with respect to the <span class="math">\(\mathbb{Z}\)</span>-basis <tt class="docutils literal"><span class="pre">Labs.zk</span></tt>, then
<tt class="docutils literal"><span class="pre">Labs.zk</span> <span class="pre">*</span> <span class="pre">m</span></tt> is a suitable <span class="math">\(\mathbb{Z}\)</span>-basis for the ideal, and</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">rnfidealabstorel</span><span class="p">(</span><span class="n">rnf</span><span class="p">,</span> <span class="n">Labs</span><span class="o">.</span><span class="n">zk</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>converts <span class="math">\(m\)</span> to a relative ideal.</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(y^2+1); L = rnfinit(K, x^2-y); Labs = nfinit(L);
? m = idealhnf(Labs, 17, x^3+2);
? B = rnfidealabstorel(L, Labs.zk * m)
%3 = [[1, 8; 0, 1], [[17, 4; 0, 1], 1]] \\ pseudo-basis for m as Z_K-module
? A = rnfidealreltoabs(L, B)
%4 = [17, x^2 + 4, x + 8, x^3 + 8*x^2] \\ Z-basis for m in Q[x]/(L.pol)
? mathnf(matalgtobasis(Labs, A))
%5 =
[17 8 4 2]

[ 0 1 0 0]

[ 0 0 1 0]

[ 0 0 0 1]
? % == m
%6 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealdown">
<tt class="descname">rnfidealdown</tt><big>(</big><em>rnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(rnf\)</span> be a relative number
field extension <span class="math">\(L/K\)</span> as output by <tt class="docutils literal"><span class="pre">rnfinit</span></tt>, and <span class="math">\(x\)</span> an ideal of
<span class="math">\(L\)</span>, given either in relative form or by a <span class="math">\(\mathbb{Z}\)</span>-basis of elements of <span class="math">\(L\)</span>
(see <tt class="docutils literal"><span class="pre">rnfidealabstorel</span></tt> (in the PARI manual)). This function returns the ideal of <span class="math">\(K\)</span>
below <span class="math">\(x\)</span>, i.e.&nbsp;the intersection of <span class="math">\(x\)</span> with <span class="math">\(K\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealhnf">
<tt class="descname">rnfidealhnf</tt><big>(</big><em>rnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealhnf" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative number
field extension <span class="math">\(L/K\)</span> as output by <tt class="docutils literal"><span class="pre">rnfinit</span></tt> and <span class="math">\(x\)</span> being a relative
ideal (which can be, as in the absolute case, of many different types,
including of course elements), computes the HNF pseudo-matrix associated to
<span class="math">\(x\)</span>, viewed as a <span class="math">\(\mathbb{Z}_K\)</span>-module.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealmul">
<tt class="descname">rnfidealmul</tt><big>(</big><em>rnf</em>, <em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealmul" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative number
field extension <span class="math">\(L/K\)</span> as output by <tt class="docutils literal"><span class="pre">rnfinit</span></tt> and <span class="math">\(x\)</span> and <span class="math">\(y\)</span> being ideals
of the relative extension <span class="math">\(L/K\)</span> given by pseudo-matrices, outputs the ideal
product, again as a relative ideal.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealnormabs">
<tt class="descname">rnfidealnormabs</tt><big>(</big><em>rnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealnormabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(rnf\)</span> be a relative
number field extension <span class="math">\(L/K\)</span> as output by <tt class="docutils literal"><span class="pre">rnfinit</span></tt> and let <span class="math">\(x\)</span> be a
relative ideal (which can be, as in the absolute case, of many different
types, including of course elements). This function computes the norm of the
<span class="math">\(x\)</span> considered as an ideal of the absolute extension <span class="math">\(L/\mathbb{Q}\)</span>. This is
identical to</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">idealnorm</span><span class="p">(</span><span class="n">rnf</span><span class="p">,</span> <span class="n">rnfidealnormrel</span><span class="p">(</span><span class="n">rnf</span><span class="p">,</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>but faster.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealnormrel">
<tt class="descname">rnfidealnormrel</tt><big>(</big><em>rnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealnormrel" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(rnf\)</span> be a relative
number field extension <span class="math">\(L/K\)</span> as output by <tt class="docutils literal"><span class="pre">rnfinit</span></tt> and let <span class="math">\(x\)</span> be a
relative ideal (which can be, as in the absolute case, of many different
types, including of course elements). This function computes the relative
norm of <span class="math">\(x\)</span> as an ideal of <span class="math">\(K\)</span> in HNF.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealreltoabs">
<tt class="descname">rnfidealreltoabs</tt><big>(</big><em>rnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealreltoabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(rnf\)</span> be a relative
number field extension <span class="math">\(L/K\)</span> as output by <tt class="docutils literal"><span class="pre">rnfinit</span></tt> and let <span class="math">\(x\)</span> be a
relative ideal, given as a <span class="math">\(\mathbb{Z}_K\)</span>-module by a pseudo matrix <span class="math">\([A,I]\)</span>.
This function returns the ideal <span class="math">\(x\)</span> as an absolute ideal of <span class="math">\(L/\mathbb{Q}\)</span> in
the form of a <span class="math">\(\mathbb{Z}\)</span>-basis, given by a vector of polynomials (modulo
<tt class="docutils literal"><span class="pre">rnf.pol</span></tt>).</p>
<p>The reason why we do not return the customary HNF in terms of a fixed
<span class="math">\(\mathbb{Z}\)</span>-basis for <span class="math">\(\mathbb{Z}_L\)</span> is precisely that no such basis has been explicitly
specified. On the other hand, if you already computed an (absolute) <em>nf</em>
structure <tt class="docutils literal"><span class="pre">Labs</span></tt> associated to <span class="math">\(L\)</span>, then</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xabs</span> <span class="o">=</span> <span class="n">rnfidealreltoabs</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="n">xLabs</span> <span class="o">=</span> <span class="n">mathnf</span><span class="p">(</span><span class="n">matalgtobasis</span><span class="p">(</span><span class="n">Labs</span><span class="p">,</span> <span class="n">xabs</span><span class="p">));</span>
</pre></div>
</div>
<p>computes a traditional HNF <tt class="docutils literal"><span class="pre">xLabs</span></tt> for <span class="math">\(x\)</span> in terms of
the fixed <span class="math">\(\mathbb{Z}\)</span>-basis <tt class="docutils literal"><span class="pre">Labs.zk</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealtwoelt">
<tt class="descname">rnfidealtwoelt</tt><big>(</big><em>rnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealtwoelt" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative
number field extension <span class="math">\(L/K\)</span> as output by <tt class="docutils literal"><span class="pre">rnfinit</span></tt> and <span class="math">\(x\)</span> being an
ideal of the relative extension <span class="math">\(L/K\)</span> given by a pseudo-matrix, gives a
vector of two generators of <span class="math">\(x\)</span> over <span class="math">\(\mathbb{Z}_L\)</span> expressed as polmods with polmod
coefficients.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealup">
<tt class="descname">rnfidealup</tt><big>(</big><em>rnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealup" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(rnf\)</span> be a relative number
field extension <span class="math">\(L/K\)</span> as output by <tt class="docutils literal"><span class="pre">rnfinit</span></tt> and let <span class="math">\(x\)</span> be an ideal of
<span class="math">\(K\)</span>. This function returns the ideal <span class="math">\(x\mathbb{Z}_L\)</span> as an absolute ideal of <span class="math">\(L/\mathbb{Q}\)</span>,
in the form of a <span class="math">\(\mathbb{Z}\)</span>-basis, given by a vector of polynomials (modulo
<tt class="docutils literal"><span class="pre">rnf.pol</span></tt>).</p>
<p>The reason why we do not return the customary HNF in terms of a fixed
<span class="math">\(\mathbb{Z}\)</span>-basis for <span class="math">\(\mathbb{Z}_L\)</span> is precisely that no such basis has been explicitly
specified. On the other hand, if you already computed an (absolute) <em>nf</em>
structure <tt class="docutils literal"><span class="pre">Labs</span></tt> associated to <span class="math">\(L\)</span>, then</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xabs</span> <span class="o">=</span> <span class="n">rnfidealup</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="n">xLabs</span> <span class="o">=</span> <span class="n">mathnf</span><span class="p">(</span><span class="n">matalgtobasis</span><span class="p">(</span><span class="n">Labs</span><span class="p">,</span> <span class="n">xabs</span><span class="p">));</span>
</pre></div>
</div>
<p>computes a traditional HNF <tt class="docutils literal"><span class="pre">xLabs</span></tt> for <span class="math">\(x\)</span> in terms of
the fixed <span class="math">\(\mathbb{Z}\)</span>-basis <tt class="docutils literal"><span class="pre">Labs.zk</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfinit">
<tt class="descname">rnfinit</tt><big>(</big><em>nf</em>, <em>pol</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfinit" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(nf\)</span> being a number field in <tt class="docutils literal"><span class="pre">nfinit</span></tt>
format considered as base field, and <em>pol</em> a polynomial defining a relative
extension over <span class="math">\(nf\)</span>, this computes data to work in the
relative extension. The main variable of <em>pol</em> must be of higher priority
(see <tt class="docutils literal"><span class="pre">priority</span></tt> (in the PARI manual)) than that of <span class="math">\(nf\)</span>, and the coefficients of
<em>pol</em> must be in <span class="math">\(nf\)</span>.</p>
<p>The result is a row vector, whose components are technical. In the following
description, we let <span class="math">\(K\)</span> be the base field defined by <span class="math">\(nf\)</span> and <span class="math">\(L/K\)</span>
the large field associated to the <em>rnf</em>. Furthermore, we let
<span class="math">\(m = [K:\mathbb{Q}]\)</span> the degree of the base field, <span class="math">\(n = [L:K]\)</span> the relative degree,
<span class="math">\(r_1\)</span> and <span class="math">\(r_2\)</span> the number of real and complex places of <span class="math">\(K\)</span>. Access to this
information via <em>member functions</em> is preferred since the specific
data organization specified below will change in the future.</p>
<p>Note that a subsequent <tt class="docutils literal"><span class="pre">nfinit</span></tt><span class="math">\((rnf)\)</span> will explicitly add an
<em>nf</em> structure associated to <span class="math">\(L\)</span> to <em>rnf</em> (and return it as well).
This is likely to be very expensive if the absolute degree <span class="math">\(mn\)</span> is large,
but fixes an integer basis for <span class="math">\(\mathbb{Z}_L\)</span> as a <span class="math">\(\mathbb{Z}\)</span>-module and allows to input
and output elements of <span class="math">\(L\)</span> in absolute form: as <tt class="docutils literal"><span class="pre">t_COL</span></tt> for elements,
as <tt class="docutils literal"><span class="pre">t_MAT</span></tt> in HNF for ideals, as <tt class="docutils literal"><span class="pre">prid</span></tt> for prime ideals. Without such
a call, elements of <span class="math">\(L\)</span> are represented as <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt>, etc.</p>
<p><span class="math">\(rnf[1]`(:literal:`rnf.pol\)</span>) contains the relative polynomial <em>pol</em>.</p>
<p><span class="math">\(rnf[2]\)</span> contains the integer basis <span class="math">\([A,d]\)</span> of <span class="math">\(K\)</span>, as
(integral) elements of <span class="math">\(L/\mathbb{Q}\)</span>. More precisely, <span class="math">\(A\)</span> is a vector of
polynomial with integer coefficients, <span class="math">\(d\)</span> is a denominator, and the integer
basis is given by <span class="math">\(A/d\)</span>.</p>
<p><span class="math">\(rnf[3]\)</span> (<tt class="docutils literal"><span class="pre">rnf.disc</span></tt>) is a two-component row vector
<span class="math">\([d(L/K),s]\)</span> where <span class="math">\(d(L/K)\)</span> is the relative ideal discriminant
of <span class="math">\(L/K\)</span> and <span class="math">\(s\)</span> is the discriminant of <span class="math">\(L/K\)</span> viewed as an element of
<span class="math">\(K^*/(K^*)^2\)</span>, in other words it is the output of <tt class="docutils literal"><span class="pre">rnfdisc</span></tt>.</p>
<p><span class="math">\(rnf[4]`(:literal:`rnf.index\)</span>) is the ideal index <span class="math">\(f\)</span>, i.e.&nbsp;such
that <span class="math">\(d(pol)\mathbb{Z}_K = f^2d(L/K)\)</span>.</p>
<p><span class="math">\(rnf[5]\)</span> is currently unused.</p>
<p><span class="math">\(rnf[6]\)</span> is currently unused.</p>
<p><span class="math">\(rnf[7]\)</span> (<tt class="docutils literal"><span class="pre">rnf.zk</span></tt>) is the pseudo-basis <span class="math">\((A,I)\)</span> for the maximal
order <span class="math">\(\mathbb{Z}_L\)</span> as a <span class="math">\(\mathbb{Z}_K\)</span>-module: <span class="math">\(A\)</span> is the relative integral pseudo basis
expressed as polynomials (in the variable of <span class="math">\(pol\)</span>) with polmod coefficients
in <span class="math">\(nf\)</span>, and the second component <span class="math">\(I\)</span> is the ideal list of the
pseudobasis in HNF.</p>
<p><span class="math">\(rnf[8]\)</span> is the inverse matrix of the integral basis matrix, with
coefficients polmods in <span class="math">\(nf\)</span>.</p>
<p><span class="math">\(rnf[9]\)</span> is currently unused.</p>
<p><span class="math">\(rnf[10]\)</span> (<tt class="docutils literal"><span class="pre">rnf.nf</span></tt>) is <span class="math">\(nf\)</span>.</p>
<p><span class="math">\(rnf[11]\)</span> is an extension of <tt class="docutils literal"><span class="pre">rnfequation(K,</span> <span class="pre">pol,</span> <span class="pre">1)</span></tt>. Namely, a
vector <span class="math">\([P, a, k, K.pol, pol]\)</span> describing the <em>absolute</em>
extension
<span class="math">\(L/\mathbb{Q}\)</span>: <span class="math">\(P\)</span> is an absolute equation, more conveniently obtained
as <tt class="docutils literal"><span class="pre">rnf.polabs</span></tt>; <span class="math">\(a\)</span> expresses the generator <span class="math">\(\alpha = y mod K.pol\)</span>
of the number field <span class="math">\(K\)</span> as an element of <span class="math">\(L\)</span>, i.e.&nbsp;a polynomial modulo the
absolute equation <span class="math">\(P\)</span>;</p>
<p><span class="math">\(k\)</span> is a small integer such that, if <span class="math">\(\beta\)</span> is an abstract root of <em>pol</em>
and <span class="math">\(\alpha\)</span> the generator of <span class="math">\(K\)</span> given above, then <span class="math">\(P(\beta + k\alpha) = 0\)</span>.</p>
<p><strong>Caveat.</strong> Be careful if <span class="math">\(k != 0\)</span> when dealing simultaneously with
absolute and relative quantities since <span class="math">\(L = \mathbb{Q}(\beta + k\alpha) = 
K(\alpha)\)</span>, and the generator chosen for the absolute extension is not the
same as for the relative one. If this happens, one can of course go on
working, but we advise to change the relative polynomial so that its root
becomes <span class="math">\(\beta + k \alpha\)</span>. Typical GP instructions would be</p>
<div class="highlight-python"><div class="highlight"><pre>[P,a,k] = rnfequation(K, pol, 1);
if (k, pol = subst(pol, x, x - k*Mod(y, K.pol)));
L = rnfinit(K, pol);
</pre></div>
</div>
<p><span class="math">\(rnf[12]\)</span> is by default unused and set equal to 0. This field is used
to store further information about the field as it becomes available (which
is rarely needed, hence would be too expensive to compute during the initial
<tt class="docutils literal"><span class="pre">rnfinit</span></tt> call).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfisabelian">
<tt class="descname">rnfisabelian</tt><big>(</big><em>nf</em>, <em>T</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfisabelian" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(T\)</span> being a relative polynomial with coefficients
in <em>nf</em>, return 1 if it defines an abelian extension, and 0 otherwise.</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(y^2 + 23);
? rnfisabelian(K, x^3 - 3*x - y)
%2 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfisfree">
<tt class="descname">rnfisfree</tt><big>(</big><em>bnf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfisfree" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <span class="math">\(bnf\)</span> as output by
<tt class="docutils literal"><span class="pre">bnfinit</span></tt>, and either a polynomial <span class="math">\(x\)</span> with coefficients in <span class="math">\(bnf\)</span>
defining a relative extension <span class="math">\(L\)</span> of <span class="math">\(bnf\)</span>, or a pseudo-basis <span class="math">\(x\)</span> of
such an extension, returns true (1) if <span class="math">\(L/bnf\)</span> is free, false (0) if
not.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfisnorm">
<tt class="descname">rnfisnorm</tt><big>(</big><em>T</em>, <em>a</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfisnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to
<tt class="docutils literal"><span class="pre">bnfisnorm</span></tt> but in the relative case. <span class="math">\(T\)</span> is as output by
<tt class="docutils literal"><span class="pre">rnfisnorminit</span></tt> applied to the extension <span class="math">\(L/K\)</span>. This tries to decide
whether the element <span class="math">\(a\)</span> in <span class="math">\(K\)</span> is the norm of some <span class="math">\(x\)</span> in the extension
<span class="math">\(L/K\)</span>.</p>
<p>The output is a vector <span class="math">\([x,q]\)</span>, where <span class="math">\(a = \mathrm{Norm}(x)*q\)</span>. The
algorithm looks for a solution <span class="math">\(x\)</span> which is an <span class="math">\(S\)</span>-integer, with <span class="math">\(S\)</span> a list
of places of <span class="math">\(K\)</span> containing at least the ramified primes, the generators of
the class group of <span class="math">\(L\)</span>, as well as those primes dividing <span class="math">\(a\)</span>. If <span class="math">\(L/K\)</span> is
Galois, then this is enough; otherwise, <span class="math">\(flag\)</span> is used to add more primes to
<span class="math">\(S\)</span>: all the places above the primes <span class="math">\(p &lt;= flag\)</span> (resp.&nbsp;<span class="math">\(p\|flag\)</span>) if <span class="math">\(flag &gt; 0\)</span>
(resp.&nbsp;<span class="math">\(flag &lt; 0\)</span>).</p>
<p>The answer is guaranteed (i.e.&nbsp;<span class="math">\(a\)</span> is a norm iff <span class="math">\(q = 1\)</span>) if the field is
Galois, or, under GRH, if <span class="math">\(S\)</span> contains all primes less than
<span class="math">\(12\log^2\|\mathrm{disc}(M)\|\)</span>, where <span class="math">\(M\)</span> is the normal
closure of <span class="math">\(L/K\)</span>.</p>
<p>If <tt class="docutils literal"><span class="pre">rnfisnorminit</span></tt> has determined (or was told) that <span class="math">\(L/K\)</span> is
Galois, and <span class="math">\(flag != 0\)</span>, a Warning is issued (so that you can set
<span class="math">\(flag = 1\)</span> to check whether <span class="math">\(L/K\)</span> is known to be Galois, according to <span class="math">\(T\)</span>).
Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bnf</span> <span class="o">=</span> <span class="n">bnfinit</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Mod</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bnf</span><span class="o">.</span><span class="n">pol</span><span class="p">);</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">rnfisnorminit</span><span class="p">(</span><span class="n">bnf</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="n">rnfisnorm</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>
</pre></div>
</div>
<p>checks whether <span class="math">\(17\)</span> is a norm in the Galois extension <span class="math">\(\mathbb{Q}(\beta) /
\mathbb{Q}(\alpha)\)</span>, where <span class="math">\(\alpha^3 + \alpha^2 - 2\alpha - 1 = 0\)</span> and <span class="math">\(\beta^2 +
\alpha^2 + 2\alpha + 1 = 0\)</span> (it is).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfisnorminit">
<tt class="descname">rnfisnorminit</tt><big>(</big><em>pol</em>, <em>polrel</em>, <em>flag=2</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfisnorminit" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(K\)</span> be defined by a root of <em>pol</em>, and <span class="math">\(L/K\)</span> the extension defined
by the polynomial <em>polrel</em>. As usual, <em>pol</em> can in fact be an <em>nf</em>,
or <em>bnf</em>, etc; if <em>pol</em> has degree <span class="math">\(1\)</span> (the base field is <span class="math">\(\mathbb{Q}\)</span>),
polrel is also allowed to be an <em>nf</em>, etc. Computes technical data needed
by <tt class="docutils literal"><span class="pre">rnfisnorm</span></tt> to solve norm equations <span class="math">\(Nx = a\)</span>, for <span class="math">\(x\)</span> in <span class="math">\(L\)</span>, and <span class="math">\(a\)</span>
in <span class="math">\(K\)</span>.</p>
<p>If <span class="math">\(flag = 0\)</span>, do not care whether <span class="math">\(L/K\)</span> is Galois or not.</p>
<p>If <span class="math">\(flag = 1\)</span>, <span class="math">\(L/K\)</span> is assumed to be Galois (unchecked), which speeds up
<tt class="docutils literal"><span class="pre">rnfisnorm</span></tt>.</p>
<p>If <span class="math">\(flag = 2\)</span>, let the routine determine whether <span class="math">\(L/K\)</span> is Galois.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfkummer">
<tt class="descname">rnfkummer</tt><big>(</big><em>bnr</em>, <em>subgp=None</em>, <em>d=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfkummer" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bnr</em>
being as output by <tt class="docutils literal"><span class="pre">bnrinit</span></tt>, finds a relative equation for the
class field corresponding to the module in <em>bnr</em> and the given
congruence subgroup (the full ray class field if <em>subgp</em> is omitted).
If <span class="math">\(d\)</span> is positive, outputs the list of all relative equations of
degree <span class="math">\(d\)</span> contained in the ray class field defined by <em>bnr</em>, with
the <em>same</em> conductor as <span class="math">\((bnr, subgp)\)</span>.</p>
<p><strong>Warning.</strong> This routine only works for subgroups of prime index. It
uses Kummer theory, adjoining necessary roots of unity (it needs to compute a
tough <tt class="docutils literal"><span class="pre">bnfinit</span></tt> here), and finds a generator via Hecke&#8217;s characterization
of ramification in Kummer extensions of prime degree. If your extension does
not have prime degree, for the time being, you have to split it by hand as a
tower / compositum of such extensions.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnflllgram">
<tt class="descname">rnflllgram</tt><big>(</big><em>nf</em>, <em>pol</em>, <em>order</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnflllgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a polynomial
<em>pol</em> with coefficients in <em>nf</em> defining a relative extension <span class="math">\(L\)</span> and
a suborder <em>order</em> of <span class="math">\(L\)</span> (of maximal rank), as output by
<tt class="docutils literal"><span class="pre">rnfpseudobasis</span></tt><span class="math">\((nf,pol)\)</span> or similar, gives
<span class="math">\([[neworder],U]\)</span>, where <em>neworder</em> is a reduced order and <span class="math">\(U\)</span> is
the unimodular transformation matrix.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfnormgroup">
<tt class="descname">rnfnormgroup</tt><big>(</big><em>bnr</em>, <em>pol</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfnormgroup" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bnr</em> being a big ray
class field as output by <tt class="docutils literal"><span class="pre">bnrinit</span></tt> and <em>pol</em> a relative polynomial
defining an Abelian extension, computes the norm group (alias Artin
or Takagi group) corresponding to the Abelian extension of
<span class="math">\(bnf =\)</span><tt class="docutils literal"><span class="pre">bnr.bnf</span></tt>
defined by <em>pol</em>, where the module corresponding to <em>bnr</em> is assumed
to be a multiple of the conductor (i.e.&nbsp;<em>pol</em> defines a subextension of
bnr). The result is the HNF defining the norm group on the given generators
of <tt class="docutils literal"><span class="pre">bnr.gen</span></tt>. Note that neither the fact that <em>pol</em> defines an
Abelian extension nor the fact that the module is a multiple of the conductor
is checked. The result is undefined if the assumption is not correct,
but the function will return the empty matrix <tt class="docutils literal"><span class="pre">[;]</span></tt> if it detects a
problem; it may also not detect the problem and return a wrong result.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfpolred">
<tt class="descname">rnfpolred</tt><big>(</big><em>nf</em>, <em>pol</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfpolred" title="Permalink to this definition">¶</a></dt>
<dd><p>THIS FUNCTION IS OBSOLETE: use <tt class="docutils literal"><span class="pre">rnfpolredbest</span></tt> instead.
Relative version of <tt class="docutils literal"><span class="pre">polred</span></tt>. Given a monic polynomial <em>pol</em> with
coefficients in <span class="math">\(nf\)</span>, finds a list of relative polynomials defining some
subfields, hopefully simpler and containing the original field. In the present
version <strong>2.8.0</strong>, this is slower and less efficient than <tt class="docutils literal"><span class="pre">rnfpolredbest</span></tt>.</p>
<p><strong>Remark.</strong> this function is based on an incomplete reduction
theory of lattices over number fields, implemented by <tt class="docutils literal"><span class="pre">rnflllgram</span></tt>, which
deserves to be improved.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfpolredabs">
<tt class="descname">rnfpolredabs</tt><big>(</big><em>nf</em>, <em>pol</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfpolredabs" title="Permalink to this definition">¶</a></dt>
<dd><p>THIS FUNCTION IS OBSOLETE: use <tt class="docutils literal"><span class="pre">rnfpolredbest</span></tt> instead.
Relative version of <tt class="docutils literal"><span class="pre">polredabs</span></tt>. Given a monic polynomial <em>pol</em>
with coefficients in <span class="math">\(nf\)</span>, finds a simpler relative polynomial defining
the same field. The binary digits of <span class="math">\(flag\)</span> mean</p>
<p>The binary digits of <span class="math">\(flag\)</span> correspond to <span class="math">\(1\)</span>: add information to convert
elements to the new representation, <span class="math">\(2\)</span>: absolute polynomial, instead of
relative, <span class="math">\(16\)</span>: possibly use a suborder of the maximal order. More precisely:</p>
<p>0: default, return <span class="math">\(P\)</span></p>
<p>1: returns <span class="math">\([P,a]\)</span> where <span class="math">\(P\)</span> is the default output and <span class="math">\(a\)</span>,
a <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> modulo <span class="math">\(P\)</span>, is a root of <em>pol</em>.</p>
<p>2: returns <em>Pabs</em>, an absolute, instead of a relative, polynomial.
Same as but faster than</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">rnfequation</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">rnfpolredabs</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span><span class="n">pol</span><span class="p">))</span>
</pre></div>
</div>
<p>3: returns <span class="math">\([Pabs,a,b]\)</span>, where <em>Pabs</em> is an absolute polynomial
as above, <span class="math">\(a\)</span>, <span class="math">\(b\)</span> are <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> modulo <em>Pabs</em>, roots of <tt class="docutils literal"><span class="pre">nf.pol</span></tt>
and <em>pol</em> respectively.</p>
<p>16: possibly use a suborder of the maximal order. This is slower than the
default when the relative discriminant is smooth, and much faster otherwise.
See <tt class="docutils literal"><span class="pre">polredabs</span></tt> (in the PARI manual).</p>
<p><strong>Warning.</strong> In the present implementation, <tt class="docutils literal"><span class="pre">rnfpolredabs</span></tt>
produces smaller polynomials than <tt class="docutils literal"><span class="pre">rnfpolred</span></tt> and is usually
faster, but its complexity is still exponential in the absolute degree.
The function <tt class="docutils literal"><span class="pre">rnfpolredbest</span></tt> runs in polynomial time, and tends to
return polynomials with smaller discriminants.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfpolredbest">
<tt class="descname">rnfpolredbest</tt><big>(</big><em>nf</em>, <em>pol</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfpolredbest" title="Permalink to this definition">¶</a></dt>
<dd><p>Relative version of <tt class="docutils literal"><span class="pre">polredbest</span></tt>. Given a monic polynomial <em>pol</em>
with coefficients in <span class="math">\(nf\)</span>, finds a simpler relative polynomial <span class="math">\(P\)</span>
defining the same field. As opposed to <tt class="docutils literal"><span class="pre">rnfpolredabs</span></tt> this function does
not return a <em>smallest</em> (canonical) polynomial with respect to some
measure, but it does run in polynomial time.</p>
<p>The binary digits of <span class="math">\(flag\)</span> correspond to <span class="math">\(1\)</span>: add information to convert
elements to the new representation, <span class="math">\(2\)</span>: absolute polynomial, instead of
relative. More precisely:</p>
<p>0: default, return <span class="math">\(P\)</span></p>
<p>1: returns <span class="math">\([P,a]\)</span> where <span class="math">\(P\)</span> is the default output and <span class="math">\(a\)</span>,
a <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> modulo <span class="math">\(P\)</span>, is a root of <em>pol</em>.</p>
<p>2: returns <em>Pabs</em>, an absolute, instead of a relative, polynomial.
Same as but faster than</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">rnfequation</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">rnfpolredbest</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span><span class="n">pol</span><span class="p">))</span>
</pre></div>
</div>
<p>3: returns <span class="math">\([Pabs,a,b]\)</span>, where <em>Pabs</em> is an absolute polynomial
as above, <span class="math">\(a\)</span>, <span class="math">\(b\)</span> are <tt class="docutils literal"><span class="pre">t_POLMOD</span></tt> modulo <em>Pabs</em>, roots of <tt class="docutils literal"><span class="pre">nf.pol</span></tt>
and <em>pol</em> respectively.</p>
<div class="highlight-python"><div class="highlight"><pre>? K = nfinit(y^3-2); pol = x^2 +x*y + y^2;
? [P, a] = rnfpolredbest(K,pol,1);
? P
%3 = x^2 - x + Mod(y - 1, y^3 - 2)
? a
%4 = Mod(Mod(2*y^2+3*y+4,y^3-2)*x + Mod(-y^2-2*y-2,y^3-2),
 x^2 - x + Mod(y-1,y^3-2))
? subst(K.pol,y,a)
%5 = 0
? [Pabs, a, b] = rnfpolredbest(K,pol,3);
? Pabs
%7 = x^6 - 3*x^5 + 5*x^3 - 3*x + 1
? a
%8 = Mod(-x^2+x+1, x^6-3*x^5+5*x^3-3*x+1)
? b
%9 = Mod(2*x^5-5*x^4-3*x^3+10*x^2+5*x-5, x^6-3*x^5+5*x^3-3*x+1)
? subst(K.pol,y,a)
%10 = 0
? substvec(pol,[x,y],[a,b])
%11 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfpseudobasis">
<tt class="descname">rnfpseudobasis</tt><big>(</big><em>nf</em>, <em>pol</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfpseudobasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a number field
<span class="math">\(nf\)</span> as output by <tt class="docutils literal"><span class="pre">nfinit</span></tt> and a polynomial <em>pol</em> with
coefficients in <span class="math">\(nf\)</span> defining a relative extension <span class="math">\(L\)</span> of <span class="math">\(nf\)</span>,
computes a pseudo-basis <span class="math">\((A,I)\)</span> for the maximal order <span class="math">\(\mathbb{Z}_L\)</span> viewed as a
<span class="math">\(\mathbb{Z}_K\)</span>-module, and the relative discriminant of <span class="math">\(L\)</span>. This is output as a
four-element row vector <span class="math">\([A,I,D,d]\)</span>, where <span class="math">\(D\)</span> is the relative ideal
discriminant and <span class="math">\(d\)</span> is the relative discriminant considered as an element of
<span class="math">\(nf^*/{nf^*}^2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfsteinitz">
<tt class="descname">rnfsteinitz</tt><big>(</big><em>nf</em>, <em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfsteinitz" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a number field <span class="math">\(nf\)</span> as
output by <tt class="docutils literal"><span class="pre">nfinit</span></tt> and either a polynomial <span class="math">\(x\)</span> with coefficients in
<span class="math">\(nf\)</span> defining a relative extension <span class="math">\(L\)</span> of <span class="math">\(nf\)</span>, or a pseudo-basis
<span class="math">\(x\)</span> of such an extension as output for example by <tt class="docutils literal"><span class="pre">rnfpseudobasis</span></tt>,
computes another pseudo-basis <span class="math">\((A,I)\)</span> (not in HNF in general) such that all
the ideals of <span class="math">\(I\)</span> except perhaps the last one are equal to the ring of
integers of <span class="math">\(nf\)</span>, and outputs the four-component row vector <span class="math">\([A,I,D,d]\)</span>
as in <tt class="docutils literal"><span class="pre">rnfpseudobasis</span></tt>. The name of this function comes from the fact
that the ideal class of the last ideal of <span class="math">\(I\)</span>, which is well defined, is the
Steinitz class of the <span class="math">\(\mathbb{Z}_K\)</span>-module <span class="math">\(\mathbb{Z}_L\)</span> (its image in <span class="math">\(SK_0(\mathbb{Z}_K)\)</span>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.select">
<tt class="descname">select</tt><big>(</big><em>f</em>, <em>A</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.select" title="Permalink to this definition">¶</a></dt>
<dd><p>We first describe the default behavior, when <span class="math">\(flag\)</span> is 0 or omitted.
Given a vector or list <tt class="docutils literal"><span class="pre">A</span></tt> and a <tt class="docutils literal"><span class="pre">t_CLOSURE</span></tt> <tt class="docutils literal"><span class="pre">f</span></tt>, <tt class="docutils literal"><span class="pre">select</span></tt>
returns the elements <span class="math">\(x\)</span> of <tt class="docutils literal"><span class="pre">A</span></tt> such that <span class="math">\(f(x)\)</span> is non-zero. In other
words, <tt class="docutils literal"><span class="pre">f</span></tt> is seen as a selection function returning a boolean value.</p>
<div class="highlight-python"><div class="highlight"><pre>? select(x-&gt;isprime(x), vector(50,i,i^2+1))
%1 = [2, 5, 17, 37, 101, 197, 257, 401, 577, 677, 1297, 1601]
? select(x-&gt;(x&lt;100), %)
%2 = [2, 5, 17, 37]
</pre></div>
</div>
<p>returns the primes of the form <span class="math">\(i^2+1\)</span> for some <span class="math">\(i &lt;= 50\)</span>,
then the elements less than 100 in the preceding result. The <tt class="docutils literal"><span class="pre">select</span></tt>
function also applies to a matrix <tt class="docutils literal"><span class="pre">A</span></tt>, seen as a vector of columns, i.e. it
selects columns instead of entries, and returns the matrix whose columns are
the selected ones.</p>
<p><strong>Remark.</strong> For <span class="math">\(v\)</span> a <tt class="docutils literal"><span class="pre">t_VEC</span></tt>, <tt class="docutils literal"><span class="pre">t_COL</span></tt>, <tt class="docutils literal"><span class="pre">t_LIST</span></tt> or <tt class="docutils literal"><span class="pre">t_MAT</span></tt>,
the alternative set-notations</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="p">[</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">]</span>
</pre></div>
</div>
<p>are available as shortcuts for</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">apply</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">select</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Vec</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
<span class="n">select</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Vec</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="nb">apply</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">Vec</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
</pre></div>
</div>
<p>respectively:</p>
<div class="highlight-python"><div class="highlight"><pre>? [ x | x &lt;- vector(50,i,i^2+1), isprime(x) ]
%1 = [2, 5, 17, 37, 101, 197, 257, 401, 577, 677, 1297, 1601]
</pre></div>
</div>
<p>If <span class="math">\(flag = 1\)</span>, this function returns instead the <em>indices</em> of
the selected elements, and not the elements themselves (indirect selection):</p>
<div class="highlight-python"><div class="highlight"><pre>? V = vector(50,i,i^2+1);
? select(x-&gt;isprime(x), V, 1)
%2 = Vecsmall([1, 2, 4, 6, 10, 14, 16, 20, 24, 26, 36, 40])
? vecextract(V, %)
%3 = [2, 5, 17, 37, 101, 197, 257, 401, 577, 677, 1297, 1601]
</pre></div>
</div>
<p>The following function lists the elements in <span class="math">\((\mathbb{Z}/N\mathbb{Z})^*\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>? invertibles(N) = select(x-&gt;gcd(x,N) == 1, [1..N])
</pre></div>
</div>
<p>Finally</p>
<div class="highlight-python"><div class="highlight"><pre>? select(x-&gt;x, M)
</pre></div>
</div>
<p>selects the non-0 entries in <tt class="docutils literal"><span class="pre">M</span></tt>. If the latter is a
<tt class="docutils literal"><span class="pre">t_MAT</span></tt>, we extract the matrix of non-0 columns. Note that <em>removing</em>
entries instead of selecting them just involves replacing the selection
function <tt class="docutils literal"><span class="pre">f</span></tt> with its negation:</p>
<div class="highlight-python"><div class="highlight"><pre>? select(x-&gt;!isprime(x), vector(50,i,i^2+1))
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.seralgdep">
<tt class="descname">seralgdep</tt><big>(</big><em>s</em>, <em>p</em>, <em>r</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.seralgdep" title="Permalink to this definition">¶</a></dt>
<dd><p>finds a linear relation between powers <span class="math">\((1,s,
..., s^p)\)</span> of the series <span class="math">\(s\)</span>, with polynomial coefficients of degree
<span class="math">\(&lt;= r\)</span>. In case no relation is found, return <span class="math">\(0\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? s = 1 + 10*y - 46*y^2 + 460*y^3 - 5658*y^4 + 77740*y^5 + O(y^6);
? seralgdep(s, 2, 2)
%2 = -x^2 + (8*y^2 + 20*y + 1)
? subst(%, x, s)
%3 = O(y^6)
? seralgdep(s, 1, 3)
%4 = (-77*y^2 - 20*y - 1)*x + (310*y^3 + 231*y^2 + 30*y + 1)
? seralgdep(s, 1, 2)
%5 = 0
</pre></div>
</div>
<p>The series main variable must not be <span class="math">\(x\)</span>, so as to be able
to express the result as a polynomial in <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.serconvol">
<tt class="descname">serconvol</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.serconvol" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolution (or Hadamard product) of the
two power series <span class="math">\(x\)</span> and <span class="math">\(y\)</span>; in other words if <span class="math">\(x = \sum a_k*X^k\)</span> and <span class="math">\(y = \sum
b_k*X^k\)</span> then <span class="math">\(serconvol(x,y) = \sum a_k*b_k*X^k\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.serlaplace">
<tt class="descname">serlaplace</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.serlaplace" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> must be a power series with non-negative
exponents or a polynomial. If <span class="math">\(x = \sum (a_k/k!)*X^k\)</span> then the result is <span class="math">\(\sum
a_k*X^k\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.serreverse">
<tt class="descname">serreverse</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.serreverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse power series of <span class="math">\(s\)</span>, i.e. the series <span class="math">\(t\)</span> such that <span class="math">\(t(s) = x\)</span>;
<span class="math">\(s\)</span> must be a power series whose valuation is exactly equal to one.</p>
<div class="highlight-python"><div class="highlight"><pre>? \ps 8
? t = serreverse(tan(x))
%2 = x - 1/3*x^3 + 1/5*x^5 - 1/7*x^7 + O(x^8)
? tan(t)
%3 = x + O(x^8)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.setbinop">
<tt class="descname">setbinop</tt><big>(</big><em>f</em>, <em>X</em>, <em>Y=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.setbinop" title="Permalink to this definition">¶</a></dt>
<dd><p>The set whose elements are the f(x,y), where x,y run through X,Y.
respectively. If <span class="math">\(Y\)</span> is omitted, assume that <span class="math">\(X = Y\)</span> and that <span class="math">\(f\)</span> is symmetric:
<span class="math">\(f(x,y) = f(y,x)\)</span> for all <span class="math">\(x,y\)</span> in <span class="math">\(X\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? X = [1,2,3]; Y = [2,3,4];
? setbinop((x,y)-&gt;x+y, X,Y) \\ set X + Y
%2 = [3, 4, 5, 6, 7]
? setbinop((x,y)-&gt;x-y, X,Y) \\ set X - Y
%3 = [-3, -2, -1, 0, 1]
? setbinop((x,y)-&gt;x+y, X) \\ set 2X = X + X
%2 = [2, 3, 4, 5, 6]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.setintersect">
<tt class="descname">setintersect</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.setintersect" title="Permalink to this definition">¶</a></dt>
<dd><p>Intersection of the two sets <span class="math">\(x\)</span> and <span class="math">\(y\)</span> (see <tt class="docutils literal"><span class="pre">setisset</span></tt>).
If <span class="math">\(x\)</span> or <span class="math">\(y\)</span> is not a set, the result is undefined.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.setisset">
<tt class="descname">setisset</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.setisset" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true (1) if <span class="math">\(x\)</span> is a set, false (0) if
not. In PARI, a set is a row vector whose entries are strictly
increasing with respect to a (somewhat arbitrary) universal comparison
function. To convert any object into a set (this is most useful for
vectors, of course), use the function <tt class="docutils literal"><span class="pre">Set</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>? a = [3, 1, 1, 2];
? setisset(a)
%2 = 0
? Set(a)
%3 = [1, 2, 3]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.setminus">
<tt class="descname">setminus</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.setminus" title="Permalink to this definition">¶</a></dt>
<dd><p>Difference of the two sets <span class="math">\(x\)</span> and <span class="math">\(y\)</span> (see <tt class="docutils literal"><span class="pre">setisset</span></tt>),
i.e.&nbsp;set of elements of <span class="math">\(x\)</span> which do not belong to <span class="math">\(y\)</span>.
If <span class="math">\(x\)</span> or <span class="math">\(y\)</span> is not a set, the result is undefined.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.setrand">
<tt class="descname">setrand</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.setrand" title="Permalink to this definition">¶</a></dt>
<dd><p>Reseeds the random number generator using the seed <span class="math">\(n\)</span>. No value is
returned. The seed is either a technical array output by <tt class="docutils literal"><span class="pre">getrand</span></tt>, or a
small positive integer, used to generate deterministically a suitable state
array. For instance, running a randomized computation starting by
<tt class="docutils literal"><span class="pre">setrand(1)</span></tt> twice will generate the exact same output.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.setsearch">
<tt class="descname">setsearch</tt><big>(</big><em>S</em>, <em>x</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.setsearch" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether <span class="math">\(x\)</span> belongs to the set <span class="math">\(S\)</span> (see <tt class="docutils literal"><span class="pre">setisset</span></tt>).</p>
<p>We first describe the default behaviour, when <span class="math">\(flag\)</span> is zero or omitted. If <span class="math">\(x\)</span>
belongs to the set <span class="math">\(S\)</span>, returns the index <span class="math">\(j\)</span> such that <span class="math">\(S[j] = x\)</span>, otherwise
returns 0.</p>
<div class="highlight-python"><div class="highlight"><pre>? T = [7,2,3,5]; S = Set(T);
? setsearch(S, 2)
%2 = 1
? setsearch(S, 4) \\ not found
%3 = 0
? setsearch(T, 7) \\ search in a randomly sorted vector
%4 = 0 \\ WRONG !
</pre></div>
</div>
<p>If <span class="math">\(S\)</span> is not a set, we also allow sorted lists with
respect to the <tt class="docutils literal"><span class="pre">cmp</span></tt> sorting function, without repeated entries,
as per <tt class="docutils literal"><span class="pre">listsort</span></tt><span class="math">\((L,1)\)</span>; otherwise the result is undefined.</p>
<div class="highlight-python"><div class="highlight"><pre>? L = List([1,4,2,3,2]); setsearch(L, 4)
%1 = 0 \\ WRONG !
? listsort(L, 1); L \\ sort L first
%2 = List([1, 2, 3, 4])
? setsearch(L, 4)
%3 = 4 \\ now correct
</pre></div>
</div>
<p>If <span class="math">\(flag\)</span> is non-zero, this function returns the index <span class="math">\(j\)</span> where <span class="math">\(x\)</span> should be
inserted, and <span class="math">\(0\)</span> if it already belongs to <span class="math">\(S\)</span>. This is meant to be used for
dynamically growing (sorted) lists, in conjunction with <tt class="docutils literal"><span class="pre">listinsert</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>? L = List([1,5,2,3,2]); listsort(L,1); L
%1 = List([1,2,3,5])
? j = setsearch(L, 4, 1) \\ 4 should have been inserted at index j
%2 = 4
? listinsert(L, 4, j); L
%3 = List([1, 2, 3, 4, 5])
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.setunion">
<tt class="descname">setunion</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.setunion" title="Permalink to this definition">¶</a></dt>
<dd><p>Union of the two sets <span class="math">\(x\)</span> and <span class="math">\(y\)</span> (see <tt class="docutils literal"><span class="pre">setisset</span></tt>).
If <span class="math">\(x\)</span> or <span class="math">\(y\)</span> is not a set, the result is undefined.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.shift">
<tt class="descname">shift</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts <span class="math">\(x\)</span> componentwise left by <span class="math">\(n\)</span> bits if <span class="math">\(n &gt;= 0\)</span> and right by <span class="math">\(\|n\|\)</span>
bits if <span class="math">\(n &lt; 0\)</span>. May be abbreviated as <span class="math">\(x\)</span> :literal:` &lt;&lt; ` <span class="math">\(n\)</span> or <span class="math">\(x\)</span> :literal:` &gt;&gt; ` <span class="math">\((-n)\)</span>.
A left shift by <span class="math">\(n\)</span> corresponds to multiplication by <span class="math">\(2^n\)</span>. A right shift of an
integer <span class="math">\(x\)</span> by <span class="math">\(\|n\|\)</span> corresponds to a Euclidean division of <span class="math">\(x\)</span> by <span class="math">\(2^{\|n\|}\)</span>
with a remainder of the same sign as <span class="math">\(x\)</span>, hence is not the same (in general) as
<span class="math">\(x \\ 2^n\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.shiftmul">
<tt class="descname">shiftmul</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.shiftmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplies <span class="math">\(x\)</span> by <span class="math">\(2^n\)</span>. The difference with
<tt class="docutils literal"><span class="pre">shift</span></tt> is that when <span class="math">\(n &lt; 0\)</span>, ordinary division takes place, hence for
example if <span class="math">\(x\)</span> is an integer the result may be a fraction, while for shifts
Euclidean division takes place when <span class="math">\(n &lt; 0\)</span> hence if <span class="math">\(x\)</span> is an integer the result
is still an integer.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sigma">
<tt class="descname">sigma</tt><big>(</big><em>x</em>, <em>k=1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of the <span class="math">\(k-th\)</span> powers of the positive divisors of <span class="math">\(\|x\|\)</span>. <span class="math">\(x\)</span>
and <span class="math">\(k\)</span> must be of type integer.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sign">
<tt class="descname">sign</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>sign (<span class="math">\(0\)</span>, <span class="math">\(1\)</span> or <span class="math">\(-1\)</span>) of <span class="math">\(x\)</span>, which must be of
type integer, real or fraction; <tt class="docutils literal"><span class="pre">t_QUAD</span></tt> with positive discriminants and
<tt class="docutils literal"><span class="pre">t_INFINITY</span></tt> are also supported.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.simplify">
<tt class="descname">simplify</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>This function simplifies <span class="math">\(x\)</span> as much as it can. Specifically, a complex or
quadratic number whose imaginary part is the integer 0 (i.e.&nbsp;not <tt class="docutils literal"><span class="pre">Mod(0,2)</span></tt>
or <tt class="docutils literal"><span class="pre">0.E-28</span></tt>) is converted to its real part, and a polynomial of degree <span class="math">\(0\)</span>
is converted to its constant term. Simplifications occur recursively.</p>
<p>This function is especially useful before using arithmetic functions,
which expect integer arguments:</p>
<div class="highlight-python"><div class="highlight"><pre>? x = 2 + y - y
%1 = 2
? isprime(x)
 *** at top-level: isprime(x)
 *** ^----------
 *** isprime: not an integer argument in an arithmetic function
? type(x)
%2 = &quot;t_POL&quot;
? type(simplify(x))
%3 = &quot;t_INT&quot;
</pre></div>
</div>
<p>Note that GP results are simplified as above before they are stored in the
history. (Unless you disable automatic simplification with <tt class="docutils literal"><span class="pre">\y</span></tt>, that is.)
In particular</p>
<div class="highlight-python"><div class="highlight"><pre>? type(%1)
%4 = &quot;t_INT&quot;
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sin">
<tt class="descname">sin</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sin" title="Permalink to this definition">¶</a></dt>
<dd><p>Sine of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sinc">
<tt class="descname">sinc</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sinc" title="Permalink to this definition">¶</a></dt>
<dd><p>Cardinal sine of <span class="math">\(x\)</span>, i.e. <span class="math">\(\sin(x)/x\)</span> if <span class="math">\(x != 0\)</span>, <span class="math">\(1\)</span> otherwise.
Note that this function also allows to compute</p>
<div class="math">
\[(1-\cos(x)) / x^2 = sinc(x/2)^2 / 2\]</div>
<p>accurately near <span class="math">\(x = 0\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sinh">
<tt class="descname">sinh</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Hyperbolic sine of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sizebyte">
<tt class="descname">sizebyte</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sizebyte" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the total number of bytes occupied by the tree representing the
PARI object <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sizedigit">
<tt class="descname">sizedigit</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sizedigit" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs a quick upper bound for the number of decimal digits of (the
components of) <span class="math">\(x\)</span>, off by at most <span class="math">\(1\)</span>. More precisely, for a positive
integer <span class="math">\(x\)</span>, it computes (approximately) the ceiling of</p>
<div class="math">
\[floor(1 + \log_2 x) \log_{10}2,\]</div>
<p>This function is DEPRECATED, essentially meaningless, and provided for
backwards compatibility only. Don&#8217;t use it!</p>
<p>To count the number of decimal digits of a positive integer <span class="math">\(x\)</span>, use
<tt class="docutils literal"><span class="pre">#digits(x)</span></tt>. To estimate (recursively) the size of <span class="math">\(x\)</span>, use
<tt class="docutils literal"><span class="pre">normlp(x)</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sqr">
<tt class="descname">sqr</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Square of <span class="math">\(x\)</span>. This operation is not completely
straightforward, i.e.&nbsp;identical to <span class="math">\(x * x\)</span>, since it can usually be
computed more efficiently (roughly one-half of the elementary
multiplications can be saved). Also, squaring a <span class="math">\(2\)</span>-adic number increases
its precision. For example,</p>
<div class="highlight-python"><div class="highlight"><pre>? (1 + O(2^4))^2
%1 = 1 + O(2^5)
? (1 + O(2^4)) * (1 + O(2^4))
%2 = 1 + O(2^4)
</pre></div>
</div>
<p>Note that this function is also called whenever one multiplies two objects
which are known to be <em>identical</em>, e.g.&nbsp;they are the value of the same
variable, or we are computing a power.</p>
<div class="highlight-python"><div class="highlight"><pre>? x = (1 + O(2^4)); x * x
%3 = 1 + O(2^5)
? (1 + O(2^4))^4
%4 = 1 + O(2^6)
</pre></div>
</div>
<p>(note the difference between <tt class="docutils literal"><span class="pre">%2</span></tt> and <tt class="docutils literal"><span class="pre">%3</span></tt> above).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sqrt">
<tt class="descname">sqrt</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of the square root of <span class="math">\(x\)</span>, defined as <span class="math">\(\sqrt{x} = 
\exp(\log x / 2)\)</span>. In particular, we have
<span class="math">\({Arg}({sqrt}(x)) belongs to ]-\Pi/2, \Pi/2]\)</span>, and if <span class="math">\(x belongs to \mathbb{R}\)</span> and <span class="math">\(x &lt; 0\)</span>,
then the result is complex with positive imaginary part.</p>
<p>Intmod a prime <span class="math">\(p\)</span>, <tt class="docutils literal"><span class="pre">t_PADIC</span></tt> and <tt class="docutils literal"><span class="pre">t_FFELT</span></tt> are allowed as arguments. In
the first 2 cases (<tt class="docutils literal"><span class="pre">t_INTMOD</span></tt>, <tt class="docutils literal"><span class="pre">t_PADIC</span></tt>), the square root (if it
exists) which is returned is the one whose first <span class="math">\(p\)</span>-adic digit is in the
interval <span class="math">\([0,p/2]\)</span>. For other arguments, the result is undefined.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sqrtint">
<tt class="descname">sqrtint</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sqrtint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the integer square root of <span class="math">\(x\)</span>, i.e. the largest integer <span class="math">\(y\)</span>
such that <span class="math">\(y^2 &lt;= x\)</span>, where <span class="math">\(x\)</span> a non-negative integer.</p>
<div class="highlight-python"><div class="highlight"><pre>? N = 120938191237; sqrtint(N)
%1 = 347761
? sqrt(N)
%2 = 347761.68741970412747602130964414095216
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sqrtnint">
<tt class="descname">sqrtnint</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sqrtnint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the integer <span class="math">\(n\)</span>-th root of <span class="math">\(x\)</span>, i.e. the largest integer <span class="math">\(y\)</span> such
that <span class="math">\(y^n &lt;= x\)</span>, where <span class="math">\(x\)</span> is a non-negative integer.</p>
<div class="highlight-python"><div class="highlight"><pre>? N = 120938191237; sqrtnint(N, 5)
%1 = 164
? N^(1/5)
%2 = 164.63140849829660842958614676939677391
</pre></div>
</div>
<p>The special case <span class="math">\(n = 2\)</span> is <tt class="docutils literal"><span class="pre">sqrtint</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.subgrouplist">
<tt class="descname">subgrouplist</tt><big>(</big><em>bnr</em>, <em>bound=None</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.subgrouplist" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bnr</em> being as output by <tt class="docutils literal"><span class="pre">bnrinit</span></tt> or a list of cyclic components
of a finite Abelian group <span class="math">\(G\)</span>, outputs the list of subgroups of <span class="math">\(G\)</span>. Subgroups
are given as HNF left divisors of the SNF matrix corresponding to <span class="math">\(G\)</span>.</p>
<p>If <span class="math">\(flag = 0\)</span> (default) and <em>bnr</em> is as output by <tt class="docutils literal"><span class="pre">bnrinit</span></tt>, gives
only the subgroups whose modulus is the conductor. Otherwise, the modulus is
not taken into account.</p>
<p>If <em>bound</em> is present, and is a positive integer, restrict the output to
subgroups of index less than <em>bound</em>. If <em>bound</em> is a vector
containing a single positive integer <span class="math">\(B\)</span>, then only subgroups of index
exactly equal to <span class="math">\(B\)</span> are computed. For instance</p>
<div class="highlight-python"><div class="highlight"><pre>? subgrouplist([6,2])
%1 = [[6, 0; 0, 2], [2, 0; 0, 2], [6, 3; 0, 1], [2, 1; 0, 1], [3, 0; 0, 2],
[1, 0; 0, 2], [6, 0; 0, 1], [2, 0; 0, 1], [3, 0; 0, 1], [1, 0; 0, 1]]
? subgrouplist([6,2],3) \\ index less than 3
%2 = [[2, 1; 0, 1], [1, 0; 0, 2], [2, 0; 0, 1], [3, 0; 0, 1], [1, 0; 0, 1]]
? subgrouplist([6,2],[3]) \\ index 3
%3 = [[3, 0; 0, 1]]
? bnr = bnrinit(bnfinit(x), [120,[1]], 1);
? L = subgrouplist(bnr, [8]);
</pre></div>
</div>
<p>In the last example, <span class="math">\(L\)</span> corresponds to the 24 subfields of
<span class="math">\(\mathbb{Q}(\zeta_{120})\)</span>, of degree <span class="math">\(8\)</span> and conductor <span class="math">\(120 oo\)</span> (by setting <em>flag</em>,
we see there are a total of <span class="math">\(43\)</span> subgroups of degree <span class="math">\(8\)</span>).</p>
<div class="highlight-python"><div class="highlight"><pre>? vector(#L, i, galoissubcyclo(bnr, L[i]))
</pre></div>
</div>
<p>will produce their equations. (For a general base field, you would
have to rely on <tt class="docutils literal"><span class="pre">bnrstark</span></tt>, or <tt class="docutils literal"><span class="pre">rnfkummer</span></tt>.)</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.subst">
<tt class="descname">subst</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.subst" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the simple variable <span class="math">\(y\)</span> by the argument <span class="math">\(z\)</span> in the &#8220;polynomial&#8221;
expression <span class="math">\(x\)</span>. Every type is allowed for <span class="math">\(x\)</span>, but if it is not a genuine
polynomial (or power series, or rational function), the substitution will be
done as if the scalar components were polynomials of degree zero. In
particular, beware that:</p>
<div class="highlight-python"><div class="highlight"><pre>? subst(1, x, [1,2; 3,4])
%1 =
[1 0]

[0 1]

? subst(1, x, Mat([0,1]))
 *** at top-level: subst(1,x,Mat([0,1])
 *** ^--------------------
 *** subst: forbidden substitution by a non square matrix.
</pre></div>
</div>
<p>If <span class="math">\(x\)</span> is a power series, <span class="math">\(z\)</span> must be either a polynomial, a power
series, or a rational function. Finally, if <span class="math">\(x\)</span> is a vector,
matrix or list, the substitution is applied to each individual entry.</p>
<p>Use the function <tt class="docutils literal"><span class="pre">substvec</span></tt> to replace several variables at once,
or the function <tt class="docutils literal"><span class="pre">substpol</span></tt> to replace a polynomial expression.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.substpol">
<tt class="descname">substpol</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.substpol" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the &#8220;variable&#8221; <span class="math">\(y\)</span> by the argument <span class="math">\(z\)</span> in the &#8220;polynomial&#8221;
expression <span class="math">\(x\)</span>. Every type is allowed for <span class="math">\(x\)</span>, but the same behavior
as <tt class="docutils literal"><span class="pre">subst</span></tt> above apply.</p>
<p>The difference with <tt class="docutils literal"><span class="pre">subst</span></tt> is that <span class="math">\(y\)</span> is allowed to be any polynomial
here. The substitution is done moding out all components of <span class="math">\(x\)</span>
(recursively) by <span class="math">\(y - t\)</span>, where <span class="math">\(t\)</span> is a new free variable of lowest
priority. Then substituting <span class="math">\(t\)</span> by <span class="math">\(z\)</span> in the resulting expression. For
instance</p>
<div class="highlight-python"><div class="highlight"><pre>? substpol(x^4 + x^2 + 1, x^2, y)
%1 = y^2 + y + 1
? substpol(x^4 + x^2 + 1, x^3, y)
%2 = x^2 + y*x + 1
? substpol(x^4 + x^2 + 1, (x+1)^2, y)
%3 = (-4*y - 6)*x + (y^2 + 3*y - 3)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.substvec">
<tt class="descname">substvec</tt><big>(</big><em>x</em>, <em>v</em>, <em>w</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.substvec" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(v\)</span> being a vector of monomials of degree 1 (variables),
<span class="math">\(w\)</span> a vector of expressions of the same length, replace in the expression
<span class="math">\(x\)</span> all occurrences of <span class="math">\(v_i\)</span> by <span class="math">\(w_i\)</span>. The substitutions are done
simultaneously; more precisely, the <span class="math">\(v_i\)</span> are first replaced by new
variables in <span class="math">\(x\)</span>, then these are replaced by the <span class="math">\(w_i\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>? substvec([x,y], [x,y], [y,x])
%1 = [y, x]
? substvec([x,y], [x,y], [y,x+y])
%2 = [y, x + y] \\ not [y, 2*y]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sumdedekind">
<tt class="descname">sumdedekind</tt><big>(</big><em>h</em>, <em>k</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sumdedekind" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Dedekind sum associated to the integers <span class="math">\(h\)</span> and <span class="math">\(k\)</span>,
corresponding to a fast implementation of</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">s</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">frac</span><span class="p">(</span><span class="n">h</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sumdigits">
<tt class="descname">sumdigits</tt><big>(</big><em>n</em>, <em>B=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sumdigits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of digits in the integer <span class="math">\(n\)</span>, when written in base <span class="math">\(B &gt; 1\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? sumdigits(123456789)
%1 = 45
? sumdigits(123456789, 2)
%1 = 16
</pre></div>
</div>
<p>Note that the sum of bits in <span class="math">\(n\)</span> is also returned by
<tt class="docutils literal"><span class="pre">hammingweight</span></tt>. This function is much faster than
<tt class="docutils literal"><span class="pre">vecsum(digits(n,B))</span></tt> when <span class="math">\(B\)</span> is <span class="math">\(10\)</span> or a power of <span class="math">\(2\)</span>, and only
slightly faster in other cases.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sumformal">
<tt class="descname">sumformal</tt><big>(</big><em>f</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sumformal" title="Permalink to this definition">¶</a></dt>
<dd><p>formal sum of the polynomial expression <span class="math">\(f\)</span> with respect to the
main variable if <span class="math">\(v\)</span> is omitted, with respect to the variable <span class="math">\(v\)</span> otherwise;
it is assumed that the base ring has characteristic zero. In other words,
considering <span class="math">\(f\)</span> as a polynomial function in the variable <span class="math">\(v\)</span>,
returns <span class="math">\(F\)</span>, a polynomial in <span class="math">\(v\)</span> vanishing at <span class="math">\(0\)</span>, such that <span class="math">\(F(b) - F(a)
= sum_{v = a+1}^b f(v)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>? sumformal(n) \\ 1 + ... + n
%1 = 1/2*n^2 + 1/2*n
? f(n) = n^3+n^2+1;
? F = sumformal(f(n)) \\ f(1) + ... + f(n)
%3 = 1/4*n^4 + 5/6*n^3 + 3/4*n^2 + 7/6*n
? sum(n = 1, 2000, f(n)) == subst(F, n, 2000)
%4 = 1
? sum(n = 1001, 2000, f(n)) == subst(F, n, 2000) - subst(F, n, 1000)
%5 = 1
? sumformal(x^2 + x*y + y^2, y)
%6 = y*x^2 + (1/2*y^2 + 1/2*y)*x + (1/3*y^3 + 1/2*y^2 + 1/6*y)
? x^2 * y + x * sumformal(y) + sumformal(y^2) == %
%7 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sumnuminit">
<tt class="descname">sumnuminit</tt><big>(</big><em>asymp</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sumnuminit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize tables for Euler&#8211;MacLaurin delta summation of a series with
positive terms. If given, <tt class="docutils literal"><span class="pre">asymp</span></tt> is of the form <span class="math">\([+oo, \alpha]\)</span>,
as in <tt class="docutils literal"><span class="pre">intnum</span></tt> and indicates the decrease rate at infinity of functions
to be summed. A positive
<span class="math">\(\alpha &gt; 0\)</span> encodes an exponential decrease of type <span class="math">\(\exp(-\alpha n)\)</span> and
a negative <span class="math">\(-2 &lt; \alpha &lt; -1\)</span> encodes a slow polynomial decrease of type
<span class="math">\(n^{\alpha}\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? \p200
? sumnum(n=1, n^-2);
time = 200 ms.
? tab = sumnuminit();
time = 188 ms.
? sumnum(n=1, n^-2, tab); \\ faster
time = 8 ms.

? tab = sumnuminit([+oo, log(2)]); \\ decrease like 2^-n
time = 200 ms.
? sumnum(n=1, 2^-n, tab)
time = 44 ms.

? tab = sumnuminit([+oo, -4/3]); \\ decrease like n^(-4/3)
time = 200 ms.
? sumnum(n=1, n^(-4/3), tab);
time = 221 ms.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.tan">
<tt class="descname">tan</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.tan" title="Permalink to this definition">¶</a></dt>
<dd><p>Tangent of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.tanh">
<tt class="descname">tanh</tt><big>(</big><em>x</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.tanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Hyperbolic tangent of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.taylor">
<tt class="descname">taylor</tt><big>(</big><em>x</em>, <em>t</em>, <em>serprec=-1</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.taylor" title="Permalink to this definition">¶</a></dt>
<dd><p>Taylor expansion around <span class="math">\(0\)</span> of <span class="math">\(x\)</span> with respect to
the simple variable <span class="math">\(t\)</span>. <span class="math">\(x\)</span> can be of any reasonable type, for example a
rational function. Contrary to <tt class="docutils literal"><span class="pre">Ser</span></tt>, which takes the valuation into
account, this function adds <span class="math">\(O(t^d)\)</span> to all components of <span class="math">\(x\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? taylor(x/(1+y), y, 5)
%1 = (y^4 - y^3 + y^2 - y + 1)*x + O(y^5)
? Ser(x/(1+y), y, 5)
 *** at top-level: Ser(x/(1+y),y,5)
 *** ^----------------
 *** Ser: main variable must have higher priority in gtoser.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.teichmuller">
<tt class="descname">teichmuller</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.teichmuller" title="Permalink to this definition">¶</a></dt>
<dd><p>Teichmüller character of the <span class="math">\(p\)</span>-adic number <span class="math">\(x\)</span>, i.e. the unique
<span class="math">\((p-1)\)</span>-th root of unity congruent to <span class="math">\(x / p^{v_p(x)}\)</span> modulo <span class="math">\(p\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.theta">
<tt class="descname">theta</tt><big>(</big><em>q</em>, <em>z</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Jacobi sine theta-function</p>
<div class="math">
\[\begin{split}\theta_1(z, q) = 2q^{1/4} \sum_{n &gt;= 0} (-1)^n q^{n(n+1)} \sin((2n+1)z).\end{split}\]</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.thetanullk">
<tt class="descname">thetanullk</tt><big>(</big><em>q</em>, <em>k</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.thetanullk" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(k\)</span>-th derivative at <span class="math">\(z = 0\)</span> of <span class="math">\(theta(q,z)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.thue">
<tt class="descname">thue</tt><big>(</big><em>tnf</em>, <em>a</em>, <em>sol=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.thue" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all solutions of the equation
<span class="math">\(P(x,y) = a\)</span> in integers <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, where <em>tnf</em> was created with
<span class="math">\(thueinit(P)\)</span>. If present, <em>sol</em> must contain the solutions of
<span class="math">\(\mathrm{Norm}(x) = a\)</span> modulo units of positive norm in the number field
defined by <span class="math">\(P\)</span> (as computed by <tt class="docutils literal"><span class="pre">bnfisintnorm</span></tt>). If there are infinitely
many solutions, an error is issued.</p>
<p>It is allowed to input directly the polynomial <span class="math">\(P\)</span> instead of a <em>tnf</em>,
in which case, the function first performs <tt class="docutils literal"><span class="pre">thueinit(P,0)</span></tt>. This is
very wasteful if more than one value of <span class="math">\(a\)</span> is required.</p>
<p>If <em>tnf</em> was computed without assuming GRH (flag <span class="math">\(1\)</span> in <tt class="docutils literal"><span class="pre">thueinit</span></tt>),
then the result is unconditional. Otherwise, it depends in principle of the
truth of the GRH, but may still be unconditionally correct in some
favorable cases. The result is conditional on the GRH if
<span class="math">\(a != ± 1\)</span> and, <span class="math">\(P\)</span> has a single irreducible rational factor, whose
associated tentative class number <span class="math">\(h\)</span> and regulator <span class="math">\(R\)</span> (as computed
assuming the GRH) satisfy</p>
<ul class="simple">
<li><span class="math">\(h &gt; 1\)</span>,</li>
<li><span class="math">\(R/0.2 &gt; 1.5\)</span>.</li>
</ul>
<p>Here&#8217;s how to solve the Thue equation <span class="math">\(x^{13} - 5y^{13} = - 4\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre>? tnf = thueinit(x^13 - 5);
? thue(tnf, -4)
%1 = [[1, 1]]
</pre></div>
</div>
<p>In this case, one checks that <tt class="docutils literal"><span class="pre">bnfinit(x^13</span> <span class="pre">-5).no</span></tt>
is <span class="math">\(1\)</span>. Hence, the only solution is <span class="math">\((x,y) = (1,1)\)</span>, and the result is
unconditional. On the other hand:</p>
<div class="highlight-python"><div class="highlight"><pre>? P = x^3-2*x^2+3*x-17; tnf = thueinit(P);
? thue(tnf, -15)
%2 = [[1, 1]] \\ a priori conditional on the GRH.
? K = bnfinit(P); K.no
%3 = 3
? K.reg
%4 = 2.8682185139262873674706034475498755834
</pre></div>
</div>
<p>This time the result is conditional. All results computed using this
particular <em>tnf</em> are likewise conditional, <em>except</em> for a right-hand
side of <span class="math">\(± 1\)</span>.
The above result is in fact correct, so we did not just disprove the GRH:</p>
<div class="highlight-python"><div class="highlight"><pre>? tnf = thueinit(x^3-2*x^2+3*x-17, 1 /*unconditional*/);
? thue(tnf, -15)
%4 = [[1, 1]]
</pre></div>
</div>
<p>Note that reducible or non-monic polynomials are allowed:</p>
<div class="highlight-python"><div class="highlight"><pre>? tnf = thueinit((2*x+1)^5 * (4*x^3-2*x^2+3*x-17), 1);
? thue(tnf, 128)
%2 = [[-1, 0], [1, 0]]
</pre></div>
</div>
<p>Reducible polynomials are in fact much easier to handle.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.thueinit">
<tt class="descname">thueinit</tt><big>(</big><em>P</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.thueinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the <em>tnf</em> corresponding to <span class="math">\(P\)</span>, a non-constant
univariate polynomial with integer coefficients.
The result is meant to be used in conjunction with <tt class="docutils literal"><span class="pre">thue</span></tt> to solve Thue
equations <span class="math">\(P(X / Y)Y^{\deg P} = a\)</span>, where <span class="math">\(a\)</span> is an integer. Accordingly,
<span class="math">\(P\)</span> must either have at least two distinct irreducible factors over <span class="math">\(\mathbb{Q}\)</span>,
or have one irreducible factor <span class="math">\(T\)</span> with degree <span class="math">\(&gt; 2\)</span> or two conjugate
complex roots: under these (necessary and sufficient) conditions, the
equation has finitely many integer solutions.</p>
<div class="highlight-python"><div class="highlight"><pre>? S = thueinit(t^2+1);
? thue(S, 5)
%2 = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]]
? S = thueinit(t+1);
 *** at top-level: thueinit(t+1)
 *** ^-------------
 *** thueinit: domain error in thueinit: P = t + 1
</pre></div>
</div>
<p>The hardest case is when <span class="math">\(\deg P &gt; 2\)</span> and <span class="math">\(P\)</span> is irreducible
with at least one real root. The routine then uses Bilu-Hanrot&#8217;s algorithm.</p>
<p>If <span class="math">\(flag\)</span> is non-zero, certify results unconditionally. Otherwise, assume
GRH, this being much faster of course. In the latter case, the result
may still be unconditionally correct, see <tt class="docutils literal"><span class="pre">thue</span></tt>. For instance in most
cases where <span class="math">\(P\)</span> is reducible (not a pure power of an irreducible), <em>or</em>
conditional computed class groups are trivial <em>or</em> the right hand side
is <span class="math">\(±1\)</span>, then results are unconditional.</p>
<p><strong>Note.</strong> The general philosophy is to disprove the existence of large
solutions then to enumerate bounded solutions naively. The implementation
will overflow when there exist huge solutions and the equation has degree
<span class="math">\(&gt; 2\)</span> (the quadratic imaginary case is special, since we can use
<tt class="docutils literal"><span class="pre">bnfisintnorm</span></tt>):</p>
<div class="highlight-python"><div class="highlight"><pre>? thue(t^3+2, 10^30)
 *** at top-level: L=thue(t^3+2,10^30)
 *** ^-----------------
 *** thue: overflow in thue (SmallSols): y &lt;= 80665203789619036028928.
? thue(x^2+2, 10^30) \\ quadratic case much easier
%1 = [[-1000000000000000, 0], [1000000000000000, 0]]
</pre></div>
</div>
<p><strong>Note.</strong> It is sometimes possible to circumvent the above, and in any
case obtain an important speed-up, if you can write <span class="math">\(P = Q(x^d)\)</span> for some <span class="math">\(d &gt; 
1\)</span> and <span class="math">\(Q\)</span> still satisfying the <tt class="docutils literal"><span class="pre">thueinit</span></tt> hypotheses. You can then solve
the equation associated to <span class="math">\(Q\)</span> then eliminate all solutions <span class="math">\((x,y)\)</span> such that
either <span class="math">\(x\)</span> or <span class="math">\(y\)</span> is not a <span class="math">\(d\)</span>-th power.</p>
<div class="highlight-python"><div class="highlight"><pre>? thue(x^4+1, 10^40); \\ stopped after 10 hours
? filter(L,d) =
 my(x,y); [[x,y] | v&lt;-L, ispower(v[1],d,&amp;x)&amp;&amp;ispower(v[2],d,&amp;y)];
? L = thue(x^2+1, 10^40);
? filter(L, 2)
%4 = [[0, 10000000000], [10000000000, 0]]
</pre></div>
</div>
<p>The last 2 commands use less than 20ms.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.trace">
<tt class="descname">trace</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>This applies to quite general <span class="math">\(x\)</span>. If <span class="math">\(x\)</span> is not a
matrix, it is equal to the sum of <span class="math">\(x\)</span> and its conjugate, except for polmods
where it is the trace as an algebraic number.</p>
<p>For <span class="math">\(x\)</span> a square matrix, it is the ordinary trace. If <span class="math">\(x\)</span> is a
non-square matrix (but not a vector), an error occurs.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.type">
<tt class="descname">type</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.type" title="Permalink to this definition">¶</a></dt>
<dd><p>This is useful only under <tt class="docutils literal"><span class="pre">gp</span></tt>. Returns the internal type name of
the PARI object <span class="math">\(x\)</span> as a string. Check out existing type names with the
metacommand <tt class="docutils literal"><span class="pre">\t</span></tt>. For example <tt class="docutils literal"><span class="pre">type(1)</span></tt> will return &#8220;<tt class="docutils literal"><span class="pre">t_INT</span></tt>&#8221;.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.valuation">
<tt class="descname">valuation</tt><big>(</big><em>x</em>, <em>p</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.valuation" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the highest
exponent of <span class="math">\(p\)</span> dividing <span class="math">\(x\)</span>. If <span class="math">\(p\)</span> is of type integer, <span class="math">\(x\)</span> must be an
integer, an intmod whose modulus is divisible by <span class="math">\(p\)</span>, a fraction, a
<span class="math">\(q\)</span>-adic number with <span class="math">\(q = p\)</span>, or a polynomial or power series in which case the
valuation is the minimum of the valuation of the coefficients.</p>
<p>If <span class="math">\(p\)</span> is of type polynomial, <span class="math">\(x\)</span> must be of type polynomial or rational
function, and also a power series if <span class="math">\(x\)</span> is a monomial. Finally, the
valuation of a vector, complex or quadratic number is the minimum of the
component valuations.</p>
<p>If <span class="math">\(x = 0\)</span>, the result is <tt class="docutils literal"><span class="pre">+oo</span></tt> if <span class="math">\(x\)</span> is an exact object. If <span class="math">\(x\)</span> is a
<span class="math">\(p\)</span>-adic numbers or power series, the result is the exponent of the zero.
Any other type combinations gives an error.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.variable">
<tt class="descname">variable</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the main variable of the object <span class="math">\(x\)</span> (the variable with the highest
priority used in <span class="math">\(x\)</span>), and <span class="math">\(p\)</span> if <span class="math">\(x\)</span> is a <span class="math">\(p\)</span>-adic number. Return <span class="math">\(0\)</span> if
<span class="math">\(x\)</span> has no variable associated to it.</p>
<div class="highlight-python"><div class="highlight"><pre>? variable(x^2 + y)
%1 = x
? variable(1 + O(5^2))
%2 = 5
? variable([x,y,z,t])
%3 = x
? variable(1)
%4 = 0
</pre></div>
</div>
<p>The construction</p>
<div class="highlight-python"><div class="highlight"><pre>if (!variable(x),...)
</pre></div>
</div>
<p>can be used to test whether a variable is attached to <span class="math">\(x\)</span>.</p>
<p>If <span class="math">\(x\)</span> is omitted, returns the list of user variables known to the
interpreter, by order of decreasing priority. (Highest priority is initially
<span class="math">\(x\)</span>, which come first until <tt class="docutils literal"><span class="pre">varhigher</span></tt> is used.) If <tt class="docutils literal"><span class="pre">varhigher</span></tt>
or <tt class="docutils literal"><span class="pre">varlower</span></tt> are used, it is quite possible to end up with different
variables (with different priorities) printed in the same way: they
will then appear multiple times in the output:</p>
<div class="highlight-python"><div class="highlight"><pre>? varhigher(&quot;y&quot;);
? varlower(&quot;y&quot;);
? variable()
%4 = [y, x, y]
</pre></div>
</div>
<p>Using <tt class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">variable()</span></tt> then <tt class="docutils literal"><span class="pre">v[1]</span></tt>, <tt class="docutils literal"><span class="pre">v[2]</span></tt>,
etc.&nbsp;allows to recover and use existing variables.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.variables">
<tt class="descname">variables</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the list of all variables occuring in object <span class="math">\(x\)</span> (all user
variables known to the interpreter if <span class="math">\(x\)</span> is omitted), sorted by
decreasing priority.</p>
<div class="highlight-python"><div class="highlight"><pre>? variables([x^2 + y*z + O(t), a+x])
%1 = [x, y, z, t, a]
</pre></div>
</div>
<p>The construction</p>
<div class="highlight-python"><div class="highlight"><pre>if (!variables(x),...)
</pre></div>
</div>
<p>can be used to test whether a variable is attached to <span class="math">\(x\)</span>.</p>
<p>If <tt class="docutils literal"><span class="pre">varhigher</span></tt> or <tt class="docutils literal"><span class="pre">varlower</span></tt> are used, it is quite possible to end up
with different variables (with different priorities) printed in the same
way: they will then appear multiple times in the output:</p>
<div class="highlight-python"><div class="highlight"><pre>? y1 = varhigher(&quot;y&quot;);
? y2 = varlower(&quot;y&quot;);
? variables(y*y1*y2)
%4 = [y, y, y]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.vecextract">
<tt class="descname">vecextract</tt><big>(</big><em>x</em>, <em>y</em>, <em>z=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.vecextract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extraction of components of the vector or matrix <span class="math">\(x\)</span> according to <span class="math">\(y\)</span>.
In case <span class="math">\(x\)</span> is a matrix, its components are the <em>columns</em> of <span class="math">\(x\)</span>. The
parameter <span class="math">\(y\)</span> is a component specifier, which is either an integer, a string
describing a range, or a vector.</p>
<p>If <span class="math">\(y\)</span> is an integer, it is considered as a mask: the binary bits of <span class="math">\(y\)</span> are
read from right to left, but correspond to taking the components from left to
right. For example, if <span class="math">\(y = 13 = (1101)_2\)</span> then the components 1,3 and 4 are
extracted.</p>
<p>If <span class="math">\(y\)</span> is a vector (<tt class="docutils literal"><span class="pre">t_VEC</span></tt>, <tt class="docutils literal"><span class="pre">t_COL</span></tt> or <tt class="docutils literal"><span class="pre">t_VECSMALL</span></tt>), which must have
integer entries, these entries correspond to the component numbers to be
extracted, in the order specified.</p>
<p>If <span class="math">\(y\)</span> is a string, it can be</p>
<ul class="simple">
<li>a single (non-zero) index giving a component number (a negative
index means we start counting from the end).</li>
<li>a range of the form <tt class="docutils literal"><span class="pre">&quot;:math:`a</span></tt>..:math:<span class="math">\(b\)</span>&#8220;<span class="math">\(, where :math:`a\)</span> and <span class="math">\(b\)</span> are
indexes as above. Any of <span class="math">\(a\)</span> and <span class="math">\(b\)</span> can be omitted; in this case, we take
as default values <span class="math">\(a = 1\)</span> and <span class="math">\(b = -1\)</span>, i.e.&nbsp;the first and last components
respectively. We then extract all components in the interval <span class="math">\([a,b]\)</span>, in
reverse order if <span class="math">\(b &lt; a\)</span>.</li>
</ul>
<p>In addition, if the first character in the string is <tt class="docutils literal"><span class="pre">^</span></tt>, the
complement of the given set of indices is taken.</p>
<p>If <span class="math">\(z\)</span> is not omitted, <span class="math">\(x\)</span> must be a matrix. <span class="math">\(y\)</span> is then the <em>row</em>
specifier, and <span class="math">\(z\)</span> the <em>column</em> specifier, where the component specifier
is as explained above.</p>
<div class="highlight-python"><div class="highlight"><pre>? v = [a, b, c, d, e];
? vecextract(v, 5) \\ mask
%1 = [a, c]
? vecextract(v, [4, 2, 1]) \\ component list
%2 = [d, b, a]
? vecextract(v, &quot;2..4&quot;) \\ interval
%3 = [b, c, d]
? vecextract(v, &quot;-1..-3&quot;) \\ interval + reverse order
%4 = [e, d, c]
? vecextract(v, &quot;^2&quot;) \\ complement
%5 = [a, c, d, e]
? vecextract(matid(3), &quot;2..&quot;, &quot;..&quot;)
%6 =
[0 1 0]

[0 0 1]
</pre></div>
</div>
<p>The range notations <tt class="docutils literal"><span class="pre">v[i..j]</span></tt> and <tt class="docutils literal"><span class="pre">v[^i]</span></tt> (for <tt class="docutils literal"><span class="pre">t_VEC</span></tt> or
<tt class="docutils literal"><span class="pre">t_COL</span></tt>) and <tt class="docutils literal"><span class="pre">M[i..j,</span> <span class="pre">k..l]</span></tt> and friends (for <tt class="docutils literal"><span class="pre">t_MAT</span></tt>) implement a
subset of the above, in a simpler and <em>faster</em> way, hence should be
preferred in most common situations. The following features are not
implemented in the range notation:</p>
<ul class="simple">
<li>reverse order,</li>
<li>omitting either <span class="math">\(a\)</span> or <span class="math">\(b\)</span> in <tt class="docutils literal"><span class="pre">:math:`a</span></tt>..:math:<span class="math">\(b`\)</span>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.vecsearch">
<tt class="descname">vecsearch</tt><big>(</big><em>v</em>, <em>x</em>, <em>cmpf=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.vecsearch" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether <span class="math">\(x\)</span> belongs to the sorted vector or list <span class="math">\(v\)</span>: return
the (positive) index where <span class="math">\(x\)</span> was found, or <span class="math">\(0\)</span> if it does not belong to
<span class="math">\(v\)</span>.</p>
<p>If the comparison function cmpf is omitted, we assume that <span class="math">\(v\)</span> is sorted in
increasing order, according to the standard comparison function <tt class="docutils literal"><span class="pre">lex</span></tt>,
thereby restricting the possible types for <span class="math">\(x\)</span> and the elements of <span class="math">\(v\)</span>
(integers, fractions, reals, and vectors of such).</p>
<p>If <tt class="docutils literal"><span class="pre">cmpf</span></tt> is present, it is understood as a comparison function and we
assume that <span class="math">\(v\)</span> is sorted according to it, see <tt class="docutils literal"><span class="pre">vecsort</span></tt> for how to
encode comparison functions.</p>
<div class="highlight-python"><div class="highlight"><pre>? v = [1,3,4,5,7];
? vecsearch(v, 3)
%2 = 2
? vecsearch(v, 6)
%3 = 0 \\ not in the list
? vecsearch([7,6,5], 5) \\ unsorted vector: result undefined
%4 = 0
</pre></div>
</div>
<p>By abuse of notation, <span class="math">\(x\)</span> is also allowed to be a matrix, seen as a vector
of its columns; again by abuse of notation, a <tt class="docutils literal"><span class="pre">t_VEC</span></tt> is considered
as part of the matrix, if its transpose is one of the matrix columns.</p>
<div class="highlight-python"><div class="highlight"><pre>? v = vecsort([3,0,2; 1,0,2]) \\ sort matrix columns according to lex order
%1 =
[0 2 3]

[0 2 1]
? vecsearch(v, [3,1]~)
%2 = 3
? vecsearch(v, [3,1]) \\ can search for x or x~
%3 = 3
? vecsearch(v, [1,2])
%4 = 0 \\ not in the list
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.vecsort">
<tt class="descname">vecsort</tt><big>(</big><em>x</em>, <em>cmpf=None</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.vecsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the vector <span class="math">\(x\)</span> in ascending order, using a mergesort method.
<span class="math">\(x\)</span> must be a list, vector or matrix (seen as a vector of its columns).
Note that mergesort is stable, hence the initial ordering of &#8220;equal&#8221;
entries (with respect to the sorting criterion) is not changed.</p>
<p>If <tt class="docutils literal"><span class="pre">cmpf</span></tt> is omitted, we use the standard comparison function
<tt class="docutils literal"><span class="pre">lex</span></tt>, thereby restricting the possible types for the elements of <span class="math">\(x\)</span>
(integers, fractions or reals and vectors of those). If <tt class="docutils literal"><span class="pre">cmpf</span></tt> is
present, it is understood as a comparison function and we sort according to
it. The following possibilities exist:</p>
<ul class="simple">
<li>an integer <span class="math">\(k\)</span>: sort according to the value of the <span class="math">\(k\)</span>-th
subcomponents of the components of&nbsp;<span class="math">\(x\)</span>.</li>
<li>a vector: sort lexicographically according to the components listed in
the vector. For example, if <span class="math">\(cmpf = [2,1,3]\)</span>, sort with respect to
the second component, and when these are equal, with respect to the first,
and when these are equal, with respect to the third.</li>
<li>a comparison function (<tt class="docutils literal"><span class="pre">t_CLOSURE</span></tt>), with two arguments <span class="math">\(x\)</span> and <span class="math">\(y\)</span>,
and returning an integer which is <span class="math">\(&lt; 0\)</span>, <span class="math">\(&gt; 0\)</span> or <span class="math">\(= 0\)</span> if <span class="math">\(x &lt; y\)</span>, <span class="math">\(x &gt; y\)</span> or
<span class="math">\(x = y\)</span> respectively. The <tt class="docutils literal"><span class="pre">sign</span></tt> function is very useful in this context:</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? vecsort([3,0,2; 1,0,2]) \\ sort columns according to lex order
%1 =
[0 2 3]

[0 2 1]
? vecsort(v, (x,y)-&gt;sign(y-x)) \\ reverse sort
? vecsort(v, (x,y)-&gt;sign(abs(x)-abs(y))) \\ sort by increasing absolute value
? cmpf(x,y) = my(dx = poldisc(x), dy = poldisc(y)); sign(abs(dx) - abs(dy))
? vecsort([x^2+1, x^3-2, x^4+5*x+1], cmpf)
</pre></div>
</div>
<p>The last example used the named <tt class="docutils literal"><span class="pre">cmpf</span></tt> instead of an anonymous function,
and sorts polynomials with respect to the absolute value of their
discriminant. A more efficient approach would use precomputations to ensure
a given discriminant is computed only once:</p>
<div class="highlight-python"><div class="highlight"><pre>? DISC = vector(#v, i, abs(poldisc(v[i])));
? perm = vecsort(vector(#v,i,i), (x,y)-&gt;sign(DISC[x]-DISC[y]))
? vecextract(v, perm)
</pre></div>
</div>
<p>Similar ideas apply whenever we sort according to the values
of a function which is expensive to compute.</p>
<p>The binary digits of <em>flag</em> mean:</p>
<ul class="simple">
<li>1: indirect sorting of the vector <span class="math">\(x\)</span>, i.e.&nbsp;if <span class="math">\(x\)</span> is an
<span class="math">\(n\)</span>-component vector, returns a permutation of <span class="math">\([1,2,...,n]\)</span> which
applied to the components of <span class="math">\(x\)</span> sorts <span class="math">\(x\)</span> in increasing order.
For example, <tt class="docutils literal"><span class="pre">vecextract(x,</span> <span class="pre">vecsort(x,,1))</span></tt> is equivalent to
<tt class="docutils literal"><span class="pre">vecsort(x)</span></tt>.</li>
<li>4: use descending instead of ascending order.</li>
<li>8: remove &#8220;duplicate&#8221; entries with respect to the sorting function
(keep the first occurring entry). For example:</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? vecsort([Pi,Mod(1,2),z], (x,y)-&gt;0, 8) \\ make everything compare equal
%1 = [3.141592653589793238462643383]
? vecsort([[2,3],[0,1],[0,3]], 2, 8)
%2 = [[0, 1], [2, 3]]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.vecsum">
<tt class="descname">vecsum</tt><big>(</big><em>v</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.vecsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of the components of the vector <span class="math">\(v\)</span>. Return <span class="math">\(0\)</span> on an
empty vector.</p>
<div class="highlight-python"><div class="highlight"><pre>? vecsum([1,2,3])
%1 = 6
? vecsum([])
%2 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.weber">
<tt class="descname">weber</tt><big>(</big><em>x</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.weber" title="Permalink to this definition">¶</a></dt>
<dd><p>One of Weber&#8217;s three <span class="math">\(f\)</span> functions.
If <span class="math">\(flag = 0\)</span>, returns</p>
<div class="math">
\[f(x) = \exp(-i\Pi/24).\eta((x+1)/2)/\eta(x) {such that} 
j = (f^{24}-16)^3/f^{24},\]</div>
<p>where <span class="math">\(j\)</span> is the elliptic <span class="math">\(j\)</span>-invariant (see the function <tt class="docutils literal"><span class="pre">ellj</span></tt>).
If <span class="math">\(flag = 1\)</span>, returns</p>
<div class="math">
\[f_1(x) = \eta(x/2)/\eta(x) {such that} 
j = (f_1^{24}+16)^3/f_1^{24}.\]</div>
<p>Finally, if <span class="math">\(flag = 2\)</span>, returns</p>
<div class="math">
\[f_2(x) = \sqrt{2}\eta(2x)/\eta(x) {such that} 
j = (f_2^{24}+16)^3/f_2^{24}.\]</div>
<p>Note the identities <span class="math">\(f^8 = f_1^8+f_2^8\)</span> and <span class="math">\(ff_1f_2 = \sqrt2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.zeta">
<tt class="descname">zeta</tt><big>(</big><em>s</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.zeta" title="Permalink to this definition">¶</a></dt>
<dd><p>For <span class="math">\(s\)</span> a complex number, Riemann&#8217;s zeta
function <span class="math">\(\zeta(s) = \sum_{n &gt;= 1}n^{-s}\)</span>,
computed using the Euler-Maclaurin summation formula, except
when <span class="math">\(s\)</span> is of type integer, in which case it is computed using
Bernoulli numbers for <span class="math">\(s &lt;= 0\)</span> or <span class="math">\(s &gt; 0\)</span> and
even, and using modular forms for <span class="math">\(s &gt; 0\)</span> and odd.</p>
<p>For <span class="math">\(s\)</span> a <span class="math">\(p\)</span>-adic number, Kubota-Leopoldt zeta function at <span class="math">\(s\)</span>, that
is the unique continuous <span class="math">\(p\)</span>-adic function on the <span class="math">\(p\)</span>-adic integers
that interpolates the values of <span class="math">\((1 - p^{-k}) \zeta(k)\)</span> at negative
integers <span class="math">\(k\)</span> such that <span class="math">\(k = 1 (mod p-1)\)</span> (resp. <span class="math">\(k\)</span> is odd) if
<span class="math">\(p\)</span> is odd (resp. <span class="math">\(p = 2\)</span>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.zetak">
<tt class="descname">zetak</tt><big>(</big><em>nfz</em>, <em>x</em>, <em>flag=0</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.zetak" title="Permalink to this definition">¶</a></dt>
<dd><p><em>znf</em> being a number
field initialized by <tt class="docutils literal"><span class="pre">zetakinit</span></tt> (<em>not</em> by <tt class="docutils literal"><span class="pre">nfinit</span></tt>),
computes the value of the Dedekind zeta function of the number
field at the complex number <span class="math">\(x\)</span>. If <span class="math">\(flag = 1\)</span> computes Dedekind <span class="math">\(\Lambda\)</span>
function instead (i.e.&nbsp;the product of the Dedekind zeta function by its gamma
and exponential factors).</p>
<p><strong>CAVEAT.</strong> This implementation is not satisfactory and must be
rewritten. In particular</p>
<ul class="simple">
<li>The accuracy of the result depends in an essential way on the
accuracy of both the <tt class="docutils literal"><span class="pre">zetakinit</span></tt> program and the current accuracy.
Be wary in particular that <span class="math">\(x\)</span> of large imaginary part or, on the
contrary, very close to an ordinary integer will suffer from precision
loss, yielding fewer significant digits than expected. Computing with 28
digits of relative accuracy, we have</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? zeta(3)
%1 = 1.202056903159594285399738161
? zeta(3-1e-20)
%2 = 1.202056903159594285401719424
? zetak(zetakinit(x), 3-1e-20)
%3 = 1.2020569031595952919 \\ 5 digits are wrong
? zetak(zetakinit(x), 3-1e-28)
%4 = -25.33411749 \\ junk
</pre></div>
</div>
<ul class="simple">
<li>As the precision increases, results become unexpectedly
completely wrong:</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>? \p100
? zetak(zetakinit(x^2-5), -1) - 1/30
%1 = 7.26691813 E-108 \\ perfect
? \p150
? zetak(zetakinit(x^2-5), -1) - 1/30
%2 = -2.486113578 E-156 \\ perfect
? \p200
? zetak(zetakinit(x^2-5), -1) - 1/30
%3 = 4.47... E-75 \\ more than half of the digits are wrong
? \p250
? zetak(zetakinit(x^2-5), -1) - 1/30
%4 = 1.6 E43 \\ junk
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.zetakinit">
<tt class="descname">zetakinit</tt><big>(</big><em>bnf</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.zetakinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a number of initialization data
concerning the number field associated to <tt class="docutils literal"><span class="pre">bnf</span></tt> so as to be able
to compute the Dedekind zeta and lambda functions, respectively
<span class="math">\(zetak(x)\)</span> and <span class="math">\(zetak(x,1)\)</span>, at the current real precision. If
you do not need the <tt class="docutils literal"><span class="pre">bnfinit</span></tt> data somewhere else, you may call it
with an irreducible polynomial instead of a <em>bnf</em>: it will call
<tt class="docutils literal"><span class="pre">bnfinit</span></tt> itself.</p>
<p>The result is a 9-component vector <span class="math">\(v\)</span> whose components are very technical
and cannot really be used except through the <tt class="docutils literal"><span class="pre">zetak</span></tt> function.</p>
<p>This function is very inefficient and should be rewritten. It needs to
computes millions of coefficients of the corresponding Dirichlet series if
the precision is big. Unless the discriminant is small it will not be able
to handle more than 9 digits of relative precision. For instance,
<tt class="docutils literal"><span class="pre">zetakinit(x^8</span> <span class="pre">-</span> <span class="pre">2)</span></tt> needs 440MB of memory at default precision.</p>
<p>This function will fail with the message</p>
<div class="highlight-python"><div class="highlight"><pre>*** bnrL1: overflow in zeta_get_N0 [need too many primes].
</pre></div>
</div>
<p>if the approximate functional equation requires us to sum
too many terms (if the discriminant of the number field is too large).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.zetamult">
<tt class="descname">zetamult</tt><big>(</big><em>s</em>, <em>precision=0</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.zetamult" title="Permalink to this definition">¶</a></dt>
<dd><p>For <span class="math">\(s\)</span> a vector of positive integers such that <span class="math">\(s[1] &gt;= 2\)</span>,
returns the multiple zeta value (MZV)</p>
<div class="math">
\[\begin{split}\zeta(s_1,..., s_k) = \sum_{n_1 &gt; ... &gt; n_k &gt; 0} n_1^{-s_1}...n_k^{-s_k}.\end{split}\]</div>
<div class="highlight-python"><div class="highlight"><pre>? zetamult([2,1]) - zeta(3) \\ Euler&#39;s identity
%1 = 0.E-38
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.zncoppersmith">
<tt class="descname">zncoppersmith</tt><big>(</big><em>P</em>, <em>N</em>, <em>X</em>, <em>B=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.zncoppersmith" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(N\)</span> being an integer and <span class="math">\(P belongs to \mathbb{Z}[X]\)</span>, finds all integers <span class="math">\(x\)</span> with
<span class="math">\(\|x\| &lt;= X\)</span> such that</p>
<div class="math">
\[\begin{split}\mathrm{gcd}(N, P(x)) &gt;= B,\end{split}\]</div>
<p>using Coppersmith&#8217;s algorithm (a famous application of the LLL
algorithm). <span class="math">\(X\)</span> must be smaller than <span class="math">\(\exp(\log^2 B / (\deg(P) \log N))\)</span>:
for <span class="math">\(B = N\)</span>, this means <span class="math">\(X &lt; N^{1/\deg(P)}\)</span>. Some <span class="math">\(x\)</span> larger than <span class="math">\(X\)</span> may
be returned if you are very lucky. The smaller <span class="math">\(B\)</span> (or the larger <span class="math">\(X\)</span>), the
slower the routine will be. The strength of Coppersmith method is the
ability to find roots modulo a general <em>composite</em> <span class="math">\(N\)</span>: if <span class="math">\(N\)</span> is a prime
or a prime power, <tt class="docutils literal"><span class="pre">polrootsmod</span></tt> or <tt class="docutils literal"><span class="pre">polrootspadic</span></tt> will be much
faster.</p>
<p>We shall now present two simple applications. The first one is
finding non-trivial factors of <span class="math">\(N\)</span>, given some partial information on the
factors; in that case <span class="math">\(B\)</span> must obviously be smaller than the largest
non-trivial divisor of <span class="math">\(N\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>setrand(1); \\ to make the example reproducible
interval = [10^30, 10^31];
p = randomprime(interval);
q = randomprime(interval); N = p*q;
p0 = p % 10^20; \\ assume we know 1) p &gt; 10^29, 2) the last 19 digits of p
L = zncoppersmith(10^19*x + p0, N, 10^12, 10^29)

\\ result in 10ms.
%6 = [738281386540]
? gcd(L[1] * 10^19 + p0, N) == p
%2 = 1
</pre></div>
</div>
<p>and we recovered <span class="math">\(p\)</span>, faster than by trying all
possibilities <span class="math">\(&lt; 10^{12}\)</span>.</p>
<p>The second application is an attack on RSA with low exponent, when the
message <span class="math">\(x\)</span> is short and the padding <span class="math">\(P\)</span> is known to the attacker. We use
the same RSA modulus <span class="math">\(N\)</span> as in the first example:</p>
<div class="highlight-python"><div class="highlight"><pre>setrand(1);
P = random(N); \\ known padding
e = 3; \\ small public encryption exponent
X = floor(N^0.3); \\ N^(1/e - epsilon)
x0 = random(X); \\ unknown short message
C = lift( (Mod(x0,N) + P)^e ); \\ known ciphertext, with padding P
zncoppersmith((P + x)^3 - C, N, X)

\\ result in 244ms.
%14 = [2679982004001230401]

? %[1] == x0
%4 = 1
</pre></div>
</div>
<p>We guessed an integer of the order of <span class="math">\(10^{18}\)</span>, almost instantly.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.znlog">
<tt class="descname">znlog</tt><big>(</big><em>x</em>, <em>g</em>, <em>o=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.znlog" title="Permalink to this definition">¶</a></dt>
<dd><p>Discrete logarithm of <span class="math">\(x\)</span> in <span class="math">\((\mathbb{Z}/N\mathbb{Z})^*\)</span> in base <span class="math">\(g\)</span>.
The result is <span class="math">\([]\)</span> when <span class="math">\(x\)</span> is not a power of <span class="math">\(g\)</span>.
If present, <span class="math">\(o\)</span> represents the multiplicative order of <span class="math">\(g\)</span>, see
<tt class="docutils literal"><span class="pre">DLfun</span></tt> (in the PARI manual); the preferred format for this parameter is
<tt class="docutils literal"><span class="pre">[ord,</span> <span class="pre">factor(ord)]</span></tt>, where <tt class="docutils literal"><span class="pre">ord</span></tt> is the order of <span class="math">\(g\)</span>.
This provides a definite speedup when the discrete log problem is simple:</p>
<div class="highlight-python"><div class="highlight"><pre>? p = nextprime(10^4); g = znprimroot(p); o = [p-1, factor(p-1)];
? for(i=1,10^4, znlog(i, g, o))
time = 205 ms.
? for(i=1,10^4, znlog(i, g))
time = 244 ms. \\ a little slower
</pre></div>
</div>
<p>The result is undefined if <span class="math">\(g\)</span> is not invertible mod <span class="math">\(N\)</span> or if the supplied
order is incorrect.</p>
<p>This function uses</p>
<ul class="simple">
<li>a combination of generic discrete log algorithms (see below).</li>
<li>in <span class="math">\((\mathbb{Z}/N\mathbb{Z})^*\)</span> when <span class="math">\(N\)</span> is prime: a linear sieve index calculus
method, suitable for <span class="math">\(N &lt; 10^{50}\)</span>, say, is used for large prime divisors of
the order.</li>
</ul>
<p>The generic discrete log algorithms are:</p>
<ul class="simple">
<li>Pohlig-Hellman algorithm, to reduce to groups of prime order <span class="math">\(q\)</span>,
where <span class="math">\(q | p-1\)</span> and <span class="math">\(p\)</span> is an odd prime divisor of <span class="math">\(N\)</span>,</li>
<li>Shanks baby-step/giant-step (<span class="math">\(q &lt; 2^{32}\)</span> is small),</li>
<li>Pollard rho method (<span class="math">\(q &gt; 2^{32}\)</span>).</li>
</ul>
<p>The latter two algorithms require <span class="math">\(O(\sqrt{q})\)</span> operations in the group on
average, hence will not be able to treat cases where <span class="math">\(q &gt; 10^{30}\)</span>, say.
In addition, Pollard rho is not able to handle the case where there are no
solutions: it will enter an infinite loop.</p>
<div class="highlight-python"><div class="highlight"><pre>? g = znprimroot(101)
%1 = Mod(2,101)
? znlog(5, g)
%2 = 24
? g^24
%3 = Mod(5, 101)

? G = znprimroot(2 * 101^10)
%4 = Mod(110462212541120451003, 220924425082240902002)
? znlog(5, G)
%5 = 76210072736547066624
? G^% == 5
%6 = 1
? N = 2^4*3^2*5^3*7^4*11; g = Mod(13, N); znlog(g^110, g)
%7 = 110
? znlog(6, Mod(2,3)) \\ no solution
%8 = []
</pre></div>
</div>
<p>For convenience, <span class="math">\(g\)</span> is also allowed to be a <span class="math">\(p\)</span>-adic number:</p>
<div class="highlight-python"><div class="highlight"><pre>? g = 3+O(5^10); znlog(2, g)
%1 = 1015243
? g^%
%2 = 2 + O(5^10)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.znorder">
<tt class="descname">znorder</tt><big>(</big><em>x</em>, <em>o=None</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.znorder" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> must be an integer mod <span class="math">\(n\)</span>, and the
result is the order of <span class="math">\(x\)</span> in the multiplicative group <span class="math">\((\mathbb{Z}/n\mathbb{Z})^*\)</span>. Returns
an error if <span class="math">\(x\)</span> is not invertible.
The parameter o, if present, represents a non-zero
multiple of the order of <span class="math">\(x\)</span>, see <tt class="docutils literal"><span class="pre">DLfun</span></tt> (in the PARI manual); the preferred format for
this parameter is <tt class="docutils literal"><span class="pre">[ord,</span> <span class="pre">factor(ord)]</span></tt>, where <tt class="docutils literal"><span class="pre">ord</span> <span class="pre">=</span> <span class="pre">eulerphi(n)</span></tt>
is the cardinality of the group.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.znprimroot">
<tt class="descname">znprimroot</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.znprimroot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a primitive root (generator) of <span class="math">\((\mathbb{Z}/n\mathbb{Z})^*\)</span>, whenever this
latter group is cyclic (<span class="math">\(n = 4\)</span> or <span class="math">\(n = 2p^k\)</span> or <span class="math">\(n = p^k\)</span>, where <span class="math">\(p\)</span> is an
odd prime and <span class="math">\(k &gt;= 0\)</span>). If the group is not cyclic, the result is
undefined. If <span class="math">\(n\)</span> is a prime power, then the smallest positive primitive
root is returned. This may not be true for <span class="math">\(n = 2p^k\)</span>, <span class="math">\(p\)</span> odd.</p>
<p>Note that this function requires factoring <span class="math">\(p-1\)</span> for <span class="math">\(p\)</span> as above,
in order to determine the exact order of elements in
<span class="math">\((\mathbb{Z}/n\mathbb{Z})^*\)</span>: this is likely to be costly if <span class="math">\(p\)</span> is large.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.znstar">
<tt class="descname">znstar</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.znstar" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the structure of the multiplicative group
<span class="math">\((\mathbb{Z}/n\mathbb{Z})^*\)</span> as a 3-component row vector <span class="math">\(v\)</span>, where <span class="math">\(v[1] = \phi(n)\)</span> is the
order of that group, <span class="math">\(v[2]\)</span> is a <span class="math">\(k\)</span>-component row-vector <span class="math">\(d\)</span> of integers
<span class="math">\(d[i]\)</span> such that <span class="math">\(d[i] &gt; 1\)</span> and <span class="math">\(d[i] \| d[i-1]\)</span> for <span class="math">\(i &gt;= 2\)</span> and
<span class="math">\((\mathbb{Z}/n\mathbb{Z})^* ~ \prod_{i = 1}^k(\mathbb{Z}/d[i]\mathbb{Z})\)</span>, and <span class="math">\(v[3]\)</span> is a <span class="math">\(k\)</span>-component row
vector giving generators of the image of the cyclic groups <span class="math">\(\mathbb{Z}/d[i]\mathbb{Z}\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre>? G = znstar(40)
%1 = [16, [4, 2, 2], [Mod(17, 40), Mod(21, 40), Mod(11, 40)]]
? G.no \\ eulerphi(40)
%2 = 16
? G.cyc \\ cycle structure
%3 = [4, 2, 2]
? G.gen \\ generators for the cyclic components
%4 = [Mod(17, 40), Mod(21, 40), Mod(11, 40)]
? apply(znorder, G.gen)
%5 = [4, 2, 2]
</pre></div>
</div>
<p>According to the above definitions, <tt class="docutils literal"><span class="pre">znstar(0)</span></tt> is
<tt class="docutils literal"><span class="pre">[2,</span> <span class="pre">[2],</span> <span class="pre">[-1]]</span></tt>, corresponding to <span class="math">\(\mathbb{Z}^*\)</span>.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.libs.pari.gen.objtogen">
<tt class="descclassname">sage.libs.pari.gen.</tt><tt class="descname">objtogen</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#sage.libs.pari.gen.objtogen" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert any Sage/Python object to a PARI gen.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="gen_py.html"
                                  title="previous chapter">Pari objects</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="pari_instance.html"
                                  title="next chapter">PARI C-library interface</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../../_sources/sage/libs/pari/gen.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pari_instance.html" title="PARI C-library interface"
             >next</a> |</li>
        <li class="right" >
          <a href="gen_py.html" title="Pari objects"
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">C/C++ Library Interfaces</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2015, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>