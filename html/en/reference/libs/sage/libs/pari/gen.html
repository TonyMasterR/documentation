<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Sage class for PARI’s GEN type &mdash; Sage Reference Manual v7.3: C/C++ Library Interfaces</title>
    
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '7.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v7.3: C/C++ Library Interfaces" href="../../../index.html" />
    <link rel="next" title="PARI C-library interface" href="pari_instance.html" />
    <link rel="prev" title="An interface to Anders Buch’s Littlewood-Richardson Calculator lrcalc" href="../lrcalc/lrcalc.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pari_instance.html" title="PARI C-library interface"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../lrcalc/lrcalc.html" title="An interface to Anders Buch’s Littlewood-Richardson Calculator lrcalc"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">C/C++ Library Interfaces</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="sage-class-for-pari-s-gen-type">
<span id="sage-libs-pari-gen"></span><h1>Sage class for PARI&#8217;s GEN type<a class="headerlink" href="#sage-class-for-pari-s-gen-type" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.libs.pari.gen"></span><p>See the <code class="docutils literal"><span class="pre">PariInstance</span></code> class for documentation and examples.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li>William Stein (2006-03-01): updated to work with PARI 2.2.12-beta</li>
<li>William Stein (2006-03-06): added newtonpoly</li>
<li>Justin Walker: contributed some of the function definitions</li>
<li>Gonzalo Tornaria: improvements to conversions; much better error
handling.</li>
<li>Robert Bradshaw, Jeroen Demeyer, William Stein (2010-08-15):
Upgrade to PARI 2.4.3 (<a class="reference external" href="https://trac.sagemath.org/9343">trac ticket #9343</a>)</li>
<li>Jeroen Demeyer (2011-11-12): rewrite various conversion routines
(<a class="reference external" href="https://trac.sagemath.org/11611">trac ticket #11611</a>, <a class="reference external" href="https://trac.sagemath.org/11854">trac ticket #11854</a>, <a class="reference external" href="https://trac.sagemath.org/11952">trac ticket #11952</a>)</li>
<li>Peter Bruin (2013-11-17): move PariInstance to a separate file
(<a class="reference external" href="https://trac.sagemath.org/15185">trac ticket #15185</a>)</li>
<li>Jeroen Demeyer (2014-02-09): upgrade to PARI 2.7 (<a class="reference external" href="https://trac.sagemath.org/15767">trac ticket #15767</a>)</li>
<li>Martin von Gagern (2014-12-17): Added some Galois functions (<a class="reference external" href="https://trac.sagemath.org/17519">trac ticket #17519</a>)</li>
<li>Jeroen Demeyer (2015-01-12): upgrade to PARI 2.8 (<a class="reference external" href="https://trac.sagemath.org/16997">trac ticket #16997</a>)</li>
<li>Jeroen Demeyer (2015-03-17): automatically generate methods from
<code class="docutils literal"><span class="pre">pari.desc</span></code> (<a class="reference external" href="https://trac.sagemath.org/17631">trac ticket #17631</a> and <a class="reference external" href="https://trac.sagemath.org/17860">trac ticket #17860</a>)</li>
<li>Kiran Kedlaya (2016-03-23): implement infinity type</li>
</ul>
<p>TESTS:</p>
<p>Before <a class="reference external" href="https://trac.sagemath.org/15654">trac ticket #15654</a>, this used to take a very long time.
Now it takes much less than a second:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">allocatemem</span><span class="p">(</span><span class="mi">200000</span><span class="p">)</span>
<span class="go">PARI stack size set to 200000 bytes, maximum size set to ...</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">ZpFM</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">pol</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">50</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">pol</span><span class="p">)</span><span class="o">.</span><span class="n">poldisc</span><span class="p">()</span>
<span class="go">2*3 + 3^4 + 2*3^6 + 3^7 + 2*3^8 + 2*3^9 + O(3^10)</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.libs.pari.gen.gen">
<em class="property">class </em><code class="descclassname">sage.libs.pari.gen.</code><code class="descname">gen</code><a class="headerlink" href="#sage.libs.pari.gen.gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.libs.pari.gen.gen_auto" title="sage.libs.pari.gen.gen_auto"><code class="xref py py-class docutils literal"><span class="pre">sage.libs.pari.gen.gen_auto</span></code></a></p>
<p>Cython extension class that models the PARI GEN type.</p>
<dl class="method">
<dt id="sage.libs.pari.gen.gen.Col">
<code class="descname">Col</code><span class="sig-paren">(</span><em>x</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the object <span class="math">\(x\)</span> into a column vector with minimal size <span class="math">\(|n|\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> &#8211; gen</li>
<li><code class="docutils literal"><span class="pre">n</span></code> &#8211; Make the column vector of minimal length <span class="math">\(|n|\)</span>. If <span class="math">\(n &gt; 0\)</span>,
append zeros; if <span class="math">\(n &lt; 0\)</span>, prepend zeros.</li>
</ul>
<p>OUTPUT:</p>
<p>A PARI column vector (type <code class="docutils literal"><span class="pre">t_COL</span></code>)</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span><span class="o">.</span><span class="n">Col</span><span class="p">()</span>
<span class="go">[1.50000000000000]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Col</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[1,2; 3,4]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Col</span><span class="p">()</span>
<span class="go">[[1, 2], [3, 4]]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;&quot;Sage&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Col</span><span class="p">()</span>
<span class="go">[&quot;S&quot;, &quot;a&quot;, &quot;g&quot;, &quot;e&quot;]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x + 3*x^3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Col</span><span class="p">()</span>
<span class="go">[3, 0, 1, 0]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x + 3*x^3 + O(x^5)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Col</span><span class="p">()</span>
<span class="go">[1, 0, 3, 0]~</span>
</pre></div>
</div>
<p>We demonstate the <span class="math">\(n\)</span> argument:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Col</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Col</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Col</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4, 0, 0]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Col</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[0, 0, 1, 2, 3, 4]~</span>
</pre></div>
</div>
<p>See also <a class="reference internal" href="#sage.libs.pari.gen.gen.Vec" title="sage.libs.pari.gen.gen.Vec"><code class="xref py py-meth docutils literal"><span class="pre">Vec()</span></code></a> (create a row vector) for more examples
and <a class="reference internal" href="#sage.libs.pari.gen.gen.Colrev" title="sage.libs.pari.gen.gen.Colrev"><code class="xref py py-meth docutils literal"><span class="pre">Colrev()</span></code></a> (create a column in reversed order).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Colrev">
<code class="descname">Colrev</code><span class="sig-paren">(</span><em>x</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.Colrev" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the object <span class="math">\(x\)</span> into a column vector with minimal size <span class="math">\(|n|\)</span>.
The order of the resulting vector is reversed compared to <a class="reference internal" href="#sage.libs.pari.gen.gen.Col" title="sage.libs.pari.gen.gen.Col"><code class="xref py py-meth docutils literal"><span class="pre">Col()</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> &#8211; gen</li>
<li><code class="docutils literal"><span class="pre">n</span></code> &#8211; Make the vector of minimal length <span class="math">\(|n|\)</span>. If <span class="math">\(n &gt; 0\)</span>,
prepend zeros; if <span class="math">\(n &lt; 0\)</span>, append zeros.</li>
</ul>
<p>OUTPUT:</p>
<p>A PARI column vector (type <code class="docutils literal"><span class="pre">t_COL</span></code>)</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span><span class="o">.</span><span class="n">Colrev</span><span class="p">()</span>
<span class="go">[1.50000000000000]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Colrev</span><span class="p">()</span>
<span class="go">[4, 3, 2, 1]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[1,2; 3,4]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Colrev</span><span class="p">()</span>
<span class="go">[[3, 4], [1, 2]]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x + 3*x^3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Colrev</span><span class="p">()</span>
<span class="go">[0, 1, 0, 3]~</span>
</pre></div>
</div>
<p>We demonstate the <span class="math">\(n\)</span> argument:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Colrev</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[4, 3, 2, 1]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Colrev</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[4, 3, 2, 1]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Colrev</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[0, 0, 4, 3, 2, 1]~</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Colrev</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[4, 3, 2, 1, 0, 0]~</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Ser">
<code class="descname">Ser</code><span class="sig-paren">(</span><em>f</em>, <em>v=-1</em>, <em>precision=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.Ser" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a power series or Laurent series in the variable <span class="math">\(v\)</span>
constructed from the object <span class="math">\(f\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">f</span></code> &#8211; PARI gen</li>
<li><code class="docutils literal"><span class="pre">v</span></code> &#8211; PARI variable (default: <span class="math">\(x\)</span>)</li>
<li><code class="docutils literal"><span class="pre">precision</span></code> &#8211; the desired relative precision (default:
the value returned by <code class="docutils literal"><span class="pre">pari.get_series_precision()</span></code>).
This is the absolute precision minus the <span class="math">\(v\)</span>-adic valuation.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>PARI object of type <code class="docutils literal"><span class="pre">t_SER</span></code></li>
</ul>
<p>The series is constructed from <span class="math">\(f\)</span> in the following way:</p>
<ul class="simple">
<li>If <span class="math">\(f\)</span> is a scalar, a constant power series is returned.</li>
<li>If <span class="math">\(f\)</span> is a polynomial, it is converted into a power series
in the obvious way.</li>
<li>If <span class="math">\(f\)</span> is a rational function, it will be expanded in a
Laurent series around <span class="math">\(v = 0\)</span>.</li>
<li>If <span class="math">\(f\)</span> is a vector, its coefficients become the coefficients
of the power series, starting from the constant term.  This
is the convention used by the function <code class="docutils literal"><span class="pre">Polrev()</span></code>, and the
reverse of that used by <code class="docutils literal"><span class="pre">Pol()</span></code>.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function will not transform objects containing
variables of higher priority than <span class="math">\(v\)</span>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">Ser</span><span class="p">()</span>
<span class="go">2 + O(x^16)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">Mod</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span><span class="o">.</span><span class="n">Ser</span><span class="p">()</span>
<span class="go">Mod(0, 7)*x^15 + O(x^16)</span>

<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">Ser</span><span class="p">()</span>
<span class="go">1 + 2*x + 3*x^2 + 4*x^3 + 5*x^4 + O(x^16)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">Ser</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">);</span> <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">1 + 2*v + 3*v^2 + 4*v^3 + 5*v^4 + O(v^16)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">f</span>
<span class="go">1 - 2*v + v^2 + 6*v^5 - 17*v^6 + 16*v^7 - 5*v^8 + 36*v^10 - 132*v^11 + 181*v^12 - 110*v^13 + 25*v^14 + 216*v^15 + O(v^16)</span>

<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^5&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Ser</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="go">x^5 + O(x^25)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1/x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Ser</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">x^-1 + O(x^0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Str">
<code class="descname">Str</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.Str" title="Permalink to this definition">¶</a></dt>
<dd><p>Str(self): Return the print representation of self as a PARI
object.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">self</span></code> - gen</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">gen</span></code> - a PARI gen of type t_STR, i.e., a PARI
string</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">Str</span><span class="p">()</span>
<span class="go">&quot;[1, 2, [abc, 1]]&quot;</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.54</span><span class="p">])</span><span class="o">.</span><span class="n">Str</span><span class="p">()</span>
<span class="go">&quot;[1, 1, 1.54000000000000]&quot;</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Str</span><span class="p">()</span>       <span class="c1"># 1 is automatically converted to string rep</span>
<span class="go">&quot;1&quot;</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>       <span class="c1"># PARI variable &quot;x&quot;</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">Str</span><span class="p">()</span>             <span class="c1"># is converted to string rep.</span>
<span class="go">&quot;x&quot;</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">Str</span><span class="p">()</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_STR&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Strexpand">
<code class="descname">Strexpand</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.Strexpand" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate the entries of the vector <span class="math">\(x\)</span> into a single string,
then perform tilde expansion and environment variable expansion
similar to shells.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> &#8211; PARI gen. Either a vector or an element which is then
treated like <span class="math">\([x]\)</span>.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>PARI string (type <code class="docutils literal"><span class="pre">t_STR</span></code>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;&quot;~/subdir&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Strexpand</span><span class="p">()</span>     <span class="c1"># random</span>
<span class="go">&quot;/home/johndoe/subdir&quot;</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;&quot;$SAGE_LOCAL&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Strexpand</span><span class="p">()</span>  <span class="c1"># random</span>
<span class="go">&quot;/usr/local/sage/local&quot;</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;&quot;$HOME&quot;&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">Strexpand</span><span class="p">()</span> <span class="o">!=</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Strtex">
<code class="descname">Strtex</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.Strtex" title="Permalink to this definition">¶</a></dt>
<dd><p>Strtex(x): Translates the vector x of PARI gens to TeX format and
returns the resulting concatenated strings as a PARI t_STR.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> &#8211; PARI gen. Either a vector or an element which is then
treated like <span class="math">\([x]\)</span>.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>PARI string (type <code class="docutils literal"><span class="pre">t_STR</span></code>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v</span><span class="o">=</span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^2&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">Strtex</span><span class="p">()</span>
<span class="go">&quot;x^2&quot;</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">=</span><span class="n">pari</span><span class="p">([</span><span class="s1">&#39;1/x^2&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">Strtex</span><span class="p">()</span>
<span class="go">&quot;\\frac{1}{x^2}x&quot;</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">=</span><span class="n">pari</span><span class="p">([</span><span class="s1">&#39;1 + 1/x + 1/(y+1)&#39;</span><span class="p">,</span><span class="s1">&#39;x-1&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">Strtex</span><span class="p">()</span>
<span class="go">&quot;\\frac{ \\left(y\n + 2\\right) \\*x\n + \\left(y\n + 1\\right) }{ \\left(y\n + 1\\right) \\*x}x\n - 1&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Vec">
<code class="descname">Vec</code><span class="sig-paren">(</span><em>x</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.Vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the object <span class="math">\(x\)</span> into a vector with minimal size <span class="math">\(|n|\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> &#8211; gen</li>
<li><code class="docutils literal"><span class="pre">n</span></code> &#8211; Make the vector of minimal length <span class="math">\(|n|\)</span>. If <span class="math">\(n &gt; 0\)</span>,
append zeros; if <span class="math">\(n &lt; 0\)</span>, prepend zeros.</li>
</ul>
<p>OUTPUT:</p>
<p>A PARI vector (type <code class="docutils literal"><span class="pre">t_VEC</span></code>)</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[1, 0, 0, 0]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^3 + 3*x - 2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[1, 0, 3, -2]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[1, 2; 3, 4]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[[1, 3]~, [2, 4]~]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;&quot;Sage&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[&quot;S&quot;, &quot;a&quot;, &quot;g&quot;, &quot;e&quot;]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;2*x^2 + 3*x^3 + O(x^5)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[2, 3, 0]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;2*x^-2 + 3*x^3 + O(x^5)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[2, 0, 0, 0, 0, 3, 0]</span>
</pre></div>
</div>
<p>Note the different term ordering for polynomials and series:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1 + x + 3*x^3 + O(x^5)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[1, 1, 0, 3, 0]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1 + x + 3*x^3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span>
<span class="go">[3, 0, 1, 1]</span>
</pre></div>
</div>
<p>We demonstate the <span class="math">\(n\)</span> argument:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Vec</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Vec</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Vec</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4, 0, 0]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Vec</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[0, 0, 1, 2, 3, 4]</span>
</pre></div>
</div>
<p>See also <a class="reference internal" href="#sage.libs.pari.gen.gen.Col" title="sage.libs.pari.gen.gen.Col"><code class="xref py py-meth docutils literal"><span class="pre">Col()</span></code></a> (create a column vector) and <a class="reference internal" href="#sage.libs.pari.gen.gen.Vecrev" title="sage.libs.pari.gen.gen.Vecrev"><code class="xref py py-meth docutils literal"><span class="pre">Vecrev()</span></code></a>
(create a vector in reversed order).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Vecrev">
<code class="descname">Vecrev</code><span class="sig-paren">(</span><em>x</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.Vecrev" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the object <span class="math">\(x\)</span> into a vector with minimal size <span class="math">\(|n|\)</span>.
The order of the resulting vector is reversed compared to <a class="reference internal" href="#sage.libs.pari.gen.gen.Vec" title="sage.libs.pari.gen.gen.Vec"><code class="xref py py-meth docutils literal"><span class="pre">Vec()</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> &#8211; gen</li>
<li><code class="docutils literal"><span class="pre">n</span></code> &#8211; Make the vector of minimal length <span class="math">\(|n|\)</span>. If <span class="math">\(n &gt; 0\)</span>,
prepend zeros; if <span class="math">\(n &lt; 0\)</span>, append zeros.</li>
</ul>
<p>OUTPUT:</p>
<p>A PARI vector (type <code class="docutils literal"><span class="pre">t_VEC</span></code>)</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">()</span>
<span class="go">[0, 0, 0, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^3 + 3*x - 2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">()</span>
<span class="go">[-2, 3, 0, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">()</span>
<span class="go">[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;Col([1, 2, 3])&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">()</span>
<span class="go">[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[1, 2; 3, 4]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">()</span>
<span class="go">[[2, 4]~, [1, 3]~]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;&quot;Sage&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">()</span>
<span class="go">[&quot;e&quot;, &quot;g&quot;, &quot;a&quot;, &quot;S&quot;]</span>
</pre></div>
</div>
<p>We demonstate the <span class="math">\(n\)</span> argument:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[4, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[4, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[0, 0, 4, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">Vecrev</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[4, 3, 2, 1, 0, 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Vecsmall">
<code class="descname">Vecsmall</code><span class="sig-paren">(</span><em>x</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.Vecsmall" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the object <span class="math">\(x\)</span> into a <code class="docutils literal"><span class="pre">t_VECSMALL</span></code> with minimal size <span class="math">\(|n|\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> &#8211; gen</li>
<li><code class="docutils literal"><span class="pre">n</span></code> &#8211; Make the vector of minimal length <span class="math">\(|n|\)</span>. If <span class="math">\(n &gt; 0\)</span>,
append zeros; if <span class="math">\(n &lt; 0\)</span>, prepend zeros.</li>
</ul>
<p>OUTPUT:</p>
<p>A PARI vector of small integers (type <code class="docutils literal"><span class="pre">t_VECSMALL</span></code>)</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">()</span>
<span class="go">Vecsmall([1, 2, 3])</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;&quot;Sage&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">()</span>
<span class="go">Vecsmall([83, 97, 103, 101])</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">()</span>
<span class="go">Vecsmall([1234])</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^2 + 2*x + 3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">()</span>
<span class="go">Vecsmall([1, 2, 3])</span>
</pre></div>
</div>
<p>We demonstate the <span class="math">\(n\)</span> argument:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Vecsmall([1, 2, 3])</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Vecsmall([1, 2, 3])</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">Vecsmall([1, 2, 3, 0, 0, 0])</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">)</span>
<span class="go">Vecsmall([0, 0, 0, 1, 2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Zn_issquare">
<code class="descname">Zn_issquare</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.Zn_issquare" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">self</span></code> is a square modulo <span class="math">\(n\)</span>, <code class="docutils literal"><span class="pre">False</span></code>
if not.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">self</span></code> &#8211; integer</li>
<li><code class="docutils literal"><span class="pre">n</span></code> &#8211; integer or factorisation matrix</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">Zn_issquare</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">Zn_issquare</span><span class="p">(</span><span class="mf">30.</span><span class="n">factor</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.Zn_sqrt">
<code class="descname">Zn_sqrt</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.Zn_sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a square root of <code class="docutils literal"><span class="pre">self</span></code> modulo <span class="math">\(n\)</span>, if such a square
root exists; otherwise, raise a <code class="docutils literal"><span class="pre">ValueError</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">self</span></code> &#8211; integer</li>
<li><code class="docutils literal"><span class="pre">n</span></code> &#8211; integer or factorisation matrix</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">Zn_sqrt</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">3 is not a square modulo 4</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">Zn_sqrt</span><span class="p">(</span><span class="mf">30.</span><span class="n">factor</span><span class="p">())</span>
<span class="go">22</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bernfrac">
<code class="descname">bernfrac</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.bernfrac" title="Permalink to this definition">¶</a></dt>
<dd><p>The Bernoulli number <span class="math">\(B_x\)</span>, where <span class="math">\(B_0 = 1\)</span>,
<span class="math">\(B_1 = -1/2\)</span>, <span class="math">\(B_2 = 1/6,\ldots,\)</span> expressed as a
rational number. The argument <span class="math">\(x\)</span> should be of type
integer.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">bernfrac</span><span class="p">()</span>
<span class="go">43867/798</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">pari</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">bernfrac</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[1, -1/2, 1/6, 0, -1/30, 0, 1/42, 0, -1/30, 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bernreal">
<code class="descname">bernreal</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.bernreal" title="Permalink to this definition">¶</a></dt>
<dd><p>The Bernoulli number <span class="math">\(B_x\)</span>, as for the function bernfrac,
but <span class="math">\(B_x\)</span> is returned as a real number (with the current
precision).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">bernreal</span><span class="p">()</span>
<span class="go">54.9711779448622</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">bernreal</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">192</span><span class="p">)</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">54.9711779448621553884711779448621553884711779448621553885</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bernvec">
<code class="descname">bernvec</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.bernvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a vector containing, as rational numbers, the Bernoulli
numbers <span class="math">\(B_0, B_2,\ldots, B_{2x}\)</span>. This routine is
obsolete. Use bernfrac instead each time you need a Bernoulli
number in exact form.</p>
<p>Note: this routine is implemented using repeated independent calls
to bernfrac, which is faster than the standard recursion in exact
arithmetic.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">bernvec</span><span class="p">()</span>
<span class="go">doctest:...: DeprecationWarning: bernvec() is deprecated, use repeated calls to bernfrac() instead</span>
<span class="go">See http://trac.sagemath.org/15767 for details.</span>
<span class="go">[1, 1/6, -1/30, 1/42, -1/30, 5/66, -691/2730, 7/6, -3617/510]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">bernfrac</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)]</span>
<span class="go">[1, 1/6, -1/30, 1/42, -1/30, 5/66, -691/2730, 7/6, -3617/510]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.besselk">
<code class="descname">besselk</code><span class="sig-paren">(</span><em>nu</em>, <em>x</em>, <em>flag=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.besselk" title="Permalink to this definition">¶</a></dt>
<dd><p>nu.besselk(x): K-Bessel function (modified Bessel function
of the second kind) of index nu, which can be complex, and argument
x.</p>
<p>If <span class="math">\(nu\)</span> or <span class="math">\(x\)</span> is an exact argument, it is first
converted to a real or complex number using the optional parameter
precision (in bits). If the arguments are inexact (e.g. real), the
smallest of their precisions is used in the computation, and the
parameter precision is ignored.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">nu</span></code> - a complex number</li>
<li><code class="docutils literal"><span class="pre">x</span></code> - real number (positive or negative)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">besselk</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0.0455907718407551 + 0.0289192946582081*I</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">besselk</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">-4.34870874986752 - 5.38744882697109*I</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">besselk</span><span class="p">(</span><span class="mi">300</span><span class="p">)</span>
<span class="go">3.74224603319728 E-132 + 2.49071062641525 E-134*I</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">besselk</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">doctest:...: DeprecationWarning: The flag argument to besselk() is deprecated and not used anymore</span>
<span class="go">See http://trac.sagemath.org/20219 for details.</span>
<span class="go">3.74224603319728 E-132 + 2.49071062641525 E-134*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bezout">
<code class="descname">bezout</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.bezout" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bezoutres">
<code class="descname">bezoutres</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.bezoutres" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <code class="xref py py-meth docutils literal"><span class="pre">polresultantext()</span></code> instead.
See <a class="reference external" href="https://trac.sagemath.org/18203">trac ticket #18203</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bid_get_cyc">
<code class="descname">bid_get_cyc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.bid_get_cyc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the structure of the group <span class="math">\((O_K/I)^*\)</span>, where <span class="math">\(I\)</span> is the
ideal represented by <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>NOTE: <code class="docutils literal"><span class="pre">self</span></code> must be a &#8220;big ideal&#8221; (<code class="docutils literal"><span class="pre">bid</span></code>) as returned by
<code class="docutils literal"><span class="pre">idealstar</span></code> for example.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealstar</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">bid_get_cyc</span><span class="p">()</span>
<span class="go">[4, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bid_get_gen">
<code class="descname">bid_get_gen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.bid_get_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of generators of the group <span class="math">\((O_K/I)^*\)</span>, where
<span class="math">\(I\)</span> is the ideal represented by <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>NOTE: <code class="docutils literal"><span class="pre">self</span></code> must be a &#8220;big ideal&#8221; (<code class="docutils literal"><span class="pre">bid</span></code>) with generators,
as returned by <code class="docutils literal"><span class="pre">idealstar</span></code> with <code class="docutils literal"><span class="pre">flag</span></code> = 2.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealstar</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">bid_get_gen</span><span class="p">()</span>
<span class="go">[7, [-2, -1]~]</span>
</pre></div>
</div>
<p>We get an exception if we do not supply <code class="docutils literal"><span class="pre">flag</span> <span class="pre">=</span> <span class="pre">2</span></code> to
<code class="docutils literal"><span class="pre">idealstar</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealstar</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">bid_get_gen</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">missing bid generators. Use idealstar(,,2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bittest">
<code class="descname">bittest</code><span class="sig-paren">(</span><em>x</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.bittest" title="Permalink to this definition">¶</a></dt>
<dd><p>bittest(x, long n): Returns bit number n (coefficient of
<span class="math">\(2^n\)</span> in binary) of the integer x. Negative numbers behave
as if modulo a big power of 2.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> - gen (pari integer)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">bool</span></code> - a Python bool</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">bittest</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">bittest</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">bittest</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">bittest</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">bittest</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">bittest</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">pari</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">bittest</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[True, False, True, True, True, True, True, True, True, True]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bnf_get_cyc">
<code class="descname">bnf_get_cyc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.bnf_get_cyc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the structure of the class group of this number field as
a vector of SNF invariants.</p>
<p>NOTE: <code class="docutils literal"><span class="pre">self</span></code> must be a &#8220;big number field&#8221; (<code class="docutils literal"><span class="pre">bnf</span></code>).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">65</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">pari_bnf</span><span class="p">()</span><span class="o">.</span><span class="n">bnf_get_cyc</span><span class="p">()</span>
<span class="go">[4, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bnf_get_gen">
<code class="descname">bnf_get_gen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.bnf_get_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of generators of the class group of this
number field.</p>
<p>NOTE: <code class="docutils literal"><span class="pre">self</span></code> must be a &#8220;big number field&#8221; (<code class="docutils literal"><span class="pre">bnf</span></code>).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">65</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">pari_bnf</span><span class="p">()</span><span class="o">.</span><span class="n">bnf_get_gen</span><span class="p">();</span> <span class="n">G</span>
<span class="go">[[3, 2; 0, 1], [2, 1; 0, 1]]</span>
<span class="gp">sage: </span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">J</span><span class="p">:</span> <span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">G</span><span class="p">)</span>
<span class="go">[Fractional ideal (3, a + 2), Fractional ideal (2, a + 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bnf_get_no">
<code class="descname">bnf_get_no</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.bnf_get_no" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the class number of <code class="docutils literal"><span class="pre">self</span></code>, a &#8220;big number field&#8221; (<code class="docutils literal"><span class="pre">bnf</span></code>).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">65</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">pari_bnf</span><span class="p">()</span><span class="o">.</span><span class="n">bnf_get_no</span><span class="p">()</span>
<span class="go">8</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bnf_get_reg">
<code class="descname">bnf_get_reg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.bnf_get_reg" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the regulator of this number field.</p>
<p>NOTE: <code class="docutils literal"><span class="pre">self</span></code> must be a &#8220;big number field&#8221; (<code class="docutils literal"><span class="pre">bnf</span></code>).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">pari_bnf</span><span class="p">()</span><span class="o">.</span><span class="n">bnf_get_reg</span><span class="p">()</span>
<span class="go">2.66089858019037...</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.bnfunit">
<code class="descname">bnfunit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.bnfunit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.change_variable_name">
<code class="descname">change_variable_name</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.change_variable_name" title="Permalink to this definition">¶</a></dt>
<dd><p>In <code class="docutils literal"><span class="pre">self</span></code>, which must be a <code class="docutils literal"><span class="pre">t_POL</span></code> or <code class="docutils literal"><span class="pre">t_SER</span></code>, set the
variable to <code class="docutils literal"><span class="pre">var</span></code>.  If the variable of <code class="docutils literal"><span class="pre">self</span></code> is already
<code class="docutils literal"><span class="pre">var</span></code>, then return <code class="docutils literal"><span class="pre">self</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">You should be careful with variable priorities when
applying this on a polynomial or series of which the
coefficients have polynomial components.  To be safe, only
use this function on polynomials with integer or rational
coefficients.  For a safer alternative, use <code class="xref py py-meth docutils literal"><span class="pre">subst()</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^3 + 17*x + 3&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">change_variable_name</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
<span class="go">y^3 + 17*y + 3</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1 + 2*y + O(y^10)&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">change_variable_name</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span>
<span class="go">1 + 2*q + O(q^10)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">change_variable_name</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="n">f</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In PARI, <code class="docutils literal"><span class="pre">I</span></code> refers to the square root of -1, so it cannot be
used as variable name.  Note the difference with <code class="xref py py-meth docutils literal"><span class="pre">subst()</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^2 + 1&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">change_variable_name</span><span class="p">(</span><span class="s2">&quot;I&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">I already exists with incompatible valence</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;I&quot;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.debug">
<code class="descname">debug</code><span class="sig-paren">(</span><em>depth=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.debug" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the internal structure of self (like the <code class="docutils literal"><span class="pre">\x</span></code> command in gp).</p>
<p>EXAMPLE:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[1/2, 1.0*I]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">debug</span><span class="p">()</span>  <span class="c1"># random addresses</span>
<span class="go">[&amp;=0000000004c5f010] VEC(lg=3):2200000000000003 0000000004c5eff8 0000000004c5efb0</span>
<span class="go">  1st component = [&amp;=0000000004c5eff8] FRAC(lg=3):0800000000000003 0000000004c5efe0 0000000004c5efc8</span>
<span class="go">    num = [&amp;=0000000004c5efe0] INT(lg=3):0200000000000003 (+,lgefint=3):4000000000000003 0000000000000001</span>
<span class="go">    den = [&amp;=0000000004c5efc8] INT(lg=3):0200000000000003 (+,lgefint=3):4000000000000003 0000000000000002</span>
<span class="go">  2nd component = [&amp;=0000000004c5efb0] COMPLEX(lg=3):0c00000000000003 00007fae8a2eb840 0000000004c5ef90</span>
<span class="go">    real = gen_0</span>
<span class="go">    imag = [&amp;=0000000004c5ef90] REAL(lg=4):0400000000000004 (+,expo=0):6000000000000000 8000000000000000 0000000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.disc">
<code class="descname">disc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.disc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the discriminant of this object.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">disc</span><span class="p">()</span>
<span class="go">-161051</span>
<span class="gp">sage: </span><span class="n">_</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[-1, 1; 11, 5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.eint1">
<code class="descname">eint1</code><span class="sig-paren">(</span><em>x</em>, <em>n=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.eint1" title="Permalink to this definition">¶</a></dt>
<dd><p>x.eint1(n): exponential integral E1(x):</p>
<div class="math">
\[\int_{x}^{\infty} \frac{e^{-t}}{t} dt\]</div>
<p>If n is present, output the vector [eint1(x), eint1(2*x), ...,
eint1(n*x)]. This is faster than repeatedly calling eint1(i*x).</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>REFERENCE:</p>
<ul class="simple">
<li>See page 262, Prop 5.6.12, of Cohen&#8217;s book &#8220;A Course in
Computational Algebraic Number Theory&#8221;.</li>
</ul>
<p>EXAMPLES:</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.elementval">
<code class="descname">elementval</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.elementval" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.libs.pari.gen.gen.nfeltval" title="sage.libs.pari.gen.gen.nfeltval"><code class="xref py py-meth docutils literal"><span class="pre">nfeltval()</span></code></a> instead.
See <a class="reference external" href="https://trac.sagemath.org/20219">trac ticket #20219</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellan">
<code class="descname">ellan</code><span class="sig-paren">(</span><em>n</em>, <em>python_ints=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.ellan" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the first <span class="math">\(n\)</span> Fourier coefficients of the modular
form attached to this elliptic curve. See ellak for more details.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">n</span></code> - a long integer</li>
<li><code class="docutils literal"><span class="pre">python_ints</span></code> - bool (default is False); if True,
return a list of Python ints instead of a PARI gen wrapper.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellan</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[1, -2, -1]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellan</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">[1, -2, -1, 2, 1, 2, -2, 0, -2, -2, 1, -2, 4, 4, -1, -4, -2, 4, 0, 2]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellan</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">ellan</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">python_ints</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">v</span>
<span class="go">[1, -2, -1, 2, 1, 2, -2, 0, -2, -2]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellaplist">
<code class="descname">ellaplist</code><span class="sig-paren">(</span><em>n</em>, <em>python_ints=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.ellaplist" title="Permalink to this definition">¶</a></dt>
<dd><p>e.ellaplist(n): Returns a PARI list of all the prime-indexed
coefficients <span class="math">\(a_p\)</span> (up to n) of the <span class="math">\(L\)</span>-function
of the elliptic curve <span class="math">\(e\)</span>, i.e. the Fourier coefficients of
the newform attached to <span class="math">\(e\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">self</span></code> &#8211; an elliptic curve</li>
<li><code class="docutils literal"><span class="pre">n</span></code> &#8211; a long integer</li>
<li><code class="docutils literal"><span class="pre">python_ints</span></code> &#8211; bool (default is False); if True,
return a list of Python ints instead of a PARI gen wrapper.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The curve e must be a medium or long vector of the type given by
ellinit. For this function to work for every n and not just those
prime to the conductor, e must be a minimal Weierstrass equation.
If this is not the case, use the function ellminimalmodel first
before using ellaplist (or you will get INCORRECT RESULTS!)</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">ellaplist</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="n">v</span>
<span class="go">[-2, -1, 1, -2]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">&lt;type &#39;sage.libs.pari.gen.gen&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_VEC&#39;</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellan</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">[1, -2, -1, 2, 1, 2, -2, 0, -2, -2]</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">ellaplist</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">python_ints</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span> <span class="n">v</span>
<span class="go">[-2, -1, 1, -2]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">ellaplist</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">([], &lt;type &#39;sage.libs.pari.gen.gen&#39;&gt;)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">ellaplist</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">python_ints</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">([], &lt;type &#39;list&#39;&gt;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellbil">
<code class="descname">ellbil</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.ellbil" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <code class="xref py py-meth docutils literal"><span class="pre">ellheight()</span></code> instead.
See <a class="reference external" href="https://trac.sagemath.org/18203">trac ticket #18203</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellisoncurve">
<code class="descname">ellisoncurve</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.ellisoncurve" title="Permalink to this definition">¶</a></dt>
<dd><p>e.ellisoncurve(x): return True if the point x is on the elliptic
curve e, False otherwise.</p>
<p>If the point or the curve have inexact coefficients, an attempt is
made to take this into account.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellisoncurve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellisoncurve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellisoncurve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.00000000000000001</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellisoncurve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.000000000000000001</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellisoncurve</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellminimalmodel">
<code class="descname">ellminimalmodel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.ellminimalmodel" title="Permalink to this definition">¶</a></dt>
<dd><p>ellminimalmodel(e): return the standard minimal integral model of
the rational elliptic curve e and the corresponding change of
variables. INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">e</span></code> - gen (that defines an elliptic curve)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">gen</span></code> - minimal model</li>
<li><code class="docutils literal"><span class="pre">gen</span></code> - change of coordinates</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">,</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">ellminimalmodel</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[1, -1, 0, 4, 3]</span>
<span class="gp">sage: </span><span class="n">ch</span>
<span class="go">[1, -1, 0, -1]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ellchangecurve</span><span class="p">(</span><span class="n">ch</span><span class="p">)[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[1, -1, 0, 4, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellpow">
<code class="descname">ellpow</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.ellpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <code class="xref py py-meth docutils literal"><span class="pre">ellmul()</span></code> instead.
See <a class="reference external" href="https://trac.sagemath.org/18203">trac ticket #18203</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.elltors">
<code class="descname">elltors</code><span class="sig-paren">(</span><em>flag=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.elltors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return information about the torsion subgroup of the given
elliptic curve.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">e</span></code> - elliptic curve over <span class="math">\(\QQ\)</span></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">gen</span></code> - the order of the torsion subgroup, a.k.a.
the number of points of finite order</li>
<li><code class="docutils literal"><span class="pre">gen</span></code> - vector giving the structure of the torsion
subgroup as a product of cyclic groups, sorted in non-increasing
order</li>
<li><code class="docutils literal"><span class="pre">gen</span></code> - vector giving points on e generating these
cyclic groups</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="mi">26</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">elltors</span><span class="p">()</span>
<span class="go">[12, [6, 2], [[1, 2], [3, -2]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ellwp">
<code class="descname">ellwp</code><span class="sig-paren">(</span><em>z='z'</em>, <em>n=20</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.ellwp" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value or the series expansion of the Weierstrass
<span class="math">\(P\)</span>-function at <span class="math">\(z\)</span> on the lattice <span class="math">\(self\)</span> (or the lattice
defined by the elliptic curve <span class="math">\(self\)</span>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">self</span></code> &#8211; an elliptic curve created using <code class="docutils literal"><span class="pre">ellinit</span></code> or a
list <code class="docutils literal"><span class="pre">[om1,</span> <span class="pre">om2]</span></code> representing generators for a lattice.</li>
<li><code class="docutils literal"><span class="pre">z</span></code> &#8211; (default: &#8216;z&#8217;) a complex number or a variable name
(as string or PARI variable).</li>
<li><code class="docutils literal"><span class="pre">n</span></code> &#8211; (default: 20) if &#8216;z&#8217; is a variable, compute the
series expansion up to at least <span class="math">\(O(z^n)\)</span>.</li>
<li><code class="docutils literal"><span class="pre">flag</span></code> &#8211; (default = 0): If <code class="docutils literal"><span class="pre">flag</span></code> is 0, compute only
<span class="math">\(P(z)\)</span>.  If <code class="docutils literal"><span class="pre">flag</span></code> is 1, compute <span class="math">\([P(z), P'(z)]\)</span>.</li>
</ul>
<p>OUTPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><span class="math">\(P(z)\)</span> (if <code class="docutils literal"><span class="pre">flag</span></code> is 0) or <span class="math">\([P(z), P'(z)]\)</span> (if <code class="docutils literal"><span class="pre">flag</span></code> is 1).</dt>
<dd><p class="first last">numbers</p>
</dd>
</dl>
</li>
</ul>
<p>EXAMPLES:</p>
<p>We first define the elliptic curve X_0(11):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
</pre></div>
</div>
<p>Compute P(1):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">ellwp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">13.9658695257485</span>
</pre></div>
</div>
<p>Compute P(1+i), where i = sqrt(-1):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ComplexField</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">ellwp</span><span class="p">(</span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">))</span>
<span class="go">-1.11510682565555 + 2.33419052307470*I</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">ellwp</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>
<span class="go">-1.11510682565555 + 2.33419052307470*I</span>
</pre></div>
</div>
<p>The series expansion, to the default <span class="math">\(O(z^20)\)</span> precision:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">ellwp</span><span class="p">()</span>
<span class="go">z^-2 + 31/15*z^2 + 2501/756*z^4 + 961/675*z^6 + 77531/41580*z^8 + 1202285717/928746000*z^10 + 2403461/2806650*z^12 + 30211462703/43418875500*z^14 + 3539374016033/7723451736000*z^16 + 413306031683977/1289540602350000*z^18 + O(z^20)</span>
</pre></div>
</div>
<p>Compute the series for wp to lower precision:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">ellwp</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">z^-2 + 31/15*z^2 + O(z^4)</span>
</pre></div>
</div>
<p>Next we use the version where the input is generators for a
lattice:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mf">1.2692</span><span class="p">,</span> <span class="mf">0.63</span> <span class="o">+</span> <span class="mf">1.45</span><span class="o">*</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">ellwp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">13.9656146936689 + 0.000644829272810...*I</span>
</pre></div>
</div>
<p>With flag=1, compute the pair P(z) and P&#8217;(z):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">ellwp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[13.9658695257485, 50.5619300880073]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate <code class="docutils literal"><span class="pre">self</span></code> with the given arguments.</p>
<p>This is currently implemented in 3 cases:</p>
<ul class="simple">
<li>univariate polynomials, rational functions, power series and
Laurent series (using a single unnamed argument or keyword
arguments),</li>
<li>any PARI object supporting the PARI function <code class="docutils literal"><span class="pre">substvec</span></code>
(in particular, multivariate polynomials) using keyword
arguments,</li>
<li>objects of type <code class="docutils literal"><span class="pre">t_CLOSURE</span></code> (functions in GP bytecode form)
using unnamed arguments.</li>
</ul>
<p>In no case is mixing unnamed and keyword arguments allowed.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^2 + 1&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_POL&#39;</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1/2</span>
</pre></div>
</div>
<p>The notation <code class="docutils literal"><span class="pre">f(x)</span></code> is an alternative for <code class="docutils literal"><span class="pre">f.eval(x)</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Evaluating power series:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1 + x + x^3 + O(x^7)&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1 + 2*y^2 + 8*y^6 + O(y^14)</span>
</pre></div>
</div>
<p>Substituting zero is sometimes possible, and trying to do so
in illegal cases can raise various errors:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1 + O(x^3)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1/x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">impossible inverse in gdiv: 0</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1/x + O(x^2)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">substituting 0 in Laurent series with negative valuation</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1/x + O(x^2)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;O(x^3)&#39;</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">impossible inverse in gdiv: O(x^3)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;O(x^0)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">domain error in polcoeff: t_SER = O(x^0)</span>
</pre></div>
</div>
<p>Evaluating multivariate polynomials:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;y^2 + x^3&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>    <span class="c1"># Dangerous, depends on PARI variable ordering</span>
<span class="go">y^2 + 1</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Safe</span>
<span class="go">y^2 + 1</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">x^3 + 1</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">evaluating PARI t_POL takes exactly 1 argument (2 given)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;2*y&#39;</span><span class="p">)</span>
<span class="go">x^2 + 8*y^3</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">()</span>
<span class="go">x^3 + y^2</span>
</pre></div>
</div>
<p>It&#8217;s not an error to substitute variables which do not appear:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="mi">37</span><span class="p">)</span>
<span class="go">x^3 + y^2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">42</span>
</pre></div>
</div>
<p>We can define and evaluate closures as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;n -&gt; n + 2&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_CLOSURE&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">5</span>

<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;() -&gt; 42&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">()</span>
<span class="go">42</span>

<span class="gp">sage: </span><span class="n">pr</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;s -&gt; print(s)&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pr</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s1">&#39;&quot;hello world&quot;&#39;</span><span class="p">)</span>
<span class="go">hello world</span>

<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;myfunc(x,y) = x*y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">30</span>
</pre></div>
</div>
<p>Default arguments work, missing arguments are treated as zero
(like in GP):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s2">&quot;(x, y, z=1.0) -&gt; [x, y, z]&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[1, 2, 1.00000000000000]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[1, 0, 1.00000000000000]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">()</span>
<span class="go">[0, 0, 1.00000000000000]</span>
</pre></div>
</div>
<p>Variadic closures are supported as well (<a class="reference external" href="https://trac.sagemath.org/18623">trac ticket #18623</a>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s2">&quot;(v[..])-&gt;length(v)&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s2">&quot;(x,y,z[..])-&gt;[x,y,z]&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">(),</span> <span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">([0, 0, []], [1, 0, []], [1, 2, []], [1, 2, [3]], [1, 2, [3, 4]])</span>
</pre></div>
</div>
<p>Using keyword arguments, we can substitute in more complicated
objects, for example a number field:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">nf</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">nf</span>
<span class="go">[y^2 + 1, [0, 1], -4, 1, [Mat([1, 0.E-38 + 1.00000000000000*I]), [1, 1.00000000000000; 1, -1.00000000000000], [1, 1; 1, -1], [2, 0; 0, -2], [2, 0; 0, 2], [1, 0; 0, -1], [1, [0, -1; 1, 0]], []], [0.E-38 + 1.00000000000000*I], [1, y], [1, 0; 0, 1], [1, 0, 0, -1; 0, 1, 1, 0]]</span>
<span class="gp">sage: </span><span class="n">nf</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="go">[x^2 + 1, [0, 1], -4, 1, [Mat([1, 0.E-38 + 1.00000000000000*I]), [1, 1.00000000000000; 1, -1.00000000000000], [1, 1; 1, -1], [2, 0; 0, -2], [2, 0; 0, 2], [1, 0; 0, -1], [1, [0, -1; 1, 0]], []], [0.E-38 + 1.00000000000000*I], [1, x], [1, 0; 0, 1], [1, 0, 0, -1; 0, 1, 1, 0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.factor">
<code class="descname">factor</code><span class="sig-paren">(</span><em>limit=-1</em>, <em>proof=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the factorization of x.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">limit</span></code> &#8211; (default: -1) is optional and can be set
whenever x is of (possibly recursive) rational type. If limit is
set, return partial factorization, using primes up to limit.</li>
<li><code class="docutils literal"><span class="pre">proof</span></code> &#8211; optional flag. If <code class="docutils literal"><span class="pre">False</span></code> (not the default),
returned factors larger than <span class="math">\(2^{64}\)</span> may only be pseudoprimes.
If <code class="docutils literal"><span class="pre">True</span></code>, always check primality. If not given, use the
global PARI default <code class="docutils literal"><span class="pre">factor_proven</span></code> which is <code class="docutils literal"><span class="pre">True</span></code> by
default in Sage.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^10-1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[x - 1, 1; x + 1, 1; x^4 - x^3 + x^2 - x + 1, 1; x^4 + x^3 + x^2 + x + 1, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">100</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[3, 1; 5, 3; 11, 1; 31, 1; 41, 1; 101, 1; 251, 1; 601, 1; 1801, 1; 4051, 1; 8101, 1; 268501, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">100</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">(</span><span class="n">proof</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[3, 1; 5, 3; 11, 1; 31, 1; 41, 1; 101, 1; 251, 1; 601, 1; 1801, 1; 4051, 1; 8101, 1; 268501, 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">100</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">(</span><span class="n">proof</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">[3, 1; 5, 3; 11, 1; 31, 1; 41, 1; 101, 1; 251, 1; 601, 1; 1801, 1; 4051, 1; 8101, 1; 268501, 1]</span>
</pre></div>
</div>
<p>We illustrate setting a limit:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">next_prime</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">50</span><span class="p">)</span><span class="o">*</span><span class="n">next_prime</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">60</span><span class="p">)</span><span class="o">*</span><span class="n">next_prime</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">factor</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[10007, 1; 100000000000000000000000000000000000000000000000151000000000700000000000000000000000000000000000000000000001057, 1]</span>
</pre></div>
</div>
<p>Setting a limit is invalid when factoring polynomials:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^11 + 1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mi">17</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">incorrect type in boundfact (t_POL)</span>
</pre></div>
</div>
<p>PARI doesn&#8217;t have an algorithm for factoring multivariate
polynomials:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^3 - y^3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">sorry, factor for general polynomials is not yet implemented</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">1000</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">doctest:...: DeprecationWarning: factor(..., lim=0) is deprecated, use an explicit limit instead</span>
<span class="go">See http://trac.sagemath.org/20205 for details.</span>
<span class="go">[257, 1; 1601, 1; 25601, 1; 76001, 1; 133842787352016..., 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.factorpadic">
<code class="descname">factorpadic</code><span class="sig-paren">(</span><em>p</em>, <em>r=20</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.factorpadic" title="Permalink to this definition">¶</a></dt>
<dd><p>p-adic factorization of the polynomial <code class="docutils literal"><span class="pre">pol</span></code> to precision <code class="docutils literal"><span class="pre">r</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pol</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">pol</span><span class="p">)</span><span class="o">.</span><span class="n">factorpadic</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[(1 + O(5^20))*x + (1 + O(5^20)), 2; (1 + O(5^20))*x + (4 + 4*5 + 4*5^2 + 4*5^3 + 4*5^4 + 4*5^5 + 4*5^6 + 4*5^7 + 4*5^8 + 4*5^9 + 4*5^10 + 4*5^11 + 4*5^12 + 4*5^13 + 4*5^14 + 4*5^15 + 4*5^16 + 4*5^17 + 4*5^18 + 4*5^19 + O(5^20)), 2]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">pol</span><span class="p">)</span><span class="o">.</span><span class="n">factorpadic</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[(1 + O(5^3))*x + (1 + O(5^3)), 2; (1 + O(5^3))*x + (4 + 4*5 + 4*5^2 + O(5^3)), 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ffprimroot">
<code class="descname">ffprimroot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.ffprimroot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a primitive root of the multiplicative group of the
definition field of the given finite field element.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">self</span></code> &#8211; a PARI finite field element (<code class="docutils literal"><span class="pre">FFELT</span></code>)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>A generator of the multiplicative group of the finite field
generated by <code class="docutils literal"><span class="pre">self</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">k</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">ffprimroot</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span>  <span class="c1"># random</span>
<span class="go">a + 1</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">fforder</span><span class="p">()</span>
<span class="go">8</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.fibonacci">
<code class="descname">fibonacci</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.fibonacci" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Fibonacci number of index x.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">fibonacci</span><span class="p">()</span>
<span class="go">2584</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">pari</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">fibonacci</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.galoissubfields">
<code class="descname">galoissubfields</code><span class="sig-paren">(</span><em>flag=0</em>, <em>v=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.galoissubfields" title="Permalink to this definition">¶</a></dt>
<dd><p>List all subfields of the Galois group <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>This wraps the <a class="reference external" href="http://pari.math.u-bordeaux.fr/dochtml/html.stable/Functions_related_to_general_number_fields.html#galoissubfields">galoissubfields</a> function from PARI.</p>
<p>This method is essentially the same as applying
<code class="xref py py-meth docutils literal"><span class="pre">galoisfixedfield()</span></code> to each group returned by
<code class="xref py py-meth docutils literal"><span class="pre">galoissubgroups()</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">self</span></code> &#8211; A Galois group as generated by <code class="xref py py-meth docutils literal"><span class="pre">galoisinit()</span></code>.</li>
<li><code class="docutils literal"><span class="pre">flag</span></code> &#8211; Has the same meaning as in <code class="xref py py-meth docutils literal"><span class="pre">galoisfixedfield()</span></code>.</li>
<li><code class="docutils literal"><span class="pre">v</span></code> &#8211; Has the same meaning as in <code class="xref py py-meth docutils literal"><span class="pre">galoisfixedfield()</span></code>.</li>
</ul>
<p>OUTPUT:</p>
<p>A vector of all subfields of this group.  Each entry is as
described in the <code class="xref py py-meth docutils literal"><span class="pre">galoisfixedfield()</span></code> method.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">108</span><span class="p">)</span><span class="o">.</span><span class="n">galoisinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">galoissubfields</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[x, x^2 + 972, x^3 + 54, x^3 + 864, x^3 - 54, x^6 + 108]</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">galoisinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">galoissubfields</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[x^2 + 2, Mod(x^3 + x, x^4 + 1), [x^2 - z*x - 1, x^2 + z*x - 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.gequal">
<code class="descname">gequal</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.gequal" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are equal using PARI&#8217;s <code class="docutils literal"><span class="pre">gequal</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;&quot;some_string&quot;&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">gequal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">gequal</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">gequal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">gequal</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">gequal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>WARNING: this relation is not transitive:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[0]&#39;</span><span class="p">);</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[0,0]&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">gequal</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">gequal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">gequal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.gequal0">
<code class="descname">gequal0</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.gequal0" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <span class="math">\(a\)</span> is equal to zero.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">gequal0</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">gequal0</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mf">1e-100</span><span class="p">)</span><span class="o">.</span><span class="n">gequal0</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s2">&quot;0.0 + 0.0*I&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">gequal0</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="o">^</span><span class="mi">20</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">)(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">gequal0</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.gequal_long">
<code class="descname">gequal_long</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.gequal_long" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <span class="math">\(a\)</span> is equal to the <code class="docutils literal"><span class="pre">long</span> <span class="pre">int</span></code> <span class="math">\(b\)</span> using PARI&#8217;s <code class="docutils literal"><span class="pre">gequalsg</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mf">2.0</span><span class="p">);</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;3*matid(3)&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">gequal_long</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">gequal_long</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">gequal_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">gequal_long</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">gequal_long</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">gequal_long</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">gequal_long</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.getattr">
<code class="descname">getattr</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.getattr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the PARI attribute with the given name.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s2">&quot;nfinit(x^2 - x - 1)&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">getattr</span><span class="p">(</span><span class="s2">&quot;pol&quot;</span><span class="p">)</span>
<span class="go">x^2 - x - 1</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">getattr</span><span class="p">(</span><span class="s2">&quot;disc&quot;</span><span class="p">)</span>
<span class="go">5</span>

<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">getattr</span><span class="p">(</span><span class="s2">&quot;reg&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">_.reg: incorrect type in reg (t_VEC)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">getattr</span><span class="p">(</span><span class="s2">&quot;zzz&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">not a function in function call</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.idealintersection">
<code class="descname">idealintersection</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.idealintersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <code class="xref py py-meth docutils literal"><span class="pre">idealintersect()</span></code> instead.
See <a class="reference external" href="https://trac.sagemath.org/20219">trac ticket #20219</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ispower">
<code class="descname">ispower</code><span class="sig-paren">(</span><em>k=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.ispower" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether or not self is a perfect k-th power. If k is not
specified, find the largest k so that self is a k-th power.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">k</span></code> - int (optional)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">power</span></code> - int, what power it is</li>
<li><code class="docutils literal"><span class="pre">g</span></code> - what it is a power of</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">ispower</span><span class="p">()</span>
<span class="go">(2, 3)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">.</span><span class="n">ispower</span><span class="p">()</span>
<span class="go">(1, 17)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">.</span><span class="n">ispower</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(False, None)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">.</span><span class="n">ispower</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(1, 17)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">ispower</span><span class="p">()</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.isprime">
<code class="descname">isprime</code><span class="sig-paren">(</span><em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.isprime" title="Permalink to this definition">¶</a></dt>
<dd><p>isprime(x, flag=0): Returns True if x is a PROVEN prime number, and
False otherwise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">flag</span></code> - int 0 (default): use a combination of
algorithms. 1: certify primality using the Pocklington-Lehmer Test.
2: certify primality using the APRCL test.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">bool</span></code> - True or False</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">isprime</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">.</span><span class="n">isprime</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">561</span><span class="p">)</span>    <span class="c1"># smallest Carmichael number</span>
<span class="gp">sage: </span><span class="n">n</span><span class="o">.</span><span class="n">isprime</span><span class="p">()</span>      <span class="c1"># not just a pseudo-primality test!</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">n</span><span class="o">.</span><span class="n">isprime</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">n</span><span class="o">.</span><span class="n">isprime</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">31</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">n</span><span class="o">.</span><span class="n">isprime</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(True, [2, 3, 1; 3, 5, 1; 7, 3, 1; 11, 3, 1; 31, 2, 1; 151, 3, 1; 331, 3, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.isprimepower">
<code class="descname">isprimepower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.isprimepower" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <code class="docutils literal"><span class="pre">self</span></code> is a prime power (with an exponent &gt;= 1).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">self</span></code> - A PARI integer</li>
</ul>
<p>OUTPUT:</p>
<p>A tuple <code class="docutils literal"><span class="pre">(k,</span> <span class="pre">p)</span></code> where <span class="math">\(k\)</span> is a Python integer and <span class="math">\(p\)</span> a PARI
integer.</p>
<ul class="simple">
<li>If the input was a prime power, <span class="math">\(p\)</span> is the prime and <span class="math">\(k\)</span> the
power.</li>
<li>Otherwise, <span class="math">\(k = 0\)</span> and <span class="math">\(p\)</span> is <code class="docutils literal"><span class="pre">self</span></code>.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">If you don&#8217;t need a proof that <span class="math">\(p\)</span> is prime, you can use
<a class="reference internal" href="#sage.libs.pari.gen.gen.ispseudoprimepower" title="sage.libs.pari.gen.gen.ispseudoprimepower"><code class="xref py py-meth docutils literal"><span class="pre">ispseudoprimepower()</span></code></a> instead.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">isprimepower</span><span class="p">()</span>
<span class="go">(2, 3)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">.</span><span class="n">isprimepower</span><span class="p">()</span>
<span class="go">(1, 17)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">isprimepower</span><span class="p">()</span>
<span class="go">(0, 18)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="o">^</span><span class="mi">12345</span><span class="p">)</span><span class="o">.</span><span class="n">isprimepower</span><span class="p">()</span>
<span class="go">(12345, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ispseudoprime">
<code class="descname">ispseudoprime</code><span class="sig-paren">(</span><em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.ispseudoprime" title="Permalink to this definition">¶</a></dt>
<dd><p>ispseudoprime(x, flag=0): Returns True if x is a pseudo-prime
number, and False otherwise.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">flag</span></code> - int 0 (default): checks whether x is a
Baillie-Pomerance-Selfridge-Wagstaff pseudo prime (strong
Rabin-Miller pseudo prime for base 2, followed by strong Lucas test
for the sequence (P,-1), P smallest positive integer such that
<span class="math">\(P^2 - 4\)</span> is not a square mod x). 0: checks whether x is a
strong Miller-Rabin pseudo prime for flag randomly chosen bases
(with end-matching to catch square roots of -1).</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">bool</span></code> - True or False, or when flag=1, either False or a tuple
(True, cert) where <code class="docutils literal"><span class="pre">cert</span></code> is a primality certificate.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">ispseudoprime</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">.</span><span class="n">ispseudoprime</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">561</span><span class="p">)</span>     <span class="c1"># smallest Carmichael number</span>
<span class="gp">sage: </span><span class="n">n</span><span class="o">.</span><span class="n">ispseudoprime</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ispseudoprimepower">
<code class="descname">ispseudoprimepower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.ispseudoprimepower" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <code class="docutils literal"><span class="pre">self</span></code> is the power (with an exponent &gt;= 1) of
a pseudo-prime.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">self</span></code> - A PARI integer</li>
</ul>
<p>OUTPUT:</p>
<p>A tuple <code class="docutils literal"><span class="pre">(k,</span> <span class="pre">p)</span></code> where <span class="math">\(k\)</span> is a Python integer and <span class="math">\(p\)</span> a PARI
integer.</p>
<ul class="simple">
<li>If the input was a pseudoprime power, <span class="math">\(p\)</span> is the pseudoprime
and <span class="math">\(k\)</span> the power.</li>
<li>Otherwise, <span class="math">\(k = 0\)</span> and <span class="math">\(p\)</span> is <code class="docutils literal"><span class="pre">self</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">3</span><span class="o">^</span><span class="mi">12345</span><span class="p">)</span><span class="o">.</span><span class="n">ispseudoprimepower</span><span class="p">()</span>
<span class="go">(12345, 3)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">1500</span> <span class="o">+</span> <span class="mi">1465</span><span class="p">)</span>         <span class="c1"># next_prime(2^1500)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">p</span><span class="o">^</span><span class="mi">11</span><span class="p">)</span><span class="o">.</span><span class="n">ispseudoprimepower</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># very fast</span>
<span class="go">11</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.issquare">
<code class="descname">issquare</code><span class="sig-paren">(</span><em>x</em>, <em>find_root=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.issquare" title="Permalink to this definition">¶</a></dt>
<dd><p>issquare(x,n): <code class="docutils literal"><span class="pre">True</span></code> if x is a square, <code class="docutils literal"><span class="pre">False</span></code> if not. If
<code class="docutils literal"><span class="pre">find_root</span></code> is given, also returns the exact square root.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.issquarefree">
<code class="descname">issquarefree</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.issquarefree" title="Permalink to this definition">¶</a></dt>
<dd><p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">issquarefree</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">issquarefree</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.j">
<code class="descname">j</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.j" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the j-invariant of this object.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">j</span><span class="p">()</span>
<span class="go">-122023936/161051</span>
<span class="gp">sage: </span><span class="n">_</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
<span class="go">[-1, 1; 2, 12; 11, -5; 31, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.lift_centered">
<code class="descname">lift_centered</code><span class="sig-paren">(</span><em>x</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.lift_centered" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <code class="docutils literal"><span class="pre">lift</span></code>, except that <code class="docutils literal"><span class="pre">t_INTMOD</span></code> and <code class="docutils literal"><span class="pre">t_PADIC</span></code> components
are lifted using centered residues:</p>
<ul class="simple">
<li>for a <code class="docutils literal"><span class="pre">t_INTMOD</span></code> <span class="math">\(x belongs to \mathbb{Z}/n\mathbb{Z}\)</span>, the lift <span class="math">\(y\)</span> is such that
<span class="math">\(-n/2 &lt; y &lt;= n/2\)</span>.</li>
<li>a <code class="docutils literal"><span class="pre">t_PADIC</span></code> <span class="math">\(x\)</span> is lifted in the same way as above (modulo
<span class="math">\(p^padicprec(x)\)</span>) if its valuation <span class="math">\(v\)</span> is non-negative; if not, returns
the fraction <span class="math">\(p^v\)</span> <code class="docutils literal"><span class="pre">centerlift</span></code><span class="math">\((x p^{-v})\)</span>; in particular, rational
reconstruction is not attempted. Use <code class="docutils literal"><span class="pre">bestappr</span></code> for this.</li>
</ul>
<p>For backward compatibility, <code class="docutils literal"><span class="pre">centerlift(x,'v)</span></code> is allowed as an alias
for <code class="docutils literal"><span class="pre">lift(x,'v)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.list">
<code class="descname">list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.list" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert self to a list of PARI gens.</p>
<p>EXAMPLES:</p>
<p>A PARI vector becomes a Sage list:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s2">&quot;vector(10,i,i^2)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span>
<span class="go">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;sage.libs.pari.gen.gen&#39;&gt;</span>
</pre></div>
</div>
<p>For polynomials, list() behaves as for ordinary Sage polynomials:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pol</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s2">&quot;x^3 + 5/3*x&quot;</span><span class="p">);</span> <span class="n">pol</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[0, 5/3, 0, 1]</span>
</pre></div>
</div>
<p>For power series or Laurent series, we get all coefficients starting
from the lowest degree term.  This includes trailing zeros:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">LaurentSeriesRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 0, 0, 0, 0, 0]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">x</span><span class="o">^-</span><span class="mi">2</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[1, 0]</span>
</pre></div>
</div>
<p>For matrices, we get a list of columns:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">]);</span> <span class="n">M</span>
<span class="go">[1 4]</span>
<span class="go">[2 5]</span>
<span class="go">[3 6]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[1, 2, 3]~, [4, 5, 6]~]</span>
</pre></div>
</div>
<p>For &#8220;scalar&#8221; types, we get a 1-element list containing <code class="docutils literal"><span class="pre">self</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s2">&quot;42&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[42]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.list_str">
<code class="descname">list_str</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.list_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str that might correctly evaluate to a Python-list.</p>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">primes</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">list_str</span><span class="p">()</span>
<span class="go">doctest:...: DeprecationWarning: the method list_str() is deprecated</span>
<span class="go">See http://trac.sagemath.org/20219 for details.</span>
<span class="go">[2, 3, 5, 7, 11]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.lllgram">
<code class="descname">lllgram</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.lllgram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.lllgramint">
<code class="descname">lllgramint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.lllgramint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.log_gamma">
<code class="descname">log_gamma</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.log_gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of the logarithm of the gamma function of <span class="math">\(x\)</span>. This
function is analytic on the complex plane with non-positive integers
removed, and can have much larger arguments than <code class="docutils literal"><span class="pre">gamma</span></code> itself.</p>
<p>For <span class="math">\(x\)</span> a power series such that <span class="math">\(x(0)\)</span> is not a pole of <code class="docutils literal"><span class="pre">gamma</span></code>,
compute the Taylor expansion. (PARI only knows about regular power series
and can&#8217;t include logarithmic terms.)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? lngamma(1+x+O(x^2))
%1 = -0.57721566490153286060651209008240243104*x + O(x^2)
? lngamma(x+O(x^2))
 *** at top-level: lngamma(x+O(x^2))
 *** ^-----------------
 *** lngamma: domain error in lngamma: valuation != 0
? lngamma(-1+x+O(x^2))
 *** lngamma: Warning: normalizing a series with 0 leading term.
 *** at top-level: lngamma(-1+x+O(x^2))
 *** ^--------------------
 *** lngamma: domain error in intformal: residue(series, pole) != 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.matkerint">
<code class="descname">matkerint</code><span class="sig-paren">(</span><em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.matkerint" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the integer kernel of a matrix.</p>
<p>This is the LLL-reduced Z-basis of the kernel of the matrix x with
integral entries.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[2,1;2,1]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">matker</span><span class="p">()</span>
<span class="go">[-1/2; 1]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[2,1;2,1]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">matkerint</span><span class="p">()</span>
<span class="go">[1; -2]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[2,1;2,1]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">matkerint</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">doctest:...: DeprecationWarning: The flag argument to matkerint() is deprecated by PARI</span>
<span class="go">See http://trac.sagemath.org/18203 for details.</span>
<span class="go">[1; -2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.mattranspose">
<code class="descname">mattranspose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.mattranspose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose of the matrix self.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[1,2,3; 4,5,6; 7,8,9]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mattranspose</span><span class="p">()</span>
<span class="go">[1, 4, 7; 2, 5, 8; 3, 6, 9]</span>
</pre></div>
</div>
<p>Unlike PARI, this always returns a matrix:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[1,2,3]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mattranspose</span><span class="p">()</span>
<span class="go">[1; 2; 3]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[1,2,3]~&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mattranspose</span><span class="p">()</span>
<span class="go">Mat([1, 2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.mod">
<code class="descname">mod</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an INTMOD or POLMOD <code class="docutils literal"><span class="pre">Mod(a,m)</span></code>, return the modulus <span class="math">\(m\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">Mod</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">mod</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s2">&quot;Mod(x, x*y)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mod</span><span class="p">()</span>
<span class="go">y*x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s2">&quot;[Mod(4,5)]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mod</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Not an INTMOD or POLMOD in mod()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.multiplicative_order">
<code class="descname">multiplicative_order</code><span class="sig-paren">(</span><em>x</em>, <em>o=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.multiplicative_order" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> must be an integer mod <span class="math">\(n\)</span>, and the
result is the order of <span class="math">\(x\)</span> in the multiplicative group <span class="math">\((\mathbb{Z}/n\mathbb{Z})^*\)</span>. Returns
an error if <span class="math">\(x\)</span> is not invertible.
The parameter o, if present, represents a non-zero
multiple of the order of <span class="math">\(x\)</span>, see <code class="docutils literal"><span class="pre">DLfun</span></code> (in the PARI manual); the preferred format for
this parameter is <code class="docutils literal"><span class="pre">[ord,</span> <span class="pre">factor(ord)]</span></code>, where <code class="docutils literal"><span class="pre">ord</span> <span class="pre">=</span> <span class="pre">eulerphi(n)</span></code>
is the cardinality of the group.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.ncols">
<code class="descname">ncols</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.ncols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of columns of self.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;matrix(19,8)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ncols</span><span class="p">()</span>
<span class="go">8</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nextprime">
<code class="descname">nextprime</code><span class="sig-paren">(</span><em>add_one=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.nextprime" title="Permalink to this definition">¶</a></dt>
<dd><p>nextprime(x): smallest pseudoprime greater than or equal to <span class="math">\(x\)</span>.
If <code class="docutils literal"><span class="pre">add_one</span></code> is non-zero, return the smallest pseudoprime
strictly greater than <span class="math">\(x\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nextprime</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">nextprime</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">nextprime</span><span class="p">(</span><span class="n">add_one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">nextprime</span><span class="p">()</span>
<span class="go">1267650600228229401496703205653</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nf_get_diff">
<code class="descname">nf_get_diff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.nf_get_diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the different of this number field as a PARI ideal.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">self</span></code> &#8211; A PARI number field being the output of <code class="docutils literal"><span class="pre">nfinit()</span></code>,</dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">bnfinit()</span></code> or <code class="docutils literal"><span class="pre">bnrinit()</span></code>.</p>
</dd>
</dl>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">nf_get_diff</span><span class="p">()</span>
<span class="go">[12, 0, 0, 0; 0, 12, 8, 0; 0, 0, 4, 0; 0, 0, 0, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nf_get_pol">
<code class="descname">nf_get_pol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.nf_get_pol" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the defining polynomial of this number field.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">self</span></code> &#8211; A PARI number field being the output of <code class="docutils literal"><span class="pre">nfinit()</span></code>,</dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">bnfinit()</span></code> or <code class="docutils literal"><span class="pre">bnrinit()</span></code>.</p>
</dd>
</dl>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="go">y^4 - 4*y^2 + 1</span>
<span class="gp">sage: </span><span class="n">bnr</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s2">&quot;K = bnfinit(x^4 - 4*x^2 + 1); bnrinit(K, 2*x)&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bnr</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="go">x^4 - 4*x^2 + 1</span>
</pre></div>
</div>
<p>For relative number fields, this returns the relative
polynomial. However, beware that <code class="docutils literal"><span class="pre">pari(L)</span></code> returns an absolute
number field:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span><span class="o">.&lt;</span><span class="n">b</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">extension</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>        <span class="c1"># Absolute</span>
<span class="go">y^8 - 28*y^6 + 208*y^4 - 408*y^2 + 36</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">pari_rnf</span><span class="p">()</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>   <span class="c1"># Relative</span>
<span class="go">x^2 - 5</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">pari_nf</span><span class="p">()</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="go">y^4 - 4*y^2 + 1</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">pari_bnf</span><span class="p">()</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="go">y^4 - 4*y^2 + 1</span>
</pre></div>
</div>
<p>An error is raised for invalid input:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s2">&quot;[0]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">PariError</span>: <span class="n">incorrect type in pol (t_VEC)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nf_get_sign">
<code class="descname">nf_get_sign</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.nf_get_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Python list <code class="docutils literal"><span class="pre">[r1,</span> <span class="pre">r2]</span></code>, where <code class="docutils literal"><span class="pre">r1</span></code> and <code class="docutils literal"><span class="pre">r2</span></code> are
Python ints representing the number of real embeddings and pairs
of complex embeddings of this number field, respectively.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">self</span></code> &#8211; A PARI number field being the output of <code class="docutils literal"><span class="pre">nfinit()</span></code>,</dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">bnfinit()</span></code> or <code class="docutils literal"><span class="pre">bnrinit()</span></code>.</p>
</dd>
</dl>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">pari_nf</span><span class="p">()</span><span class="o">.</span><span class="n">nf_get_sign</span><span class="p">();</span> <span class="n">s</span>
<span class="go">[4, 0]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">CyclotomicField</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="o">.</span><span class="n">pari_nf</span><span class="p">()</span><span class="o">.</span><span class="n">nf_get_sign</span><span class="p">()</span>
<span class="go">[0, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nf_get_zk">
<code class="descname">nf_get_zk</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.nf_get_zk" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector with a <span class="math">\(\ZZ\)</span>-basis for the ring of integers of
this number field. The first element is always <span class="math">\(1\)</span>.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">self</span></code> &#8211; A PARI number field being the output of <code class="docutils literal"><span class="pre">nfinit()</span></code>,</dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">bnfinit()</span></code> or <code class="docutils literal"><span class="pre">bnrinit()</span></code>.</p>
</dd>
</dl>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">nf_get_zk</span><span class="p">()</span>
<span class="go">[1, y, y^3 - 4*y, y^2 - 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nf_subst">
<code class="descname">nf_subst</code><span class="sig-paren">(</span><em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.nf_subst" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a PARI number field <code class="docutils literal"><span class="pre">self</span></code>, return the same PARI
number field but in the variable <code class="docutils literal"><span class="pre">z</span></code>.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">self</span></code> &#8211; A PARI number field being the output of <code class="docutils literal"><span class="pre">nfinit()</span></code>,</dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">bnfinit()</span></code> or <code class="docutils literal"><span class="pre">bnrinit()</span></code>.</p>
</dd>
</dl>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We can substitute in a PARI <code class="docutils literal"><span class="pre">nf</span></code> structure:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Kpari</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">pari_nf</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="go">y^2 + 5</span>
<span class="gp">sage: </span><span class="n">Lpari</span> <span class="o">=</span> <span class="n">Kpari</span><span class="o">.</span><span class="n">nf_subst</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Lpari</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="go">a^2 + 5</span>
</pre></div>
</div>
<p>We can also substitute in a PARI <code class="docutils literal"><span class="pre">bnf</span></code> structure:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Kpari</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">pari_bnf</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="go">y^2 + 5</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">bnf_get_cyc</span><span class="p">()</span>  <span class="c1"># Structure of class group</span>
<span class="go">[2]</span>
<span class="gp">sage: </span><span class="n">Lpari</span> <span class="o">=</span> <span class="n">Kpari</span><span class="o">.</span><span class="n">nf_subst</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Lpari</span><span class="o">.</span><span class="n">nf_get_pol</span><span class="p">()</span>
<span class="go">a^2 + 5</span>
<span class="gp">sage: </span><span class="n">Lpari</span><span class="o">.</span><span class="n">bnf_get_cyc</span><span class="p">()</span>  <span class="c1"># We still have a bnf after substituting</span>
<span class="go">[2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfbasis">
<code class="descname">nfbasis</code><span class="sig-paren">(</span><em>flag=0</em>, <em>fa=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.nfbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Integral basis of the field <span class="math">\(\QQ[a]\)</span>, where <code class="docutils literal"><span class="pre">a</span></code> is a root of
the polynomial x.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">flag</span></code>: if set to 1 and <code class="docutils literal"><span class="pre">fa</span></code> is not given: assume that no
square of a prime &gt; 500000 divides the discriminant of <code class="docutils literal"><span class="pre">x</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">fa</span></code>: If present, encodes a subset of primes at which to
check for maximality. This must be one of the three following
things:</p>
<blockquote>
<div><ul class="simple">
<li>an integer: check all primes up to <code class="docutils literal"><span class="pre">fa</span></code> using trial
division.</li>
<li>a vector: a list of primes to check.</li>
<li>a matrix: a partial factorization of the discriminant
of <code class="docutils literal"><span class="pre">x</span></code>.</li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In earlier versions of Sage, other bits in <code class="docutils literal"><span class="pre">flag</span></code> were
defined but these are now simply ignored.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^3 - 17&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nfbasis</span><span class="p">()</span>
<span class="go">[1, x, 1/3*x^2 - 1/3*x + 1/3]</span>
</pre></div>
</div>
<p>We test <code class="docutils literal"><span class="pre">flag</span></code> = 1, noting it gives a wrong result when the
discriminant (-4 * <span class="math">\(p`^2 * `q\)</span> in the example below) has a big square
factor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">next_prime</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">10</span><span class="p">);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">next_prime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">);</span> <span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">p</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">nfbasis</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Wrong result</span>
<span class="go">[1, x]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">nfbasis</span><span class="p">()</span>    <span class="c1"># Correct result</span>
<span class="go">[1, 1/10000000019*x]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">nfbasis</span><span class="p">(</span><span class="n">fa</span><span class="o">=</span><span class="mi">10</span><span class="o">^</span><span class="mi">6</span><span class="p">)</span>   <span class="c1"># Check primes up to 10^6: wrong result</span>
<span class="go">[1, x]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">nfbasis</span><span class="p">(</span><span class="n">fa</span><span class="o">=</span><span class="s2">&quot;[2,2; </span><span class="si">%s</span><span class="s2">,2]&quot;</span><span class="o">%</span><span class="n">p</span><span class="p">)</span>    <span class="c1"># Correct result and faster</span>
<span class="go">[1, 1/10000000019*x]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">nfbasis</span><span class="p">(</span><span class="n">fa</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">p</span><span class="p">])</span>              <span class="c1"># Equivalent with the above</span>
<span class="go">[1, 1/10000000019*x]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfbasis_d">
<code class="descname">nfbasis_d</code><span class="sig-paren">(</span><em>flag=0</em>, <em>fa=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.nfbasis_d" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#sage.libs.pari.gen.gen.nfbasis" title="sage.libs.pari.gen.gen.nfbasis"><code class="xref py py-meth docutils literal"><span class="pre">nfbasis()</span></code></a>, but return a tuple <code class="docutils literal"><span class="pre">(B,</span> <span class="pre">D)</span></code> where <span class="math">\(B\)</span>
is the integral basis and <span class="math">\(D\)</span> the discriminant.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;alpha&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nfbasis_d</span><span class="p">()</span>
<span class="go">([1, y, y^2], -108)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">5</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span><span class="s1">&#39;beta&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">_pari_</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nfbasis_d</span><span class="p">()</span>
<span class="go">([1, y, y^2, y^3, y^4], 45753125)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">Polrev</span><span class="p">()</span><span class="o">.</span><span class="n">nfbasis_d</span><span class="p">()</span>
<span class="go">([1, x, x^2], -108)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfbasistoalg_lift">
<code class="descname">nfbasistoalg_lift</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.nfbasistoalg_lift" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the column vector <code class="docutils literal"><span class="pre">x</span></code> on the integral basis into a
polynomial representing the algebraic number.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">nf</span></code> &#8211; a number field</li>
<li><code class="docutils literal"><span class="pre">x</span></code> &#8211; a column of rational numbers of length equal to the
degree of <code class="docutils literal"><span class="pre">nf</span></code> or a single rational number</li>
</ul>
</div></blockquote>
<p>OUTPUT:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">nf.nfbasistoalg(x).lift()</span></code></li>
</ul>
</div></blockquote>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">polygen</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">17</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Kpari</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">pari_nf</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">getattr</span><span class="p">(</span><span class="s1">&#39;zk&#39;</span><span class="p">)</span>
<span class="go">[1, 1/3*y^2 - 1/3*y + 1/3, y]</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">nfbasistoalg_lift</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">nfbasistoalg_lift</span><span class="p">(</span><span class="s2">&quot;[3/2, -5, 0]~&quot;</span><span class="p">)</span>
<span class="go">-5/3*y^2 + 5/3*y - 1/6</span>
<span class="gp">sage: </span><span class="n">Kpari</span><span class="o">.</span><span class="n">getattr</span><span class="p">(</span><span class="s1">&#39;zk&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">pari</span><span class="p">(</span><span class="s2">&quot;[3/2, -5, 0]~&quot;</span><span class="p">)</span>
<span class="go">-5/3*y^2 + 5/3*y - 1/6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfeltval">
<code class="descname">nfeltval</code><span class="sig-paren">(</span><em>x</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.nfeltval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the valuation of the number field element <span class="math">\(x\)</span> at the prime <span class="math">\(p\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">nf</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^2 + 1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nfinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">nf</span><span class="o">.</span><span class="n">idealprimedec</span><span class="p">(</span><span class="mi">5</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">nf</span><span class="o">.</span><span class="n">nfeltval</span><span class="p">(</span><span class="s1">&#39;50 - 25*x&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nfgenerator">
<code class="descname">nfgenerator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.nfgenerator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.nrows">
<code class="descname">nrows</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.nrows" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of rows of self.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;matrix(19,8)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span>
<span class="go">19</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.omega">
<code class="descname">omega</code><span class="sig-paren">(</span><em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.omega" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the basis for the period lattice of this elliptic curve.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">ellinit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="go">[1.26920930427955, 0.634604652139777 - 1.45881661693850*I]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.order">
<code class="descname">order</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <code class="xref py py-meth docutils literal"><span class="pre">znorder()</span></code> instead.
See <a class="reference external" href="https://trac.sagemath.org/20219">trac ticket #20219</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.padicprime">
<code class="descname">padicprime</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.padicprime" title="Permalink to this definition">¶</a></dt>
<dd><p>The uniformizer of the p-adic ring this element lies in, as a t_INT.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> - gen, of type t_PADIC</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">p</span></code> - gen, of type t_INT</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Qp</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="mi">11</span><span class="o">^-</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="mi">11</span><span class="o">^-</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">11</span><span class="o">^-</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">padicprime</span><span class="p">()</span>
<span class="go">11</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">padicprime</span><span class="p">()</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_INT&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.phi">
<code class="descname">phi</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <code class="xref py py-meth docutils literal"><span class="pre">eulerphi()</span></code> instead.
See <a class="reference external" href="https://trac.sagemath.org/20219">trac ticket #20219</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.poldegree">
<code class="descname">poldegree</code><span class="sig-paren">(</span><em>var=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.poldegree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree of this polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.polinterpolate">
<code class="descname">polinterpolate</code><span class="sig-paren">(</span><em>ya</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.polinterpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>self.polinterpolate(ya,x,e): polynomial interpolation at x
according to data vectors self, ya (i.e. return P such that
P(self[i]) = ya[i] for all i). Also return an error estimate on the
returned value.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.polisirreducible">
<code class="descname">polisirreducible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.polisirreducible" title="Permalink to this definition">¶</a></dt>
<dd><p>f.polisirreducible(): Returns True if f is an irreducible
non-constant polynomial, or False if f is reducible or constant.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.polroots">
<code class="descname">polroots</code><span class="sig-paren">(</span><em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.polroots" title="Permalink to this definition">¶</a></dt>
<dd><p>Complex roots of the given polynomial using Schonhage&#8217;s method,
as modified by Gourdon.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.polylog">
<code class="descname">polylog</code><span class="sig-paren">(</span><em>x</em>, <em>m</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.polylog" title="Permalink to this definition">¶</a></dt>
<dd><p>x.polylog(m,flag=0): m-th polylogarithm of x. flag is optional, and
can be 0: default, 1: D_m -modified m-th polylog of x, 2:
D_m-modified m-th polylog of x, 3: P_m-modified m-th polylog of
x.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<p>TODO: Add more explanation, copied from the PARI manual.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">polylog</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">5.64181141475134 - 8.32820207698027*I</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">polylog</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">5.64181141475134 - 8.32820207698027*I</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">polylog</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0.523778453502411</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">polylog</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-0.400459056163451</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.pr_get_e">
<code class="descname">pr_get_e</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.pr_get_e" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the ramification index (over <span class="math">\(\QQ\)</span>) of this prime ideal.</p>
<p>NOTE: <code class="docutils literal"><span class="pre">self</span></code> must be a PARI prime ideal (as returned by
<code class="docutils literal"><span class="pre">idealfactor</span></code> for example).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">2</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_e</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">3</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_e</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">5</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_e</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.pr_get_f">
<code class="descname">pr_get_f</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.pr_get_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the residue class degree (over <span class="math">\(\QQ\)</span>) of this prime ideal.</p>
<p>NOTE: <code class="docutils literal"><span class="pre">self</span></code> must be a PARI prime ideal (as returned by
<code class="docutils literal"><span class="pre">idealfactor</span></code> for example).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">2</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_f</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">3</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_f</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">5</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_f</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.pr_get_gen">
<code class="descname">pr_get_gen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.pr_get_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the second generator of this PARI prime ideal, where the
first generator is <code class="docutils literal"><span class="pre">self.pr_get_p()</span></code>.</p>
<p>NOTE: <code class="docutils literal"><span class="pre">self</span></code> must be a PARI prime ideal (as returned by
<code class="docutils literal"><span class="pre">idealfactor</span></code> for example).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">2</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_gen</span><span class="p">();</span> <span class="n">g</span><span class="p">;</span> <span class="n">K</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">[1, 1]~</span>
<span class="go">i + 1</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">3</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_gen</span><span class="p">();</span> <span class="n">g</span><span class="p">;</span> <span class="n">K</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">[3, 0]~</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">5</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_gen</span><span class="p">();</span> <span class="n">g</span><span class="p">;</span> <span class="n">K</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">[-2, 1]~</span>
<span class="go">i - 2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.pr_get_p">
<code class="descname">pr_get_p</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.pr_get_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the prime of <span class="math">\(\ZZ\)</span> lying below this prime ideal.</p>
<p>NOTE: <code class="docutils literal"><span class="pre">self</span></code> must be a PARI prime ideal (as returned by
<code class="docutils literal"><span class="pre">idealfactor</span></code> for example).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QuadraticField</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">idealfactor</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span> <span class="n">F</span>
<span class="go">[[5, [-2, 1]~, 1, 1, [2, -1; 1, 2]], 1; [5, [2, 1]~, 1, 1, [-2, -1; 1, -2]], 1]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pr_get_p</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.precision">
<code class="descname">precision</code><span class="sig-paren">(</span><em>x</em>, <em>n=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.precision" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the precision of <span class="math">\(x\)</span> to be <span class="math">\(n\)</span>, where <span class="math">\(n\)</span> is an integer.
If <span class="math">\(n\)</span> is omitted, output the real precision of <span class="math">\(x\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> - gen</li>
<li><code class="docutils literal"><span class="pre">n</span></code> - (optional) int</li>
</ul>
<p>OUTPUT: gen</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.printtex">
<code class="descname">printtex</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.printtex" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.libs.pari.gen.gen.Strtex" title="sage.libs.pari.gen.gen.Strtex"><code class="xref py py-meth docutils literal"><span class="pre">Strtex()</span></code></a> instead.
See <a class="reference external" href="https://trac.sagemath.org/20219">trac ticket #20219</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.python">
<code class="descname">python</code><span class="sig-paren">(</span><em>locals=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.python" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the closest Python/Sage equivalent of the given PARI object.</p>
<p>INPUT:</p>
<ul class="simple">
<li><span class="math">\(z\)</span> &#8211; PARI <code class="docutils literal"><span class="pre">gen</span></code></li>
<li><span class="math">\(locals\)</span> &#8211; optional dictionary used in fallback cases that
involve <a class="reference external" href="../../../../misc/sage/misc/sage_eval.html#sage.misc.sage_eval.sage_eval" title="(in Sage Reference Manual: Utilities v7.3)"><code class="xref py py-func docutils literal"><span class="pre">sage_eval()</span></code></a></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <code class="docutils literal"><span class="pre">self</span></code> is a real (type <code class="docutils literal"><span class="pre">t_REAL</span></code>), then the result
will be a RealField element of the equivalent precision;
if <code class="docutils literal"><span class="pre">self</span></code> is a complex (type <code class="docutils literal"><span class="pre">t_COMPLEX</span></code>), then the
result will be a ComplexField element of precision the
maximal precision of the real and imaginary parts.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;389/17&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">()</span>
<span class="go">389/17</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;(2/3)*x^3 + x - 5/7 + y&#39;</span><span class="p">);</span> <span class="n">f</span>
<span class="go">2/3*x^3 + x + (y - 5/7)</span>
<span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">)</span>
<span class="go">(x, y)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">python</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span>
<span class="go">2/3*x^3 + x + y - 5/7</span>
</pre></div>
</div>
<p>You can also use <a class="reference internal" href="#sage.libs.pari.gen.gen.sage" title="sage.libs.pari.gen.gen.sage"><code class="xref py py-meth docutils literal"><span class="pre">sage()</span></code></a>, which is an alias:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">sage</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span>
<span class="go">2/3*x^3 + x + y - 5/7</span>
</pre></div>
</div>
<p>Converting a real number:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">set_real_precision</span><span class="p">(</span><span class="mi">70</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1.234&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">a</span>
<span class="go">1.234000000000000000000000000000000000000000000000000000000000000000000000000</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Real Field with 256 bits of precision</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">set_real_precision</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="go">70</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1.234&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">a</span>
<span class="go">1.23400000000000000</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Real Field with 64 bits of precision</span>
</pre></div>
</div>
<p>For complex numbers, the parent depends on the PARI type:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;(3+I)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">a</span>
<span class="go">i + 3</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Number Field in i with defining polynomial x^2 + 1</span>

<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;2^31-1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">a</span>
<span class="go">2147483647</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Integer Ring</span>

<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;12/34&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">a</span>
<span class="go">6/17</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Rational Field</span>

<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;(3+I)/2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">a</span>
<span class="go">1/2*i + 3/2</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Number Field in i with defining polynomial x^2 + 1</span>

<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">CC</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="mf">2.0</span><span class="o">*</span><span class="n">I</span><span class="p">));</span> <span class="n">z</span>
<span class="go">1.00000000000000 + 2.00000000000000*I</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">a</span>
<span class="go">1.00000000000000000 + 2.00000000000000000*I</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Complex Field with 64 bits of precision</span>

<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">a</span>
<span class="go">1.00000000000000000 + 2.00000000000000000*I</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Complex Field with 64 bits of precision</span>
</pre></div>
</div>
<p>Vectors and matrices:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[1,2,3,4]&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_VEC&#39;</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">b</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>

<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[1,2;3,4]&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_MAT&#39;</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">b</span>
<span class="go">[1 2]</span>
<span class="go">[3 4]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 2 by 2 dense matrices over Integer Ring</span>

<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;Vecsmall([1,2,3,4])&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_VECSMALL&#39;</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">python</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4]</span>
</pre></div>
</div>
<p>We use the locals dictionary:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;(2/3)*x^3 + x - 5/7 + y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.libs.pari.gen</span> <span class="kn">import</span> <span class="n">gentoobj</span>
<span class="gp">sage: </span><span class="n">gentoobj</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span>
<span class="go">2/3*x^3 + x + y - 5/7</span>
<span class="gp">sage: </span><span class="n">gentoobj</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NameError</span>: <span class="n">name &#39;x&#39; is not defined</span>
</pre></div>
</div>
<p>Conversion of p-adics:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Qp</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="mi">11</span><span class="o">^-</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="mi">11</span><span class="o">^-</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">11</span><span class="o">^-</span><span class="mi">6</span><span class="p">);</span> <span class="n">x</span>
<span class="go">11^-10 + 5*11^-7 + 11^-6 + O(11^-5)</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="n">y</span>
<span class="go">11^-10 + 5*11^-7 + 11^-6 + O(11^-5)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">11^-10 + 5*11^-7 + 11^-6 + O(11^-5)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">(</span><span class="mi">11</span><span class="o">^-</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">11^-5 + O(11^0)</span>
</pre></div>
</div>
<p>Conversion of infinities:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;oo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">+Infinity</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;-oo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">-Infinity</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.python_list">
<code class="descname">python_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.python_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Python list of the PARI gens. This object must be of type
t_VEC or t_COL.</p>
<p>INPUT: None</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">list</span></code> - Python list whose elements are the
elements of the input gen.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">102</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">python_list</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w</span>
<span class="go">[1, 2, 3, 10, 102, 10]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;sage.libs.pari.gen.gen&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s2">&quot;[1,2,3]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">python_list</span><span class="p">()</span>
<span class="go">[1, 2, 3]</span>

<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s2">&quot;[1,2,3]~&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">python_list</span><span class="p">()</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.python_list_small">
<code class="descname">python_list_small</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.python_list_small" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Python list of the PARI gens. This object must be of type
t_VECSMALL, and the resulting list contains python &#8216;int&#8217;s.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v</span><span class="o">=</span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">102</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span><span class="o">.</span><span class="n">Vecsmall</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">python_list_small</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w</span>
<span class="go">[1, 2, 3, 10, 102, 10]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.qfrep">
<code class="descname">qfrep</code><span class="sig-paren">(</span><em>B</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.qfrep" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector of (half) the number of vectors of norms from 1 to <span class="math">\(B\)</span>
for the integral and definite quadratic form <code class="docutils literal"><span class="pre">self</span></code>.
Binary digits of flag mean 1: count vectors of even norm from
1 to <span class="math">\(2B\)</span>, 2: return a <code class="docutils literal"><span class="pre">t_VECSMALL</span></code> instead of a <code class="docutils literal"><span class="pre">t_VEC</span></code>
(which is faster).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s2">&quot;[5,1,1;1,3,1;1,1,1]&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">qfrep</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">[1, 1, 2, 2, 2, 4, 4, 3, 3, 4, 2, 4, 6, 0, 4, 6, 4, 5, 6, 4]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">qfrep</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[1, 2, 4, 3, 4, 4, 0, 6, 5, 4, 12, 4, 4, 8, 0, 3, 8, 6, 12, 12]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">qfrep</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Vecsmall([1, 1, 2, 2, 2, 4, 4, 3, 3, 4, 2, 4, 6, 0, 4, 6, 4, 5, 6, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <code class="xref py py-meth docutils literal"><span class="pre">polrecip()</span></code> instead.
See <a class="reference external" href="https://trac.sagemath.org/20219">trac ticket #20219</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.rnfisnorm">
<code class="descname">rnfisnorm</code><span class="sig-paren">(</span><em>T</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.rnfisnorm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.rnfpolred">
<code class="descname">rnfpolred</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.rnfpolred" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.rnfpolredabs">
<code class="descname">rnfpolredabs</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.rnfpolredabs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.round">
<code class="descname">round</code><span class="sig-paren">(</span><em>x</em>, <em>estimate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.round" title="Permalink to this definition">¶</a></dt>
<dd><p>round(x,estimate=False): If x is a real number, returns x rounded
to the nearest integer (rounding up). If the optional argument
estimate is True, also returns the binary exponent e of the
difference between the original and the rounded value (the
&#8220;fractional part&#8221;) (this is the integer ceiling of log_2(error)).</p>
<p>When x is a general PARI object, this function returns the result
of rounding every coefficient at every level of PARI object. Note
that this is different than what the truncate function does (see
the example below).</p>
<p>One use of round is to get exact results after a long approximate
computation, when theory tells you that the coefficients must be
integers.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> - gen</li>
<li><code class="docutils literal"><span class="pre">estimate</span></code> - (optional) bool, False by default</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>if estimate is False, return a single gen.</li>
<li>if estimate is True, return rounded version of x and error
estimate in bits, both as gens.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1.5&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1.5&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(2, -1)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1.5 + 2.1*I&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">2 + 2*I</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1.0001&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(1, -14)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;(2.4*x^2 - 1.7)/x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">(2*x^2 - 2)/x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;(2.4*x^2 - 1.7)/x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
<span class="go">2.40000000000000*x</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sage">
<code class="descname">sage</code><span class="sig-paren">(</span><em>locals=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.sage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the closest Python/Sage equivalent of the given PARI object.</p>
<p>INPUT:</p>
<ul class="simple">
<li><span class="math">\(z\)</span> &#8211; PARI <code class="docutils literal"><span class="pre">gen</span></code></li>
<li><span class="math">\(locals\)</span> &#8211; optional dictionary used in fallback cases that
involve <a class="reference external" href="../../../../misc/sage/misc/sage_eval.html#sage.misc.sage_eval.sage_eval" title="(in Sage Reference Manual: Utilities v7.3)"><code class="xref py py-func docutils literal"><span class="pre">sage_eval()</span></code></a></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <code class="docutils literal"><span class="pre">self</span></code> is a real (type <code class="docutils literal"><span class="pre">t_REAL</span></code>), then the result
will be a RealField element of the equivalent precision;
if <code class="docutils literal"><span class="pre">self</span></code> is a complex (type <code class="docutils literal"><span class="pre">t_COMPLEX</span></code>), then the
result will be a ComplexField element of precision the
maximal precision of the real and imaginary parts.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;389/17&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">()</span>
<span class="go">389/17</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;(2/3)*x^3 + x - 5/7 + y&#39;</span><span class="p">);</span> <span class="n">f</span>
<span class="go">2/3*x^3 + x + (y - 5/7)</span>
<span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">)</span>
<span class="go">(x, y)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">python</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span>
<span class="go">2/3*x^3 + x + y - 5/7</span>
</pre></div>
</div>
<p>You can also use <a class="reference internal" href="#sage.libs.pari.gen.gen.sage" title="sage.libs.pari.gen.gen.sage"><code class="xref py py-meth docutils literal"><span class="pre">sage()</span></code></a>, which is an alias:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">sage</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span>
<span class="go">2/3*x^3 + x + y - 5/7</span>
</pre></div>
</div>
<p>Converting a real number:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">set_real_precision</span><span class="p">(</span><span class="mi">70</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1.234&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">a</span>
<span class="go">1.234000000000000000000000000000000000000000000000000000000000000000000000000</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Real Field with 256 bits of precision</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">set_real_precision</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="go">70</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1.234&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">a</span>
<span class="go">1.23400000000000000</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Real Field with 64 bits of precision</span>
</pre></div>
</div>
<p>For complex numbers, the parent depends on the PARI type:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;(3+I)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">a</span>
<span class="go">i + 3</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Number Field in i with defining polynomial x^2 + 1</span>

<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;2^31-1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">a</span>
<span class="go">2147483647</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Integer Ring</span>

<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;12/34&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">a</span>
<span class="go">6/17</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Rational Field</span>

<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;(3+I)/2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">a</span>
<span class="go">1/2*i + 3/2</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Number Field in i with defining polynomial x^2 + 1</span>

<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">CC</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="mf">2.0</span><span class="o">*</span><span class="n">I</span><span class="p">));</span> <span class="n">z</span>
<span class="go">1.00000000000000 + 2.00000000000000*I</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">a</span>
<span class="go">1.00000000000000000 + 2.00000000000000000*I</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Complex Field with 64 bits of precision</span>

<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">a</span>
<span class="go">1.00000000000000000 + 2.00000000000000000*I</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Complex Field with 64 bits of precision</span>
</pre></div>
</div>
<p>Vectors and matrices:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[1,2,3,4]&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_VEC&#39;</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">b</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>

<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[1,2;3,4]&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_MAT&#39;</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">python</span><span class="p">();</span> <span class="n">b</span>
<span class="go">[1 2]</span>
<span class="go">[3 4]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Full MatrixSpace of 2 by 2 dense matrices over Integer Ring</span>

<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;Vecsmall([1,2,3,4])&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_VECSMALL&#39;</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">python</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4]</span>
</pre></div>
</div>
<p>We use the locals dictionary:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;(2/3)*x^3 + x - 5/7 + y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.libs.pari.gen</span> <span class="kn">import</span> <span class="n">gentoobj</span>
<span class="gp">sage: </span><span class="n">gentoobj</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span>
<span class="go">2/3*x^3 + x + y - 5/7</span>
<span class="gp">sage: </span><span class="n">gentoobj</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NameError</span>: <span class="n">name &#39;x&#39; is not defined</span>
</pre></div>
</div>
<p>Conversion of p-adics:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Qp</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="mi">11</span><span class="o">^-</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="mi">11</span><span class="o">^-</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">11</span><span class="o">^-</span><span class="mi">6</span><span class="p">);</span> <span class="n">x</span>
<span class="go">11^-10 + 5*11^-7 + 11^-6 + O(11^-5)</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="n">y</span>
<span class="go">11^-10 + 5*11^-7 + 11^-6 + O(11^-5)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">11^-10 + 5*11^-7 + 11^-6 + O(11^-5)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">(</span><span class="mi">11</span><span class="o">^-</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">11^-5 + O(11^0)</span>
</pre></div>
</div>
<p>Conversion of infinities:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;oo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">+Infinity</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;-oo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span>
<span class="go">-Infinity</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sizebyte">
<code class="descname">sizebyte</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.sizebyte" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total number of bytes occupied by the complete tree
of the object x. Note that this number depends on whether the
computer is 32-bit or 64-bit.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> - gen</li>
</ul>
<p>OUTPUT: int (a Python int)</p>
<p>EXAMPLE:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizebyte</span><span class="p">()</span>
<span class="go">12           # 32-bit</span>
<span class="go">24           # 64-bit</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sizedigit">
<code class="descname">sizedigit</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.sizedigit" title="Permalink to this definition">¶</a></dt>
<dd><p>sizedigit(x): Return a quick estimate for the maximal number of
decimal digits before the decimal point of any component of x.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> - gen</li>
</ul>
<p>OUTPUT: Python integer</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;10^100&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">Str</span><span class="p">()</span><span class="o">.</span><span class="n">length</span><span class="p">()</span>
<span class="go">101</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">sizedigit</span><span class="p">()</span>
<span class="go">doctest:...: DeprecationWarning: sizedigit() is deprecated in PARI</span>
<span class="go">See http://trac.sagemath.org/18203 for details.</span>
<span class="go">101</span>
</pre></div>
</div>
<p>Note that digits after the decimal point are ignored:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1.234&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">1.23400000000000</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">sizedigit</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The estimate can be one too big:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;7234.1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizedigit</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;9234.1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizedigit</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sizeword">
<code class="descname">sizeword</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.sizeword" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total number of machine words occupied by the
complete tree of the object x.  A machine word is 32 or
64 bits, depending on the computer.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> - gen</li>
</ul>
<p>OUTPUT: int (a Python int)</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizeword</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizeword</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1000000&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizeword</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;10^100&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizeword</span><span class="p">()</span>
<span class="go">13      # 32-bit</span>
<span class="go">8       # 64-bit</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">RDF</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span><span class="o">.</span><span class="n">sizeword</span><span class="p">()</span>
<span class="go">4       # 32-bit</span>
<span class="go">3       # 64-bit</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizeword</span><span class="p">()</span>
<span class="go">9</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x^20&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizeword</span><span class="p">()</span>
<span class="go">66</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;[x, I]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sizeword</span><span class="p">()</span>
<span class="go">20</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sqrtn">
<code class="descname">sqrtn</code><span class="sig-paren">(</span><em>x</em>, <em>n</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.sqrtn" title="Permalink to this definition">¶</a></dt>
<dd><p>x.sqrtn(n): return the principal branch of the n-th root of x,
i.e., the one such that
<span class="math">\(\arg(\sqrt(x)) \in ]-\pi/n, \pi/n]\)</span>. Also returns a second
argument which is a suitable root of unity allowing one to recover
all the other roots. If it was not possible to find such a number,
then this second return value is 0. If the argument is present and
no square root exists, return 0 instead of raising an error.</p>
<p>If <span class="math">\(x\)</span> is an exact argument, it is first converted to a
real or complex number using the optional parameter precision (in
bits). If <span class="math">\(x\)</span> is inexact (e.g. real), its own precision is
used in the computation, and the parameter precision is ignored.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">intmods (modulo a prime) and <span class="math">\(p\)</span>-adic numbers are
allowed as arguments.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> - gen</li>
<li><code class="docutils literal"><span class="pre">n</span></code> - integer</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">gen</span></code> - principal n-th root of x</li>
<li><code class="docutils literal"><span class="pre">gen</span></code> - root of unity z that gives the other
roots</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sqrtn</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">z</span>
<span class="go">0.309016994374947 + 0.951056516295154*I</span>
<span class="gp">sage: </span><span class="n">s</span>
<span class="go">1.14869835499704</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">^</span><span class="mi">5</span>
<span class="go">2.00000000000000</span>
<span class="gp">sage: </span><span class="n">z</span><span class="o">^</span><span class="mi">5</span>
<span class="go">1.00000000000000 - 2.710505431 E-20*I       # 32-bit</span>
<span class="go">1.00000000000000 - 2.71050543121376 E-20*I  # 64-bit</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">^</span><span class="mi">5</span>
<span class="go">2.00000000000000 + 0.E-19*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sumdiv">
<code class="descname">sumdiv</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.sumdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of the divisors of <span class="math">\(n\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">sumdiv</span><span class="p">()</span>
<span class="go">18</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.sumdivk">
<code class="descname">sumdivk</code><span class="sig-paren">(</span><em>n</em>, <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.sumdivk" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of the k-th powers of the divisors of n.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">sumdivk</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">130</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.truncate">
<code class="descname">truncate</code><span class="sig-paren">(</span><em>x</em>, <em>estimate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.truncate" title="Permalink to this definition">¶</a></dt>
<dd><p>truncate(x,estimate=False): Return the truncation of x. If estimate
is True, also return the number of error bits.</p>
<p>When x is in the real numbers, this means that the part after the
decimal point is chopped away, e is the binary exponent of the
difference between the original and truncated value (the
&#8220;fractional part&#8221;). If x is a rational function, the result is the
integer part (Euclidean quotient of numerator by denominator) and
if requested the error estimate is 0.</p>
<p>When truncate is applied to a power series (in X), it transforms it
into a polynomial or a rational function with denominator a power
of X, by chopping away the <span class="math">\(O(X^k)\)</span>. Similarly, when
applied to a p-adic number, it transforms it into an integer or a
rational number by chopping away the <span class="math">\(O(p^k)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> - gen</li>
<li><code class="docutils literal"><span class="pre">estimate</span></code> - (optional) bool, which is False by
default</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>if estimate is False, return a single gen.</li>
<li>if estimate is True, return rounded version of x and error
estimate in bits, both as gens.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;(x^2+1)/x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">(x^2 + 1)/x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;(x^2+1)/x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
<span class="go">x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1.043&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1.043&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(1, -5)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1.6&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1.6&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1/3 + 2 + 3^2 + O(3^3)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
<span class="go">34/3</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;sin(x+O(x^10))&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
<span class="go">1/362880*x^9 - 1/5040*x^7 + 1/120*x^5 - 1/6*x^3 + x</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;sin(x+O(x^10))&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>   <span class="c1"># each coefficient has abs &lt; 1</span>
<span class="go">x + O(x^10)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.type">
<code class="descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the PARI type of self as a string.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In Cython, it is much faster to simply use typ(self.g) for
checking PARI types.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_INT&#39;</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_POL&#39;</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s1">&#39;oo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;t_INFINITY&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.vecmax">
<code class="descname">vecmax</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.vecmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of the elements of the vector/matrix <span class="math">\(x\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">])</span><span class="o">.</span><span class="n">vecmax</span><span class="p">()</span>
<span class="go">8.00000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen.vecmin">
<code class="descname">vecmin</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen.vecmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum of the elements of the vector/matrix <span class="math">\(x\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">])</span><span class="o">.</span><span class="n">vecmin</span><span class="p">()</span>
<span class="go">-5/3</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.libs.pari.gen.gen_auto">
<em class="property">class </em><code class="descclassname">sage.libs.pari.gen.</code><code class="descname">gen_auto</code><a class="headerlink" href="#sage.libs.pari.gen.gen_auto" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/element.html#sage.structure.element.RingElement" title="(in Sage Reference Manual: Basic Structures v7.3)"><code class="xref py py-class docutils literal"><span class="pre">sage.structure.element.RingElement</span></code></a></p>
<p>Part of the <a class="reference internal" href="#sage.libs.pari.gen.gen" title="sage.libs.pari.gen.gen"><code class="xref py py-class docutils literal"><span class="pre">gen</span></code></a> class containing auto-generated functions.</p>
<p>This class is not meant to be used directly, use the derived class
<a class="reference internal" href="#sage.libs.pari.gen.gen" title="sage.libs.pari.gen.gen"><code class="xref py py-class docutils literal"><span class="pre">gen</span></code></a> instead.</p>
<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Col">
<code class="descname">Col</code><span class="sig-paren">(</span><em>x</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Col" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the object <span class="math">\(x\)</span> into a column vector. The dimension of the
resulting vector can be optionally specified via the extra parameter <span class="math">\(n\)</span>.</p>
<p>If <span class="math">\(n\)</span> is omitted or <span class="math">\(0\)</span>, the dimension depends on the type of <span class="math">\(x\)</span>; the
vector has a single component, except when <span class="math">\(x\)</span> is</p>
<ul class="simple">
<li>a vector or a quadratic form (in which case the resulting vector
is simply the initial object considered as a row vector),</li>
<li>a polynomial or a power series. In the case of a polynomial, the
coefficients of the vector start with the leading coefficient of the
polynomial, while for power series only the significant coefficients are
taken into account, but this time by increasing order of degree.
In this last case, <code class="docutils literal"><span class="pre">Vec</span></code> is the reciprocal function of <code class="docutils literal"><span class="pre">Pol</span></code> and
<code class="docutils literal"><span class="pre">Ser</span></code> respectively,</li>
<li>a matrix (the column of row vector comprising the matrix is returned),</li>
<li>a character string (a vector of individual characters is returned).</li>
</ul>
<p>In the last two cases (matrix and character string), <span class="math">\(n\)</span> is meaningless and
must be omitted or an error is raised. Otherwise, if <span class="math">\(n\)</span> is given, <span class="math">\(0\)</span>
entries are appended at the end of the vector if <span class="math">\(n &gt; 0\)</span>, and prepended at
the beginning if <span class="math">\(n &lt; 0\)</span>. The dimension of the resulting vector is <span class="math">\(\|n\|\)</span>.</p>
<p>Note that the function <code class="docutils literal"><span class="pre">Colrev</span></code> does not exist, use <code class="docutils literal"><span class="pre">Vecrev</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Colrev">
<code class="descname">Colrev</code><span class="sig-paren">(</span><em>x</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Colrev" title="Permalink to this definition">¶</a></dt>
<dd><p>As <span class="math">\(Col(x, -n)\)</span>, then reverse the result. In particular,
<code class="docutils literal"><span class="pre">Colrev</span></code> is the reciprocal function of <code class="docutils literal"><span class="pre">Polrev</span></code>: the
coefficients of the vector start with the constant coefficient of the
polynomial and the others follow by increasing degree.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.List">
<code class="descname">List</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.List" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms a (row or column) vector <span class="math">\(x\)</span> into a list, whose components are
the entries of <span class="math">\(x\)</span>. Similarly for a list, but rather useless in this case.
For other types, creates a list with the single element <span class="math">\(x\)</span>. Note that,
except when <span class="math">\(x\)</span> is omitted, this function creates a small memory leak; so,
either initialize all lists to the empty list, or use them sparingly.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Map">
<code class="descname">Map</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Map" title="Permalink to this definition">¶</a></dt>
<dd><p>A &#8220;Map&#8221; is an associative array, or dictionary: a data
type composed of a collection of (<em>key</em>, <em>value</em>) pairs, such that
each key appears just once in the collection. This function
converts the matrix <span class="math">\([a_1,b_1;a_2,b_2;...;a_n,b_n]\)</span> to the map <span class="math">\(a_i:---&gt;
b_i\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = Map(factor(13!));
? mapget(M,3)
%2 = 5
</pre></div>
</div>
<p>If the argument <span class="math">\(x\)</span> is omitted, creates an empty map, which
may be filled later via <code class="docutils literal"><span class="pre">mapput</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Mat">
<code class="descname">Mat</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the object <span class="math">\(x\)</span> into a matrix.
If <span class="math">\(x\)</span> is already a matrix, a copy of <span class="math">\(x\)</span> is created.
If <span class="math">\(x\)</span> is a row (resp. column) vector, this creates a 1-row (resp.
1-column) matrix, <em>unless</em> all elements are column (resp.&nbsp;row) vectors
of the same length, in which case the vectors are concatenated sideways
and the associated big matrix is returned.
If <span class="math">\(x\)</span> is a binary quadratic form, creates the associated <span class="math">\(2 x 2\)</span>
matrix. Otherwise, this creates a <span class="math">\(1 x 1\)</span> matrix containing <span class="math">\(x\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? Mat(x + 1)
%1 =
[x + 1]
? Vec( matid(3) )
%2 = [[1, 0, 0]~, [0, 1, 0]~, [0, 0, 1]~]
? Mat(%)
%3 =
[1 0 0]

[0 1 0]

[0 0 1]
? Col( [1,2; 3,4] )
%4 = [[1, 2], [3, 4]]~
? Mat(%)
%5 =
[1 2]

[3 4]
? Mat(Qfb(1,2,3))
%6 =
[1 1]

[1 3]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Mod">
<code class="descname">Mod</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Mod" title="Permalink to this definition">¶</a></dt>
<dd><p>In its basic form, creates an intmod or a polmod <span class="math">\((a mod b)\)</span>; <span class="math">\(b\)</span> must
be an integer or a polynomial. We then obtain a <code class="docutils literal"><span class="pre">t_INTMOD</span></code> and a
<code class="docutils literal"><span class="pre">t_POLMOD</span></code> respectively:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? t = Mod(2,17); t^8
%1 = Mod(1, 17)
? t = Mod(x,x^2+1); t^2
%2 = Mod(-1, x^2+1)
</pre></div>
</div>
<p>If <span class="math">\(a \% b\)</span> makes sense and yields a result of the
appropriate type (<code class="docutils literal"><span class="pre">t_INT</span></code> or scalar/<code class="docutils literal"><span class="pre">t_POL</span></code>), the operation succeeds as
well:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? Mod(1/2, 5)
%3 = Mod(3, 5)
? Mod(7 + O(3^6), 3)
%4 = Mod(1, 3)
? Mod(Mod(1,12), 9)
%5 = Mod(1, 3)
? Mod(1/x, x^2+1)
%6 = Mod(-1, x^2+1)
? Mod(exp(x), x^4)
%7 = Mod(1/6*x^3 + 1/2*x^2 + x + 1, x^4)
</pre></div>
</div>
<p>If <span class="math">\(a\)</span> is a complex object, &#8220;base change&#8221; it to <span class="math">\(\mathbb{Z}/b\mathbb{Z}\)</span> or <span class="math">\(K[x]/(b)\)</span>,
which is equivalent to, but faster than, multiplying it by <code class="docutils literal"><span class="pre">Mod(1,b)</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? Mod([1,2;3,4], 2)
%8 =
[Mod(1, 2) Mod(0, 2)]

[Mod(1, 2) Mod(0, 2)]
? Mod(3*x+5, 2)
%9 = Mod(1, 2)*x + Mod(1, 2)
? Mod(x^2 + y*x + y^3, y^2+1)
%10 = Mod(1, y^2 + 1)*x^2 + Mod(y, y^2 + 1)*x + Mod(-y, y^2 + 1)
</pre></div>
</div>
<p>This function is not the same as <span class="math">\(x\)</span> <code class="docutils literal"><span class="pre">%</span></code> <span class="math">\(y\)</span>, the result of which
has no knowledge of the intended modulus <span class="math">\(y\)</span>. Compare</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? x = 4 % 5; x + 1
%1 = 5
? x = Mod(4,5); x + 1
%2 = Mod(0,5)
</pre></div>
</div>
<p>Note that such &#8220;modular&#8221; objects can be lifted via <code class="docutils literal"><span class="pre">lift</span></code> or
<code class="docutils literal"><span class="pre">centerlift</span></code>. The modulus of a <code class="docutils literal"><span class="pre">t_INTMOD</span></code> or <code class="docutils literal"><span class="pre">t_POLMOD</span></code> <span class="math">\(z\)</span> can
be recovered via <code class="docutils literal"><span class="pre">:math:`z</span></code>.mod`.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Pol">
<code class="descname">Pol</code><span class="sig-paren">(</span><em>t</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Pol" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the object <span class="math">\(t\)</span> into a polynomial with main variable <span class="math">\(v\)</span>. If <span class="math">\(t\)</span>
is a scalar, this gives a constant polynomial. If <span class="math">\(t\)</span> is a power series with
non-negative valuation or a rational function, the effect is similar to
<code class="docutils literal"><span class="pre">truncate</span></code>, i.e.&nbsp;we chop off the <span class="math">\(O(X^k)\)</span> or compute the Euclidean
quotient of the numerator by the denominator, then change the main variable
of the result to <span class="math">\(v\)</span>.</p>
<p>The main use of this function is when <span class="math">\(t\)</span> is a vector: it creates the
polynomial whose coefficients are given by <span class="math">\(t\)</span>, with <span class="math">\(t[1]\)</span> being the leading
coefficient (which can be zero). It is much faster to evaluate
<code class="docutils literal"><span class="pre">Pol</span></code> on a vector of coefficients in this way, than the corresponding
formal expression <span class="math">\(a_n X^n +...+ a_0\)</span>, which is evaluated naively exactly
as written (linear versus quadratic time in <span class="math">\(n\)</span>). <code class="docutils literal"><span class="pre">Polrev</span></code> can be used if
one wants <span class="math">\(x[1]\)</span> to be the constant coefficient:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? Pol([1,2,3])
%1 = x^2 + 2*x + 3
? Polrev([1,2,3])
%2 = 3*x^2 + 2*x + 1
</pre></div>
</div>
<p>The reciprocal function of <code class="docutils literal"><span class="pre">Pol</span></code> (resp.&nbsp;<code class="docutils literal"><span class="pre">Polrev</span></code>) is <code class="docutils literal"><span class="pre">Vec</span></code> (resp.&nbsp;
<code class="docutils literal"><span class="pre">Vecrev</span></code>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? Vec(Pol([1,2,3]))
%1 = [1, 2, 3]
? Vecrev( Polrev([1,2,3]) )
%2 = [1, 2, 3]
</pre></div>
</div>
<p><strong>Warning.</strong> This is <em>not</em> a substitution function. It will not
transform an object containing variables of higher priority than&nbsp;<span class="math">\(v\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? Pol(x + y, y)
 *** at top-level: Pol(x+y,y)
 *** ^----------
 *** Pol: variable must have higher priority in gtopoly.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Polrev">
<code class="descname">Polrev</code><span class="sig-paren">(</span><em>t</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Polrev" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the object <span class="math">\(t\)</span> into a polynomial
with main variable <span class="math">\(v\)</span>. If <span class="math">\(t\)</span> is a scalar, this gives a constant polynomial.
If <span class="math">\(t\)</span> is a power series, the effect is identical to <code class="docutils literal"><span class="pre">truncate</span></code>, i.e.&nbsp;it
chops off the <span class="math">\(O(X^k)\)</span>.</p>
<p>The main use of this function is when <span class="math">\(t\)</span> is a vector: it creates the
polynomial whose coefficients are given by <span class="math">\(t\)</span>, with <span class="math">\(t[1]\)</span> being the
constant term. <code class="docutils literal"><span class="pre">Pol</span></code> can be used if one wants <span class="math">\(t[1]\)</span> to be the leading
coefficient:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? Polrev([1,2,3])
%1 = 3*x^2 + 2*x + 1
? Pol([1,2,3])
%2 = x^2 + 2*x + 3
</pre></div>
</div>
<p>The reciprocal function of <code class="docutils literal"><span class="pre">Pol</span></code> (resp.&nbsp;<code class="docutils literal"><span class="pre">Polrev</span></code>) is <code class="docutils literal"><span class="pre">Vec</span></code> (resp.&nbsp;
<code class="docutils literal"><span class="pre">Vecrev</span></code>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Qfb">
<code class="descname">Qfb</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>c</em>, <em>D=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Qfb" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the binary quadratic form
<span class="math">\(ax^2+bxy+cy^2\)</span>. If <span class="math">\(b^2-4ac &gt; 0\)</span>, initialize Shanks&#8217; distance
function to <span class="math">\(D\)</span>. Negative definite forms are not implemented,
use their positive definite counterpart instead.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Ser">
<code class="descname">Ser</code><span class="sig-paren">(</span><em>s</em>, <em>v=None</em>, <em>serprec=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Ser" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the object <span class="math">\(s\)</span> into a power series with main variable <span class="math">\(v\)</span>
(<span class="math">\(x\)</span> by default) and precision (number of significant terms) equal to
<span class="math">\(d &gt;= 0\)</span> (<span class="math">\(d = seriesprecision\)</span> by default). If <span class="math">\(s\)</span> is a
scalar, this gives a constant power series in <span class="math">\(v\)</span> with precision <code class="docutils literal"><span class="pre">d</span></code>.
If <span class="math">\(s\)</span> is a polynomial, the polynomial is truncated to <span class="math">\(d\)</span> terms if needed</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? Ser(1, &#39;y, 5)
%1 = 1 + O(y^5)
? Ser(x^2,, 5)
%2 = x^2 + O(x^7)
? T = polcyclo(100)
%3 = x^40 - x^30 + x^20 - x^10 + 1
? Ser(T, &#39;x, 11)
%4 = 1 - x^10 + O(x^11)
</pre></div>
</div>
<p>The function is more or less equivalent with multiplication by
<span class="math">\(1 + O(v^d)\)</span> in theses cases, only faster.</p>
<p>If <span class="math">\(s\)</span> is a vector, on the other hand, the coefficients of the vector are
understood to be the coefficients of the power series starting from the
constant term (as in <code class="docutils literal"><span class="pre">Polrev</span></code><span class="math">\((x)\)</span>), and the precision <span class="math">\(d\)</span> is ignored:
in other words, in this case, we convert <code class="docutils literal"><span class="pre">t_VEC</span></code> / <code class="docutils literal"><span class="pre">t_COL</span></code> to the power
series whose significant terms are exactly given by the vector entries.
Finally, if <span class="math">\(s\)</span> is already a power series in <span class="math">\(v\)</span>, we return it verbatim,
ignoring <span class="math">\(d\)</span> again. If <span class="math">\(d\)</span> significant terms are desired in the last two
cases, convert/truncate to <code class="docutils literal"><span class="pre">t_POL</span></code> first.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? v = [1,2,3]; Ser(v, t, 7)
%5 = 1 + 2*t + 3*t^2 + O(t^3) \\ 3 terms: 7 is ignored!
? Ser(Polrev(v,t), t, 7)
%6 = 1 + 2*t + 3*t^2 + O(t^7)
? s = 1+x+O(x^2); Ser(s, x, 7)
%7 = 1 + x + O(x^2) \\ 2 terms: 7 ignored
? Ser(truncate(s), x, 7)
%8 = 1 + x + O(x^7)
</pre></div>
</div>
<p>The warning given for <code class="docutils literal"><span class="pre">Pol</span></code> also applies here: this is not a substitution
function.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Set">
<code class="descname">Set</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Set" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts <span class="math">\(x\)</span> into a set, i.e.&nbsp;into a row vector, with strictly increasing
entries with respect to the (somewhat arbitrary) universal comparison function
<code class="docutils literal"><span class="pre">cmp</span></code>. Standard container types <code class="docutils literal"><span class="pre">t_VEC</span></code>, <code class="docutils literal"><span class="pre">t_COL</span></code>, <code class="docutils literal"><span class="pre">t_LIST</span></code> and
<code class="docutils literal"><span class="pre">t_VECSMALL</span></code> are converted to the set with corresponding elements. All
others are converted to a set with one element.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? Set([1,2,4,2,1,3])
%1 = [1, 2, 3, 4]
? Set(x)
%2 = [x]
? Set(Vecsmall([1,3,2,1,3]))
%3 = [1, 2, 3]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Strchr">
<code class="descname">Strchr</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Strchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts <span class="math">\(x\)</span> to a string, translating each integer
into a character.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? Strchr(97)
%1 = &quot;a&quot;
? Vecsmall(&quot;hello world&quot;)
%2 = Vecsmall([104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100])
? Strchr(%)
%3 = &quot;hello world&quot;
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Vec">
<code class="descname">Vec</code><span class="sig-paren">(</span><em>x</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the object <span class="math">\(x\)</span> into a row vector. The dimension of the
resulting vector can be optionally specified via the extra parameter <span class="math">\(n\)</span>.</p>
<p>If <span class="math">\(n\)</span> is omitted or <span class="math">\(0\)</span>, the dimension depends on the type of <span class="math">\(x\)</span>; the
vector has a single component, except when <span class="math">\(x\)</span> is</p>
<ul class="simple">
<li>a vector or a quadratic form: returns the initial object considered as a
row vector,</li>
<li>a polynomial or a power series: returns a vector consisting of the coefficients.
In the case of a polynomial, the coefficients of the vector start with the leading
coefficient of the polynomial, while for power series only the significant coefficients
are taken into account, but this time by increasing order of degree.
<code class="docutils literal"><span class="pre">Vec</span></code> is the reciprocal function of <code class="docutils literal"><span class="pre">Pol</span></code> for a polynomial and of
<code class="docutils literal"><span class="pre">Ser</span></code> for a power series,</li>
<li>a matrix: returns the vector of columns comprising the matrix,</li>
<li>a character string: returns the vector of individual characters,</li>
<li>a map: returns the vector of the domain of the map,</li>
<li>an error context (<code class="docutils literal"><span class="pre">t_ERROR</span></code>): returns the error components, see
<code class="docutils literal"><span class="pre">iferr</span></code>.</li>
</ul>
<p>In the last four cases (matrix, character string, map, error), <span class="math">\(n\)</span> is
meaningless and must be omitted or an error is raised. Otherwise, if <span class="math">\(n\)</span> is
given, <span class="math">\(0\)</span> entries are appended at the end of the vector if <span class="math">\(n &gt; 0\)</span>, and
prepended at the beginning if <span class="math">\(n &lt; 0\)</span>. The dimension of the resulting vector
is <span class="math">\(\|n\|\)</span>. Variant: <code class="docutils literal"><span class="pre">GEN</span> <span class="pre">:strong:`gtovec`(GEN</span> <span class="pre">x)</span></code> is also available.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Vecrev">
<code class="descname">Vecrev</code><span class="sig-paren">(</span><em>x</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Vecrev" title="Permalink to this definition">¶</a></dt>
<dd><p>As <span class="math">\(Vec(x, -n)\)</span>, then reverse the result. In particular,
<code class="docutils literal"><span class="pre">Vecrev</span></code> is the reciprocal function of <code class="docutils literal"><span class="pre">Polrev</span></code>: the
coefficients of the vector start with the constant coefficient of the
polynomial and the others follow by increasing degree.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.Vecsmall">
<code class="descname">Vecsmall</code><span class="sig-paren">(</span><em>x</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.Vecsmall" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the object <span class="math">\(x\)</span> into a row vector of type <code class="docutils literal"><span class="pre">t_VECSMALL</span></code>. The
dimension of the resulting vector can be optionally specified via the extra
parameter <span class="math">\(n\)</span>.</p>
<p>This acts as <code class="docutils literal"><span class="pre">Vec</span></code><span class="math">\((x,n)\)</span>, but only on a limited set of objects:
the result must be representable as a vector of small integers.
If <span class="math">\(x\)</span> is a character string, a vector of individual characters in ASCII
encoding is returned (<code class="docutils literal"><span class="pre">Strchr</span></code> yields back the character string).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Absolute value of <span class="math">\(x\)</span> (modulus if <span class="math">\(x\)</span> is complex).
Rational functions are not allowed. Contrary to most transcendental
functions, an exact argument is <em>not</em> converted to a real number before
applying <code class="docutils literal"><span class="pre">abs</span></code> and an exact result is returned if possible.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? abs(-1)
%1 = 1
? abs(3/7 + 4/7*I)
%2 = 5/7
? abs(1 + I)
%3 = 1.414213562373095048801688724
</pre></div>
</div>
<p>If <span class="math">\(x\)</span> is a polynomial, returns <span class="math">\(-x\)</span> if the leading coefficient is
real and negative else returns <span class="math">\(x\)</span>. For a power series, the constant
coefficient is considered instead.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.acos">
<code class="descname">acos</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.acos" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of <span class="math">\({cos}^{-1}(x) = -i \log (x + i\sqrt{1-x^2})\)</span>.
In particular, <span class="math">\({Re(acos}(x)) belongs to [0,\Pi]\)</span> and if <span class="math">\(x belongs to \mathbb{R}\)</span> and <span class="math">\(\|x\| &gt; 1\)</span>,
then <span class="math">\({acos}(x)\)</span> is complex. The branch cut is in two pieces:
<span class="math">\(]- oo ,-1]\)</span> , continuous with quadrant II, and <span class="math">\([1,+ oo [\)</span>, continuous
with quadrant IV. We have <span class="math">\({acos}(x) = \Pi/2 - {asin}(x)\)</span> for all
<span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.acosh">
<code class="descname">acosh</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.acosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of <span class="math">\({cosh}^{-1}(x) = 2
\log(\sqrt{(x+1)/2} + \sqrt{(x-1)/2})\)</span>. In particular,
<span class="math">\({Re}({acosh}(x)) &gt;= 0\)</span> and
<span class="math">\({Im}({acosh}(x)) belongs to ]-\Pi,\Pi]\)</span>; if <span class="math">\(x belongs to \mathbb{R}\)</span> and <span class="math">\(x &lt; 1\)</span>, then
<span class="math">\({acosh}(x)\)</span> is complex.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.addprimes">
<code class="descname">addprimes</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.addprimes" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the integers contained in the
vector <span class="math">\(x\)</span> (or the single integer <span class="math">\(x\)</span>) to a special table of
&#8220;user-defined primes&#8221;, and returns that table. Whenever <code class="docutils literal"><span class="pre">factor</span></code> is
subsequently called, it will trial divide by the elements in this table.
If <span class="math">\(x\)</span> is empty or omitted, just returns the current list of extra
primes.</p>
<p>The entries in <span class="math">\(x\)</span> must be primes: there is no internal check, even if
the <code class="docutils literal"><span class="pre">factor_proven</span></code> default is set. To remove primes from the list use
<code class="docutils literal"><span class="pre">removeprimes</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.agm">
<code class="descname">agm</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.agm" title="Permalink to this definition">¶</a></dt>
<dd><p>Arithmetic-geometric mean of <span class="math">\(x\)</span> and <span class="math">\(y\)</span>. In the
case of complex or negative numbers, the optimal AGM is returned
(the largest in absolute value over all choices of the signs of the square
roots). <span class="math">\(p\)</span>-adic or power series arguments are also allowed. Note that
a <span class="math">\(p\)</span>-adic agm exists only if <span class="math">\(x/y\)</span> is congruent to 1 modulo <span class="math">\(p\)</span> (modulo
16 for <span class="math">\(p = 2\)</span>). <span class="math">\(x\)</span> and <span class="math">\(y\)</span> cannot both be vectors or matrices.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algabsdim">
<code class="descname">algabsdim</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algabsdim" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code> or by
<code class="docutils literal"><span class="pre">algtableinit</span></code>, returns the dimension of <em>al</em> over its prime subfield
(<span class="math">\(\mathbb{Q}\)</span> or <span class="math">\(\mathbb{F}_p\)</span>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^3-y+1);
? A = alginit(nf, [-1,-1]);
? algabsdim(A)
%3 = 12
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algadd">
<code class="descname">algadd</code><span class="sig-paren">(</span><em>al</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algadd" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in <em>al</em>, computes their sum <span class="math">\(x+y\)</span> in
the algebra&nbsp;<em>al</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A = alginit(nfinit(y),[-1,1]);
? algadd(A,[1,0]~,[1,2]~)
%2 = [2, 2]~
</pre></div>
</div>
<p>Also accepts matrices with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algalgtobasis">
<code class="descname">algalgtobasis</code><span class="sig-paren">(</span><em>al</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algalgtobasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <em>x</em> in the central simple algebra <em>al</em> output
by <code class="docutils literal"><span class="pre">alginit</span></code>, transforms it to a column vector on the integral basis of
<em>al</em>. This is the inverse function of <code class="docutils literal"><span class="pre">algbasistoalg</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A = alginit(nfinit(y^2-5),[2,y]);
? algalgtobasis(A,[y,1]~)
%2 = [0, 2, 0, -1, 2, 0, 0, 0]~
? algbasistoalg(A,algalgtobasis(A,[y,1]~))
%3 = [Mod(Mod(y, y^2 - 5), x^2 - 2), 1]~
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algaut">
<code class="descname">algaut</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algaut" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a cyclic algebra <span class="math">\(al = (L/K,\sigma,b)\)</span> output by
<code class="docutils literal"><span class="pre">alginit</span></code>, returns the automorphism <span class="math">\(\sigma\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y);
? p = idealprimedec(nf,7)[1];
? p2 = idealprimedec(nf,11)[1];
? A = alginit(nf,[3,[[p,p2],[1/3,2/3]],[0]]);
? algaut(A)
%5 = -1/3*x^2 + 1/3*x + 26/3
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algb">
<code class="descname">algb</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algb" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a cyclic algebra <span class="math">\(al = (L/K,\sigma,b)\)</span> output by
<code class="docutils literal"><span class="pre">alginit</span></code>, returns the element <span class="math">\(b belongs to K\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>nf = nfinit(y);
? p = idealprimedec(nf,7)[1];
? p2 = idealprimedec(nf,11)[1];
? A = alginit(nf,[3,[[p,p2],[1/3,2/3]],[0]]);
? algb(A)
%5 = Mod(-77, y)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algbasis">
<code class="descname">algbasis</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an central simple algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code>, returns
a <span class="math">\(\mathbb{Z}\)</span>-basis of the order&nbsp;<span class="math">\({\cal O}_0\)</span> stored in <em>al</em> with respect to the
natural order in <em>al</em>. It is a maximal order if one has been computed.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>A = alginit(nfinit(y), [-1,-1]);
? algbasis(A)
%2 =
[1 0 0 1/2]

[0 1 0 1/2]

[0 0 1 1/2]

[0 0 0 1/2]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algbasistoalg">
<code class="descname">algbasistoalg</code><span class="sig-paren">(</span><em>al</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algbasistoalg" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <em>x</em> in the central simple algebra <em>al</em> output
by <code class="docutils literal"><span class="pre">alginit</span></code>, transforms it to its algebraic representation in <em>al</em>.
This is the inverse function of <code class="docutils literal"><span class="pre">algalgtobasis</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A = alginit(nfinit(y^2-5),[2,y]);
? z = algbasistoalg(A,[0,1,0,0,2,-3,0,0]~);
? liftall(z)
%3 = [(-1/2*y - 2)*x + (-1/4*y + 5/4), -3/4*y + 7/4]~
? algalgtobasis(A,z)
%4 = [0, 1, 0, 0, 2, -3, 0, 0]~
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algcenter">
<code class="descname">algcenter</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algcenter" title="Permalink to this definition">¶</a></dt>
<dd><p>If <em>al</em> is a table algebra output by <code class="docutils literal"><span class="pre">algtableinit</span></code>, returns a
basis of the center of the algebra&nbsp;<em>al</em> over its prime field (<span class="math">\(\mathbb{Q}\)</span> or
<span class="math">\(\mathbb{F}_p\)</span>). If <em>al</em> is a central simple algebra output by <code class="docutils literal"><span class="pre">alginit</span></code>,
returns the center of&nbsp;<em>al</em>, which is stored in <em>al</em>.</p>
<p>A simple example: the <span class="math">\(2 x 2\)</span> upper triangular matrices over <span class="math">\(\mathbb{Q}\)</span>,
generated by <span class="math">\(I_2\)</span>, <span class="math">\(a = [0,1;0,0]\)</span> and <span class="math">\(b = [0,0;0,1]\)</span>,
such that <span class="math">\(a^2 = 0\)</span>, <span class="math">\(ab = a\)</span>, <span class="math">\(ba = 0\)</span>, <span class="math">\(b^2 = b\)</span>: the diagonal matrices
form the center.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
? A = algtableinit(mt);
? algcenter(A) \\ = (I_2)
%3 =
[1]

[0]

[0]
</pre></div>
</div>
<p>An example in the central simple case:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^3-y+1);
? A = alginit(nf, [-1,-1]);
? algcenter(A).pol
%3 = y^3 - y + 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algcentralproj">
<code class="descname">algcentralproj</code><span class="sig-paren">(</span><em>al</em>, <em>z</em>, <em>maps=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algcentralproj" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a table algebra <em>al</em> output by <code class="docutils literal"><span class="pre">algtableinit</span></code> and a
<code class="docutils literal"><span class="pre">t_VEC</span></code> <span class="math">\(z = [z_1,...,z_n]\)</span> of orthogonal central idempotents,
returns a <code class="docutils literal"><span class="pre">t_VEC</span></code> <span class="math">\([al_1,...,al_n]\)</span> of algebras such that
<span class="math">\(al_i = z_i al\)</span>. If <span class="math">\(maps = 1\)</span>, each <span class="math">\(al_i\)</span> is a <code class="docutils literal"><span class="pre">t_VEC</span></code>
<span class="math">\([quo,proj,lift]\)</span> where <em>quo</em> is the quotient algebra, <em>proj</em> is a
<code class="docutils literal"><span class="pre">t_MAT</span></code> representing the projection onto this quotient and <em>lift</em> is a
<code class="docutils literal"><span class="pre">t_MAT</span></code> representing a lift.</p>
<p>A simple example: <span class="math">\(\mathbb{F}_2\oplus \mathbb{F}_4\)</span>, generated by&nbsp;<span class="math">\(1 = (1,1)\)</span>, <span class="math">\(e = (1,0)\)</span>
and&nbsp;<span class="math">\(x\)</span> such that&nbsp;<span class="math">\(x^2+x+1 = 0\)</span>. We have&nbsp;<span class="math">\(e^2 = e\)</span>, <span class="math">\(x^2 = x+1\)</span> and&nbsp;<span class="math">\(ex = 0\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,2);
? e = [0,1,0]~;
? e2 = algsub(A,[1,0,0]~,e);
? [a,a2] = algcentralproj(A,[e,e2]);
? algdim(a)
%6 = 1
? algdim(a2)
%7 = 2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algchar">
<code class="descname">algchar</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algchar" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code> or <code class="docutils literal"><span class="pre">algtableinit</span></code>,
returns the characteristic of <em>al</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,13);
? algchar(A)
%3 = 13
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algcharpoly">
<code class="descname">algcharpoly</code><span class="sig-paren">(</span><em>al</em>, <em>b</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algcharpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(b\)</span> in <em>al</em>, returns its characteristic polynomial
as a polynomial in the variable <span class="math">\(v\)</span>. If <em>al</em> is a table algebra output
by <code class="docutils literal"><span class="pre">algtableinit</span></code>, returns the absolute characteristic polynomial of
<em>b</em>, which is an element of <span class="math">\(\mathbb{F}_p[v]\)</span> or&nbsp;<span class="math">\(\mathbb{Q}[v]\)</span>; if <em>al</em> is a
central simple algebra output by <code class="docutils literal"><span class="pre">alginit</span></code>, returns the reduced
characteristic polynomial of <em>b</em>, which is an element of <span class="math">\(K[v]\)</span> where&nbsp;<span class="math">\(K\)</span>
is the center of <em>al</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? al = alginit(nfinit(y), [-1,-1]); \\ (-1,-1)_Q
? algcharpoly(al, [0,1]~)
%2 = x^2 + 1
</pre></div>
</div>
<p>Also accepts a square matrix with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algdecomposition">
<code class="descname">algdecomposition</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algdecomposition" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being a table algebra output by <code class="docutils literal"><span class="pre">algtableinit</span></code>, returns
<span class="math">\([J,[al_1,...,al_n]]\)</span> where <span class="math">\(J\)</span> is a basis of the Jacobson radical of
<em>al</em> and <span class="math">\(al_1,...,al_n\)</span> are the simple factors of the semisimple
algebra <span class="math">\(al/J\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algdegree">
<code class="descname">algdegree</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algdegree" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code>, returns
the degree of <em>al</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^3-y+1);
? A = alginit(nf, [-1,-1]);
? algdegree(A)
%3 = 2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algdep">
<code class="descname">algdep</code><span class="sig-paren">(</span><em>z</em>, <em>k</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algdep" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(z\)</span> being real/complex, or <span class="math">\(p\)</span>-adic, finds a polynomial (in the variable
<code class="docutils literal"><span class="pre">'x</span></code>) of degree at most
<span class="math">\(k\)</span>, with integer coefficients, having <span class="math">\(z\)</span> as approximate root. Note that the
polynomial which is obtained is not necessarily the &#8220;correct&#8221; one. In fact
it is not even guaranteed to be irreducible. One can check the closeness
either by a polynomial evaluation (use <code class="docutils literal"><span class="pre">subst</span></code>), or by computing the
roots of the polynomial given by <code class="docutils literal"><span class="pre">algdep</span></code> (use <code class="docutils literal"><span class="pre">polroots</span></code> or
<code class="docutils literal"><span class="pre">polrootspadic</span></code>).</p>
<p>Internally, <code class="docutils literal"><span class="pre">lindep</span></code><span class="math">\(([1,z,...,z^k], flag)\)</span> is used. A non-zero value of
<span class="math">\(flag\)</span> may improve on the default behavior if the input number is known to a
<em>huge</em> accuracy, and you suspect the last bits are incorrect: if <span class="math">\(flag &gt; 0\)</span>
the computation is done with an accuracy of <span class="math">\(flag\)</span> decimal digits; to get
meaningful results, the parameter <span class="math">\(flag\)</span> should be smaller than the number of
correct decimal digits in the input.
But default values are usually sufficient, so try without <span class="math">\(flag\)</span> first:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \p200
? z = 2^(1/6)+3^(1/5);
? algdep(z, 30); \\ right in 280ms
? algdep(z, 30, 100); \\ wrong in 169ms
? algdep(z, 30, 170); \\ right in 288ms
? algdep(z, 30, 200); \\ wrong in 320ms
? \p250
? z = 2^(1/6)+3^(1/5); \\ recompute to new, higher, accuracy !
? algdep(z, 30); \\ right in 329ms
? algdep(z, 30, 200); \\ right in 324ms
? \p500
? algdep(2^(1/6)+3^(1/5), 30); \\ right in 677ms
? \p1000
? algdep(2^(1/6)+3^(1/5), 30); \\ right in 1.5s
</pre></div>
</div>
<p>The changes in <code class="docutils literal"><span class="pre">realprecision</span></code> only affect the quality of the
initial approximation to <span class="math">\(2^{1/6} + 3^{1/5}\)</span>, <code class="docutils literal"><span class="pre">algdep</span></code> itself uses
exact operations. The size of its operands depend on the accuracy of the
input of course: more accurate input means slower operations.</p>
<p>Proceeding by increments of 5 digits of accuracy, <code class="docutils literal"><span class="pre">algdep</span></code> with default
flag produces its first correct result at 195 digits, and from then on a
steady stream of correct results:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>\\ <span class="n">assume</span> <span class="n">T</span> <span class="n">contains</span> <span class="n">the</span> <span class="n">correct</span> <span class="n">result</span><span class="p">,</span> <span class="k">for</span> <span class="n">comparison</span>
<span class="n">forstep</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">localprec</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>\
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">algdep</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="o">^</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">),</span><span class="mi">30</span><span class="p">)</span> <span class="o">==</span> <span class="n">T</span><span class="p">))</span>
</pre></div>
</div>
<p>The above example is the test case studied in a 2000 paper by Borwein and
Lisonek: Applications of integer relation algorithms, <em>Discrete Math.</em>,
<strong>217</strong>, p.&nbsp;65&#8211;82. The version of PARI tested there was 1.39, which
succeeded reliably from precision 265 on, in about 200 as much time as the
current version.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algdim">
<code class="descname">algdim</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algdim" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code>, returns
the dimension of <em>al</em> over its center. Given a table algebra <em>al</em>
output by <code class="docutils literal"><span class="pre">algtableinit</span></code>, returns the dimension of <em>al</em> over its prime
subfield (<span class="math">\(\mathbb{Q}\)</span> or <span class="math">\(\mathbb{F}_p\)</span>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^3-y+1);
? A = alginit(nf, [-1,-1]);
? algdim(A)
%3 = 4
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algdisc">
<code class="descname">algdisc</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algdisc" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code>, computes
the discriminant of the order <span class="math">\({\cal O}_0\)</span> stored in <em>al</em>, that is the
determinant of the trace form <span class="math">\(\rm{Tr} : {\cal O}_0 x {\cal O}_0 \to \mathbb{Z}\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2-5);
? A = alginit(nf, [-3,1-y]);
? [PR,h] = alghassef(A);
%3 = [[[2, [2, 0]~, 1, 2, 1], [3, [3, 0]~, 1, 2, 1]], Vecsmall([0, 1])]
? n = algdegree(A);
? D = algabsdim(A);
? h = vector(#h, i, n - gcd(n,h[i]));
? n^D * nf.disc^(n^2) * idealnorm(nf, idealfactorback(nf,PR,h))^n
%4 = 12960000
? algdisc(A)
%5 = 12960000
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algdivl">
<code class="descname">algdivl</code><span class="sig-paren">(</span><em>al</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algdivl" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in <em>al</em>, computes their left quotient
<span class="math">\(x\backslash y\)</span> in the algebra <em>al</em>: an element <span class="math">\(z\)</span> such that <span class="math">\(xz = y\)</span> (such
an element is not unique when <span class="math">\(x\)</span> is a zerodivisor). If&nbsp;<span class="math">\(x\)</span> is invertible, this
is the same as <span class="math">\(x^{-1}y\)</span>. Assumes that <span class="math">\(y\)</span> is left divisible by <span class="math">\(x\)</span> (i.e. that
<span class="math">\(z\)</span> exists). Also accepts matrices with coefficients in&nbsp;<em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algdivr">
<code class="descname">algdivr</code><span class="sig-paren">(</span><em>al</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algdivr" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in <em>al</em>, return <span class="math">\(xy^{-1}\)</span>. Also accepts
matrices with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.alggroup">
<code class="descname">alggroup</code><span class="sig-paren">(</span><em>gal</em>, <em>p=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.alggroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the group algebra&nbsp;<span class="math">\(K[G]\)</span> over&nbsp;<span class="math">\(K = \mathbb{Q}\)</span> (<span class="math">\(p\)</span> omitted) or&nbsp;<span class="math">\(\mathbb{F}_p\)</span>
where&nbsp;<span class="math">\(G\)</span> is the underlying group of the <code class="docutils literal"><span class="pre">galoisinit</span></code> structure&nbsp;<em>gal</em>.
The input&nbsp;<em>gal</em> is also allowed to be a <code class="docutils literal"><span class="pre">t_VEC</span></code> of permutations that is
closed under products.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfsplitting(x^3-x+1);
? gal = galoisinit(K);
? al = alggroup(gal);
? algissemisimple(al)
%4 = 1
? G = [Vecsmall([1,2,3]), Vecsmall([1,3,2])];
? al2 = alggroup(G, 2);
? algissemisimple(al2)
%8 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.alghasse">
<code class="descname">alghasse</code><span class="sig-paren">(</span><em>al</em>, <em>pl</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.alghasse" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code> and a prime
ideal or an integer between <span class="math">\(1\)</span> and <span class="math">\(r_1+r_2\)</span>, returns a <code class="docutils literal"><span class="pre">t_FRAC</span></code> <span class="math">\(h\)</span> : the
local Hasse invariant of <em>al</em> at the place specified by <em>pl</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? alghasse(A, 1)
%3 = 1/2
? alghasse(A, 2)
%4 = 0
? alghasse(A, idealprimedec(nf,2)[1])
%5 = 1/2
? alghasse(A, idealprimedec(nf,5)[1])
%6 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.alghassef">
<code class="descname">alghassef</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.alghassef" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code>, returns
a <code class="docutils literal"><span class="pre">t_VEC</span></code> <span class="math">\([PR, h_f]\)</span> describing the local Hasse invariants at the
finite places of the center: <code class="docutils literal"><span class="pre">PR</span></code> is a <code class="docutils literal"><span class="pre">t_VEC</span></code> of primes and <span class="math">\(h_f\)</span> is a
<code class="docutils literal"><span class="pre">t_VECSMALL</span></code> of integers modulo the degree <span class="math">\(d\)</span> of <em>al</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,2*y-1]);
? [PR,hf] = alghassef(A);
? PR
%4 = [[19, [10, 2]~, 1, 1, [-8, 2; 2, -10]], [2, [2, 0]~, 1, 2, 1]]
? hf
%5 = Vecsmall([1, 0])
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.alghassei">
<code class="descname">alghassei</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.alghassei" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code>, returns
a <code class="docutils literal"><span class="pre">t_VECSMALL</span></code> <span class="math">\(h_i\)</span> of <span class="math">\(r_1\)</span> integers modulo the degree <span class="math">\(d\)</span> of <em>al</em>,
where <span class="math">\(r_1\)</span> is the number of real places of the center: the local Hasse
invariants of <em>al</em> at infinite places.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? alghassei(A)
%3 = Vecsmall([1, 0])
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algindex">
<code class="descname">algindex</code><span class="sig-paren">(</span><em>al</em>, <em>pl=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the central simple algebra&nbsp;<span class="math">\(A\)</span> over&nbsp;<span class="math">\(K\)</span> (as output by
alginit), that is the degree&nbsp;<span class="math">\(e\)</span> of the unique central division algebra&nbsp;<span class="math">\(D\)</span>
over <span class="math">\(K\)</span> such that&nbsp;<span class="math">\(A\)</span> is isomorphic to some matrix algebra&nbsp;<span class="math">\(M_d(D)\)</span>. If
<em>pl</em> is set, it should be a prime ideal of&nbsp;<span class="math">\(K\)</span> or an integer between&nbsp;<span class="math">\(1\)</span>
and&nbsp;<span class="math">\(r_1+r_2\)</span>, and in that case return the local index at the place <em>pl</em>
instead.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? algindex(A, 1)
%3 = 2
? algindex(A, 2)
%4 = 1
? algindex(A, idealprimedec(nf,2)[1])
%5 = 2
? algindex(A, idealprimedec(nf,5)[1])
%6 = 1
? algindex(A)
%7 = 2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.alginit">
<code class="descname">alginit</code><span class="sig-paren">(</span><em>B</em>, <em>C</em>, <em>v=None</em>, <em>flag=1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.alginit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the central simple algebra defined by data <span class="math">\(B\)</span>, <span class="math">\(C\)</span> and
variable <span class="math">\(v\)</span>, as follows.</p>
<ul class="simple">
<li>(multiplication table) <span class="math">\(B\)</span> is the base number field <span class="math">\(K\)</span> in <code class="docutils literal"><span class="pre">nfinit</span></code>
form, <span class="math">\(C\)</span> is a &#8220;multiplication table&#8221; over <span class="math">\(K\)</span>.
As a <span class="math">\(K\)</span>-vector space, the algebra is generated by a basis
<span class="math">\((e_1 = 1,..., e_n)\)</span>; the table is given as a <code class="docutils literal"><span class="pre">t_VEC</span></code> of <span class="math">\(n\)</span> matrices in
<span class="math">\(M_n(K)\)</span>, giving the left multiplication by the basis elements <span class="math">\(e_i\)</span>, in the
given basis.
Assumes that <span class="math">\(e_1 = 1\)</span>, that the multiplication table is integral, and that
<span class="math">\(K[e_1,...,e_n]\)</span> describes a central simple algebra over <span class="math">\(K\)</span>.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">m_i</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
 <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
 <span class="n">m_j</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">;</span>
 <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">;</span>
 <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">;</span>
 <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
 <span class="n">m_k</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
 <span class="n">A</span> <span class="o">=</span> <span class="n">alginit</span><span class="p">(</span><span class="n">nfinit</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="p">[</span><span class="n">matid</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">m_i</span><span class="p">,</span><span class="n">m_j</span><span class="p">,</span><span class="n">m_k</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</div>
<p>represents (in a complicated way) the quaternion algebra <span class="math">\((-1,-1)_\mathbb{Q}\)</span>.
See below for a simpler solution.</p>
<ul class="simple">
<li>(cyclic algebra) <span class="math">\(B\)</span> is an <code class="docutils literal"><span class="pre">rnf</span></code> structure associated with a cyclic
number field extension <span class="math">\(L/K\)</span> of degree <span class="math">\(d\)</span>, <span class="math">\(C\)</span> is a <code class="docutils literal"><span class="pre">t_VEC</span></code>
<code class="docutils literal"><span class="pre">[sigma,b]</span></code> with 2 components: <code class="docutils literal"><span class="pre">sigma</span></code> is a <code class="docutils literal"><span class="pre">t_POLMOD</span></code> representing
an automorphism generating <span class="math">\({Gal}(L/K)\)</span>, <span class="math">\(b\)</span> is an element in <span class="math">\(K^*\)</span>. This
represents the cyclic algebra&nbsp;<span class="math">\((L/K,\sigma,b)\)</span>. Currently the element <span class="math">\(b\)</span> has
to be integral.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? Q = nfinit(y); T = polcyclo(5, &#39;x); F = rnfinit(Q, T);
? A = alginit(F, [Mod(x^2,T), 3]);
</pre></div>
</div>
<p>defines the cyclic algebra <span class="math">\((L/\mathbb{Q}, \sigma, 3)\)</span>, where
<span class="math">\(L = \mathbb{Q}(\zeta_5)\)</span> and <span class="math">\(\sigma:\zeta:---&gt;\zeta^2\)</span> generates
<span class="math">\({Gal}(L/\mathbb{Q})\)</span>.</p>
<ul class="simple">
<li>(quaternion algebra, special case of the above) <span class="math">\(B\)</span> is an <code class="docutils literal"><span class="pre">nf</span></code>
structure associated with a number field <span class="math">\(K\)</span>, <span class="math">\(C = [a,b]\)</span> is a vector
containing two elements of <span class="math">\(K^*\)</span> with <span class="math">\(a\)</span> not a square in <span class="math">\(K\)</span>, returns the quaternion algebra <span class="math">\((a,b)_K\)</span>.
The variable <span class="math">\(v\)</span> (<code class="docutils literal"><span class="pre">'x</span></code> by default) must have higher priority than the
variable of <span class="math">\(K\)</span><code class="docutils literal"><span class="pre">.pol</span></code> and is used to represent elements in the splitting
field <span class="math">\(L = K[x]/(x^2-a)\)</span>.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? Q = nfinit(y); A = alginit(Q, [-1,-1]); \\ (-1,-1)_Q
</pre></div>
</div>
<ul class="simple">
<li>(algebra/<span class="math">\(K\)</span> defined by local Hasse invariants)
<span class="math">\(B\)</span> is an <code class="docutils literal"><span class="pre">nf</span></code> structure associated with a number field <span class="math">\(K\)</span>,
<span class="math">\(C = [d, [PR,h_f], h_i]\)</span> is a triple
containing an integer <span class="math">\(d &gt; 1\)</span>, a pair <span class="math">\([PR, h_f]\)</span> describing the
Hasse invariants at finite places, and <span class="math">\(h_i\)</span> the Hasse invariants
at archimedean (real) places. A local Hasse invariant belongs to <span class="math">\((1/d)\mathbb{Z}/\mathbb{Z}
\subset \mathbb{Q}/\mathbb{Z}\)</span>, and is given either as a <code class="docutils literal"><span class="pre">t_FRAC</span></code> (lift to <span class="math">\((1/d)\mathbb{Z}\)</span>),
a <code class="docutils literal"><span class="pre">t_INT</span></code> or <code class="docutils literal"><span class="pre">t_INTMOD</span></code> modulo <span class="math">\(d\)</span> (lift to <span class="math">\(\mathbb{Z}/d\mathbb{Z}\)</span>); a whole vector
of local invariants can also be given as a <code class="docutils literal"><span class="pre">t_VECSMALL</span></code>, whose
entries are handled as <code class="docutils literal"><span class="pre">t_INT</span></code>&nbsp;s. <code class="docutils literal"><span class="pre">PR</span></code> is a list of prime ideals
(<code class="docutils literal"><span class="pre">prid</span></code> structures), and <span class="math">\(h_f\)</span> is a vector of the same length giving the
local invariants at those maximal ideals. The invariants at infinite real
places are indexed by the real roots <span class="math">\(K\)</span><code class="docutils literal"><span class="pre">.roots</span></code>: if the Archimedean
place <span class="math">\(v\)</span> is associated with the <span class="math">\(j\)</span>-th root, the value of
<span class="math">\(h_v\)</span> is given by <span class="math">\(h_i[j]\)</span>, must be <span class="math">\(0\)</span> or <span class="math">\(1/2\)</span> (or&nbsp;<span class="math">\(d/2\)</span> modulo&nbsp;<span class="math">\(d\)</span>), and
can be nonzero only if&nbsp;<span class="math">\(d\)</span> is even.</li>
</ul>
<p>By class field theory, provided the local invariants <span class="math">\(h_v\)</span> sum to <span class="math">\(0\)</span>, up
to Brauer equivalence, there is a unique central simple algebra over <span class="math">\(K\)</span>
with given local invariants and trivial invariant elsewhere. In particular,
up to isomorphism, there is a unique such algebra <span class="math">\(A\)</span> of degree <span class="math">\(d\)</span>.</p>
<p>We realize <span class="math">\(A\)</span> as a cyclic algebra through class field theory. The variable <span class="math">\(v\)</span>
(<code class="docutils literal"><span class="pre">'x</span></code> by default) must have higher priority than the variable of
<span class="math">\(K\)</span><code class="docutils literal"><span class="pre">.pol</span></code> and is used to represent elements in the (cyclic) splitting
field extension <span class="math">\(L/K\)</span> for <span class="math">\(A\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2+1);
? PR = idealprimedec(nf,5); #PR
%2 = 2
? hi = [];
? hf = [PR, [1/3,-1/3]];
? A = alginit(nf, [3,hf,hi]);
? algsplittingfield(A).pol
%6 = x^3 - 21*x + 7
</pre></div>
</div>
<ul class="simple">
<li>(matrix algebra, toy example) <span class="math">\(B\)</span> is an <code class="docutils literal"><span class="pre">nf</span></code> structure associated
to a number field <span class="math">\(K\)</span>, <span class="math">\(C = d\)</span> is a positive integer. Returns a cyclic
algebra isomorphic to the matrix algebra <span class="math">\(M_d(K)\)</span>.</li>
</ul>
<p>In all cases, this function computes a maximal order for the algebra by default,
which may require a lot of time. Setting <span class="math">\(flag = 0\)</span> prevents this computation.</p>
<p>The pari object representing such an algebra <span class="math">\(A\)</span> is a <code class="docutils literal"><span class="pre">t_VEC</span></code> with the
following data:</p>
<ul class="simple">
<li>A splitting field <span class="math">\(L\)</span> of <span class="math">\(A\)</span> of the same degree over <span class="math">\(K\)</span> as <span class="math">\(A\)</span>, in
<code class="docutils literal"><span class="pre">rnfinit</span></code> format, accessed with <code class="docutils literal"><span class="pre">algsplittingfield</span></code>.</li>
<li>The same splitting field <span class="math">\(L\)</span> in <code class="docutils literal"><span class="pre">nfinit</span></code> format.</li>
<li>The Hasse invariants at the real places of <span class="math">\(K\)</span>, accessed with
<code class="docutils literal"><span class="pre">alghassei</span></code>.</li>
<li>The Hasse invariants of <span class="math">\(A\)</span> at the finite primes of <span class="math">\(K\)</span> that ramify in
the natural order of <span class="math">\(A\)</span>, accessed with <code class="docutils literal"><span class="pre">alghassef</span></code>.</li>
<li>A basis of an order <span class="math">\({\cal O}_0\)</span> expressed on the basis of the natural
order, accessed with <code class="docutils literal"><span class="pre">algord</span></code>.</li>
<li>A basis of the natural order expressed on the basis of <span class="math">\({\cal O}_0\)</span>,
accessed with <code class="docutils literal"><span class="pre">alginvord</span></code>.</li>
<li>The left multiplication table of <span class="math">\({\cal O}_0\)</span> on the previous basis,
accessed with <code class="docutils literal"><span class="pre">algmultable</span></code>.</li>
<li>The characteristic of <span class="math">\(A\)</span> (always <span class="math">\(0\)</span>), accessed with <code class="docutils literal"><span class="pre">algchar</span></code>.</li>
<li>The absolute traces of the elements of the basis of <span class="math">\({\cal O}_0\)</span>.</li>
<li>If <span class="math">\(A\)</span> was constructed as a cyclic algebra&nbsp;<span class="math">\((L/K,\sigma,b)\)</span> of degree
<span class="math">\(d\)</span>, a <code class="docutils literal"><span class="pre">t_VEC</span></code> <span class="math">\([\sigma,\sigma^2,...,\sigma^{d-1}]\)</span>. The function
<code class="docutils literal"><span class="pre">algaut</span></code> returns <span class="math">\(\sigma\)</span>.</li>
<li>If <span class="math">\(A\)</span> was constructed as a cyclic algebra&nbsp;<span class="math">\((L/K,\sigma,b)\)</span>, the
element <span class="math">\(b\)</span>, accessed with <code class="docutils literal"><span class="pre">algb</span></code>.</li>
<li>If <span class="math">\(A\)</span> was constructed with its multiplication table <span class="math">\(mt\)</span> over <span class="math">\(K\)</span>,
the <code class="docutils literal"><span class="pre">t_VEC</span></code> of <code class="docutils literal"><span class="pre">t_MAT</span></code> <span class="math">\(mt\)</span>, accessed with <code class="docutils literal"><span class="pre">algrelmultable</span></code>.</li>
<li>If <span class="math">\(A\)</span> was constructed with its multiplication table <span class="math">\(mt\)</span> over <span class="math">\(K\)</span>,
a <code class="docutils literal"><span class="pre">t_VEC</span></code> with three components: a <code class="docutils literal"><span class="pre">t_COL</span></code> representing an element of <span class="math">\(A\)</span>
generating the splitting field <span class="math">\(L\)</span> as a maximal subfield of <span class="math">\(A\)</span>, a <code class="docutils literal"><span class="pre">t_MAT</span></code>
representing an <span class="math">\(L\)</span>-basis <span class="math">\({\cal B}\)</span> of <span class="math">\(A\)</span> expressed on the <span class="math">\(\mathbb{Z}\)</span>-basis of
<span class="math">\({\cal O}_0\)</span>, and a <code class="docutils literal"><span class="pre">t_MAT</span></code> representing the <span class="math">\(\mathbb{Z}\)</span>-basis of <span class="math">\({\cal O}_0\)</span>
expressed on <span class="math">\({\cal B}\)</span>. This data is accessed with <code class="docutils literal"><span class="pre">algsplittingdata</span></code>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.alginv">
<code class="descname">alginv</code><span class="sig-paren">(</span><em>al</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.alginv" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(x\)</span> in <em>al</em>, computes its inverse <span class="math">\(x^{-1}\)</span> in the
algebra <em>al</em>. Assumes that <span class="math">\(x\)</span> is invertible.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A = alginit(nfinit(y), [-1,-1]);
? alginv(A,[1,1,0,0]~)
%2 = [1/2, 1/2, 0, 0]~
</pre></div>
</div>
<p>Also accepts matrices with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.alginvbasis">
<code class="descname">alginvbasis</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.alginvbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an central simple algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code>, returns
a <span class="math">\(\mathbb{Z}\)</span>-basis of the natural order in <em>al</em> with respect to the order&nbsp;<span class="math">\({\cal
O}_0\)</span> stored in <em>al</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>A = alginit(nfinit(y), [-1,-1]);
? alginvbasis(A)
%2 =
[1 0 0 -1]

[0 1 0 -1]

[0 0 1 -1]

[0 0 0 2]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algisassociative">
<code class="descname">algisassociative</code><span class="sig-paren">(</span><em>mt</em>, <em>p=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algisassociative" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if the multiplication table <code class="docutils literal"><span class="pre">mt</span></code> is suitable for
<code class="docutils literal"><span class="pre">algtableinit(mt,p)</span></code>, 0 otherwise. More precisely, <code class="docutils literal"><span class="pre">mt</span></code> should be
a <code class="docutils literal"><span class="pre">t_VEC</span></code> of <span class="math">\(n\)</span> matrices in <span class="math">\(M_n(K)\)</span>, giving the left multiplications
by the basis elements <span class="math">\(e_1,..., e_n\)</span> (structure constants).
We check whether the first basis element <span class="math">\(e_1\)</span> is <span class="math">\(1\)</span> and <span class="math">\(e_i(e_je_k) = 
(e_ie_j)e_k\)</span> for all <span class="math">\(i,j,k\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
? algisassociative(mt)
%2 = 1
</pre></div>
</div>
<p>May be used to check a posteriori an algebra: we also allow <code class="docutils literal"><span class="pre">mt</span></code> as
output by <code class="docutils literal"><span class="pre">algtableinit</span></code> (<span class="math">\(p\)</span> is ignored in this case).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algiscommutative">
<code class="descname">algiscommutative</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algiscommutative" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being a table algebra output by <code class="docutils literal"><span class="pre">algtableinit</span></code> or a central
simple algebra output by <code class="docutils literal"><span class="pre">alginit</span></code>, tests whether the algebra <em>al</em> is
commutative.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
? A = algtableinit(mt);
? algiscommutative(A)
%3 = 0
? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,2);
? algiscommutative(A)
%6 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algisdivision">
<code class="descname">algisdivision</code><span class="sig-paren">(</span><em>al</em>, <em>pl=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algisdivision" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code>, test
whether <em>al</em> is a division algebra. If <em>pl</em> is set, it should be a
prime ideal of&nbsp;<span class="math">\(K\)</span> or an integer between&nbsp;<span class="math">\(1\)</span> and&nbsp;<span class="math">\(r_1+r_2\)</span>, and in that case
test whether <em>al</em> is locally a division algebra at the place <em>pl</em>
instead.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? algisdivision(A, 1)
%3 = 1
? algisdivision(A, 2)
%4 = 0
? algisdivision(A, idealprimedec(nf,2)[1])
%5 = 1
? algisdivision(A, idealprimedec(nf,5)[1])
%6 = 0
? algisdivision(A)
%7 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algisramified">
<code class="descname">algisramified</code><span class="sig-paren">(</span><em>al</em>, <em>pl=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algisramified" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code>, test
whether <em>al</em> is ramified, i.e. not isomorphic to a matrix algebra over its
center. If <em>pl</em> is set, it should be a prime ideal of&nbsp;<span class="math">\(K\)</span> or an integer
between&nbsp;<span class="math">\(1\)</span> and&nbsp;<span class="math">\(r_1+r_2\)</span>, and in that case test whether <em>al</em> is locally
ramified at the place <em>pl</em> instead.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? algisramified(A, 1)
%3 = 1
? algisramified(A, 2)
%4 = 0
? algisramified(A, idealprimedec(nf,2)[1])
%5 = 1
? algisramified(A, idealprimedec(nf,5)[1])
%6 = 0
? algisramified(A)
%7 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algissemisimple">
<code class="descname">algissemisimple</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algissemisimple" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being a table algebra output by <code class="docutils literal"><span class="pre">algtableinit</span></code> or a central
simple algebra output by <code class="docutils literal"><span class="pre">alginit</span></code>, tests whether the algebra <em>al</em> is
semisimple.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
? A = algtableinit(mt);
? algissemisimple(A)
%3 = 0
? m_i=[0,-1,0,0;1,0,0,0;0,0,0,-1;0,0,1,0]; \\quaternion algebra (-1,-1)
? m_j=[0,0,-1,0;0,0,0,1;1,0,0,0;0,-1,0,0];
? m_k=[0,0,0,-1;0,0,-1,0;0,1,0,0;1,0,0,0];
? mt = [matid(4), m_i, m_j, m_k];
? A = algtableinit(mt);
? algissemisimple(A)
%9 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algissimple">
<code class="descname">algissimple</code><span class="sig-paren">(</span><em>al</em>, <em>ss=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algissimple" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being a table algebra output by <code class="docutils literal"><span class="pre">algtableinit</span></code> or a central
simple algebra output by <code class="docutils literal"><span class="pre">alginit</span></code>, tests whether the algebra <em>al</em> is
simple. If <span class="math">\(ss = 1\)</span>, assumes that the algebra&nbsp;<em>al</em> is semisimple
without testing it.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
? A = algtableinit(mt); \\ matrices [*,*; 0,*]
? algissimple(A)
%3 = 0
? algissimple(A,1) \\ incorrectly assume that A is semisimple
%4 = 1
? m_i=[0,-1,0,0;1,0,0,0;0,0,0,-1;0,0,1,0];
? m_j=[0,0,-1,0;0,0,0,1;1,0,0,0;0,-1,0,0];
? m_k=[0,0,0,-1;0,0,b,0;0,1,0,0;1,0,0,0];
? mt = [matid(4), m_i, m_j, m_k];
? A = algtableinit(mt); \\ quaternion algebra (-1,-1)
? algissimple(A)
%10 = 1
? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,2); \\ direct sum F_4+F_2
? algissimple(A)
%13 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algissplit">
<code class="descname">algissplit</code><span class="sig-paren">(</span><em>al</em>, <em>pl=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algissplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code>, test
whether <em>al</em> is split, i.e. isomorphic to a matrix algebra over its center.
If <em>pl</em> is set, it should be a prime ideal of&nbsp;<span class="math">\(K\)</span> or an integer between&nbsp;<span class="math">\(1\)</span>
and&nbsp;<span class="math">\(r_1+r_2\)</span>, and in that case test whether <em>al</em> is locally split at the
place <em>pl</em> instead.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? algissplit(A, 1)
%3 = 0
? algissplit(A, 2)
%4 = 1
? algissplit(A, idealprimedec(nf,2)[1])
%5 = 0
? algissplit(A, idealprimedec(nf,5)[1])
%6 = 1
? algissplit(A)
%7 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.alglathnf">
<code class="descname">alglathnf</code><span class="sig-paren">(</span><em>al</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.alglathnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an algebra <em>al</em> and a square invertible matrix <em>m</em> with size
the dimension of <em>al</em>, returns the lattice generated by the columns of
<em>m</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? al = alginit(nfinit(y^2+7), [-1,-1]);
? a = [1,1,-1/2,1,1/3,-1,1,1]~;
? mt = algleftmultable(al,a);
? lat = alglathnf(al,mt);
? lat[2]
%5 = 1/6
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algleftmultable">
<code class="descname">algleftmultable</code><span class="sig-paren">(</span><em>al</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algleftmultable" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <em>x</em> in <em>al</em>, computes its left multiplication
table. If <em>x</em> is given in basis form, returns its multiplication table on
the integral basis; if <em>x</em> is given in algebraic form, returns its
multiplication table on the basis corresponding to the algebraic form of
elements of <em>al</em>. In every case, if <em>x</em> is a <code class="docutils literal"><span class="pre">t_COL</span></code> of length <span class="math">\(n\)</span>,
then the output is a <span class="math">\(n x n\)</span> <code class="docutils literal"><span class="pre">t_MAT</span></code>.
Also accepts a square matrix with coefficients in <em>al</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A = alginit(nfinit(y), [-1,-1]);
? algleftmultable(A,[0,1,0,0]~)
%2 =
[0 -1 1 0]

[1 0 1 1]

[0 0 1 1]

[0 0 -2 -1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algmul">
<code class="descname">algmul</code><span class="sig-paren">(</span><em>al</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in <em>al</em>, computes their product <span class="math">\(x*y\)</span>
in the algebra&nbsp;<em>al</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A = alginit(nfinit(y), [-1,-1]);
? algmul(A,[1,1,0,0]~,[0,0,2,1]~)
%2 = [2, 3, 5, -4]~
</pre></div>
</div>
<p>Also accepts matrices with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algmultable">
<code class="descname">algmultable</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algmultable" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a multiplication table of <em>al</em> over its
prime subfield (<span class="math">\(\mathbb{Q}\)</span> or <span class="math">\(\mathbb{F}_p\)</span>), as a <code class="docutils literal"><span class="pre">t_VEC</span></code> of <code class="docutils literal"><span class="pre">t_MAT</span></code>: the left
multiplication tables of basis elements. If <em>al</em> was output by
<code class="docutils literal"><span class="pre">algtableinit</span></code>, returns the multiplication table used to define <em>al</em>.
If <em>al</em> was output by <code class="docutils literal"><span class="pre">alginit</span></code>, returns the multiplication table of
the order&nbsp;<span class="math">\({\cal O}_0\)</span> stored in <em>al</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A = alginit(nfinit(y), [-1,-1]);
? M = algmultable(A);
? #M
%3 = 4
? M[1] \\ multiplication by e_1 = 1
%4 =
[1 0 0 0]

[0 1 0 0]

[0 0 1 0]

[0 0 0 1]

? M[2]
%5 =
[0 -1 1 0]

[1 0 1 1]

[0 0 1 1]

[0 0 -2 -1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algneg">
<code class="descname">algneg</code><span class="sig-paren">(</span><em>al</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algneg" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(x\)</span> in <em>al</em>, computes its opposite <span class="math">\(-x\)</span> in the
algebra <em>al</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A = alginit(nfinit(y), [-1,-1]);
? algneg(A,[1,1,0,0]~)
%2 = [-1, -1, 0, 0]~
</pre></div>
</div>
<p>Also accepts matrices with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algnorm">
<code class="descname">algnorm</code><span class="sig-paren">(</span><em>al</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <em>x</em> in <em>al</em>, computes its norm. If <em>al</em> is
a table algebra output by <code class="docutils literal"><span class="pre">algtableinit</span></code>, returns the absolute norm of
<em>x</em>, which is an element of <span class="math">\(\mathbb{F}_p\)</span> of&nbsp;<span class="math">\(\mathbb{Q}\)</span>; if <em>al</em> is a central
simple algebra output by <code class="docutils literal"><span class="pre">alginit</span></code>, returns the reduced norm of <em>x</em>,
which is an element of the center of <em>al</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,19);
? algnorm(A,[0,-2,3]~)
%3 = 18
</pre></div>
</div>
<p>Also accepts a square matrix with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algpoleval">
<code class="descname">algpoleval</code><span class="sig-paren">(</span><em>al</em>, <em>T</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algpoleval" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(b\)</span> in <em>al</em> and a polynomial <span class="math">\(T\)</span> in <span class="math">\(K[X]\)</span>,
computes <span class="math">\(T(b)\)</span> in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algpow">
<code class="descname">algpow</code><span class="sig-paren">(</span><em>al</em>, <em>x</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(x\)</span> in <em>al</em> and an integer <span class="math">\(n\)</span>, computes the
power <span class="math">\(x^n\)</span> in the algebra <em>al</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A = alginit(nfinit(y), [-1,-1]);
? algpow(A,[1,1,0,0]~,7)
%2 = [8, -8, 0, 0]~
</pre></div>
</div>
<p>Also accepts a square matrix with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algprimesubalg">
<code class="descname">algprimesubalg</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algprimesubalg" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being the output of <code class="docutils literal"><span class="pre">algtableinit</span></code> representing a semisimple
algebra of positive characteristic, returns a basis of the prime subalgebra
of&nbsp;<em>al</em>. The prime subalgebra of&nbsp;<em>al</em> is the subalgebra fixed by the
Frobenius automorphism of the center of <em>al</em>. It is abstractly isomorphic
to a product of copies of <span class="math">\(\mathbb{F}_p\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,2);
? algprimesubalg(A)
%3 =
[1 0]

[0 1]

[0 0]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algquotient">
<code class="descname">algquotient</code><span class="sig-paren">(</span><em>al</em>, <em>I</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algquotient" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being a table algebra output by <code class="docutils literal"><span class="pre">algtableinit</span></code> and <em>I</em>
being a basis of a two-sided ideal of <em>al</em> represented by a matrix,
returns the quotient <span class="math">\(al/I\)</span>. When <span class="math">\(flag = 1\)</span>, returns a
<code class="docutils literal"><span class="pre">t_VEC</span></code> <span class="math">\([al/I,proj,lift]\)</span> where <em>proj</em> and
<em>lift</em> are matrices respectively representing the projection map and a
section of it.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,2);
? AQ = algquotient(A,[0;1;0]);
? algdim(AQ)
%4 = 2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algradical">
<code class="descname">algradical</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algradical" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being a table algebra output by <code class="docutils literal"><span class="pre">algtableinit</span></code>, returns a
basis of the Jacobson radical of the algebra <em>al</em> over its prime field
(<span class="math">\(\mathbb{Q}\)</span> or <span class="math">\(\mathbb{F}_p\)</span>).</p>
<p>Here is an example with <span class="math">\(A = \mathbb{Q}[x]/(x^2)\)</span>, generated by <span class="math">\((1,x)\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? mt = [matid(2),[0,0;1,0]];
? A = algtableinit(mt);
? algradical(A) \\ = (x)
%3 =
[0]

[1]
</pre></div>
</div>
<p>Another one with <span class="math">\(2 x 2\)</span> upper triangular matrices over <span class="math">\(\mathbb{Q}\)</span>, generated
by <span class="math">\(I_2\)</span>, <span class="math">\(a = [0,1;0,0]\)</span> and <span class="math">\(b = [0,0;0,1]\)</span>, such that <span class="math">\(a^2 = 
0\)</span>, <span class="math">\(ab = a\)</span>, <span class="math">\(ba = 0\)</span>, <span class="math">\(b^2 = b\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
? A = algtableinit(mt);
? algradical(A) \\ = (a)
%6 =
[0]

[1]

[0]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algramifiedplaces">
<code class="descname">algramifiedplaces</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algramifiedplaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code>, return a
<code class="docutils literal"><span class="pre">t_VEC</span></code> containing the list of places of the center of <em>al</em> that are
ramified in <em>al</em>. Each place is described as an integer between&nbsp;<span class="math">\(1\)</span>
and&nbsp;<span class="math">\(r_1\)</span> or as a prime ideal.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2-5);
? A = alginit(nf, [-1,y]);
? algramifiedplaces(A)
%3 = [1, [2, [2, 0]~, 1, 2, 1]]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algrandom">
<code class="descname">algrandom</code><span class="sig-paren">(</span><em>al</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algrandom" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an algebra <em>al</em> and an integer <em>b</em>, returns a random
element in <em>al</em> with coefficients in&nbsp;<span class="math">\([-b,b]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algrelmultable">
<code class="descname">algrelmultable</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algrelmultable" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code> defined by a multiplication table over its center (a number field), returns this multiplication table.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^3-5); a = y; b = y^2;
? {m_i = [0,a,0,0;
 1,0,0,0;
 0,0,0,a;
 0,0,1,0];}
? {m_j = [0, 0,b, 0;
 0, 0,0,-b;
 1, 0,0, 0;
 0,-1,0, 0];}
? {m_k = [0, 0,0,-a*b;
 0, 0,b, 0;
 0,-a,0, 0;
 1, 0,0, 0];}
? mt = [matid(4), m_i, m_j, m_k];
? A = alginit(nf,mt,&#39;x);
? M = algrelmultable(A);
? M[2] == m_i
%8 = 1
? M[3] == m_j
%9 = 1
? M[4] == m_k
%10 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algsimpledec">
<code class="descname">algsimpledec</code><span class="sig-paren">(</span><em>al</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algsimpledec" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being the output of <code class="docutils literal"><span class="pre">algtableinit</span></code> representing a semisimple
algebra, returns a <code class="docutils literal"><span class="pre">t_VEC</span></code> <span class="math">\([al_1,al_2,...,al_n]\)</span> such
that&nbsp;<em>al</em> is isomorphic to the direct sum of the simple algebras
<span class="math">\(al_i\)</span>. When <span class="math">\(flag = 1\)</span>, each component is instead a <code class="docutils literal"><span class="pre">t_VEC</span></code>
<span class="math">\([al_i,proj_i,lift_i]\)</span> where <span class="math">\(proj_i\)</span>
and&nbsp;<span class="math">\(lift_i\)</span> are matrices respectively representing the projection map
on the <span class="math">\(i\)</span>-th factor and a section of it. The factors are sorted by
increasing dimension, then increasing dimension of the center. This ensures
that the ordering of the isomorphism classes of the factors is deterministic
over finite fields, but not necessarily over&nbsp;<span class="math">\(\mathbb{Q}\)</span>.</p>
<p><strong>Warning.</strong> The images of the <span class="math">\(lift_i\)</span> are not guaranteed to form a direct sum.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algsplittingdata">
<code class="descname">algsplittingdata</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algsplittingdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code> defined
by a multiplication table over its center&nbsp;<span class="math">\(K\)</span> (a number field), returns data
stored to compute a splitting of <em>al</em> over an extension. This data is a
<code class="docutils literal"><span class="pre">t_VEC</span></code> <code class="docutils literal"><span class="pre">[t,Lbas,Lbasinv]</span></code> with <span class="math">\(3\)</span> components:</p>
<ul class="simple">
<li>an element <span class="math">\(t\)</span> of <em>al</em> such that <span class="math">\(L = K(t)\)</span> is a maximal subfield
of <em>al</em>;</li>
<li>a matrix <code class="docutils literal"><span class="pre">Lbas</span></code> expressing a <span class="math">\(L\)</span>-basis of <em>al</em> (given an
<span class="math">\(L\)</span>-vector space structure by multiplication on the right) on the integral
basis of <em>al</em>;</li>
<li>a matrix <code class="docutils literal"><span class="pre">Lbasinv</span></code> expressing the integral basis of <em>al</em> on
the previous <span class="math">\(L\)</span>-basis.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^3-5); a = y; b = y^2;
? {m_i = [0,a,0,0;
 1,0,0,0;
 0,0,0,a;
 0,0,1,0];}
? {m_j = [0, 0,b, 0;
 0, 0,0,-b;
 1, 0,0, 0;
 0,-1,0, 0];}
? {m_k = [0, 0,0,-a*b;
 0, 0,b, 0;
 0,-a,0, 0;
 1, 0,0, 0];}
? mt = [matid(4), m_i, m_j, m_k];
? A = alginit(nf,mt,&#39;x);
? [t,Lb,Lbi] = algsplittingdata(A);
? t
%8 = [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]~;
? matsize(Lb)
%9 = [12, 2]
? matsize(Lbi)
%10 = [2, 12]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algsplittingfield">
<code class="descname">algsplittingfield</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algsplittingfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a central simple algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code>, returns
an <code class="docutils literal"><span class="pre">rnf</span></code> structure: the splitting field of <em>al</em> that is stored in
<em>al</em>, as a relative extension of the center.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">nf</span> <span class="o">=</span> <span class="n">nfinit</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">5</span><span class="p">);</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span>
<span class="p">{</span><span class="n">m_i</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">;</span>
 <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">;</span>
 <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">;</span>
 <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">];}</span>
<span class="p">{</span><span class="n">m_j</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">b</span><span class="p">;</span>
 <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">];}</span>
<span class="p">{</span><span class="n">m_k</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
 <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">];}</span>
<span class="n">mt</span> <span class="o">=</span> <span class="p">[</span><span class="n">matid</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">m_i</span><span class="p">,</span> <span class="n">m_j</span><span class="p">,</span> <span class="n">m_k</span><span class="p">];</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">alginit</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span><span class="n">mt</span><span class="p">,</span><span class="s1">&#39;x);</span>
<span class="n">algsplittingfield</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">pol</span>
<span class="o">%</span><span class="mi">8</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algsplittingmatrix">
<code class="descname">algsplittingmatrix</code><span class="sig-paren">(</span><em>al</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algsplittingmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>A central simple algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code> contains data
describing an isomorphism&nbsp;<span class="math">\(\phi : A\otimes_K L \to M_d(L)\)</span>, where <span class="math">\(d\)</span> is the
degree of the algebra and <span class="math">\(L\)</span> is an extension of <span class="math">\(L\)</span> with&nbsp;<span class="math">\([L:K] = d\)</span>. Returns
the matrix <span class="math">\(\phi(x)\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A = alginit(nfinit(y), [-1,-1]);
? algsplittingmatrix(A,[0,0,0,2]~)
%2 =
[Mod(x + 1, x^2 + 1) Mod(Mod(1, y)*x + Mod(-1, y), x^2 + 1)]

[Mod(x + 1, x^2 + 1) Mod(-x + 1, x^2 + 1)]
</pre></div>
</div>
<p>Also accepts matrices with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algsqr">
<code class="descname">algsqr</code><span class="sig-paren">(</span><em>al</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algsqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(x\)</span> in <em>al</em>, computes its square <span class="math">\(x^2\)</span> in the
algebra <em>al</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A = alginit(nfinit(y), [-1,-1]);
? algsqr(A,[1,0,2,0]~)
%2 = [-3, 0, 4, 0]~
</pre></div>
</div>
<p>Also accepts a square matrix with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algsub">
<code class="descname">algsub</code><span class="sig-paren">(</span><em>al</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algsub" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in <em>al</em>, computes their difference
<span class="math">\(x-y\)</span> in the algebra <em>al</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A = alginit(nfinit(y), [-1,-1]);
? algsub(A,[1,1,0,0]~,[1,0,1,0]~)
%2 = [0, 1, -1, 0]~
</pre></div>
</div>
<p>Also accepts matrices with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algsubalg">
<code class="descname">algsubalg</code><span class="sig-paren">(</span><em>al</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algsubalg" title="Permalink to this definition">¶</a></dt>
<dd><p><em>al</em> being a table algebra output by <code class="docutils literal"><span class="pre">algtableinit</span></code> and <em>B</em>
being a basis of a subalgebra of <em>al</em> represented by a matrix, returns an
algebra isomorphic to <em>B</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,2);
? B = algsubalg(A,[1,0; 0,0; 0,1]);
? algdim(A)
%4 = 3
? algdim(B)
%5 = 2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algtableinit">
<code class="descname">algtableinit</code><span class="sig-paren">(</span><em>mt</em>, <em>p=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algtableinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the associative algebra over <span class="math">\(K = \mathbb{Q}\)</span> (p omitted) or <span class="math">\(\mathbb{F}_p\)</span>
defined by the multiplication table <em>mt</em>.
As a <span class="math">\(K\)</span>-vector space, the algebra is generated by a basis
<span class="math">\((e_1 = 1, e_2,..., e_n)\)</span>; the table is given as a <code class="docutils literal"><span class="pre">t_VEC</span></code> of <span class="math">\(n\)</span> matrices in
<span class="math">\(M_n(K)\)</span>, giving the left multiplication by the basis elements <span class="math">\(e_i\)</span>, in the
given basis.
Assumes that <span class="math">\(e_1 = 1\)</span>, that <span class="math">\(K e_1\oplus...\oplus K e_n]\)</span> describes an
associative algebra over <span class="math">\(K\)</span>, and in the case <span class="math">\(K = \mathbb{Q}\)</span> that the multiplication
table is integral. If the algebra is already known to be central
and simple, then the case <span class="math">\(K = \mathbb{F}_p\)</span> is useless, and one should use
<code class="docutils literal"><span class="pre">alginit</span></code> directly.</p>
<p>The point of this function is to input a finite dimensional <span class="math">\(K\)</span>-algebra, so
as to later compute its radical, then to split the quotient algebra as a
product of simple algebras over <span class="math">\(K\)</span>.</p>
<p>The pari object representing such an algebra <span class="math">\(A\)</span> is a <code class="docutils literal"><span class="pre">t_VEC</span></code> with the
following data:</p>
<ul class="simple">
<li>The characteristic of <span class="math">\(A\)</span>, accessed with <code class="docutils literal"><span class="pre">algchar</span></code>.</li>
<li>The multiplication table of <span class="math">\(A\)</span>, accessed with <code class="docutils literal"><span class="pre">algmultable</span></code>.</li>
<li>The traces of the elements of the basis.</li>
</ul>
<p>A simple example: the <span class="math">\(2 x 2\)</span> upper triangular matrices over <span class="math">\(\mathbb{Q}\)</span>,
generated by <span class="math">\(I_2\)</span>, <span class="math">\(a = [0,1;0,0]\)</span> and <span class="math">\(b = [0,0;0,1]\)</span>,
such that <span class="math">\(a^2 = 0\)</span>, <span class="math">\(ab = a\)</span>, <span class="math">\(ba = 0\)</span>, <span class="math">\(b^2 = b\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? mt = [matid(3),[0,0,0;1,0,1;0,0,0],[0,0,0;0,0,0;1,0,1]];
? A = algtableinit(mt);
? algradical(A) \\ = (a)
%6 =
[0]

[1]

[0]
? algcenter(A) \\ = (I_2)
%7 =
[1]

[0]

[0]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algtensor">
<code class="descname">algtensor</code><span class="sig-paren">(</span><em>al1</em>, <em>al2</em>, <em>maxord=1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algtensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two algebras <em>al1</em> and <em>al2</em>, computes their tensor
product. For table algebras output by <code class="docutils literal"><span class="pre">algtableinit</span></code>, the flag
<em>maxord</em> is ignored. For central simple algebras output by <code class="docutils literal"><span class="pre">alginit</span></code>,
computes a maximal order by default. Prevent this computation by setting
<span class="math">\(maxord = 0\)</span>.</p>
<p>Currently only implemented for cyclic algebras of coprime degree over the same
center&nbsp;<span class="math">\(K\)</span>, and the tensor product is over&nbsp;<span class="math">\(K\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algtrace">
<code class="descname">algtrace</code><span class="sig-paren">(</span><em>al</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <em>x</em> in <em>al</em>, computes its trace. If <em>al</em> is
a table algebra output by <code class="docutils literal"><span class="pre">algtableinit</span></code>, returns the absolute trace of
<em>x</em>, which is an element of <span class="math">\(\mathbb{F}_p\)</span> or&nbsp;<span class="math">\(\mathbb{Q}\)</span>; if <em>al</em> is the output of
<code class="docutils literal"><span class="pre">alginit</span></code>, returns the reduced trace of <em>x</em>, which is an element of
the center of <em>al</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A = alginit(nfinit(y), [-1,-1]);
? algtrace(A,[5,0,0,1]~)
%2 = 11
</pre></div>
</div>
<p>Also accepts a square matrix with coefficients in <em>al</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.algtype">
<code class="descname">algtype</code><span class="sig-paren">(</span><em>al</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.algtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an algebra <em>al</em> output by <code class="docutils literal"><span class="pre">alginit</span></code> or by <code class="docutils literal"><span class="pre">algtableinit</span></code>, returns an integer indicating the type of algebra:</p>
<ul class="simple">
<li><span class="math">\(0\)</span>: not a valid algebra.</li>
<li><span class="math">\(1\)</span>: table algebra output by <code class="docutils literal"><span class="pre">algtableinit</span></code>.</li>
<li><span class="math">\(2\)</span>: central simple algebra output by <code class="docutils literal"><span class="pre">alginit</span></code> and represented by
a multiplication table over its center.</li>
<li><span class="math">\(3\)</span>: central simple algebra output by <code class="docutils literal"><span class="pre">alginit</span></code> and represented by
a cyclic algebra.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? algtype([])
%1 = 0
? mt = [matid(3), [0,0,0; 1,1,0; 0,0,0], [0,0,1; 0,0,0; 1,0,1]];
? A = algtableinit(mt,2);
? algtype(A)
%4 = 1
? nf = nfinit(y^3-5);
? a = y; b = y^2;
? {m_i = [0,a,0,0;
 1,0,0,0;
 0,0,0,a;
 0,0,1,0];}
? {m_j = [0, 0,b, 0;
 0, 0,0,-b;
 1, 0,0, 0;
 0,-1,0, 0];}
? {m_k = [0, 0,0,-a*b;
 0, 0,b, 0;
 0,-a,0, 0;
 1, 0,0, 0];}
? mt = [matid(4), m_i, m_j, m_k];
? A = alginit(nf,mt,&#39;x);
? algtype(A)
%12 = 2
? A = alginit(nfinit(y), [-1,-1]);
? algtype(A)
%14 = 3
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.allocatemem">
<code class="descname">allocatemem</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.allocatemem" title="Permalink to this definition">¶</a></dt>
<dd><p>This special operation changes the stack size <em>after</em>
initialization. <span class="math">\(x\)</span> must be a non-negative integer. If <span class="math">\(x &gt; 0\)</span>, a new stack
of at least <span class="math">\(x\)</span> bytes is allocated. We may allocate more than <span class="math">\(x\)</span> bytes if
<span class="math">\(x\)</span> is way too small, or for alignment reasons: the current formula is
<span class="math">\(\max(16*ceil{x/16}, 500032)\)</span> bytes.</p>
<p>If <span class="math">\(x = 0\)</span>, the size of the new stack is twice the size of the old one.</p>
<p>This command is much more useful if <code class="docutils literal"><span class="pre">parisizemax</span></code> is non-zero, and we
describe this case first. With <code class="docutils literal"><span class="pre">parisizemax</span></code> enabled, there are three
sizes of interest:</p>
<ul class="simple">
<li>a virtual stack size, <code class="docutils literal"><span class="pre">parisizemax</span></code>, which is an absolute upper
limit for the stack size; this is set by <code class="docutils literal"><span class="pre">default(parisizemax,</span> <span class="pre">...)</span></code>.</li>
<li>the desired typical stack size, <code class="docutils literal"><span class="pre">parisize</span></code>, that will grow as
needed, up to <code class="docutils literal"><span class="pre">parisizemax</span></code>; this is set by <code class="docutils literal"><span class="pre">default(parisize,</span> <span class="pre">...)</span></code>.</li>
<li>the current stack size, which is less that <code class="docutils literal"><span class="pre">parisizemax</span></code>,
typically equal to <code class="docutils literal"><span class="pre">parisize</span></code> but possibly larger and increasing
dynamically as needed; <code class="docutils literal"><span class="pre">allocatemem</span></code> allows to change that one
explicitly.</li>
</ul>
<p>The <code class="docutils literal"><span class="pre">allocatemem</span></code> command forces stack
usage to increase temporarily (up to <code class="docutils literal"><span class="pre">parisizemax</span></code> of course); for
instance if you notice using <code class="docutils literal"><span class="pre">\gm2</span></code> that we seem to collect garbage a
lot, e.g.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \gm2
 debugmem = 2
? default(parisize,&quot;32M&quot;)
 *** Warning: new stack size = 32000000 (30.518 Mbytes).
? bnfinit(&#39;x^2+10^30-1)
 *** bnfinit: collecting garbage in hnffinal, i = 1.
 *** bnfinit: collecting garbage in hnffinal, i = 2.
 *** bnfinit: collecting garbage in hnffinal, i = 3.
</pre></div>
</div>
<p>and so on for hundred of lines. Then, provided the
<code class="docutils literal"><span class="pre">breakloop</span></code> default is set, you can interrupt the computation, type
<code class="docutils literal"><span class="pre">allocatemem(100*10^6)</span></code> at the break loop prompt, then let the
computation go on by typing :literal:` &lt; Enter &gt; <span class="math">\(. Back at the :literal:`gp\)</span> prompt,
the desired stack size of <code class="docutils literal"><span class="pre">parisize</span></code> is restored. Note that changing either
<code class="docutils literal"><span class="pre">parisize</span></code> or <code class="docutils literal"><span class="pre">parisizemax</span></code> at the break loop prompt would interrupt
the computation, contrary to the above.</p>
<p>In most cases, <code class="docutils literal"><span class="pre">parisize</span></code> will increase automatically (up to
<code class="docutils literal"><span class="pre">parisizemax</span></code>) and there is no need to perform the above maneuvers.
But that the garbage collector is sufficiently efficient that
a given computation can still run without increasing the stack size,
albeit very slowly due to the frequent garbage collections.</p>
<p><strong>Deprecated: when :literal:`parisizemax.</strong> is unset`
This is currently still the default behavior in order not to break backward
compatibility. The rest of this section documents the
behavior of <code class="docutils literal"><span class="pre">allocatemem</span></code> in that (deprecated) situation: it becomes a
synonym for <code class="docutils literal"><span class="pre">default(parisize,...)</span></code>. In that case, there is no
notion of a virtual stack, and the stack size is always equal to
<code class="docutils literal"><span class="pre">parisize</span></code>. If more memory is needed, the PARI stack overflows, aborting
the computation.</p>
<p>Thus, increasing <code class="docutils literal"><span class="pre">parisize</span></code> via <code class="docutils literal"><span class="pre">allocatemem</span></code> or
<code class="docutils literal"><span class="pre">default(parisize,...)</span></code> before a big computation is important.
Unfortunately, either must be typed at the <code class="docutils literal"><span class="pre">gp</span></code> prompt in
interactive usage, or left by itself at the start of batch files.
They cannot be used meaningfully in loop-like constructs, or as part of a
larger expression sequence, e.g</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>allocatemem(); x = 1; \\ This will not set x!
</pre></div>
</div>
<p>In fact, all loops are immediately exited, user functions terminated, and
the rest of the sequence following <code class="docutils literal"><span class="pre">allocatemem()</span></code> is silently
discarded, as well as all pending sequences of instructions. We just go on
reading the next instruction sequence from the file we are in (or from the
user). In particular, we have the following possibly unexpected behavior: in</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;file.gp&quot;</span><span class="p">);</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>were <code class="docutils literal"><span class="pre">file.gp</span></code> contains an <code class="docutils literal"><span class="pre">allocatemem</span></code> statement,
the <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span></code> is never executed, since all pending instructions in the
current sequence are discarded.</p>
<p>The reason for these unfortunate side-effects is that, with
<code class="docutils literal"><span class="pre">parisizemax</span></code> disabled, increasing the stack size physically
moves the stack, so temporary objects created during the current expression
evaluation are not correct anymore. (In particular byte-compiled expressions,
which are allocated on the stack.) To avoid accessing obsolete pointers to
the old stack, this routine ends by a <code class="docutils literal"><span class="pre">longjmp</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>f</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the <code class="docutils literal"><span class="pre">t_CLOSURE</span></code> <code class="docutils literal"><span class="pre">f</span></code> to the entries of <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">A</span></code>
is a scalar, return <code class="docutils literal"><span class="pre">f(A)</span></code>. If <code class="docutils literal"><span class="pre">A</span></code> is a polynomial or power series,
apply <code class="docutils literal"><span class="pre">f</span></code> on all coefficients. If <code class="docutils literal"><span class="pre">A</span></code> is a vector or list, return
the elements <span class="math">\(f(x)\)</span> where <span class="math">\(x\)</span> runs through <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">A</span></code> is a matrix,
return the matrix whose entries are the <span class="math">\(f(A[i,j])\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? apply(x-&gt;x^2, [1,2,3,4])
%1 = [1, 4, 9, 16]
? apply(x-&gt;x^2, [1,2;3,4])
%2 =
[1 4]

[9 16]
? apply(x-&gt;x^2, 4*x^2 + 3*x+ 2)
%3 = 16*x^2 + 9*x + 4
</pre></div>
</div>
<p>Note that many functions already act componentwise on
vectors or matrices, but they almost never act on lists; in this
case, <code class="docutils literal"><span class="pre">apply</span></code> is a good solution:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? L = List([Mod(1,3), Mod(2,4)]);
? lift(L)
 *** at top-level: lift(L)
 *** ^-------
 *** lift: incorrect type in lift.
? apply(lift, L);
%2 = List([1, 2])
</pre></div>
</div>
<p><strong>Remark.</strong> For <span class="math">\(v\)</span> a <code class="docutils literal"><span class="pre">t_VEC</span></code>, <code class="docutils literal"><span class="pre">t_COL</span></code>, <code class="docutils literal"><span class="pre">t_LIST</span></code> or <code class="docutils literal"><span class="pre">t_MAT</span></code>,
the alternative set-notations</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="p">[</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">]</span>
</pre></div>
</div>
<p>are available as shortcuts for</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">apply</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">select</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Vec</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
<span class="n">select</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Vec</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="n">apply</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">Vec</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
</pre></div>
</div>
<p>respectively:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? L = List([Mod(1,3), Mod(2,4)]);
? [ lift(x) | x&lt;-L ]
%2 = [1, 2]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.arg">
<code class="descname">arg</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.arg" title="Permalink to this definition">¶</a></dt>
<dd><p>Argument of the complex number <span class="math">\(x\)</span>, such that <span class="math">\(-\Pi &lt; {arg}(x) &lt;= \Pi\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.asin">
<code class="descname">asin</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.asin" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of <span class="math">\({sin}^{-1}(x) = -i \log(ix + \sqrt{1 - x^2})\)</span>.
In particular, <span class="math">\({Re(asin}(x)) belongs to [-\Pi/2,\Pi/2]\)</span> and if <span class="math">\(x belongs to \mathbb{R}\)</span> and
<span class="math">\(\|x\| &gt; 1\)</span> then <span class="math">\({asin}(x)\)</span> is complex. The branch cut is in two pieces:
<span class="math">\(]- oo ,-1]\)</span>, continuous with quadrant II, and <span class="math">\([1,+ oo [\)</span> continuous
with quadrant IV. The function satisfies <span class="math">\(i {asin}(x) = 
{asinh}(ix)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.asinh">
<code class="descname">asinh</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.asinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of <span class="math">\({sinh}^{-1}(x) = \log(x + \sqrt{1+x^2})\)</span>. In
particular <span class="math">\({Im(asinh}(x)) belongs to [-\Pi/2,\Pi/2]\)</span>.
The branch cut is in two pieces: <span class="math">\(]-i oo ,-i]\)</span>, continuous with quadrant III
and <span class="math">\([+i,+i oo [\)</span>, continuous with quadrant I.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.atan">
<code class="descname">atan</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.atan" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of <span class="math">\({tan}^{-1}(x) = \log ((1+ix)/(1-ix)) /
2i\)</span>. In particular the real part of <span class="math">\({atan}(x)\)</span> belongs to
<span class="math">\(]-\Pi/2,\Pi/2[\)</span>.
The branch cut is in two pieces:
<span class="math">\(]-i oo ,-i[\)</span>, continuous with quadrant IV, and <span class="math">\(]i,+i oo [\)</span> continuous
with quadrant II. The function satisfies <span class="math">\({atan}(x) = 
-i{atanh}(ix)\)</span> for all <span class="math">\(x != ± i\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.atanh">
<code class="descname">atanh</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.atanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of <span class="math">\({tanh}^{-1}(x) = \log ((1+x)/(1-x)) / 2\)</span>. In
particular the imaginary part of <span class="math">\({atanh}(x)\)</span> belongs to
<span class="math">\([-\Pi/2,\Pi/2]\)</span>; if <span class="math">\(x belongs to \mathbb{R}\)</span> and <span class="math">\(\|x\| &gt; 1\)</span> then <span class="math">\({atanh}(x)\)</span> is complex.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.besselh1">
<code class="descname">besselh1</code><span class="sig-paren">(</span><em>nu</em>, <em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.besselh1" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(H^1\)</span>-Bessel function of index <em>nu</em> and argument <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.besselh2">
<code class="descname">besselh2</code><span class="sig-paren">(</span><em>nu</em>, <em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.besselh2" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(H^2\)</span>-Bessel function of index <em>nu</em> and argument <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.besseli">
<code class="descname">besseli</code><span class="sig-paren">(</span><em>nu</em>, <em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.besseli" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(I\)</span>-Bessel function of index <em>nu</em> and
argument <span class="math">\(x\)</span>. If <span class="math">\(x\)</span> converts to a power series, the initial factor
<span class="math">\((x/2)^\nu/\Gamma(\nu+1)\)</span> is omitted (since it cannot be represented in PARI
when <span class="math">\(\nu\)</span> is not integral).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.besselj">
<code class="descname">besselj</code><span class="sig-paren">(</span><em>nu</em>, <em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.besselj" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(J\)</span>-Bessel function of index <em>nu</em> and
argument <span class="math">\(x\)</span>. If <span class="math">\(x\)</span> converts to a power series, the initial factor
<span class="math">\((x/2)^\nu/\Gamma(\nu+1)\)</span> is omitted (since it cannot be represented in PARI
when <span class="math">\(\nu\)</span> is not integral).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.besseljh">
<code class="descname">besseljh</code><span class="sig-paren">(</span><em>n</em>, <em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.besseljh" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(J\)</span>-Bessel function of half integral index.
More precisely, <span class="math">\(besseljh(n,x)\)</span> computes <span class="math">\(J_{n+1/2}(x)\)</span> where <span class="math">\(n\)</span>
must be of type integer, and <span class="math">\(x\)</span> is any element of <span class="math">\(\mathbb{C}\)</span>. In the
present version <strong>2.8.0</strong>, this function is not very accurate when <span class="math">\(x\)</span> is small.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.besselk">
<code class="descname">besselk</code><span class="sig-paren">(</span><em>nu</em>, <em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.besselk" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(K\)</span>-Bessel function of index <em>nu</em> and argument <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.besseln">
<code class="descname">besseln</code><span class="sig-paren">(</span><em>nu</em>, <em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.besseln" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(N\)</span>-Bessel function of index <em>nu</em> and argument <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bestappr">
<code class="descname">bestappr</code><span class="sig-paren">(</span><em>x</em>, <em>B=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bestappr" title="Permalink to this definition">¶</a></dt>
<dd><p>Using variants of the extended Euclidean algorithm, returns a rational
approximation <span class="math">\(a/b\)</span> to <span class="math">\(x\)</span>, whose denominator is limited
by <span class="math">\(B\)</span>, if present. If <span class="math">\(B\)</span> is omitted, return the best approximation
affordable given the input accuracy; if you are looking for true rational
numbers, presumably approximated to sufficient accuracy, you should first
try that option. Otherwise, <span class="math">\(B\)</span> must be a positive real scalar (impose
<span class="math">\(0 &lt; b &lt;= B\)</span>).</p>
<ul class="simple">
<li>If <span class="math">\(x\)</span> is a <code class="docutils literal"><span class="pre">t_REAL</span></code> or a <code class="docutils literal"><span class="pre">t_FRAC</span></code>, this function uses continued
fractions.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? bestappr(Pi, 100)
%1 = 22/7
? bestappr(0.1428571428571428571428571429)
%2 = 1/7
? bestappr([Pi, sqrt(2) + &#39;x], 10^3)
%3 = [355/113, x + 1393/985]
</pre></div>
</div>
<p>By definition, <span class="math">\(a/b\)</span> is the best rational approximation to <span class="math">\(x\)</span> if
<span class="math">\(\|b x - a\| &lt; \|v x - u\|\)</span> for all integers <span class="math">\((u,v)\)</span> with <span class="math">\(0 &lt; v &lt;= B\)</span>.
(Which implies that <span class="math">\(n/d\)</span> is a convergent of the continued fraction of <span class="math">\(x\)</span>.)</p>
<ul class="simple">
<li>If <span class="math">\(x\)</span> is a <code class="docutils literal"><span class="pre">t_INTMOD</span></code> modulo <span class="math">\(N\)</span> or a <code class="docutils literal"><span class="pre">t_PADIC</span></code> of precision <span class="math">\(N = 
p^k\)</span>, this function performs rational modular reconstruction modulo <span class="math">\(N\)</span>. The
routine then returns the unique rational number <span class="math">\(a/b\)</span> in coprime integers
<span class="math">\(|a| &lt; N/2B\)</span> and <span class="math">\(b &lt;= B\)</span> which is congruent to <span class="math">\(x\)</span> modulo <span class="math">\(N\)</span>. Omitting
<span class="math">\(B\)</span> amounts to choosing it of the order of <span class="math">\(\sqrt{N/2}\)</span>. If rational
reconstruction is not possible (no suitable <span class="math">\(a/b\)</span> exists), returns <span class="math">\([]\)</span>.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? bestappr(Mod(18526731858, 11^10))
%1 = 1/7
? bestappr(Mod(18526731858, 11^20))
%2 = []
? bestappr(3 + 5 + 3*5^2 + 5^3 + 3*5^4 + 5^5 + 3*5^6 + O(5^7))
%2 = -1/3
</pre></div>
</div>
<p>In most concrete uses, <span class="math">\(B\)</span> is a prime power and we performed
Hensel lifting to obtain <span class="math">\(x\)</span>.</p>
<p>The function applies recursively to components of complex objects
(polynomials, vectors,...). If rational reconstruction fails for even a
single entry, return <span class="math">\([]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bestapprPade">
<code class="descname">bestapprPade</code><span class="sig-paren">(</span><em>x</em>, <em>B=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bestapprPade" title="Permalink to this definition">¶</a></dt>
<dd><p>Using variants of the extended Euclidean algorithm, returns a rational
function approximation <span class="math">\(a/b\)</span> to <span class="math">\(x\)</span>, whose denominator is limited
by <span class="math">\(B\)</span>, if present. If <span class="math">\(B\)</span> is omitted, return the best approximation
affordable given the input accuracy; if you are looking for true rational
functions, presumably approximated to sufficient accuracy, you should first
try that option. Otherwise, <span class="math">\(B\)</span> must be a non-negative real (impose
<span class="math">\(0 &lt;= {degree}(b) &lt;= B\)</span>).</p>
<ul class="simple">
<li>If <span class="math">\(x\)</span> is a <code class="docutils literal"><span class="pre">t_RFRAC</span></code> or <code class="docutils literal"><span class="pre">t_SER</span></code>, this function uses continued
fractions.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? bestapprPade((1-x^11)/(1-x)+O(x^11))
%1 = 1/(-x + 1)
? bestapprPade([1/(1+x+O(x^10)), (x^3-2)/(x^3+1)], 1)
%2 = [1/(x + 1), -2]
</pre></div>
</div>
<ul class="simple">
<li>If <span class="math">\(x\)</span> is a <code class="docutils literal"><span class="pre">t_POLMOD</span></code> modulo <span class="math">\(N\)</span> or a <code class="docutils literal"><span class="pre">t_SER</span></code> of precision <span class="math">\(N = 
t^k\)</span>, this function performs rational modular reconstruction modulo <span class="math">\(N\)</span>. The
routine then returns the unique rational function <span class="math">\(a/b\)</span> in coprime
polynomials, with <span class="math">\({degree}(b) &lt;= B\)</span> which is congruent to <span class="math">\(x\)</span> modulo
<span class="math">\(N\)</span>. Omitting <span class="math">\(B\)</span> amounts to choosing it of the order of <span class="math">\(N/2\)</span>. If rational
reconstruction is not possible (no suitable <span class="math">\(a/b\)</span> exists), returns <span class="math">\([]\)</span>.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? bestapprPade(Mod(1+x+x^2+x^3+x^4, x^4-2))
%1 = (2*x - 1)/(x - 1)
? % * Mod(1,x^4-2)
%2 = Mod(x^3 + x^2 + x + 3, x^4 - 2)
? bestapprPade(Mod(1+x+x^2+x^3+x^5, x^9))
%2 = []
? bestapprPade(Mod(1+x+x^2+x^3+x^5, x^10))
%3 = (2*x^4 + x^3 - x - 1)/(-x^5 + x^3 + x^2 - 1)
</pre></div>
</div>
<p>The function applies recursively to components of complex objects
(polynomials, vectors,...). If rational reconstruction fails for even a
single entry, return <span class="math">\([]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bezout">
<code class="descname">bezout</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bezout" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated alias for <code class="docutils literal"><span class="pre">gcdext</span></code></p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bezoutres">
<code class="descname">bezoutres</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bezoutres" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated alias for <code class="docutils literal"><span class="pre">polresultantext</span></code></p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bigomega">
<code class="descname">bigomega</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bigomega" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of prime divisors of the integer <span class="math">\(\|x\|\)</span> counted with
multiplicity:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? factor(392)
%1 =
[2 3]

[7 2]

? bigomega(392)
%2 = 5; \\ = 3+2
? omega(392)
%3 = 2; \\ without multiplicity
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.binary">
<code class="descname">binary</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the vector of the binary digits of <span class="math">\(\|x\|\)</span>. Here <span class="math">\(x\)</span> can be an
integer, a real number (in which case the result has two components, one for
the integer part, one for the fractional part) or a vector/matrix.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? binary(10)
%1 = [1, 0, 1, 0]

? binary(3.14)
%2 = [[1, 1], [0, 0, 1, 0, 0, 0, [...]]

? binary([1,2])
%3 = [[1], [1, 0]]
</pre></div>
</div>
<p>By convention, <span class="math">\(0\)</span> has no digits:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? binary(0)
%4 = []
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.binomial">
<code class="descname">binomial</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.binomial" title="Permalink to this definition">¶</a></dt>
<dd><p>binomial coefficient <span class="math">\(binom{x}{y}\)</span>.
Here <span class="math">\(y\)</span> must be an integer, but <span class="math">\(x\)</span> can be any PARI object.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bitand">
<code class="descname">bitand</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bitand" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise <code class="docutils literal"><span class="pre">and</span></code>
of two integers <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, that is the integer</p>
<div class="math">
\[\sum_i (x_i&nbsp;and&nbsp;y_i) 2^i\]</div>
<p>Negative numbers behave <span class="math">\(2\)</span>-adically, i.e.&nbsp;the result is the <span class="math">\(2\)</span>-adic limit
of <code class="docutils literal"><span class="pre">bitand</span></code><span class="math">\((x_n,y_n)\)</span>, where <span class="math">\(x_n\)</span> and <span class="math">\(y_n\)</span> are non-negative integers
tending to <span class="math">\(x\)</span> and <span class="math">\(y\)</span> respectively. (The result is an ordinary integer,
possibly negative.)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? bitand(5, 3)
%1 = 1
? bitand(-5, 3)
%2 = 3
? bitand(-5, -3)
%3 = -7
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bitneg">
<code class="descname">bitneg</code><span class="sig-paren">(</span><em>x</em>, <em>n=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bitneg" title="Permalink to this definition">¶</a></dt>
<dd><p>bitwise negation of an integer <span class="math">\(x\)</span>,
truncated to <span class="math">\(n\)</span> bits, <span class="math">\(n &gt;= 0\)</span>, that is the integer</p>
<div class="math">
\[\sum_{i = 0}^{n-1} not(x_i) 2^i.\]</div>
<p>The special case <span class="math">\(n = -1\)</span> means no truncation: an infinite sequence of
leading <span class="math">\(1\)</span> is then represented as a negative number.</p>
<p>See <code class="docutils literal"><span class="pre">bitand</span></code> (in the PARI manual) for the behavior for negative arguments.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bitnegimply">
<code class="descname">bitnegimply</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bitnegimply" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise negated imply of two integers <span class="math">\(x\)</span> and
<span class="math">\(y\)</span> (or <code class="docutils literal"><span class="pre">not</span></code> <span class="math">\((x ==&gt; y)\)</span>), that is the integer</p>
<div class="math">
\[\sum
(x_i&nbsp;and not(y_i)) 2^i\]</div>
<p>See <code class="docutils literal"><span class="pre">bitand</span></code> (in the PARI manual) for the behavior for negative arguments.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bitor">
<code class="descname">bitor</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bitor" title="Permalink to this definition">¶</a></dt>
<dd><p>bitwise (inclusive)
<code class="docutils literal"><span class="pre">or</span></code> of two integers <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, that is the integer</p>
<div class="math">
\[\sum
(x_i&nbsp;or&nbsp;y_i) 2^i\]</div>
<p>See <code class="docutils literal"><span class="pre">bitand</span></code> (in the PARI manual) for the behavior for negative arguments.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bitprecision">
<code class="descname">bitprecision</code><span class="sig-paren">(</span><em>x</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bitprecision" title="Permalink to this definition">¶</a></dt>
<dd><p>The function has two different behaviors according to whether <span class="math">\(n\)</span> is
present and positive or not. If <span class="math">\(n\)</span> is missing, the function returns the
(floating point) precision in bits of the PARI object <span class="math">\(x\)</span>. If <span class="math">\(x\)</span> is an
exact object, the largest single precision integer is returned.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? bitprecision(exp(1e-100))
%1 = 512 \\ 512 bits
? bitprecision( [ exp(1e-100), 0.5 ] )
%2 = 128 \\ minimal accuracy among components
? bitprecision(2 + x)
%3 = 9223372036854775807 \\ exact object
</pre></div>
</div>
<p>The return value for exact objects is meaningless since it is not even the
same on 32 and 64-bit machines. The proper way to test whether an object is
exact is</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? isexact(x) = (bitprecision(x) == bitprecision(0));
</pre></div>
</div>
<p>If <span class="math">\(n\)</span> is present and positive, the function creates a new object equal to <span class="math">\(x\)</span>
with the new bit-precision roughly <span class="math">\(n\)</span>. In fact, the smallest multiple of 64
(resp.&nbsp;32 on a 32-bit machine) larger than or equal to <span class="math">\(n\)</span>.</p>
<p>For <span class="math">\(x\)</span> a vector or a matrix, the operation is
done componentwise; for series and polynomials, the operation is done
coefficientwise. For real <span class="math">\(x\)</span>, <span class="math">\(n\)</span> is the number of desired significant
<em>bits</em>. If <span class="math">\(n\)</span> is smaller than the precision of <span class="math">\(x\)</span>, <span class="math">\(x\)</span> is truncated,
otherwise <span class="math">\(x\)</span> is extended with zeros. For exact or non-floating point types,
no change.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? bitprecision(Pi, 10) \\ actually 64 bits ~ 19 decimal digits
%1 = 3.141592653589793239
? bitprecision(1, 10)
%2 = 1
? bitprecision(1 + O(x), 10)
%3 = 1 + O(x)
? bitprecision(2 + O(3^5), 10)
%4 = 2 + O(3^5)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bittest">
<code class="descname">bittest</code><span class="sig-paren">(</span><em>x</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bittest" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the <span class="math">\(n-th\)</span> bit of <span class="math">\(x\)</span> starting
from the right (i.e.&nbsp;the coefficient of <span class="math">\(2^n\)</span> in the binary expansion of <span class="math">\(x\)</span>).
The result is 0 or 1.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? bittest(7, 3)
%1 = 1 \\ the 3rd bit is 1
? bittest(7, 4)
%2 = 0 \\ the 4th bit is 0
</pre></div>
</div>
<p>See <code class="docutils literal"><span class="pre">bitand</span></code> (in the PARI manual) for the behavior at negative arguments.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bitxor">
<code class="descname">bitxor</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bitxor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise (exclusive) <code class="docutils literal"><span class="pre">or</span></code>
of two integers <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, that is the integer</p>
<div class="math">
\[\sum (x_i&nbsp;xor&nbsp;y_i) 2^i\]</div>
<p>See <code class="docutils literal"><span class="pre">bitand</span></code> (in the PARI manual) for the behavior for negative arguments.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfcertify">
<code class="descname">bnfcertify</code><span class="sig-paren">(</span><em>bnf</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfcertify" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(bnf\)</span> being as output by
<code class="docutils literal"><span class="pre">bnfinit</span></code>, checks whether the result is correct, i.e.&nbsp;whether it is
possible to remove the assumption of the Generalized Riemann
Hypothesis. It is correct if and only if the answer is 1. If it is
incorrect, the program may output some error message, or loop indefinitely.
You can check its progress by increasing the debug level. The <em>bnf</em>
structure must contain the fundamental units:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = bnfinit(x^3+2^2^3+1); bnfcertify(K)
 *** at top-level: K=bnfinit(x^3+2^2^3+1);bnfcertify(K)
 *** ^-------------
 *** bnfcertify: missing units in bnf.
? K = bnfinit(x^3+2^2^3+1, 1); \\ include units
? bnfcertify(K)
%3 = 1
</pre></div>
</div>
<p>If flag is present, only certify that the class group is a quotient of the
one computed in bnf (much simpler in general); likewise, the computed units
may form a subgroup of the full unit group. In this variant, the units are
no longer needed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = bnfinit(x^3+2^2^3+1); bnfcertify(K, 1)
%4 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfcompress">
<code class="descname">bnfcompress</code><span class="sig-paren">(</span><em>bnf</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfcompress" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a compressed version of <em>bnf</em> (from <code class="docutils literal"><span class="pre">bnfinit</span></code>), a
&#8220;small Buchmann&#8217;s number field&#8221; (or <em>sbnf</em> for short) which contains
enough information to recover a full <span class="math">\(bnf\)</span> vector very rapidly, but
which is much smaller and hence easy to store and print. Calling
<code class="docutils literal"><span class="pre">bnfinit</span></code> on the result recovers a true <code class="docutils literal"><span class="pre">bnf</span></code>, in general different
from the original. Note that an <em>snbf</em> is useless for almost all
purposes besides storage, and must be converted back to <em>bnf</em> form
before use; for instance, no <code class="docutils literal"><span class="pre">nf*</span></code>, <code class="docutils literal"><span class="pre">bnf*</span></code> or member function
accepts them.</p>
<p>An <em>sbnf</em> is a 12 component vector <span class="math">\(v\)</span>, as follows. Let <code class="docutils literal"><span class="pre">bnf</span></code> be
the result of a full <code class="docutils literal"><span class="pre">bnfinit</span></code>, complete with units. Then <span class="math">\(v[1]\)</span> is
<code class="docutils literal"><span class="pre">bnf.pol</span></code>, <span class="math">\(v[2]\)</span> is the number of real embeddings <code class="docutils literal"><span class="pre">bnf.sign[1]</span></code>,
<span class="math">\(v[3]\)</span> is <code class="docutils literal"><span class="pre">bnf.disc</span></code>, <span class="math">\(v[4]\)</span> is <code class="docutils literal"><span class="pre">bnf.zk</span></code>, <span class="math">\(v[5]\)</span> is the list of roots
<code class="docutils literal"><span class="pre">bnf.roots</span></code>, <span class="math">\(v[7]\)</span> is the matrix <span class="math">\(W = bnf[1]\)</span>,
<span class="math">\(v[8]\)</span> is the matrix <span class="math">\(matalpha = bnf[2]\)</span>,
<span class="math">\(v[9]\)</span> is the prime ideal factor base <code class="docutils literal"><span class="pre">bnf[5]</span></code> coded in a compact way,
and ordered according to the permutation <code class="docutils literal"><span class="pre">bnf[6]</span></code>, <span class="math">\(v[10]\)</span> is the
2-component vector giving the number of roots of unity and a generator,
expressed on the integral basis, <span class="math">\(v[11]\)</span> is the list of fundamental units,
expressed on the integral basis, <span class="math">\(v[12]\)</span> is a vector containing the algebraic
numbers alpha corresponding to the columns of the matrix <code class="docutils literal"><span class="pre">matalpha</span></code>,
expressed on the integral basis.</p>
<p>All the components are exact (integral or rational), except for the roots in
<span class="math">\(v[5]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfdecodemodule">
<code class="descname">bnfdecodemodule</code><span class="sig-paren">(</span><em>nf</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfdecodemodule" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(m\)</span> is a module as output in the
first component of an extension given by <code class="docutils literal"><span class="pre">bnrdisclist</span></code>, outputs the
true module.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = bnfinit(x^2+23); L = bnrdisclist(K, 10); s = L[1][2]
%1 = [[Mat([8, 1]), [[0, 0, 0]]], [Mat([9, 1]), [[0, 0, 0]]]]
? bnfdecodemodule(K, s[1][1])
%2 =
[2 0]

[0 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfinit">
<code class="descname">bnfinit</code><span class="sig-paren">(</span><em>P</em>, <em>flag=0</em>, <em>tech=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a
<code class="docutils literal"><span class="pre">bnf</span></code> structure. Used in programs such as <code class="docutils literal"><span class="pre">bnfisprincipal</span></code>,
<code class="docutils literal"><span class="pre">bnfisunit</span></code> or <code class="docutils literal"><span class="pre">bnfnarrow</span></code>. By default, the results are conditional
on the GRH, see <code class="docutils literal"><span class="pre">GRHbnf</span></code> (in the PARI manual). The result is a
10-component vector <em>bnf</em>.</p>
<p>This implements Buchmann&#8217;s sub-exponential algorithm for computing the
class group, the regulator and a system of fundamental units of the
general algebraic number field <span class="math">\(K\)</span> defined by the irreducible polynomial <span class="math">\(P\)</span>
with integer coefficients.</p>
<p>If the precision becomes insufficient, <code class="docutils literal"><span class="pre">gp</span></code> does not strive to compute
the units by default (<span class="math">\(flag = 0\)</span>).</p>
<p>When <span class="math">\(flag = 1\)</span>, we insist on finding the fundamental units exactly. Be
warned that this can take a very long time when the coefficients of the
fundamental units on the integral basis are very large. If the fundamental
units are simply too large to be represented in this form, an error message
is issued. They could be obtained using the so-called compact representation
of algebraic numbers as a formal product of algebraic integers. The latter is
implemented internally but not publicly accessible yet.</p>
<p><span class="math">\(tech\)</span> is a technical vector (empty by default, see <code class="docutils literal"><span class="pre">GRHbnf</span></code> (in the PARI manual)).
Careful use of this parameter may speed up your computations,
but it is mostly obsolete and you should leave it alone.</p>
<p>The components of a <em>bnf</em> or <em>sbnf</em> are technical and never used by
the casual user. In fact: <em>never access a component directly, always use
a proper member function.</em> However, for the sake of completeness and internal
documentation, their description is as follows. We use the notations
explained in the book by H. Cohen, <em>A Course in Computational Algebraic
Number Theory</em>, Graduate Texts in Maths <strong>138</strong>, Springer-Verlag, 1993,
Section 6.5, and subsection 6.5.5 in particular.</p>
<p><span class="math">\(bnf[1]\)</span> contains the matrix <span class="math">\(W\)</span>, i.e.&nbsp;the matrix in Hermite normal
form giving relations for the class group on prime ideal generators
<span class="math">\((p_i)_{1 &lt;= i &lt;= r}\)</span>.</p>
<p><span class="math">\(bnf[2]\)</span> contains the matrix <span class="math">\(B\)</span>, i.e.&nbsp;the matrix containing the
expressions of the prime ideal factorbase in terms of the <span class="math">\(p_i\)</span>.
It is an <span class="math">\(r x c\)</span> matrix.</p>
<p><span class="math">\(bnf[3]\)</span> contains the complex logarithmic embeddings of the system of
fundamental units which has been found. It is an <span class="math">\((r_1+r_2) x (r_1+r_2-1)\)</span>
matrix.</p>
<p><span class="math">\(bnf[4]\)</span> contains the matrix <span class="math">\(M&quot;_C\)</span> of Archimedean components of the
relations of the matrix <span class="math">\((W\|B)\)</span>.</p>
<p><span class="math">\(bnf[5]\)</span> contains the prime factor base, i.e.&nbsp;the list of prime
ideals used in finding the relations.</p>
<p><span class="math">\(bnf[6]\)</span> used to contain a permutation of the prime factor base, but
has been obsoleted. It contains a dummy <span class="math">\(0\)</span>.</p>
<p><span class="math">\(bnf[7]\)</span> or <code class="docutils literal"><span class="pre">:emphasis:`bnf</span></code>.nf` is equal to the number field data
<span class="math">\(nf\)</span> as would be given by <code class="docutils literal"><span class="pre">nfinit</span></code>.</p>
<p><span class="math">\(bnf[8]\)</span> is a vector containing the classgroup <code class="docutils literal"><span class="pre">:emphasis:`bnf</span></code>.clgp`
as a finite abelian group, the regulator <code class="docutils literal"><span class="pre">:emphasis:`bnf</span></code>.reg`, a <span class="math">\(1\)</span> (used to
contain an obsolete &#8220;check number&#8221;), the number of roots of unity and a
generator <code class="docutils literal"><span class="pre">:emphasis:`bnf</span></code>.tu`, the fundamental units <code class="docutils literal"><span class="pre">:emphasis:`bnf</span></code>.fu`.</p>
<p><span class="math">\(bnf[9]\)</span> is a 3-element row vector used in <code class="docutils literal"><span class="pre">bnfisprincipal</span></code> only
and obtained as follows. Let <span class="math">\(D = U W V\)</span> obtained by applying the
Smith normal form algorithm to the matrix <span class="math">\(W\)</span> ( = <span class="math">\(bnf[1]\)</span>) and
let <span class="math">\(U_r\)</span> be the reduction of <span class="math">\(U\)</span> modulo <span class="math">\(D\)</span>. The first elements of the
factorbase are given (in terms of <code class="docutils literal"><span class="pre">bnf.gen</span></code>) by the columns of <span class="math">\(U_r\)</span>,
with Archimedean component <span class="math">\(g_a\)</span>; let also <span class="math">\(GD_a\)</span> be the Archimedean
components of the generators of the (principal) ideals defined by the
<code class="docutils literal"><span class="pre">bnf.gen[i]^bnf.cyc[i]</span></code>. Then <span class="math">\(bnf[9] = [U_r, g_a, GD_a]\)</span>.</p>
<p><span class="math">\(bnf[10]\)</span> is by default unused and set equal to 0. This field is used
to store further information about the field as it becomes available, which
is rarely needed, hence would be too expensive to compute during the initial
<code class="docutils literal"><span class="pre">bnfinit</span></code> call. For instance, the generators of the principal ideals
<code class="docutils literal"><span class="pre">bnf.gen[i]^bnf.cyc[i]</span></code> (during a call to <code class="docutils literal"><span class="pre">bnrisprincipal</span></code>), or
those corresponding to the relations in <span class="math">\(W\)</span> and <span class="math">\(B\)</span> (when the <code class="docutils literal"><span class="pre">bnf</span></code>
internal precision needs to be increased).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfisintnorm">
<code class="descname">bnfisintnorm</code><span class="sig-paren">(</span><em>bnf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfisintnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a complete system of
solutions (modulo units of positive norm) of the absolute norm equation
<span class="math">\(\mathrm{Norm}(a) = x\)</span>,
where <span class="math">\(a\)</span> is an integer in <span class="math">\(bnf\)</span>. If <span class="math">\(bnf\)</span> has not been certified,
the correctness of the result depends on the validity of GRH.</p>
<p>See also <code class="docutils literal"><span class="pre">bnfisnorm</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfisnorm">
<code class="descname">bnfisnorm</code><span class="sig-paren">(</span><em>bnf</em>, <em>x</em>, <em>flag=1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfisnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to tell whether the
rational number <span class="math">\(x\)</span> is the norm of some element y in <span class="math">\(bnf\)</span>. Returns a
vector <span class="math">\([a,b]\)</span> where <span class="math">\(x = Norm(a)*b\)</span>. Looks for a solution which is an <span class="math">\(S\)</span>-unit,
with <span class="math">\(S\)</span> a certain set of prime ideals containing (among others) all primes
dividing <span class="math">\(x\)</span>. If <span class="math">\(bnf\)</span> is known to be Galois, set <span class="math">\(flag = 0\)</span> (in
this case, <span class="math">\(x\)</span> is a norm iff <span class="math">\(b = 1\)</span>). If <span class="math">\(flag\)</span> is non zero the program adds to
<span class="math">\(S\)</span> the following prime ideals, depending on the sign of <span class="math">\(flag\)</span>. If <span class="math">\(flag &gt; 0\)</span>,
the ideals of norm less than <span class="math">\(flag\)</span>. And if <span class="math">\(flag &lt; 0\)</span> the ideals dividing <span class="math">\(flag\)</span>.</p>
<p>Assuming GRH, the answer is guaranteed (i.e.&nbsp;<span class="math">\(x\)</span> is a norm iff <span class="math">\(b = 1\)</span>),
if <span class="math">\(S\)</span> contains all primes less than <span class="math">\(12\log(\mathrm{disc}(Bnf))^2\)</span>, where
<span class="math">\(Bnf\)</span> is the Galois closure of <span class="math">\(bnf\)</span>.</p>
<p>See also <code class="docutils literal"><span class="pre">bnfisintnorm</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfisprincipal">
<code class="descname">bnfisprincipal</code><span class="sig-paren">(</span><em>bnf</em>, <em>x</em>, <em>flag=1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfisprincipal" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(bnf\)</span> being the 
number field data output by <code class="docutils literal"><span class="pre">bnfinit</span></code>, and <span class="math">\(x\)</span> being an ideal, this
function tests whether the ideal is principal or not. The result is more
complete than a simple true/false answer and solves general discrete
logarithm problem. Assume the class group is <span class="math">\(\oplus (\mathbb{Z}/d_i\mathbb{Z})g_i\)</span>
(where the generators <span class="math">\(g_i\)</span> and their orders <span class="math">\(d_i\)</span> are respectively given by
<code class="docutils literal"><span class="pre">bnf.gen</span></code> and <code class="docutils literal"><span class="pre">bnf.cyc</span></code>). The routine returns a row vector <span class="math">\([e,t]\)</span>,
where <span class="math">\(e\)</span> is a vector of exponents <span class="math">\(0 &lt;= e_i &lt; d_i\)</span>, and <span class="math">\(t\)</span> is a number
field element such that</p>
<div class="math">
\[x = (t) \prod_i g_i^{e_i}.\]</div>
<p>For <em>given</em> <span class="math">\(g_i\)</span> (i.e. for a given <code class="docutils literal"><span class="pre">bnf</span></code>), the <span class="math">\(e_i\)</span> are unique,
and <span class="math">\(t\)</span> is unique modulo units.</p>
<p>In particular, <span class="math">\(x\)</span> is principal if and only if <span class="math">\(e\)</span> is the zero vector. Note
that the empty vector, which is returned when the class number is <span class="math">\(1\)</span>, is
considered to be a zero vector (of dimension <span class="math">\(0\)</span>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = bnfinit(y^2+23);
? K.cyc
%2 = [3]
? K.gen
%3 = [[2, 0; 0, 1]] \\ a prime ideal above 2
? P = idealprimedec(K,3)[1]; \\ a prime ideal above 3
? v = bnfisprincipal(K, P)
%5 = [[2]~, [3/4, 1/4]~]
? idealmul(K, v[2], idealfactorback(K, K.gen, v[1]))
%6 =
[3 0]

[0 1]
? % == idealhnf(K, P)
%7 = 1
</pre></div>
</div>
<p>The binary digits of <em>flag</em> mean:</p>
<ul class="simple">
<li><span class="math">\(1\)</span>: If set, outputs <span class="math">\([e,t]\)</span> as explained above, otherwise returns
only <span class="math">\(e\)</span>, which is much easier to compute. The following idiom only tests
whether an ideal is principal:</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>is_principal(bnf, x) = !bnfisprincipal(bnf,x,0);
</pre></div>
</div>
<ul class="simple">
<li><span class="math">\(2\)</span>: It may not be possible to recover <span class="math">\(t\)</span>, given the initial accuracy
to which the <code class="docutils literal"><span class="pre">bnf</span></code> structure was computed. In that case, a warning is
printed and <span class="math">\(t\)</span> is set equal to the empty vector <code class="docutils literal"><span class="pre">[]~</span></code>. If this bit is
set, increase the precision and recompute needed quantities until <span class="math">\(t\)</span> can be
computed. Warning: setting this may induce <em>lengthy</em> computations.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfissunit">
<code class="descname">bnfissunit</code><span class="sig-paren">(</span><em>bnf</em>, <em>sfu</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfissunit" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(bnf\)</span> being output by
<code class="docutils literal"><span class="pre">bnfinit</span></code>, <em>sfu</em> by <code class="docutils literal"><span class="pre">bnfsunit</span></code>, gives the column vector of
exponents of <span class="math">\(x\)</span> on the fundamental <span class="math">\(S\)</span>-units and the roots of unity.
If <span class="math">\(x\)</span> is not a unit, outputs an empty vector.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfisunit">
<code class="descname">bnfisunit</code><span class="sig-paren">(</span><em>bnf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfisunit" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bnf</em> being the number field data
output by <code class="docutils literal"><span class="pre">bnfinit</span></code> and <span class="math">\(x\)</span> being an algebraic number (type integer,
rational or polmod), this outputs the decomposition of <span class="math">\(x\)</span> on the fundamental
units and the roots of unity if <span class="math">\(x\)</span> is a unit, the empty vector otherwise.
More precisely, if <span class="math">\(u_1\)</span>,...,:math:<span class="math">\(u_r\)</span> are the fundamental units, and <span class="math">\(\zeta\)</span>
is the generator of the group of roots of unity (<code class="docutils literal"><span class="pre">bnf.tu</span></code>), the output is
a vector <span class="math">\([x_1,...,x_r,x_{r+1}]\)</span> such that <span class="math">\(x = u_1^{x_1}...
u_r^{x_r}.\zeta^{x_{r+1}}\)</span>. The <span class="math">\(x_i\)</span> are integers for <span class="math">\(i &lt;= r\)</span> and is an
integer modulo the order of <span class="math">\(\zeta\)</span> for <span class="math">\(i = r+1\)</span>.</p>
<p>Note that <em>bnf</em> need not contain the fundamental unit explicitly:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? setrand(1); bnf = bnfinit(x^2-x-100000);
? bnf.fu
 *** at top-level: bnf.fu
 *** ^--
 *** _.fu: missing units in .fu.
? u = [119836165644250789990462835950022871665178127611316131167, \
 379554884019013781006303254896369154068336082609238336]~;
? bnfisunit(bnf, u)
%3 = [-1, Mod(0, 2)]~
</pre></div>
</div>
<p>The given <span class="math">\(u\)</span> is the inverse of the fundamental unit
implicitly stored in <em>bnf</em>. In this case, the fundamental unit was not
computed and stored in algebraic form since the default accuracy was too
low. (Re-run the command at \g1 or higher to see such diagnostics.)</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfnarrow">
<code class="descname">bnfnarrow</code><span class="sig-paren">(</span><em>bnf</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfnarrow" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bnf</em> being as output by
<code class="docutils literal"><span class="pre">bnfinit</span></code>, computes the narrow class group of <em>bnf</em>. The output is
a 3-component row vector <span class="math">\(v\)</span> analogous to the corresponding class group
component <code class="docutils literal"><span class="pre">:emphasis:`bnf</span></code>.clgp`: the first component
is the narrow class number <code class="docutils literal"><span class="pre">:math:`v</span></code>.no`, the second component is a vector
containing the SNF cyclic components <code class="docutils literal"><span class="pre">:math:`v</span></code>.cyc` of
the narrow class group, and the third is a vector giving the generators of
the corresponding <code class="docutils literal"><span class="pre">:math:`v</span></code>.gen` cyclic groups. Note that this function is a
special case of <code class="docutils literal"><span class="pre">bnrinit</span></code>; the <em>bnf</em> need not contain fundamental
units.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfsignunit">
<code class="descname">bnfsignunit</code><span class="sig-paren">(</span><em>bnf</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfsignunit" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(bnf\)</span> being as output by
<code class="docutils literal"><span class="pre">bnfinit</span></code>, this computes an <span class="math">\(r_1 x (r_1+r_2-1)\)</span> matrix having <span class="math">\(±1\)</span>
components, giving the signs of the real embeddings of the fundamental units.
The following functions compute generators for the totally positive units:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">exponents</span> <span class="n">of</span> <span class="n">totally</span> <span class="n">positive</span> <span class="n">units</span> <span class="n">generators</span> <span class="n">on</span> <span class="n">bnf</span><span class="o">.</span><span class="n">tufu</span> <span class="o">*/</span>
<span class="n">tpuexpo</span><span class="p">(</span><span class="n">bnf</span><span class="p">)</span><span class="o">=</span>
<span class="p">{</span> <span class="n">my</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">K</span><span class="p">);</span>

 <span class="n">S</span> <span class="o">=</span> <span class="n">bnfsignunit</span><span class="p">(</span><span class="n">bnf</span><span class="p">);</span> <span class="n">d</span> <span class="o">=</span> <span class="n">matsize</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
 <span class="n">S</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
 <span class="n">S</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span><span class="n">vectorv</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">S</span><span class="p">);</span> \\ <span class="n">add</span> <span class="n">sign</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
 <span class="n">K</span> <span class="o">=</span> <span class="n">lift</span><span class="p">(</span><span class="n">matker</span><span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="n">Mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)));</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">mathnfmodid</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">matid</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="p">}</span>

<span class="o">/*</span> <span class="n">totally</span> <span class="n">positive</span> <span class="n">units</span> <span class="o">*/</span>
<span class="n">tpu</span><span class="p">(</span><span class="n">bnf</span><span class="p">)</span><span class="o">=</span>
<span class="p">{</span> <span class="n">my</span><span class="p">(</span><span class="n">vu</span> <span class="o">=</span> <span class="n">bnf</span><span class="o">.</span><span class="n">tufu</span><span class="p">,</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">tpuexpo</span><span class="p">(</span><span class="n">bnf</span><span class="p">));</span>

 <span class="n">vector</span><span class="p">(</span><span class="c1">#ex-1, i, factorback(vu, ex[,i+1])) \\ ex[,1] is 1</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnfsunit">
<code class="descname">bnfsunit</code><span class="sig-paren">(</span><em>bnf</em>, <em>S</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnfsunit" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the fundamental <span class="math">\(S\)</span>-units of the
number field <span class="math">\(bnf\)</span> (output by <code class="docutils literal"><span class="pre">bnfinit</span></code>), where <span class="math">\(S\)</span> is a list of
prime ideals (output by <code class="docutils literal"><span class="pre">idealprimedec</span></code>). The output is a vector <span class="math">\(v\)</span> with
6 components.</p>
<p><span class="math">\(v[1]\)</span> gives a minimal system of (integral) generators of the <span class="math">\(S\)</span>-unit group
modulo the unit group.</p>
<p><span class="math">\(v[2]\)</span> contains technical data needed by <code class="docutils literal"><span class="pre">bnfissunit</span></code>.</p>
<p><span class="math">\(v[3]\)</span> is an empty vector (used to give the logarithmic embeddings of the
generators in <span class="math">\(v[1]\)</span> in version 2.0.16).</p>
<p><span class="math">\(v[4]\)</span> is the <span class="math">\(S\)</span>-regulator (this is the product of the regulator, the
determinant of <span class="math">\(v[2]\)</span> and the natural logarithms of the norms of the ideals
in <span class="math">\(S\)</span>).</p>
<p><span class="math">\(v[5]\)</span> gives the <span class="math">\(S\)</span>-class group structure, in the usual format
(a row vector whose three components give in order the <span class="math">\(S\)</span>-class number,
the cyclic components and the generators).</p>
<p><span class="math">\(v[6]\)</span> is a copy of <span class="math">\(S\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrL1">
<code class="descname">bnrL1</code><span class="sig-paren">(</span><em>bnr</em>, <em>H=None</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrL1" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <em>bnr</em> be the number field data output by <code class="docutils literal"><span class="pre">bnrinit(,,1)</span></code> and
<em>H</em> be a square matrix defining a congruence subgroup of the
ray class group corresponding to <em>bnr</em> (the trivial congruence subgroup
if omitted). This function returns, for each character <span class="math">\(\chi\)</span> of the ray
class group which is trivial on <span class="math">\(H\)</span>, the value at <span class="math">\(s = 1\)</span> (or <span class="math">\(s = 0\)</span>) of the
abelian <span class="math">\(L\)</span>-function associated to <span class="math">\(\chi\)</span>. For the value at <span class="math">\(s = 0\)</span>, the
function returns in fact for each <span class="math">\(\chi\)</span> a vector <span class="math">\([r_\chi, c_\chi]\)</span> where</p>
<div class="math">
\[L(s, \chi) = c.s^r + O(s^{r + 1})\]</div>
<p>near <span class="math">\(0\)</span>.</p>
<p>The argument <em>flag</em> is optional, its binary digits
mean 1: compute at <span class="math">\(s = 0\)</span> if unset or <span class="math">\(s = 1\)</span> if set, 2: compute the
primitive <span class="math">\(L\)</span>-function associated to <span class="math">\(\chi\)</span> if unset or the <span class="math">\(L\)</span>-function
with Euler factors at prime ideals dividing the modulus of <em>bnr</em> removed
if set (that is <span class="math">\(L_S(s, \chi)\)</span>, where <span class="math">\(S\)</span> is the
set of infinite places of the number field together with the finite prime
ideals dividing the modulus of <em>bnr</em>), 3: return also the character if
set.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">K</span> <span class="o">=</span> <span class="n">bnfinit</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">229</span><span class="p">);</span>
<span class="n">bnr</span> <span class="o">=</span> <span class="n">bnrinit</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">bnrL1</span><span class="p">(</span><span class="n">bnr</span><span class="p">)</span>
</pre></div>
</div>
<p>returns the order and the first non-zero term of <span class="math">\(L(s, \chi)\)</span> at <span class="math">\(s = 0\)</span>
where <span class="math">\(\chi\)</span> runs through the characters of the class group of
<span class="math">\(K = \mathbb{Q}(\sqrt{229})\)</span>. Then</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bnr2</span> <span class="o">=</span> <span class="n">bnrinit</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">bnrL1</span><span class="p">(</span><span class="n">bnr2</span><span class="p">,,</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>returns the order and the first non-zero terms of <span class="math">\(L_S(s, \chi)\)</span> at <span class="math">\(s = 0\)</span>
where <span class="math">\(\chi\)</span> runs through the characters of the class group of <span class="math">\(K\)</span> and <span class="math">\(S\)</span> is
the set of infinite places of <span class="math">\(K\)</span> together with the finite prime <span class="math">\(2\)</span>. Note
that the ray class group modulo <span class="math">\(2\)</span> is in fact the class group, so
<code class="docutils literal"><span class="pre">bnrL1(bnr2,0)</span></code> returns the same answer as <code class="docutils literal"><span class="pre">bnrL1(bnr,0)</span></code>.</p>
<p>This function will fail with the message</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">***</span> <span class="n">bnrL1</span><span class="p">:</span> <span class="n">overflow</span> <span class="ow">in</span> <span class="n">zeta_get_N0</span> <span class="p">[</span><span class="n">need</span> <span class="n">too</span> <span class="n">many</span> <span class="n">primes</span><span class="p">]</span><span class="o">.</span>
</pre></div>
</div>
<p>if the approximate functional equation requires us to sum
too many terms (if the discriminant of <span class="math">\(K\)</span> is too large).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrchar">
<code class="descname">bnrchar</code><span class="sig-paren">(</span><em>bnr</em>, <em>g</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrchar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all characters <span class="math">\(\chi\)</span> on <code class="docutils literal"><span class="pre">bnr.clgp</span></code> such that
<span class="math">\(\chi(g_i) = e(v_i)\)</span>, where <span class="math">\(e(x) = \exp(2i\Pi x)\)</span>. If <span class="math">\(v\)</span> is omitted,
returns all characters that are trivial on the <span class="math">\(g_i\)</span>. Else the vectors <span class="math">\(g\)</span>
and <span class="math">\(v\)</span> must have the same length, the <span class="math">\(g_i\)</span> must be ideals in any form, and
each <span class="math">\(v_i\)</span> is a rational number whose denominator must divide the order of
<span class="math">\(g_i\)</span> in the ray class group. For convenience, the vector of the <span class="math">\(g_i\)</span>
can be replaced by a matrix whose columns give their discrete logarithm,
as given by <code class="docutils literal"><span class="pre">bnrisprincipal</span></code>; this allows to specify abstractly a
subgroup of the ray class group.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? bnr = bnrinit(bnfinit(x), [160,[1]], 1); /* (Z/160Z)^* */
? bnr.cyc
%2 = [8, 4, 2]
? g = bnr.gen;
? bnrchar(bnr, g, [1/2,0,0])
%4 = [[4, 0, 0]] \\ a unique character
? bnrchar(bnr, [g[1],g[3]]) \\ all characters trivial on g[1] and g[3]
%5 = [[0, 1, 0], [0, 2, 0], [0, 3, 0], [0, 0, 0]]
? bnrchar(bnr, [1,0,0;0,1,0;0,0,2]) \\ characters trivial on the given subgroup
%6 = [[0, 0, 1], [0, 0, 0]]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrclassno">
<code class="descname">bnrclassno</code><span class="sig-paren">(</span><em>A</em>, <em>B=None</em>, <em>C=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrclassno" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(A\)</span>, <span class="math">\(B\)</span>, <span class="math">\(C\)</span> define a class field <span class="math">\(L\)</span> over a ground field <span class="math">\(K\)</span>
(of type <code class="docutils literal"><span class="pre">[:emphasis:`bnr</span></code>]`,
<code class="docutils literal"><span class="pre">[:emphasis:`bnr</span></code>, <em>subgroup</em>]`,
or <code class="docutils literal"><span class="pre">[:emphasis:`bnf</span></code>, <em>modulus</em>]`,
or <code class="docutils literal"><span class="pre">[:emphasis:`bnf</span></code>, <em>modulus</em>,:emphasis:<span class="math">\(subgroup\)</span>]`,
<code class="docutils literal"><span class="pre">CFT</span></code> (in the PARI manual)); this function returns the relative degree <span class="math">\([L:K]\)</span>.</p>
<p>In particular if <span class="math">\(A\)</span> is a <em>bnf</em> (with units), and <span class="math">\(B\)</span> a modulus,
this function returns the corresponding ray class number modulo <span class="math">\(B\)</span>.
One can input the associated <em>bid</em> (with generators if the subgroup
<span class="math">\(C\)</span> is non trivial) for <span class="math">\(B\)</span> instead of the module itself, saving some time.</p>
<p>This function is faster than <code class="docutils literal"><span class="pre">bnrinit</span></code> and should be used if only the
ray class number is desired. See <code class="docutils literal"><span class="pre">bnrclassnolist</span></code> if you need ray class
numbers for all moduli less than some bound.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrclassnolist">
<code class="descname">bnrclassnolist</code><span class="sig-paren">(</span><em>bnf</em>, <em>list</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrclassnolist" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(bnf\)</span> being as
output by <code class="docutils literal"><span class="pre">bnfinit</span></code>, and <em>list</em> being a list of moduli (with units) as
output by <code class="docutils literal"><span class="pre">ideallist</span></code> or <code class="docutils literal"><span class="pre">ideallistarch</span></code>, outputs the list of the
class numbers of the corresponding ray class groups. To compute a single
class number, <code class="docutils literal"><span class="pre">bnrclassno</span></code> is more efficient.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? bnf = bnfinit(x^2 - 2);
? L = ideallist(bnf, 100, 2);
? H = bnrclassnolist(bnf, L);
? H[98]
%4 = [1, 3, 1]
? l = L[1][98]; ids = vector(#l, i, l[i].mod[1])
%5 = [[98, 88; 0, 1], [14, 0; 0, 7], [98, 10; 0, 1]]
</pre></div>
</div>
<p>The weird <code class="docutils literal"><span class="pre">l[i].mod[1]</span></code>, is the first component of <code class="docutils literal"><span class="pre">l[i].mod</span></code>, i.e.
the finite part of the conductor. (This is cosmetic: since by construction
the Archimedean part is trivial, I do not want to see it). This tells us that
the ray class groups modulo the ideals of norm 98 (printed as <code class="docutils literal"><span class="pre">%5</span></code>) have
respectively order <span class="math">\(1\)</span>, <span class="math">\(3\)</span> and <span class="math">\(1\)</span>. Indeed, we may check directly:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? bnrclassno(bnf, ids[2])
%6 = 3
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrconductor">
<code class="descname">bnrconductor</code><span class="sig-paren">(</span><em>A</em>, <em>B=None</em>, <em>C=None</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrconductor" title="Permalink to this definition">¶</a></dt>
<dd><p>Conductor <span class="math">\(f\)</span> of the subfield of a ray class field as defined by <span class="math">\([A,B,C]\)</span>
(of type <code class="docutils literal"><span class="pre">[:emphasis:`bnr</span></code>]`,
<code class="docutils literal"><span class="pre">[:emphasis:`bnr</span></code>, <em>subgroup</em>]`,
<code class="docutils literal"><span class="pre">[:emphasis:`bnf</span></code>, <em>modulus</em>]` or
<code class="docutils literal"><span class="pre">[:emphasis:`bnf</span></code>, <em>modulus</em>, <em>subgroup</em>]`,
<code class="docutils literal"><span class="pre">CFT</span></code> (in the PARI manual))</p>
<p>If <span class="math">\(flag = 0\)</span>, returns <span class="math">\(f\)</span>.</p>
<p>If <span class="math">\(flag = 1\)</span>, returns <span class="math">\([f, Cl_f, H]\)</span>, where <span class="math">\(Cl_f\)</span> is the ray class group
modulo <span class="math">\(f\)</span>, as a finite abelian group; finally <span class="math">\(H\)</span> is the subgroup of <span class="math">\(Cl_f\)</span>
defining the extension.</p>
<p>If <span class="math">\(flag = 2\)</span>, returns <span class="math">\([f, bnr(f), H]\)</span>, as above except <span class="math">\(Cl_f\)</span> is
replaced by a <code class="docutils literal"><span class="pre">bnr</span></code> structure, as output by <span class="math">\(bnrinit(,f,1)\)</span>.</p>
<p>In place of a subgroup <span class="math">\(H\)</span>, this function also accepts a character
<em>chi</em> <span class="math">\(= (a_j)\)</span>, expressed as usual in terms of the generators
<code class="docutils literal"><span class="pre">bnr.gen</span></code>: <span class="math">\(\chi(g_j) = \exp(2i\Pi a_j / d_j)\)</span>, where <span class="math">\(g_j\)</span> has
order <span class="math">\(d_j = bnr.cyc[j]\)</span>. In which case, the function returns
respectively</p>
<p>If <span class="math">\(flag = 0\)</span>, the conductor <span class="math">\(f\)</span> of <span class="math">\({Ker} \chi\)</span>.</p>
<p>If <span class="math">\(flag = 1\)</span>, <span class="math">\([f, Cl_f, \chi_f]\)</span>, where <span class="math">\(\chi_f\)</span> is <span class="math">\(\chi\)</span> expressed
on the minimal ray class group, whose modulus is the conductor.</p>
<p>If <span class="math">\(flag = 2\)</span>, <span class="math">\([f, bnr(f), \chi_f]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrconductorofchar">
<code class="descname">bnrconductorofchar</code><span class="sig-paren">(</span><em>bnr</em>, <em>chi</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrconductorofchar" title="Permalink to this definition">¶</a></dt>
<dd><p>THIS FUNCTION IS OBSOLETE: use <em>bnrconductor</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrdisc">
<code class="descname">bnrdisc</code><span class="sig-paren">(</span><em>A</em>, <em>B=None</em>, <em>C=None</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrdisc" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(A\)</span>, <span class="math">\(B\)</span>, <span class="math">\(C\)</span> defining a class field <span class="math">\(L\)</span> over a ground field <span class="math">\(K\)</span>
(of type <code class="docutils literal"><span class="pre">[:emphasis:`bnr</span></code>]`,
<code class="docutils literal"><span class="pre">[:emphasis:`bnr</span></code>, <em>subgroup</em>]`,
<code class="docutils literal"><span class="pre">[:emphasis:`bnr</span></code>, <em>character</em>]`,
<code class="docutils literal"><span class="pre">[:emphasis:`bnf</span></code>, <em>modulus</em>]` or
<code class="docutils literal"><span class="pre">[:emphasis:`bnf</span></code>, <em>modulus</em>, <em>subgroup</em>]`,
<code class="docutils literal"><span class="pre">CFT</span></code> (in the PARI manual)), outputs data <span class="math">\([N,r_1,D]\)</span> giving the discriminant and
signature of <span class="math">\(L\)</span>, depending on the binary digits of <em>flag</em>:</p>
<ul class="simple">
<li>1: if this bit is unset, output absolute data related to <span class="math">\(L/\mathbb{Q}\)</span>:
<span class="math">\(N\)</span> is the absolute degree <span class="math">\([L:\mathbb{Q}]\)</span>, <span class="math">\(r_1\)</span> the number of real places of <span class="math">\(L\)</span>,
and <span class="math">\(D\)</span> the discriminant of <span class="math">\(L/\mathbb{Q}\)</span>. Otherwise, output relative data for <span class="math">\(L/K\)</span>:
<span class="math">\(N\)</span> is the relative degree <span class="math">\([L:K]\)</span>, <span class="math">\(r_1\)</span> is the number of real places of <span class="math">\(K\)</span>
unramified in <span class="math">\(L\)</span> (so that the number of real places of <span class="math">\(L\)</span> is equal to <span class="math">\(r_1\)</span>
times <span class="math">\(N\)</span>), and <span class="math">\(D\)</span> is the relative discriminant ideal of <span class="math">\(L/K\)</span>.</li>
<li>2: if this bit is set and if the modulus is not the conductor of <span class="math">\(L\)</span>,
only return 0.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrdisclist">
<code class="descname">bnrdisclist</code><span class="sig-paren">(</span><em>bnf</em>, <em>bound</em>, <em>arch=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrdisclist" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(bnf\)</span> being as output by <code class="docutils literal"><span class="pre">bnfinit</span></code> (with units), computes a
list of discriminants of Abelian extensions of the number field by increasing
modulus norm up to bound <em>bound</em>. The ramified Archimedean places are
given by <em>arch</em>; all possible values are taken if <em>arch</em> is omitted.</p>
<p>The alternative syntax <span class="math">\(bnrdisclist(bnf,list)\)</span> is
supported, where <em>list</em> is as output by <code class="docutils literal"><span class="pre">ideallist</span></code> or
<code class="docutils literal"><span class="pre">ideallistarch</span></code> (with units), in which case <em>arch</em> is disregarded.</p>
<p>The output <span class="math">\(v\)</span> is a vector of vectors, where <span class="math">\(v[i][j]\)</span> is understood to be in
fact <span class="math">\(V[2^{15}(i-1)+j]\)</span> of a unique big vector <span class="math">\(V\)</span>. (This awkward scheme
allows for larger vectors than could be otherwise represented.)</p>
<p><span class="math">\(V[k]\)</span> is itself a vector <span class="math">\(W\)</span>, whose length is the number of ideals of norm
<span class="math">\(k\)</span>. We consider first the case where <em>arch</em> was specified. Each
component of <span class="math">\(W\)</span> corresponds to an ideal <span class="math">\(m\)</span> of norm <span class="math">\(k\)</span>, and
gives invariants associated to the ray class field <span class="math">\(L\)</span> of <span class="math">\(bnf\)</span> of
conductor <span class="math">\([m, arch]\)</span>. Namely, each contains a vector <span class="math">\([m,d,r,D]\)</span> with
the following meaning: <span class="math">\(m\)</span> is the prime ideal factorization of the modulus,
<span class="math">\(d = [L:\mathbb{Q}]\)</span> is the absolute degree of <span class="math">\(L\)</span>, <span class="math">\(r\)</span> is the number of real places
of <span class="math">\(L\)</span>, and <span class="math">\(D\)</span> is the factorization of its absolute discriminant. We set <span class="math">\(d
= r = D = 0\)</span> if <span class="math">\(m\)</span> is not the finite part of a conductor.</p>
<p>If <em>arch</em> was omitted, all <span class="math">\(t = 2^{r_1}\)</span> possible values are taken and a
component of <span class="math">\(W\)</span> has the form <span class="math">\([m, [[d_1,r_1,D_1],..., [d_t,r_t,D_t]]]\)</span>,
where <span class="math">\(m\)</span> is the finite part of the conductor as above, and
<span class="math">\([d_i,r_i,D_i]\)</span> are the invariants of the ray class field of conductor
<span class="math">\([m,v_i]\)</span>, where <span class="math">\(v_i\)</span> is the <span class="math">\(i\)</span>-th Archimedean component, ordered by
inverse lexicographic order; so <span class="math">\(v_1 = [0,...,0]\)</span>, <span class="math">\(v_2 = [1,0...,0]\)</span>,
etc. Again, we set <span class="math">\(d_i = r_i = D_i = 0\)</span> if <span class="math">\([m,v_i]\)</span> is not a conductor.</p>
<p>Finally, each prime ideal <span class="math">\(pr = [p,\alpha,e,f,\beta]\)</span> in the prime
factorization <span class="math">\(m\)</span> is coded as the integer <span class="math">\(p.n^2+(f-1).n+(j-1)\)</span>,
where <span class="math">\(n\)</span> is the degree of the base field and <span class="math">\(j\)</span> is such that</p>
<p><code class="docutils literal"><span class="pre">pr</span> <span class="pre">=</span> <span class="pre">idealprimedec(:emphasis:`nf</span></code>,p)[j]`.</p>
<p><span class="math">\(m\)</span> can be decoded using <code class="docutils literal"><span class="pre">bnfdecodemodule</span></code>.</p>
<p>Note that to compute such data for a single field, either <code class="docutils literal"><span class="pre">bnrclassno</span></code>
or <code class="docutils literal"><span class="pre">bnrdisc</span></code> is more efficient.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrgaloisapply">
<code class="descname">bnrgaloisapply</code><span class="sig-paren">(</span><em>bnr</em>, <em>mat</em>, <em>H</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrgaloisapply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the automorphism given by its matrix <em>mat</em> to the congruence
subgroup <span class="math">\(H\)</span> given as a HNF matrix.
The matrix <em>mat</em> can be computed with <code class="docutils literal"><span class="pre">bnrgaloismatrix</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrgaloismatrix">
<code class="descname">bnrgaloismatrix</code><span class="sig-paren">(</span><em>bnr</em>, <em>aut</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrgaloismatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix of the action of the automorphism <em>aut</em> of the base
field <code class="docutils literal"><span class="pre">bnf.nf</span></code> on the generators of the ray class field <code class="docutils literal"><span class="pre">bnr.gen</span></code>.
<em>aut</em> can be given as a polynomial, an algebraic number, or a vector of
automorphisms or a Galois group as output by <code class="docutils literal"><span class="pre">galoisinit</span></code>, in which case a
vector of matrices is returned (in the later case, only for the generators
<code class="docutils literal"><span class="pre">aut.gen</span></code>).</p>
<p>See <code class="docutils literal"><span class="pre">bnrisgalois</span></code> for an example.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrinit">
<code class="descname">bnrinit</code><span class="sig-paren">(</span><em>bnf</em>, <em>f</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrinit" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(bnf\)</span> is as
output by <code class="docutils literal"><span class="pre">bnfinit</span></code> (including fundamental units), <span class="math">\(f\)</span> is a modulus,
initializes data linked to the ray class group structure corresponding to
this module, a so-called <code class="docutils literal"><span class="pre">bnr</span></code> structure. One can input the associated
<em>bid</em> with generators for <span class="math">\(f\)</span> instead of the module itself, saving some
time. (As in <code class="docutils literal"><span class="pre">idealstar</span></code>, the finite part of the conductor may be given
by a factorization into prime ideals, as produced by <code class="docutils literal"><span class="pre">idealfactor</span></code>.)</p>
<p>The following member functions are available
on the result: <code class="docutils literal"><span class="pre">.bnf</span></code> is the underlying <em>bnf</em>,
<code class="docutils literal"><span class="pre">.mod</span></code> the modulus, <code class="docutils literal"><span class="pre">.bid</span></code> the <code class="docutils literal"><span class="pre">bid</span></code> structure associated to the
modulus; finally, <code class="docutils literal"><span class="pre">.clgp</span></code>, <code class="docutils literal"><span class="pre">.no</span></code>, <code class="docutils literal"><span class="pre">.cyc</span></code>, <code class="docutils literal"><span class="pre">.gen</span></code> refer to the
ray class group (as a finite abelian group), its cardinality, its elementary
divisors, its generators (only computed if <span class="math">\(flag = 1\)</span>).</p>
<p>The last group of functions are different from the members of the underlying
<em>bnf</em>, which refer to the class group; use <code class="docutils literal"><span class="pre">:emphasis:`bnr</span></code>.bnf.:emphasis:<span class="math">\(xxx`\)</span>
to access these, e.g.&nbsp;<code class="docutils literal"><span class="pre">:emphasis:`bnr</span></code>.bnf.cyc` to get the cyclic decomposition
of the class group.</p>
<p>They are also different from the members of the underlying <em>bid</em>, which
refer to <span class="math">\((\mathbb{Z}_K/f)^*\)</span>; use <code class="docutils literal"><span class="pre">:emphasis:`bnr</span></code>.bid.:emphasis:<span class="math">\(xxx`\)</span> to access these,
e.g.&nbsp;<code class="docutils literal"><span class="pre">:emphasis:`bnr</span></code>.bid.no` to get <span class="math">\(\phi(f)\)</span>.</p>
<p>If <span class="math">\(flag = 0\)</span> (default), the generators of the ray class group are not computed,
which saves time. Hence <code class="docutils literal"><span class="pre">:emphasis:`bnr</span></code>.gen` would produce an error.</p>
<p>If <span class="math">\(flag = 1\)</span>, as the default, except that generators are computed.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrisconductor">
<code class="descname">bnrisconductor</code><span class="sig-paren">(</span><em>A</em>, <em>B=None</em>, <em>C=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrisconductor" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast variant of <code class="docutils literal"><span class="pre">bnrconductor</span></code><span class="math">\((A,B,C)\)</span>; <span class="math">\(A\)</span>, <span class="math">\(B\)</span>, <span class="math">\(C\)</span> represent
an extension of the base field, given by class field theory
(see&nbsp;<code class="docutils literal"><span class="pre">CFT</span></code> (in the PARI manual)). Outputs 1 if this modulus is the conductor, and 0
otherwise. This is slightly faster than <code class="docutils literal"><span class="pre">bnrconductor</span></code> when the
character or subgroup is not primitive.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrisgalois">
<code class="descname">bnrisgalois</code><span class="sig-paren">(</span><em>bnr</em>, <em>gal</em>, <em>H</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrisgalois" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the class field associated to the subgroup <span class="math">\(H\)</span> is Galois
over the subfield of <code class="docutils literal"><span class="pre">bnr.nf</span></code> fixed by the group <em>gal</em>, which can be
given as output by <code class="docutils literal"><span class="pre">galoisinit</span></code>, or as a matrix or a vector of matrices as
output by <code class="docutils literal"><span class="pre">bnrgaloismatrix</span></code>, the second option being preferable, since it
saves the recomputation of the matrices. Note: The function assumes that the
ray class field associated to bnr is Galois, which is not checked.</p>
<p>In the following example, we lists the congruence subgroups of subextension of
degree at most <span class="math">\(3\)</span> of the ray class field of conductor <span class="math">\(9\)</span> which are Galois
over the rationals.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">K</span><span class="o">=</span><span class="n">bnfinit</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="mi">4</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">253009</span><span class="p">);</span>
<span class="n">G</span><span class="o">=</span><span class="n">galoisinit</span><span class="p">(</span><span class="n">K</span><span class="p">);</span>
<span class="n">B</span><span class="o">=</span><span class="n">bnrinit</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">L1</span><span class="o">=</span><span class="p">[</span><span class="n">H</span><span class="o">|</span><span class="n">H</span><span class="o">&lt;-</span><span class="n">subgrouplist</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">bnrisgalois</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">H</span><span class="p">)]</span>
<span class="c1">##</span>
<span class="n">M</span><span class="o">=</span><span class="n">bnrgaloismatrix</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">G</span><span class="p">)</span>
<span class="n">L2</span><span class="o">=</span><span class="p">[</span><span class="n">H</span><span class="o">|</span><span class="n">H</span><span class="o">&lt;-</span><span class="n">subgrouplist</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">bnrisgalois</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">H</span><span class="p">)]</span>
<span class="c1">##</span>
</pre></div>
</div>
<p>The second computation is much faster since <code class="docutils literal"><span class="pre">bnrgaloismatrix(B,G)</span></code> is
computed only once.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrisprincipal">
<code class="descname">bnrisprincipal</code><span class="sig-paren">(</span><em>bnr</em>, <em>x</em>, <em>flag=1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrisprincipal" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bnr</em> being the
number field data which is output by <code class="docutils literal"><span class="pre">bnrinit</span></code><span class="math">\((,,1)\)</span> and <span class="math">\(x\)</span> being an
ideal in any form, outputs the components of <span class="math">\(x\)</span> on the ray class group
generators in a way similar to <code class="docutils literal"><span class="pre">bnfisprincipal</span></code>. That is a 2-component
vector <span class="math">\(v\)</span> where <span class="math">\(v[1]\)</span> is the vector of components of <span class="math">\(x\)</span> on the ray class
group generators, <span class="math">\(v[2]\)</span> gives on the integral basis an element <span class="math">\(\alpha\)</span> such
that <span class="math">\(x = \alpha\prod_ig_i^{x_i}\)</span>.</p>
<p>If <span class="math">\(flag = 0\)</span>, outputs only <span class="math">\(v_1\)</span>. In that case, <em>bnr</em> need not contain the
ray class group generators, i.e.&nbsp;it may be created with <code class="docutils literal"><span class="pre">bnrinit</span></code><span class="math">\((,,0)\)</span>
If <span class="math">\(x\)</span> is not coprime to the modulus of <em>bnr</em> the result is undefined.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrrootnumber">
<code class="descname">bnrrootnumber</code><span class="sig-paren">(</span><em>bnr</em>, <em>chi</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrrootnumber" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(\chi = chi\)</span> is a
character over <em>bnr</em>, not necessarily primitive, let
<span class="math">\(L(s,\chi) = \sum_{id} \chi(id) N(id)^{-s}\)</span> be the associated
Artin L-function. Returns the so-called Artin root number, i.e.&nbsp;the
complex number <span class="math">\(W(\chi)\)</span> of modulus 1 such that</p>
<div class="math">
\[\Lambda(1-s,\chi) = W(\chi) \Lambda(s,\overline{\chi})\]</div>
<p>where <span class="math">\(\Lambda(s,\chi) = A(\chi)^{s/2}\gamma_\chi(s) L(s,\chi)\)</span> is
the enlarged L-function associated to <span class="math">\(L\)</span>.</p>
<p>The generators of the ray class group are needed, and you can set <span class="math">\(flag = 1\)</span> if
the character is known to be primitive. Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bnf</span> <span class="o">=</span> <span class="n">bnfinit</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">57</span><span class="p">);</span>
<span class="n">bnr</span> <span class="o">=</span> <span class="n">bnrinit</span><span class="p">(</span><span class="n">bnf</span><span class="p">,</span> <span class="p">[</span><span class="mi">7</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">bnrrootnumber</span><span class="p">(</span><span class="n">bnr</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>returns the root number of the character <span class="math">\(\chi\)</span> of
<span class="math">\(\mathrm{Cl}_{7 oo _1 oo _2}(\mathbb{Q}(\sqrt{229}))\)</span> defined by <span class="math">\(\chi(g_1^ag_2^b)
= \zeta_1^{2a}\zeta_2^b\)</span>. Here <span class="math">\(g_1, g_2\)</span> are the generators of the
ray-class group given by <code class="docutils literal"><span class="pre">bnr.gen</span></code> and <span class="math">\(\zeta_1 = e^{2i\Pi/N_1},
\zeta_2 = e^{2i\Pi/N_2}\)</span> where <span class="math">\(N_1, N_2\)</span> are the orders of <span class="math">\(g_1\)</span> and
<span class="math">\(g_2\)</span> respectively (<span class="math">\(N_1 = 6\)</span> and <span class="math">\(N_2 = 3\)</span> as <code class="docutils literal"><span class="pre">bnr.cyc</span></code> readily tells us).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.bnrstark">
<code class="descname">bnrstark</code><span class="sig-paren">(</span><em>bnr</em>, <em>subgroup=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.bnrstark" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bnr</em> being as output by <code class="docutils literal"><span class="pre">bnrinit(,,1)</span></code>, finds a relative equation
for the class field corresponding to the modulus in <em>bnr</em> and the given
congruence subgroup (as usual, omit <span class="math">\(subgroup\)</span> if you want the whole ray
class group).</p>
<p>The main variable of <em>bnr</em> must not be <span class="math">\(x\)</span>, and the ground field and the
class field must be totally real. When the base field is <span class="math">\(\mathbb{Q}\)</span>, the vastly
simpler <code class="docutils literal"><span class="pre">galoissubcyclo</span></code> is used instead. Here is an example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bnf</span> <span class="o">=</span> <span class="n">bnfinit</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">bnr</span> <span class="o">=</span> <span class="n">bnrinit</span><span class="p">(</span><span class="n">bnf</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">bnrstark</span><span class="p">(</span><span class="n">bnr</span><span class="p">)</span>
</pre></div>
</div>
<p>returns the ray class field of <span class="math">\(\mathbb{Q}(\sqrt{3})\)</span> modulo <span class="math">\(5\)</span>. Usually, one wants
to apply to the result one of</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">rnfpolredabs</span><span class="p">(</span><span class="n">bnf</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> \\ <span class="n">compute</span> <span class="n">a</span> <span class="n">reduced</span> <span class="n">relative</span> <span class="n">polynomial</span>
<span class="n">rnfpolredabs</span><span class="p">(</span><span class="n">bnf</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="mi">16</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> \\ <span class="n">compute</span> <span class="n">a</span> <span class="n">reduced</span> <span class="n">absolute</span> <span class="n">polynomial</span>
</pre></div>
</div>
<p>The routine uses Stark units and needs to find a suitable auxiliary
conductor, which may not exist when the class field is not cyclic over the
base. In this case <code class="docutils literal"><span class="pre">bnrstark</span></code> is allowed to return a vector of
polynomials defining <em>independent</em> relative extensions, whose compositum
is the requested class field. It was decided that it was more useful
to keep the extra information thus made available, hence the user has to take
the compositum herself.</p>
<p>Even if it exists, the auxiliary conductor may be so large that later
computations become unfeasible. (And of course, Stark&#8217;s conjecture may simply
be wrong.) In case of difficulties, try <code class="docutils literal"><span class="pre">rnfkummer</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? bnr = bnrinit(bnfinit(y^8-12*y^6+36*y^4-36*y^2+9,1), 2, 1);
? bnrstark(bnr)
 *** at top-level: bnrstark(bnr)
 *** ^-------------
 *** bnrstark: need 3919350809720744 coefficients in initzeta.
 *** Computation impossible.
? lift( rnfkummer(bnr) )
time = 24 ms.
%2 = x^2 + (1/3*y^6 - 11/3*y^4 + 8*y^2 - 5)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.call">
<code class="descname">call</code><span class="sig-paren">(</span><em>f</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.call" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(A = [a_1,..., a_n]\)</span> being a vector and <span class="math">\(f\)</span> being a function, returns the
evaluation of <span class="math">\(f(a_1,...,a_n)\)</span>.
<span class="math">\(f\)</span> can also be the name of a built-in GP function.
If <span class="math">\(\# A = 1\)</span>, <code class="docutils literal"><span class="pre">call`(:math:`f,A</span></code>) = <code class="docutils literal"><span class="pre">apply`(:math:`f,A</span></code>)[1].
If <span class="math">\(f\)</span> is variadic, the variadic arguments must grouped in a vector in
the last component of <span class="math">\(A\)</span>.</p>
<p>This function is useful</p>
<ul class="simple">
<li>when writing a variadic function, to call another one:</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fprintf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="nb">format</span><span class="p">,</span><span class="n">args</span><span class="p">[</span><span class="o">..</span><span class="p">])</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="n">call</span><span class="p">(</span><span class="n">Strprintf</span><span class="p">,[</span><span class="nb">format</span><span class="p">,</span><span class="n">args</span><span class="p">]))</span>
</pre></div>
</div>
<ul class="simple">
<li>when dealing with function arguments with unspecified arity</li>
</ul>
<p>The function below implements a global memoization interface:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>memo=Map();
memoize(f,A[..])=
{
 my(res);
 if(!mapisdefined(memo, [f,A], &amp;res),
 res = call(f,A);
 mapput(memo,[f,A],res));
 res;
}
</pre></div>
</div>
<p>for example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? memoize(factor,2^128+1)
%3 = [59649589127497217,1;5704689200685129054721,1]
? ##
 *** last result computed in 76 ms.
? memoize(factor,2^128+1)
%4 = [59649589127497217,1;5704689200685129054721,1]
? ##
 *** last result computed in 0 ms.
? memoize(ffinit,3,3)
%5 = Mod(1,3)*x^3+Mod(1,3)*x^2+Mod(1,3)*x+Mod(2,3)
? fibo(n)=if(n==0,0,n==1,1,memoize(fibo,n-2)+memoize(fibo,n-1));
? fibo(100)
%7 = 354224848179261915075
</pre></div>
</div>
<ul class="simple">
<li>to call operators through their internal names without using
<code class="docutils literal"><span class="pre">alias</span></code></li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">matnbelts</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="o">=</span> <span class="n">call</span><span class="p">(</span><span class="s2">&quot;_*_&quot;</span><span class="p">,</span><span class="n">matsize</span><span class="p">(</span><span class="n">M</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ceil">
<code class="descname">ceil</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Ceiling of <span class="math">\(x\)</span>. When <span class="math">\(x\)</span> is in <span class="math">\(\mathbb{R}\)</span>, the result is the
smallest integer greater than or equal to <span class="math">\(x\)</span>. Applied to a rational
function, <span class="math">\(ceil(x)\)</span> returns the Euclidean quotient of the numerator by
the denominator.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.centerlift">
<code class="descname">centerlift</code><span class="sig-paren">(</span><em>x</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.centerlift" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <code class="docutils literal"><span class="pre">lift</span></code>, except that <code class="docutils literal"><span class="pre">t_INTMOD</span></code> and <code class="docutils literal"><span class="pre">t_PADIC</span></code> components
are lifted using centered residues:</p>
<ul class="simple">
<li>for a <code class="docutils literal"><span class="pre">t_INTMOD</span></code> <span class="math">\(x belongs to \mathbb{Z}/n\mathbb{Z}\)</span>, the lift <span class="math">\(y\)</span> is such that
<span class="math">\(-n/2 &lt; y &lt;= n/2\)</span>.</li>
<li>a <code class="docutils literal"><span class="pre">t_PADIC</span></code> <span class="math">\(x\)</span> is lifted in the same way as above (modulo
<span class="math">\(p^padicprec(x)\)</span>) if its valuation <span class="math">\(v\)</span> is non-negative; if not, returns
the fraction <span class="math">\(p^v\)</span> <code class="docutils literal"><span class="pre">centerlift</span></code><span class="math">\((x p^{-v})\)</span>; in particular, rational
reconstruction is not attempted. Use <code class="docutils literal"><span class="pre">bestappr</span></code> for this.</li>
</ul>
<p>For backward compatibility, <code class="docutils literal"><span class="pre">centerlift(x,'v)</span></code> is allowed as an alias
for <code class="docutils literal"><span class="pre">lift(x,'v)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.characteristic">
<code class="descname">characteristic</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.characteristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the characteristic of the base ring over which <span class="math">\(x\)</span> is defined (as
defined by <code class="docutils literal"><span class="pre">t_INTMOD</span></code> and <code class="docutils literal"><span class="pre">t_FFELT</span></code> components). The function raises an
exception if incompatible primes arise from <code class="docutils literal"><span class="pre">t_FFELT</span></code> and <code class="docutils literal"><span class="pre">t_PADIC</span></code>
components.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? characteristic(Mod(1,24)*x + Mod(1,18)*y)
%1 = 6
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.charconj">
<code class="descname">charconj</code><span class="sig-paren">(</span><em>cyc</em>, <em>chi</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.charconj" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <em>cyc</em> represent a finite abelian group by its elementary
divisors, i.e. <span class="math">\((d_j)\)</span> represents <span class="math">\(\sum_{j &lt;= k} \mathbb{Z}/d_j\mathbb{Z}\)</span> with <span class="math">\(d_k
| ... \| d_1\)</span>; any object which has a <code class="docutils literal"><span class="pre">.cyc</span></code> method is also
allowed, e.g.&nbsp;the output of <code class="docutils literal"><span class="pre">znstar</span></code> or <code class="docutils literal"><span class="pre">bnrinit</span></code>. A character
on this group is given by a row vector <span class="math">\(\chi = [a_1,...,a_n]\)</span> such that
<span class="math">\(\chi(\prod g_j^{n_j}) = \exp(2\Pi i\sum a_j n_j / d_j)\)</span>, where <span class="math">\(g_j\)</span> denotes
the generator (of order <span class="math">\(d_j\)</span>) of the <span class="math">\(j\)</span>-th cyclic component.</p>
<p>This function returns the conjugate character.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? cyc = [15,5]; chi = [1,1];
? charconj(cyc, chi)
%2 = [14, 4]
? bnf = bnfinit(x^2+23);
? bnf.cyc
%4 = [3]
? charconj(bnf, [1])
%5 = [2]
</pre></div>
</div>
<p>For Dirichlet characters (when <code class="docutils literal"><span class="pre">cyc</span></code> is
<code class="docutils literal"><span class="pre">idealstar(,q)</span></code>), characters in Conrey representation are available,
see <code class="docutils literal"><span class="pre">dirichletchar</span></code> (in the PARI manual) or <code class="docutils literal"><span class="pre">??character</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = idealstar(,8); \\ (Z/8Z)^*
? charorder(G, 3) \\ Conrey label
%2 = 2
? chi = znconreylog(G, 3);
? charorder(G, chi) \\ Conrey logarithm
%4 = 2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.chardiv">
<code class="descname">chardiv</code><span class="sig-paren">(</span><em>cyc</em>, <em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.chardiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <em>cyc</em> represent a finite abelian group by its elementary
divisors, i.e. <span class="math">\((d_j)\)</span> represents <span class="math">\(\sum_{j &lt;= k} \mathbb{Z}/d_j\mathbb{Z}\)</span> with <span class="math">\(d_k
| ... \| d_1\)</span>; any object which has a <code class="docutils literal"><span class="pre">.cyc</span></code> method is also
allowed, e.g.&nbsp;the output of <code class="docutils literal"><span class="pre">znstar</span></code> or <code class="docutils literal"><span class="pre">bnrinit</span></code>. A character
on this group is given by a row vector <span class="math">\(a = [a_1,...,a_n]\)</span> such that
<span class="math">\(\chi(\prod g_j^{n_j}) = \exp(2\Pi i\sum a_j n_j / d_j)\)</span>, where <span class="math">\(g_j\)</span> denotes
the generator (of order <span class="math">\(d_j\)</span>) of the <span class="math">\(j\)</span>-th cyclic component.</p>
<p>Given two characters <span class="math">\(a\)</span> and <span class="math">\(b\)</span>, return the character
<span class="math">\(a / b = a \overline{b}\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? cyc = [15,5]; a = [1,1]; b = [2,4];
? chardiv(cyc, a,b)
%2 = [14, 2]
? bnf = bnfinit(x^2+23);
? bnf.cyc
%4 = [3]
? chardiv(bnf, [1], [2])
%5 = [2]
</pre></div>
</div>
<p>For Dirichlet characters on <span class="math">\((\mathbb{Z}/N\mathbb{Z})^*\)</span>, additional
representations are available (Conrey labels, Conrey logarithm),
see <code class="docutils literal"><span class="pre">dirichletchar</span></code> (in the PARI manual) or <code class="docutils literal"><span class="pre">??character</span></code>.
If the two characters are in the same format, the
result is given in the same format, otherwise a Conrey logarithm is used.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = idealstar(,100);
? G.cyc
%2 = [20, 2]
? a = [10, 1]; \\ usual representation for characters
? b = 7; \\ Conrey label;
? c = znconreylog(G, 11); \\ Conrey log
? chardiv(G, b,b)
%6 = 1 \\ Conrey label
? chardiv(G, a,b)
%7 = [0, 5]~ \\ Conrey log
? chardiv(G, a,c)
%7 = [0, 14]~ \\ Conrey log
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.chareval">
<code class="descname">chareval</code><span class="sig-paren">(</span><em>G</em>, <em>chi</em>, <em>x</em>, <em>z=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.chareval" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(G\)</span> be an abelian group structure affording a discrete logarithm
method, e.g <span class="math">\(G = idealstar(,N)\)</span> for <span class="math">\((\mathbb{Z}/N\mathbb{Z})^*\)</span> or a <code class="docutils literal"><span class="pre">bnr</span></code>
structure, let <span class="math">\(x\)</span> be an element of <span class="math">\(G\)</span> and let <em>chi</em> be a character of
<span class="math">\(G\)</span> (see the note below for details). This function returns the value of
<em>chi</em> at <span class="math">\(x\)</span>.</p>
<p><strong>Note on characters.</strong>
Let <span class="math">\(K\)</span> be some field. If <span class="math">\(G\)</span> is an abelian group,
let <span class="math">\(\chi: G \to K^*\)</span> be a character of finite order and let <span class="math">\(o\)</span> be a
multiple of the character order such that <span class="math">\(\chi(n) = \zeta^{c(n)}\)</span> for some
fixed <span class="math">\(\zeta belongs to K^*\)</span> of multiplicative order <span class="math">\(o\)</span> and a unique morphism <span class="math">\(c: G
\to (\mathbb{Z}/o\mathbb{Z},+)\)</span>. Our usual convention is to write</p>
<div class="math">
\[G = (\mathbb{Z}/o_1\mathbb{Z}) g_1 \oplus...\oplus (\mathbb{Z}/o_d\mathbb{Z}) g_d\]</div>
<p>for some generators <span class="math">\((g_i)\)</span> of respective order <span class="math">\(d_i\)</span>, where the group has
exponent <span class="math">\(o := {lcm}_i o_i\)</span>. Since <span class="math">\(\zeta^o = 1\)</span>, the vector <span class="math">\((c_i)\)</span> in
<span class="math">\(\prod (\mathbb{Z}/o_i\mathbb{Z})\)</span> defines a character <span class="math">\(\chi\)</span> on <span class="math">\(G\)</span> via <span class="math">\(\chi(g_i) = 
\zeta^{c_i (o/o_i)}\)</span> for all <span class="math">\(i\)</span>. Classical Dirichlet characters have values
in <span class="math">\(K = \mathbb{C}\)</span> and we can take <span class="math">\(\zeta = \exp(2i\Pi/o)\)</span>.</p>
<p><strong>Note on Dirichlet characters.</strong>
In the special case where <em>bid</em> is attached to <span class="math">\(G = (\mathbb{Z}/q\mathbb{Z})^*\)</span>
(as per <code class="docutils literal"><span class="pre">bid</span> <span class="pre">=</span> <span class="pre">idealstar(,q)</span></code>), the Dirichlet
character <em>chi</em> can be written in one of the usual 3 formats: a <code class="docutils literal"><span class="pre">t_VEC</span></code>
in terms of <code class="docutils literal"><span class="pre">bid.gen</span></code> as above, a <code class="docutils literal"><span class="pre">t_COL</span></code> in terms of the Conrey
generators, or a <code class="docutils literal"><span class="pre">t_INT</span></code> (Conrey label);
see <code class="docutils literal"><span class="pre">dirichletchar</span></code> (in the PARI manual) or <code class="docutils literal"><span class="pre">??character</span></code>.</p>
<p>The character value is encoded as follows, depending on the optional
argument <span class="math">\(z\)</span>:</p>
<ul class="simple">
<li>If <span class="math">\(z\)</span> is omitted: return the rational number <span class="math">\(c(x)/o\)</span> for <span class="math">\(x\)</span> coprime
to <span class="math">\(q\)</span>, where we normalize <span class="math">\(0 &lt;= c(x) &lt; o\)</span>. If <span class="math">\(x\)</span> can not be mapped to the
group (e.g. <span class="math">\(x\)</span> is not coprime to the conductor of a Dirichlet or Hecke
character) we return the sentinel value <span class="math">\(-1\)</span>.</li>
<li>If <span class="math">\(z\)</span> is an integer <span class="math">\(o\)</span>, then we assume that <span class="math">\(o\)</span> is a multiple of the
character order and we return the integer <span class="math">\(c(x)\)</span> when <span class="math">\(x\)</span> belongs
to the group, and the sentinel value <span class="math">\(-1\)</span> otherwise.</li>
<li><span class="math">\(z\)</span> can be of the form <span class="math">\([zeta, o]\)</span>, where <em>zeta</em>
is an <span class="math">\(o\)</span>-th root of <span class="math">\(1\)</span> and <span class="math">\(o\)</span> is a multiple of the character order.
We return <span class="math">\(\zeta^{c(x)}\)</span> if <span class="math">\(x\)</span> belongs to the group, and the sentinel
value <span class="math">\(0\)</span> otherwise. (Note that this coincides with the usual extension
of Dirichlet characters to <span class="math">\(\mathbb{Z}\)</span>, or of Hecke characters to general ideals.)</li>
<li>Finally, <span class="math">\(z\)</span> can be of the form <span class="math">\([vzeta, o]\)</span>, where
<em>vzeta</em> is a vector of powers <span class="math">\(\zeta^0,..., \zeta^{o-1}\)</span>
of some <span class="math">\(o\)</span>-th root of <span class="math">\(1\)</span> and <span class="math">\(o\)</span> is a multiple of the character order.
As above, we return <span class="math">\(\zeta^{c(x)}\)</span> after a table lookup. Or the sentinel
value <span class="math">\(0\)</span>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.charker">
<code class="descname">charker</code><span class="sig-paren">(</span><em>cyc</em>, <em>chi</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.charker" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <em>cyc</em> represent a finite abelian group by its elementary
divisors, i.e. <span class="math">\((d_j)\)</span> represents <span class="math">\(\sum_{j &lt;= k} \mathbb{Z}/d_j\mathbb{Z}\)</span> with <span class="math">\(d_k
| ... \| d_1\)</span>; any object which has a <code class="docutils literal"><span class="pre">.cyc</span></code> method is also
allowed, e.g.&nbsp;the output of <code class="docutils literal"><span class="pre">znstar</span></code> or <code class="docutils literal"><span class="pre">bnrinit</span></code>. A character
on this group is given by a row vector <span class="math">\(\chi = [a_1,...,a_n]\)</span> such that
<span class="math">\(\chi(\prod g_j^{n_j}) = \exp(2\Pi i\sum a_j n_j / d_j)\)</span>, where <span class="math">\(g_j\)</span> denotes
the generator (of order <span class="math">\(d_j\)</span>) of the <span class="math">\(j\)</span>-th cyclic component.</p>
<p>This function returns the kernel of <span class="math">\(\chi\)</span>, as a matrix <span class="math">\(K\)</span> in HNF which is a
left-divisor of <code class="docutils literal"><span class="pre">matdiagonal(d)</span></code>. Its columns express in terms of
the <span class="math">\(g_j\)</span> the generators of the subgroup. The determinant of <span class="math">\(K\)</span> is the
kernel index.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? cyc = [15,5]; chi = [1,1];
? charker(cyc, chi)
%2 =
[15 12]

[ 0 1]

? bnf = bnfinit(x^2+23);
? bnf.cyc
%4 = [3]
? charker(bnf, [1])
%5 =
[3]
</pre></div>
</div>
<p>Note that for Dirichlet characters (when <code class="docutils literal"><span class="pre">cyc</span></code> is
<code class="docutils literal"><span class="pre">idealstar(,q)</span></code>), characters in Conrey representation are available,
see <code class="docutils literal"><span class="pre">dirichletchar</span></code> (in the PARI manual) or <code class="docutils literal"><span class="pre">??character</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = idealstar(,8); \\ (Z/8Z)^*
? charker(G, 1) \\ Conrey label for trivial character
%2 =
[1 0]

[0 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.charmul">
<code class="descname">charmul</code><span class="sig-paren">(</span><em>cyc</em>, <em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.charmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <em>cyc</em> represent a finite abelian group by its elementary
divisors, i.e. <span class="math">\((d_j)\)</span> represents <span class="math">\(\sum_{j &lt;= k} \mathbb{Z}/d_j\mathbb{Z}\)</span> with <span class="math">\(d_k
| ... \| d_1\)</span>; any object which has a <code class="docutils literal"><span class="pre">.cyc</span></code> method is also
allowed, e.g.&nbsp;the output of <code class="docutils literal"><span class="pre">znstar</span></code> or <code class="docutils literal"><span class="pre">bnrinit</span></code>. A character
on this group is given by a row vector <span class="math">\(a = [a_1,...,a_n]\)</span> such that
<span class="math">\(\chi(\prod g_j^{n_j}) = \exp(2\Pi i\sum a_j n_j / d_j)\)</span>, where <span class="math">\(g_j\)</span> denotes
the generator (of order <span class="math">\(d_j\)</span>) of the <span class="math">\(j\)</span>-th cyclic component.</p>
<p>Given two characters <span class="math">\(a\)</span> and <span class="math">\(b\)</span>, return the product character <span class="math">\(ab\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? cyc = [15,5]; a = [1,1]; b = [2,4];
? charmul(cyc, a,b)
%2 = [3, 0]
? bnf = bnfinit(x^2+23);
? bnf.cyc
%4 = [3]
? charmul(bnf, [1], [2])
%5 = [0]
</pre></div>
</div>
<p>For Dirichlet characters on <span class="math">\((\mathbb{Z}/N\mathbb{Z})^*\)</span>, additional
representations are available (Conrey labels, Conrey logarithm), see
<code class="docutils literal"><span class="pre">dirichletchar</span></code> (in the PARI manual) or <code class="docutils literal"><span class="pre">??character</span></code>. If the two characters are in
the same format, their
product is given in the same format, otherwise a Conrey logarithm is used.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = idealstar(,100);
? G.cyc
%2 = [20, 2]
? a = [10, 1]; \\ usual representation for characters
? b = 7; \\ Conrey label;
? c = znconreylog(G, 11); \\ Conrey log
? charmul(G, b,b)
%6 = 49 \\ Conrey label
? charmul(G, a,b)
%7 = [0, 15]~ \\ Conrey log
? charmul(G, a,c)
%7 = [0, 6]~ \\ Conrey log
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.charorder">
<code class="descname">charorder</code><span class="sig-paren">(</span><em>cyc</em>, <em>chi</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.charorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <em>cyc</em> represent a finite abelian group by its elementary
divisors, i.e. <span class="math">\((d_j)\)</span> represents <span class="math">\(\sum_{j &lt;= k} \mathbb{Z}/d_j\mathbb{Z}\)</span> with <span class="math">\(d_k
| ... \| d_1\)</span>; any object which has a <code class="docutils literal"><span class="pre">.cyc</span></code> method is also
allowed, e.g.&nbsp;the output of <code class="docutils literal"><span class="pre">znstar</span></code> or <code class="docutils literal"><span class="pre">bnrinit</span></code>. A character
on this group is given by a row vector <span class="math">\(\chi = [a_1,...,a_n]\)</span> such that
<span class="math">\(\chi(\prod g_j^{n_j}) = \exp(2\Pi i\sum a_j n_j / d_j)\)</span>, where <span class="math">\(g_j\)</span> denotes
the generator (of order <span class="math">\(d_j\)</span>) of the <span class="math">\(j\)</span>-th cyclic component.</p>
<p>This function returns the order of the character <code class="docutils literal"><span class="pre">chi</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? cyc = [15,5]; chi = [1,1];
? charorder(cyc, chi)
%2 = 15
? bnf = bnfinit(x^2+23);
? bnf.cyc
%4 = [3]
? charorder(bnf, [1])
%5 = 3
</pre></div>
</div>
<p>For Dirichlet characters (when <code class="docutils literal"><span class="pre">cyc</span></code> is
<code class="docutils literal"><span class="pre">idealstar(,q)</span></code>), characters in Conrey representation are available,
see <code class="docutils literal"><span class="pre">dirichletchar</span></code> (in the PARI manual) or <code class="docutils literal"><span class="pre">??character</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = idealstar(,100); \\ (Z/100Z)^*
? charorder(G, 7) \\ Conrey label
%2 = 4
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.charpoly">
<code class="descname">charpoly</code><span class="sig-paren">(</span><em>A</em>, <em>v=None</em>, <em>flag=5</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.charpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>characteristic polynomial
of <span class="math">\(A\)</span> with respect to the variable <span class="math">\(v\)</span>, i.e.&nbsp;determinant of <span class="math">\(v*I-A\)</span> if <span class="math">\(A\)</span>
is a square matrix.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? charpoly([1,2;3,4]);
%1 = x^2 - 5*x - 2
? charpoly([1,2;3,4],, &#39;t)
%2 = t^2 - 5*t - 2
</pre></div>
</div>
<p>If <span class="math">\(A\)</span> is not a square matrix, the function returns the characteristic
polynomial of the map &#8220;multiplication by <span class="math">\(A\)</span>&#8221; if <span class="math">\(A\)</span> is a scalar:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? charpoly(Mod(x+2, x^3-2))
%1 = x^3 - 6*x^2 + 12*x - 10
? charpoly(I)
%2 = x^2 + 1
? charpoly(quadgen(5))
%3 = x^2 - x - 1
? charpoly(ffgen(ffinit(2,4)))
%4 = Mod(1, 2)*x^4 + Mod(1, 2)*x^3 + Mod(1, 2)*x^2 + Mod(1, 2)*x + Mod(1, 2)
</pre></div>
</div>
<p>The value of <span class="math">\(flag\)</span> is only significant for matrices, and we advise to stick
to the default value. Let <span class="math">\(n\)</span> be the dimension of <span class="math">\(A\)</span>.</p>
<p>If <span class="math">\(flag = 0\)</span>, same method (Le Verrier&#8217;s) as for computing the adjoint matrix,
i.e.&nbsp;using the traces of the powers of <span class="math">\(A\)</span>. Assumes that <span class="math">\(n!\)</span> is
invertible; uses <span class="math">\(O(n^4)\)</span> scalar operations.</p>
<p>If <span class="math">\(flag = 1\)</span>, uses Lagrange interpolation which is usually the slowest method.
Assumes that <span class="math">\(n!\)</span> is invertible; uses <span class="math">\(O(n^4)\)</span> scalar operations.</p>
<p>If <span class="math">\(flag = 2\)</span>, uses the Hessenberg form. Assumes that the base ring is a field.
Uses <span class="math">\(O(n^3)\)</span> scalar operations, but suffers from coefficient explosion
unless the base field is finite or <span class="math">\(\mathbb{R}\)</span>.</p>
<p>If <span class="math">\(flag = 3\)</span>, uses Berkowitz&#8217;s division free algorithm, valid over any
ring (commutative, with unit). Uses <span class="math">\(O(n^4)\)</span> scalar operations.</p>
<p>If <span class="math">\(flag = 4\)</span>, <span class="math">\(x\)</span> must be integral. Uses a modular algorithm: Hessenberg form
for various small primes, then Chinese remainders.</p>
<p>If <span class="math">\(flag = 5\)</span> (default), uses the &#8220;best&#8221; method given <span class="math">\(x\)</span>.
This means we use Berkowitz unless the base ring is <span class="math">\(\mathbb{Z}\)</span> (use <span class="math">\(flag = 4\)</span>)
or a field where coefficient explosion does not occur,
e.g.&nbsp;a finite field or the reals (use <span class="math">\(flag = 2\)</span>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.chinese">
<code class="descname">chinese</code><span class="sig-paren">(</span><em>x</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.chinese" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are both intmods or both polmods, creates (with the same
type) a <span class="math">\(z\)</span> in the same residue class as <span class="math">\(x\)</span> and in the same residue class as
<span class="math">\(y\)</span>, if it is possible.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? chinese(Mod(1,2), Mod(2,3))
%1 = Mod(5, 6)
? chinese(Mod(x,x^2-1), Mod(x+1,x^2+1))
%2 = Mod(-1/2*x^2 + x + 1/2, x^4 - 1)
</pre></div>
</div>
<p>This function also allows vector and matrix arguments, in which case the
operation is recursively applied to each component of the vector or matrix.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? chinese([Mod(1,2),Mod(1,3)], [Mod(1,5),Mod(2,7)])
%3 = [Mod(1, 10), Mod(16, 21)]
</pre></div>
</div>
<p>For polynomial arguments in the same variable, the function is applied to each
coefficient; if the polynomials have different degrees, the high degree terms
are copied verbatim in the result, as if the missing high degree terms in the
polynomial of lowest degree had been <code class="docutils literal"><span class="pre">Mod(0,1)</span></code>. Since the latter
behavior is usually <em>not</em> the desired one, we propose to convert the
polynomials to vectors of the same length first:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? P = x+1; Q = x^2+2*x+1;
? chinese(P*Mod(1,2), Q*Mod(1,3))
%4 = Mod(1, 3)*x^2 + Mod(5, 6)*x + Mod(3, 6)
? chinese(Vec(P,3)*Mod(1,2), Vec(Q,3)*Mod(1,3))
%5 = [Mod(1, 6), Mod(5, 6), Mod(4, 6)]
? Pol(%)
%6 = Mod(1, 6)*x^2 + Mod(5, 6)*x + Mod(4, 6)
</pre></div>
</div>
<p>If <span class="math">\(y\)</span> is omitted, and <span class="math">\(x\)</span> is a vector, <code class="docutils literal"><span class="pre">chinese</span></code> is applied recursively
to the components of <span class="math">\(x\)</span>, yielding a residue belonging to the same class as all
components of <span class="math">\(x\)</span>.</p>
<p>Finally <span class="math">\(chinese(x,x) = x\)</span> regardless of the type of <span class="math">\(x\)</span>; this allows
vector arguments to contain other data, so long as they are identical in both
vectors.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.cmp">
<code class="descname">cmp</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.cmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the result of a comparison between arbitrary objects <span class="math">\(x\)</span> and <span class="math">\(y\)</span>
(as <span class="math">\(-1\)</span>, <span class="math">\(0\)</span> or <span class="math">\(1\)</span>). The underlying order relation is transitive,
the function returns <span class="math">\(0\)</span> if and only if <span class="math">\(x&nbsp; === &nbsp;y\)</span>, and its
restriction to integers coincides with the customary one. Besides that,
it has no useful mathematical meaning.</p>
<p>In case all components are equal up to the smallest length of the operands,
the more complex is considered to be larger. More precisely, the longest is
the largest; when lengths are equal, we have matrix <span class="math">\(&gt;\)</span> vector <span class="math">\(&gt;\)</span> scalar.
For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? cmp(1, 2)
%1 = -1
? cmp(2, 1)
%2 = 1
? cmp(1, 1.0) \\ note that 1 == 1.0, but (1===1.0) is false.
%3 = -1
? cmp(x + Pi, [])
%4 = -1
</pre></div>
</div>
<p>This function is mostly useful to handle sorted lists or
vectors of arbitrary objects. For instance, if <span class="math">\(v\)</span> is a vector, the
construction <code class="docutils literal"><span class="pre">vecsort(v,</span> <span class="pre">cmp)</span></code> is equivalent to <code class="docutils literal"><span class="pre">Set(v)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.component">
<code class="descname">component</code><span class="sig-paren">(</span><em>x</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.component" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts the <span class="math">\(n-th\)</span>-component of <span class="math">\(x\)</span>. This is to be understood
as follows: every PARI type has one or two initial code words. The
components are counted, starting at 1, after these code words. In particular
if <span class="math">\(x\)</span> is a vector, this is indeed the <span class="math">\(n-th\)</span>-component of <span class="math">\(x\)</span>, if
<span class="math">\(x\)</span> is a matrix, the <span class="math">\(n-th\)</span> column, if <span class="math">\(x\)</span> is a polynomial, the
<span class="math">\(n-th\)</span> coefficient (i.e.&nbsp;of degree <span class="math">\(n-1\)</span>), and for power series,
the <span class="math">\(n-th\)</span> significant coefficient.</p>
<p>For polynomials and power series, one should rather use <code class="docutils literal"><span class="pre">polcoeff</span></code>, and
for vectors and matrices, the <code class="docutils literal"><span class="pre">[]</span></code> operator. Namely, if <span class="math">\(x\)</span> is a
vector, then <code class="docutils literal"><span class="pre">x[n]</span></code> represents the <span class="math">\(n-th\)</span> component of <span class="math">\(x\)</span>. If
<span class="math">\(x\)</span> is a matrix, <code class="docutils literal"><span class="pre">x[m,n]</span></code> represents the coefficient of row <code class="docutils literal"><span class="pre">m</span></code> and
column <code class="docutils literal"><span class="pre">n</span></code> of the matrix, <code class="docutils literal"><span class="pre">x[m,]</span></code> represents the <span class="math">\(m-th\)</span>
<em>row</em> of <span class="math">\(x\)</span>, and <code class="docutils literal"><span class="pre">x[,n]</span></code> represents the <span class="math">\(n-th\)</span>
<em>column</em> of <span class="math">\(x\)</span>.</p>
<p>Using of this function requires detailed knowledge of the structure of the
different PARI types, and thus it should almost never be used directly.
Some useful exceptions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? x = 3 + O(3^5);
? component(x, 2)
%2 = 81 \\ p^(p-adic accuracy)
? component(x, 1)
%3 = 3 \\ p
? q = Qfb(1,2,3);
? component(q, 1)
%5 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.concat">
<code class="descname">concat</code><span class="sig-paren">(</span><em>x</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenation of <span class="math">\(x\)</span> and <span class="math">\(y\)</span>. If <span class="math">\(x\)</span> or <span class="math">\(y\)</span> is
not a vector or matrix, it is considered as a one-dimensional vector. All
types are allowed for <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, but the sizes must be compatible. Note
that matrices are concatenated horizontally, i.e.&nbsp;the number of rows stays
the same. Using transpositions, one can concatenate them vertically,
but it is often simpler to use <code class="docutils literal"><span class="pre">matconcat</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? x = matid(2); y = 2*matid(2);
? concat(x,y)
%2 =
[1 0 2 0]

[0 1 0 2]
? concat(x~,y~)~
%3 =
[1 0]

[0 1]

[2 0]

[0 2]
? matconcat([x;y])
%4 =
[1 0]

[0 1]

[2 0]

[0 2]
</pre></div>
</div>
<p>To concatenate vectors sideways (i.e.&nbsp;to obtain a two-row or two-column
matrix), use <code class="docutils literal"><span class="pre">Mat</span></code> instead, or <code class="docutils literal"><span class="pre">matconcat</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? x = [1,2];
? y = [3,4];
? concat(x,y)
%3 = [1, 2, 3, 4]

? Mat([x,y]~)
%4 =
[1 2]

[3 4]
? matconcat([x;y])
%5 =
[1 2]

[3 4]
</pre></div>
</div>
<p>Concatenating a row vector to a matrix having the same number of columns will
add the row to the matrix (top row if the vector is <span class="math">\(x\)</span>, i.e.&nbsp;comes first, and
bottom row otherwise).</p>
<p>The empty matrix <code class="docutils literal"><span class="pre">[;]</span></code> is considered to have a number of rows compatible
with any operation, in particular concatenation. (Note that this is
<em>not</em> the case for empty vectors <code class="docutils literal"><span class="pre">[&nbsp;]</span></code> or <code class="docutils literal"><span class="pre">[&nbsp;]~</span></code>.)</p>
<p>If <span class="math">\(y\)</span> is omitted, <span class="math">\(x\)</span> has to be a row vector or a list, in which case its
elements are concatenated, from left to right, using the above rules.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? concat([1,2], [3,4])
%1 = [1, 2, 3, 4]
? a = [[1,2]~, [3,4]~]; concat(a)
%2 =
[1 3]

[2 4]

? concat([1,2; 3,4], [5,6]~)
%3 =
[1 2 5]

[3 4 6]
? concat([%, [7,8]~, [1,2,3,4]])
%5 =
[1 2 5 7]

[3 4 6 8]

[1 2 3 4]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.conj">
<code class="descname">conj</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Conjugate of <span class="math">\(x\)</span>. The meaning of this
is clear, except that for real quadratic numbers, it means conjugation in the
real quadratic field. This function has no effect on integers, reals,
intmods, fractions or <span class="math">\(p\)</span>-adics. The only forbidden type is polmod
(see <code class="docutils literal"><span class="pre">conjvec</span></code> for this).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.conjvec">
<code class="descname">conjvec</code><span class="sig-paren">(</span><em>z</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.conjvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Conjugate vector representation of <span class="math">\(z\)</span>. If <span class="math">\(z\)</span> is a
polmod, equal to <code class="docutils literal"><span class="pre">Mod</span></code><span class="math">\((a,T)\)</span>, this gives a vector of length
<span class="math">\({degree}(T)\)</span> containing:</p>
<ul class="simple">
<li>the complex embeddings of <span class="math">\(z\)</span> if <span class="math">\(T\)</span> has rational coefficients,
i.e.&nbsp;the <span class="math">\(a(r[i])\)</span> where <span class="math">\(r = polroots(T)\)</span>;</li>
<li>the conjugates of <span class="math">\(z\)</span> if <span class="math">\(T\)</span> has some intmod coefficients;</li>
</ul>
<p>if <span class="math">\(z\)</span> is a finite field element, the result is the vector of
conjugates <span class="math">\([z,z^p,z^{p^2},...,z^{p^{n-1}}]\)</span> where <span class="math">\(n = {degree}(T)\)</span>.</p>
<p>If <span class="math">\(z\)</span> is an integer or a rational number, the result is&nbsp;<span class="math">\(z\)</span>. If
<span class="math">\(z\)</span> is a (row or column) vector, the result is a matrix whose columns are
the conjugate vectors of the individual elements of <span class="math">\(z\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.content">
<code class="descname">content</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.content" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the gcd of all the coefficients of <span class="math">\(x\)</span>,
when this gcd makes sense. This is the natural definition
if <span class="math">\(x\)</span> is a polynomial (and by extension a power series) or a
vector/matrix. This is in general a weaker notion than the <em>ideal</em>
generated by the coefficients:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? content(2*x+y)
%1 = 1 \\ = gcd(2,y) over Q[y]
</pre></div>
</div>
<p>If <span class="math">\(x\)</span> is a scalar, this simply returns the absolute value of <span class="math">\(x\)</span> if <span class="math">\(x\)</span> is
rational (<code class="docutils literal"><span class="pre">t_INT</span></code> or <code class="docutils literal"><span class="pre">t_FRAC</span></code>), and either <span class="math">\(1\)</span> (inexact input) or <span class="math">\(x\)</span>
(exact input) otherwise; the result should be identical to <code class="docutils literal"><span class="pre">gcd(x,</span> <span class="pre">0)</span></code>.</p>
<p>The content of a rational function is the ratio of the contents of the
numerator and the denominator. In recursive structures, if a
matrix or vector <em>coefficient</em> <span class="math">\(x\)</span> appears, the gcd is taken
not with <span class="math">\(x\)</span>, but with its content:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? content([ [2], 4*matid(3) ])
%1 = 2
</pre></div>
</div>
<p>The content of a <code class="docutils literal"><span class="pre">t_VECSMALL</span></code> is computed assuming the
entries are signed integers in <span class="math">\([-2^{BIL-1}, 2^{BIL-1}[\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.contfrac">
<code class="descname">contfrac</code><span class="sig-paren">(</span><em>x</em>, <em>b=None</em>, <em>nmax=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.contfrac" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the row vector whose components are the partial quotients of the
continued fraction expansion of <span class="math">\(x\)</span>. In other words, a result
<span class="math">\([a_0,...,a_n]\)</span> means that <span class="math">\(x ~ a_0+1/(a_1+...+1/a_n)\)</span>. The
output is normalized so that <span class="math">\(a_n != 1\)</span> (unless we also have <span class="math">\(n = 0\)</span>).</p>
<p>The number of partial quotients <span class="math">\(n+1\)</span> is limited by <code class="docutils literal"><span class="pre">nmax</span></code>. If
<code class="docutils literal"><span class="pre">nmax</span></code> is omitted, the expansion stops at the last significant partial
quotient.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \p19
 realprecision = 19 significant digits
? contfrac(Pi)
%1 = [3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2]
? contfrac(Pi,, 3) \\ n = 2
%2 = [3, 7, 15]
</pre></div>
</div>
<p><span class="math">\(x\)</span> can also be a rational function or a power series.</p>
<p>If a vector <span class="math">\(b\)</span> is supplied, the numerators are equal to the coefficients
of <span class="math">\(b\)</span>, instead of all equal to <span class="math">\(1\)</span> as above; more precisely, <span class="math">\(x ~ 
(1/b_0)(a_0+b_1/(a_1+...+b_n/a_n))\)</span>; for a numerical continued fraction
(<span class="math">\(x\)</span> real), the <span class="math">\(a_i\)</span> are integers, as large as possible; if <span class="math">\(x\)</span> is a
rational function, they are polynomials with <span class="math">\(\deg a_i = \deg b_i + 1\)</span>.
The length of the result is then equal to the length of <span class="math">\(b\)</span>, unless the next
partial quotient cannot be reliably computed, in which case the expansion
stops. This happens when a partial remainder is equal to zero (or too small
compared to the available significant digits for <span class="math">\(x\)</span> a <code class="docutils literal"><span class="pre">t_REAL</span></code>).</p>
<p>A direct implementation of the numerical continued fraction
<code class="docutils literal"><span class="pre">contfrac(x,b)</span></code> described above would be</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>\\ &quot;greedy&quot; generalized continued fraction
cf(x, b) =
{ my( a= vector(#b), t );

 x *= b[1];
 for (i = 1, #b,
 a[i] = floor(x);
 t = x - a[i]; if (!t || i == #b, break);
 x = b[i+1] / t;
 ); a;
}
</pre></div>
</div>
<p>There is some degree of freedom when choosing the <span class="math">\(a_i\)</span>; the
program above can easily be modified to derive variants of the standard
algorithm. In the same vein, although no builtin
function implements the related Engel expansion (a special kind of
Egyptian fraction decomposition: <span class="math">\(x = 1/a_1 + 1/(a_1a_2) +...\)</span> ),
it can be obtained as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>\\ n terms of the Engel expansion of x
engel(x, n = 10) =
{ my( u = x, a = vector(n) );
 for (k = 1, n,
 a[k] = ceil(1/u);
 u = u*a[k] - 1;
 if (!u, break);
 ); a
}
</pre></div>
</div>
<p><strong>Obsolete hack.</strong> (don&#8217;t use this): If <span class="math">\(b\)</span> is an integer, <em>nmax</em>
is ignored and the command is understood as <code class="docutils literal"><span class="pre">contfrac(:math:`x,,</span> <span class="pre">b</span></code>)`.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.contfraceval">
<code class="descname">contfraceval</code><span class="sig-paren">(</span><em>CF</em>, <em>t</em>, <em>lim=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.contfraceval" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a continued fraction <code class="docutils literal"><span class="pre">CF</span></code> output by <code class="docutils literal"><span class="pre">contfracinit</span></code>, evaluate
the first <code class="docutils literal"><span class="pre">lim</span></code> terms of the continued fraction at <code class="docutils literal"><span class="pre">t</span></code> (all
terms if <code class="docutils literal"><span class="pre">lim</span></code> is negative or omitted; if positive, <code class="docutils literal"><span class="pre">lim</span></code> must be
less than or equal to the length of <code class="docutils literal"><span class="pre">CF</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.contfracinit">
<code class="descname">contfracinit</code><span class="sig-paren">(</span><em>M</em>, <em>lim=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.contfracinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <span class="math">\(M\)</span> representing the power series <span class="math">\(S = \sum_{n &gt;= 0} M[n+1]z^n\)</span>,
transform it into a continued fraction; restrict to <span class="math">\(n &lt;= lim\)</span>
if latter is non-negative. <span class="math">\(M\)</span> can be a vector, a power
series, a polynomial, or a rational function.
The result is a 2-component vector <span class="math">\([A,B]\)</span> such that
<span class="math">\(S = M[1] / (1+A[1]z+B[1]z^2/(1+A[2]z+B[2]z^2/(1+...1/(1+A[lim/2]z))))\)</span>.
Does not work if any coefficient of <span class="math">\(M\)</span> vanishes, nor for series for
which certain partial denominators vanish.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.contfracpnqn">
<code class="descname">contfracpnqn</code><span class="sig-paren">(</span><em>x</em>, <em>n=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.contfracpnqn" title="Permalink to this definition">¶</a></dt>
<dd><p>When <span class="math">\(x\)</span> is a vector or a one-row matrix, <span class="math">\(x\)</span>
is considered as the list of partial quotients <span class="math">\([a_0,a_1,...,a_n]\)</span> of a
rational number, and the result is the 2 by 2 matrix
<span class="math">\([p_n,p_{n-1};q_n,q_{n-1}]\)</span> in the standard notation of continued fractions,
so <span class="math">\(p_n/q_n = a_0+1/(a_1+...+1/a_n)\)</span>. If <span class="math">\(x\)</span> is a matrix with two rows
<span class="math">\([b_0,b_1,...,b_n]\)</span> and <span class="math">\([a_0,a_1,...,a_n]\)</span>, this is then considered as a
generalized continued fraction and we have similarly
<span class="math">\(p_n/q_n = (1/b_0)(a_0+b_1/(a_1+...+b_n/a_n))\)</span>. Note that in this case one
usually has <span class="math">\(b_0 = 1\)</span>.</p>
<p>If <span class="math">\(n &gt;= 0\)</span> is present, returns all convergents from <span class="math">\(p_0/q_0\)</span> up to
<span class="math">\(p_n/q_n\)</span>. (All convergents if <span class="math">\(x\)</span> is too small to compute the <span class="math">\(n+1\)</span>
requested convergents.)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? a=contfrac(Pi,20)
%1 = [3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2, 2, 2]
? contfracpnqn(a,3)
%2 =
[3 22 333 355]

[1 7 106 113]

? contfracpnqn(a,7)
%3 =
[3 22 333 355 103993 104348 208341 312689]

[1 7 106 113 33102 33215 66317 99532]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.core">
<code class="descname">core</code><span class="sig-paren">(</span><em>n</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.core" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(n\)</span> is an integer written as
<span class="math">\(n = df^2\)</span> with <span class="math">\(d\)</span> squarefree, returns <span class="math">\(d\)</span>. If <span class="math">\(flag\)</span> is non-zero,
returns the two-element row vector <span class="math">\([d,f]\)</span>. By convention, we write <span class="math">\(0 = 0
x 1^2\)</span>, so <code class="docutils literal"><span class="pre">core(0,</span> <span class="pre">1)</span></code> returns <span class="math">\([0,1]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.coredisc">
<code class="descname">coredisc</code><span class="sig-paren">(</span><em>n</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.coredisc" title="Permalink to this definition">¶</a></dt>
<dd><p>A <em>fundamental discriminant</em> is an integer of the form <span class="math">\(t = 1
mod 4\)</span> or <span class="math">\(4t = 8,12 mod 16\)</span>, with <span class="math">\(t\)</span> squarefree (i.e.&nbsp;<span class="math">\(1\)</span> or the
discriminant of a quadratic number field). Given a non-zero integer
<span class="math">\(n\)</span>, this routine returns the (unique) fundamental discriminant <span class="math">\(d\)</span>
such that <span class="math">\(n = df^2\)</span>, <span class="math">\(f\)</span> a positive rational number. If <span class="math">\(flag\)</span> is non-zero,
returns the two-element row vector <span class="math">\([d,f]\)</span>. If <span class="math">\(n\)</span> is congruent to
0 or 1 modulo 4, <span class="math">\(f\)</span> is an integer, and a half-integer otherwise.</p>
<p>By convention, <code class="docutils literal"><span class="pre">coredisc(0,</span> <span class="pre">1))</span></code> returns <span class="math">\([0,1]\)</span>.</p>
<p>Note that <code class="docutils literal"><span class="pre">quaddisc</span></code><span class="math">\((n)\)</span> returns the same value as <code class="docutils literal"><span class="pre">coredisc</span></code><span class="math">\((n)\)</span>,
and also works with rational inputs <span class="math">\(n belongs to \mathbb{Q}^*\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.cos">
<code class="descname">cos</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.cos" title="Permalink to this definition">¶</a></dt>
<dd><p>Cosine of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.cosh">
<code class="descname">cosh</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.cosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Hyperbolic cosine of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.cotan">
<code class="descname">cotan</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.cotan" title="Permalink to this definition">¶</a></dt>
<dd><p>Cotangent of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.cotanh">
<code class="descname">cotanh</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.cotanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Hyperbolic cotangent of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.denominator">
<code class="descname">denominator</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.denominator" title="Permalink to this definition">¶</a></dt>
<dd><p>Denominator of <span class="math">\(x\)</span>. The meaning of this
is clear when <span class="math">\(x\)</span> is a rational number or function. If <span class="math">\(x\)</span> is an integer
or a polynomial, it is treated as a rational number or function,
respectively, and the result is equal to <span class="math">\(1\)</span>. For polynomials, you
probably want to use</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">denominator</span><span class="p">(</span> <span class="n">content</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>instead. As for modular objects, <code class="docutils literal"><span class="pre">t_INTMOD</span></code> and <code class="docutils literal"><span class="pre">t_PADIC</span></code> have
denominator <span class="math">\(1\)</span>, and the denominator of a <code class="docutils literal"><span class="pre">t_POLMOD</span></code> is the denominator
of its (minimal degree) polynomial representative.</p>
<p>If <span class="math">\(x\)</span> is a recursive structure, for instance a vector or matrix, the lcm
of the denominators of its components (a common denominator) is computed.
This also applies for <code class="docutils literal"><span class="pre">t_COMPLEX</span></code>&nbsp;s and <code class="docutils literal"><span class="pre">t_QUAD</span></code>&nbsp;s.</p>
<p><strong>Warning.</strong> Multivariate objects are created according to variable
priorities, with possibly surprising side effects (<span class="math">\(x/y\)</span> is a polynomial, but
<span class="math">\(y/x\)</span> is a rational function). See <code class="docutils literal"><span class="pre">priority</span></code> (in the PARI manual).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.deriv">
<code class="descname">deriv</code><span class="sig-paren">(</span><em>x</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.deriv" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of <span class="math">\(x\)</span> with respect to the main
variable if <span class="math">\(v\)</span> is omitted, and with respect to <span class="math">\(v\)</span> otherwise. The derivative
of a scalar type is zero, and the derivative of a vector or matrix is done
componentwise. One can use <span class="math">\(x'\)</span> as a shortcut if the derivative is with
respect to the main variable of <span class="math">\(x\)</span>.</p>
<p>By definition, the main variable of a <code class="docutils literal"><span class="pre">t_POLMOD</span></code> is the main variable among
the coefficients from its two polynomial components (representative and
modulus); in other words, assuming a polmod represents an element of
<span class="math">\(R[X]/(T(X))\)</span>, the variable <span class="math">\(X\)</span> is a mute variable and the derivative is
taken with respect to the main variable used in the base ring <span class="math">\(R\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.diffop">
<code class="descname">diffop</code><span class="sig-paren">(</span><em>x</em>, <em>v</em>, <em>d</em>, <em>n=1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.diffop" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(v\)</span> be a vector of variables, and <span class="math">\(d\)</span> a vector of the same length,
return the image of <span class="math">\(x\)</span> by the <span class="math">\(n\)</span>-power (<span class="math">\(1\)</span> if n is not given) of the differential
operator <span class="math">\(D\)</span> that assumes the value <code class="docutils literal"><span class="pre">d[i]</span></code> on the variable <code class="docutils literal"><span class="pre">v[i]</span></code>.
The value of <span class="math">\(D\)</span> on a scalar type is zero, and <span class="math">\(D\)</span> applies componentwise to a vector
or matrix. When applied to a <code class="docutils literal"><span class="pre">t_POLMOD</span></code>, if no value is provided for the variable
of the modulus, such value is derived using the implicit function theorem.</p>
<p>Some examples:
This function can be used to differentiate formal expressions:
If <span class="math">\(E = \exp(X^2)\)</span> then we have <span class="math">\(E' = 2*X*E\)</span>. We can derivate <span class="math">\(X*exp(X^2)\)</span> as follow:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? diffop(E*X,[X,E],[1,2*X*E])
%1 = (2*X^2 + 1)*E
</pre></div>
</div>
<p>Let <code class="docutils literal"><span class="pre">Sin</span></code> and <code class="docutils literal"><span class="pre">Cos</span></code> be two function such that <span class="math">\(Sin^2+Cos^2 = 1\)</span>
and <span class="math">\(Cos' = -Sin\)</span>. We can differentiate <span class="math">\(Sin/Cos\)</span> as follow,
PARI inferring the value of <span class="math">\(Sin'\)</span> from the equation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? diffop(Mod(&#39;Sin/&#39;Cos,&#39;Sin^2+&#39;Cos^2-1),[&#39;Cos],[-&#39;Sin])
%1 = Mod(1/Cos^2, Sin^2 + (Cos^2 - 1))
</pre></div>
</div>
<p>Compute the Bell polynomials (both complete and partial) via the Faa di Bruno formula:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Bell</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span>
<span class="p">{</span>
 <span class="n">my</span><span class="p">(</span><span class="n">var</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="n">Str</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">)));</span>
 <span class="n">my</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">dv</span><span class="p">);</span>
 <span class="n">v</span><span class="o">=</span><span class="n">vector</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;E,var(i-1)));</span>
 <span class="n">dv</span><span class="o">=</span><span class="n">vector</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;X*var(1)*&#39;</span><span class="n">E</span><span class="p">,</span><span class="n">var</span><span class="p">(</span><span class="n">i</span><span class="p">)));</span>
 <span class="n">x</span><span class="o">=</span><span class="n">diffop</span><span class="p">(</span><span class="s1">&#39;E,v,dv,k)/&#39;</span><span class="n">E</span><span class="p">;</span>
 <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="n">subst</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s1">&#39;X,1),polcoeff(x,n,&#39;</span><span class="n">X</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.digits">
<code class="descname">digits</code><span class="sig-paren">(</span><em>x</em>, <em>b=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.digits" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the vector of the digits of <span class="math">\(\|x\|\)</span> in base <span class="math">\(b\)</span>, where <span class="math">\(x\)</span> and <span class="math">\(b\)</span> are
integers (<span class="math">\(b = 10\)</span> by default). See <code class="docutils literal"><span class="pre">fromdigits</span></code> for the reverse
operation.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? digits(123)
%1 = [1, 2, 3, 0]

? digits(10, 2) \\ base 2
%2 = [1, 0, 1, 0]
</pre></div>
</div>
<p>By convention, <span class="math">\(0\)</span> has no digits:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? digits(0)
%3 = []
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.dilog">
<code class="descname">dilog</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.dilog" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of the dilogarithm of <span class="math">\(x\)</span>,
i.e.&nbsp;analytic continuation of the power series <span class="math">\(\log_2(x) = \sum_{n &gt;= 1}x^n/n^2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.dirdiv">
<code class="descname">dirdiv</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.dirdiv" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> and <span class="math">\(y\)</span> being vectors of perhaps different
lengths but with <span class="math">\(y[1] != 0\)</span> considered as Dirichlet series, computes
the quotient of <span class="math">\(x\)</span> by <span class="math">\(y\)</span>, again as a vector.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.dirmul">
<code class="descname">dirmul</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.dirmul" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> and <span class="math">\(y\)</span> being vectors of perhaps different lengths representing
the Dirichlet series <span class="math">\(\sum_n x_n n^{-s}\)</span> and <span class="math">\(\sum_n y_n n^{-s}\)</span>,
computes the product of <span class="math">\(x\)</span> by <span class="math">\(y\)</span>, again as a vector.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? dirmul(vector(10,n,1), vector(10,n,moebius(n)))
%1 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</pre></div>
</div>
<p>The product
length is the minimum of <span class="math">\(\#&nbsp;x*&nbsp;v(y)\)</span> and <span class="math">\(\#&nbsp;y*&nbsp;v(x)\)</span>,
where <span class="math">\(v(x)\)</span> is the index of the first non-zero coefficient.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? dirmul([0,1], [0,1]);
%2 = [0, 0, 0, 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.dirzetak">
<code class="descname">dirzetak</code><span class="sig-paren">(</span><em>nf</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.dirzetak" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives as a vector the first <span class="math">\(b\)</span>
coefficients of the Dedekind zeta function of the number field <span class="math">\(nf\)</span>
considered as a Dirichlet series.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.divisors">
<code class="descname">divisors</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.divisors" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a row vector whose components are the
divisors of <span class="math">\(x\)</span>. The factorization of <span class="math">\(x\)</span> (as output by <code class="docutils literal"><span class="pre">factor</span></code>) can
be used instead.</p>
<p>By definition, these divisors are the products of the irreducible
factors of <span class="math">\(n\)</span>, as produced by <code class="docutils literal"><span class="pre">factor(n)</span></code>, raised to appropriate
powers (no negative exponent may occur in the factorization). If <span class="math">\(n\)</span> is
an integer, they are the positive divisors, in increasing order.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.divrem">
<code class="descname">divrem</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.divrem" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a column vector with two components, the first being the Euclidean
quotient (<code class="docutils literal"><span class="pre">:math:`x</span></code> \:math:<span class="math">\(y`\)</span>), the second the Euclidean remainder
(<code class="docutils literal"><span class="pre">:math:`x</span></code> - (<span class="math">\(x\)</span>\:math:<span class="math">\(y\)</span>)*:math:<span class="math">\(y`\)</span>), of the division of <span class="math">\(x\)</span> by <span class="math">\(y\)</span>. This avoids the
need to do two divisions if one needs both the quotient and the remainder.
If <span class="math">\(v\)</span> is present, and <span class="math">\(x\)</span>, <span class="math">\(y\)</span> are multivariate
polynomials, divide with respect to the variable <span class="math">\(v\)</span>.</p>
<p>Beware that <code class="docutils literal"><span class="pre">divrem(:math:`x</span></code>,:math:<span class="math">\(y\)</span>)[2]` is in general not the same as
<code class="docutils literal"><span class="pre">:math:`x</span></code> % <span class="math">\(y`\)</span>; no GP operator corresponds to it:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? divrem(1/2, 3)[2]
%1 = 1/2
? (1/2) % 3
%2 = 2
? divrem(Mod(2,9), 3)[2]
 *** at top-level: divrem(Mod(2,9),3)[2
 *** ^--------------------
 *** forbidden division t_INTMOD \ t_INT.
? Mod(2,9) % 6
%3 = Mod(2,3)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.eint1">
<code class="descname">eint1</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.eint1" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential integral <span class="math">\(\int_x^ oo (e^{-t})/(t)dt = 
incgam(0, x)\)</span>, where the latter expression extends the function
definition from real <span class="math">\(x &gt; 0\)</span> to all complex <span class="math">\(x != 0\)</span>.</p>
<p>If <span class="math">\(n\)</span> is present, we must have <span class="math">\(x &gt; 0\)</span>; the function returns the
<span class="math">\(n\)</span>-dimensional vector <span class="math">\([eint1(x),...,eint1(nx)]\)</span>. Contrary to
other transcendental functions, and to the default case (<span class="math">\(n\)</span> omitted), the
values are correct up to a bounded <em>absolute</em>, rather than relative,
error <span class="math">\(10^{-n}\)</span>, where <span class="math">\(n\)</span> is <code class="docutils literal"><span class="pre">precision</span></code><span class="math">\((x)\)</span> if <span class="math">\(x\)</span> is a <code class="docutils literal"><span class="pre">t_REAL</span></code>
and defaults to <code class="docutils literal"><span class="pre">realprecision</span></code> otherwise. (In the most important
application, to the computation of <span class="math">\(L\)</span>-functions via approximate functional
equations, those values appear as weights in long sums and small individual
relative errors are less useful than controlling the absolute error.) This is
faster than repeatedly calling <code class="docutils literal"><span class="pre">eint1(:math:`i</span></code> * x)`, but less precise.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellL1">
<code class="descname">ellL1</code><span class="sig-paren">(</span><em>e</em>, <em>r=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellL1" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value at <span class="math">\(s = 1\)</span> of the derivative of order <span class="math">\(r\)</span> of the
<span class="math">\(L\)</span>-function of the elliptic curve <span class="math">\(e\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? e = ellinit(&quot;11a1&quot;); \\ order of vanishing is 0
? ellL1(e)
%2 = 0.2538418608559106843377589233
? e = ellinit(&quot;389a1&quot;); \\ order of vanishing is 2
? ellL1(e)
%4 = -5.384067311837218089235032414 E-29
? ellL1(e, 1)
%5 = 0
? ellL1(e, 2)
%6 = 1.518633000576853540460385214
</pre></div>
</div>
<p>The main use of this function, after computing at <em>low</em> accuracy the
order of vanishing using <code class="docutils literal"><span class="pre">ellanalyticrank</span></code>, is to compute the
leading term at <em>high</em> accuracy to check (or use) the Birch and
Swinnerton-Dyer conjecture:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \p18
 realprecision = 18 significant digits
? e = ellinit(&quot;5077a1&quot;); ellanalyticrank(e)
time = 8 ms.
%1 = [3, 10.3910994007158041]
? \p200
 realprecision = 202 significant digits (200 digits displayed)
? ellL1(e, 3)
time = 104 ms.
%3 = 10.3910994007158041387518505103609170697263563756570092797[...]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elladd">
<code class="descname">elladd</code><span class="sig-paren">(</span><em>E</em>, <em>z1</em>, <em>z2</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elladd" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of the points <span class="math">\(z1\)</span> and <span class="math">\(z2\)</span> on the
elliptic curve corresponding to <span class="math">\(E\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellak">
<code class="descname">ellak</code><span class="sig-paren">(</span><em>E</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellak" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the coefficient <span class="math">\(a_n\)</span> of the <span class="math">\(L\)</span>-function of the elliptic curve
<span class="math">\(E/\mathbb{Q}\)</span>, i.e.&nbsp;coefficients of a newform of weight 2 by the modularity theorem
(Taniyama-Shimura-Weil conjecture). <span class="math">\(E\)</span> must be an <code class="docutils literal"><span class="pre">ell</span></code> structure
over <span class="math">\(\mathbb{Q}\)</span> as output by <code class="docutils literal"><span class="pre">ellinit</span></code>. <span class="math">\(E\)</span> must be given by an integral model,
not necessarily minimal, although a minimal model will make the function
faster.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([0,1]);
? ellak(E, 10)
%2 = 0
? e = ellinit([5^4,5^6]); \\ not minimal at 5
? ellak(e, 5) \\ wasteful but works
%3 = -3
? E = ellminimalmodel(e); \\ now minimal
? ellak(E, 5)
%5 = -3
</pre></div>
</div>
<p>If the model is not minimal at a number of bad primes, then
the function will be slower on those <span class="math">\(n\)</span> divisible by the bad primes.
The speed should be comparable for other <span class="math">\(n\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? for(i=1,10^6, ellak(E,5))
time = 820 ms.
? for(i=1,10^6, ellak(e,5)) \\ 5 is bad, markedly slower
time = 1,249 ms.

? for(i=1,10^5,ellak(E,5*i))
time = 977 ms.
? for(i=1,10^5,ellak(e,5*i)) \\ still slower but not so much on average
time = 1,008 ms.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellan">
<code class="descname">ellan</code><span class="sig-paren">(</span><em>E</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellan" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the vector of the first <span class="math">\(n\)</span> Fourier coefficients <span class="math">\(a_k\)</span>
corresponding to the elliptic curve <span class="math">\(E\)</span>. The curve must be given by an
integral model, not necessarily minimal, although a minimal model will make
the function faster.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellanalyticrank">
<code class="descname">ellanalyticrank</code><span class="sig-paren">(</span><em>e</em>, <em>eps=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellanalyticrank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the order of vanishing at <span class="math">\(s = 1\)</span> of the <span class="math">\(L\)</span>-function of the
elliptic curve <span class="math">\(e\)</span> and the value of the first non-zero derivative. To
determine this order, it is assumed that any value less than <code class="docutils literal"><span class="pre">eps</span></code> is
zero. If no value of <code class="docutils literal"><span class="pre">eps</span></code> is given, a value of half the current
precision is used.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? e = ellinit(&quot;11a1&quot;); \\ rank 0
? ellanalyticrank(e)
%2 = [0, 0.2538418608559106843377589233]
? e = ellinit(&quot;37a1&quot;); \\ rank 1
? ellanalyticrank(e)
%4 = [1, 0.3059997738340523018204836835]
? e = ellinit(&quot;389a1&quot;); \\ rank 2
? ellanalyticrank(e)
%6 = [2, 1.518633000576853540460385214]
? e = ellinit(&quot;5077a1&quot;); \\ rank 3
? ellanalyticrank(e)
%8 = [3, 10.39109940071580413875185035]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellap">
<code class="descname">ellap</code><span class="sig-paren">(</span><em>E</em>, <em>p=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellap" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(E\)</span> be an <code class="docutils literal"><span class="pre">ell</span></code> structure as output by <code class="docutils literal"><span class="pre">ellinit</span></code>, defined over
<span class="math">\(\mathbb{Q}\)</span> or a finite field <span class="math">\(\mathbb{F}_q\)</span>. The argument <span class="math">\(p\)</span> is best left omitted if the
curve is defined over a finite field, and must be a prime number otherwise.
This function computes the trace of Frobenius <span class="math">\(t\)</span> for the elliptic curve <span class="math">\(E\)</span>,
defined by the equation <span class="math">\(\#E(\mathbb{F}_q) = q+1 - t\)</span>.</p>
<p>When the characteristic of the finite field is large, the availability of
the <code class="docutils literal"><span class="pre">seadata</span></code> package will speed the computation.</p>
<p>If the curve is defined over <span class="math">\(\mathbb{Q}\)</span>, <span class="math">\(p\)</span> must be explicitly given and the
function computes the trace of the reduction over <span class="math">\(\mathbb{F}_p\)</span>.
The trace of Frobenius is also the <span class="math">\(a_p\)</span> coefficient in the curve <span class="math">\(L\)</span>-series
<span class="math">\(L(E,s) = \sum_n a_n n^{-s}\)</span>, whence the function name. The equation must be
integral at <span class="math">\(p\)</span> but need not be minimal at <span class="math">\(p\)</span>; of course, a minimal model
will be more efficient.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([0,1]); \\ y^2 = x^3 + 0.x + 1, defined over Q
? ellap(E, 7) \\ 7 necessary here
%2 = -4 \\ #E(F_7) = 7+1-(-4) = 12
? ellcard(E, 7)
%3 = 12 \\ OK

? E = ellinit([0,1], 11); \\ defined over F_11
? ellap(E) \\ no need to repeat 11
%4 = 0
? ellap(E, 11) \\ ... but it also works
%5 = 0
? ellgroup(E, 13) \\ ouch, inconsistent input!
 *** at top-level: ellap(E,13)
 *** ^-----------
 *** ellap: inconsistent moduli in Rg_to_Fp:
 11
 13

? Fq = ffgen(ffinit(11,3), &#39;a); \\ defines F_q := F_{11^3}
? E = ellinit([a+1,a], Fq); \\ y^2 = x^3 + (a+1)x + a, defined over F_q
? ellap(E)
%8 = -3
</pre></div>
</div>
<p><strong>Algorithms used.</strong> If <span class="math">\(E/\mathbb{F}_q\)</span> has CM by a principal imaginary
quadratic order we use a fast explicit formula (involving essentially
Kronecker symbols and Cornacchia&#8217;s algorithm), in <span class="math">\(O(\log q)^2\)</span>.
Otherwise, we use Shanks-Mestre&#8217;s baby-step/giant-step method, which runs in
time <span class="math">\(~{O}(q^{1/4})\)</span> using <span class="math">\(~{O}(q^{1/4})\)</span> storage, hence becomes
unreasonable when <span class="math">\(q\)</span> has about 30&nbsp;digits. Above this range, the <code class="docutils literal"><span class="pre">SEA</span></code>
algorithm becomes available, heuristically in <span class="math">\(~{O}(\log q)^4\)</span>, and
primes of the order of 200&nbsp;digits become feasible. In small
characteristic we use Mestre&#8217;s (p = 2), Kohel&#8217;s (p = 3,5,7,13), Satoh-Harley
(all in <span class="math">\(~{O}(p^{2} n^2)\)</span>) or Kedlaya&#8217;s (in <span class="math">\(~{O}(p n^3)\)</span>)
algorithms.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellbil">
<code class="descname">ellbil</code><span class="sig-paren">(</span><em>E</em>, <em>z1</em>, <em>z2</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellbil" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated alias for <code class="docutils literal"><span class="pre">ellheight(E,P,Q)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellcard">
<code class="descname">ellcard</code><span class="sig-paren">(</span><em>E</em>, <em>p=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellcard" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(E\)</span> be an <code class="docutils literal"><span class="pre">ell</span></code> structure as output by <code class="docutils literal"><span class="pre">ellinit</span></code>, defined over
<span class="math">\(\mathbb{Q}\)</span> or a finite field <span class="math">\(\mathbb{F}_q\)</span>. The argument <span class="math">\(p\)</span> is best left omitted if the
curve is defined over a finite field, and must be a prime number otherwise.
This function computes the order of the group <span class="math">\(E(\mathbb{F}_q)\)</span> (as would be
computed by <code class="docutils literal"><span class="pre">ellgroup</span></code>).</p>
<p>When the characteristic of the finite field is large, the availability of
the <code class="docutils literal"><span class="pre">seadata</span></code> package will speed the computation.</p>
<p>If the curve is defined over <span class="math">\(\mathbb{Q}\)</span>, <span class="math">\(p\)</span> must be explicitly given and the
function computes the cardinality of the reduction over <span class="math">\(\mathbb{F}_p\)</span>; the
equation need not be minimal at <span class="math">\(p\)</span>, but a minimal model will be more
efficient. The reduction is allowed to be singular, and we return the order
of the group of non-singular points in this case.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellchangecurve">
<code class="descname">ellchangecurve</code><span class="sig-paren">(</span><em>E</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellchangecurve" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the data for the elliptic curve <span class="math">\(E\)</span>
by changing the coordinates using the vector <code class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">[u,r,s,t]</span></code>, i.e.&nbsp;if <span class="math">\(x'\)</span>
and <span class="math">\(y'\)</span> are the new coordinates, then <span class="math">\(x = u^2x'+r\)</span>, <span class="math">\(y = u^3y'+su^2x'+t\)</span>.
<span class="math">\(E\)</span> must be an <code class="docutils literal"><span class="pre">ell</span></code> structure as output by <code class="docutils literal"><span class="pre">ellinit</span></code>. The special
case <span class="math">\(v = 1\)</span> is also used instead of <span class="math">\([1,0,0,0]\)</span> to denote the
trivial coordinate change.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellchangepoint">
<code class="descname">ellchangepoint</code><span class="sig-paren">(</span><em>x</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellchangepoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the coordinates of the point or
vector of points <span class="math">\(x\)</span> using the vector <code class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">[u,r,s,t]</span></code>, i.e.&nbsp;if <span class="math">\(x'\)</span> and
<span class="math">\(y'\)</span> are the new coordinates, then <span class="math">\(x = u^2x'+r\)</span>, <span class="math">\(y = u^3y'+su^2x'+t\)</span> (see also
<code class="docutils literal"><span class="pre">ellchangecurve</span></code>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E0 = ellinit([1,1]); P0 = [0,1]; v = [1,2,3,4];
? E = ellchangecurve(E0, v);
? P = ellchangepoint(P0,v)
%3 = [-2, 3]
? ellisoncurve(E, P)
%4 = 1
? ellchangepointinv(P,v)
%5 = [0, 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellchangepointinv">
<code class="descname">ellchangepointinv</code><span class="sig-paren">(</span><em>x</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellchangepointinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the coordinates of the point or vector of points <span class="math">\(x\)</span> using
the inverse of the isomorphism associated to <code class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">[u,r,s,t]</span></code>,
i.e.&nbsp;if <span class="math">\(x'\)</span> and <span class="math">\(y'\)</span> are the old coordinates, then <span class="math">\(x = u^2x'+r\)</span>,
<span class="math">\(y = u^3y'+su^2x'+t\)</span> (inverse of <code class="docutils literal"><span class="pre">ellchangepoint</span></code>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E0 = ellinit([1,1]); P0 = [0,1]; v = [1,2,3,4];
? E = ellchangecurve(E0, v);
? P = ellchangepoint(P0,v)
%3 = [-2, 3]
? ellisoncurve(E, P)
%4 = 1
? ellchangepointinv(P,v)
%5 = [0, 1] \\ we get back P0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellconvertname">
<code class="descname">ellconvertname</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellconvertname" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an elliptic curve name, as found in the <code class="docutils literal"><span class="pre">elldata</span></code> database,
from a string to a triplet <span class="math">\([conductor, isogeny class,
index]\)</span>. It will also convert a triplet back to a curve name.
Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? ellconvertname(&quot;123b1&quot;)
%1 = [123, 1, 1]
? ellconvertname(%)
%2 = &quot;123b1&quot;
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elldivpol">
<code class="descname">elldivpol</code><span class="sig-paren">(</span><em>E</em>, <em>n</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elldivpol" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(n\)</span>-division polynomial <span class="math">\(f_n\)</span> for the curve <span class="math">\(E\)</span> in the
variable <span class="math">\(v\)</span>. In standard notation, for any affine point <span class="math">\(P = (X,Y)\)</span> on the
curve, we have</p>
<div class="math">
\[[n]P = (\phi_n(P)\psi_n(P) : \omega_n(P) : \psi_n(P)^3)\]</div>
<p>for some polynomials <span class="math">\(\phi_n,\omega_n,\psi_n\)</span> in
<span class="math">\(\mathbb{Z}[a_1,a_2,a_3,a_4,a_6][X,Y]\)</span>. We have <span class="math">\(f_n(X) = \psi_n(X)\)</span> for <span class="math">\(n\)</span> odd, and
<span class="math">\(f_n(X) = \psi_n(X,Y) (2Y + a_1X+a_3)\)</span> for <span class="math">\(n\)</span> even. We have</p>
<div class="math">
\[f_1 = 1, f_2 = 4X^3 + b_2X^2 + 2b_4 X + b_6, f_3 = 3 X^4 + b_2 X^3 + 3b_4 X^2 + 3 b_6 X + b8,\]</div>
<div class="math">
\[f_4 = f_2(2X^6 + b_2 X^5 + 5b_4 X^4 + 10 b_6 X^3 + 10 b_8 X^2 +
(b_2b_8-b_4b_6)X + (b_8b_4 - b_6^2)),...\]</div>
<p>For <span class="math">\(n &gt;= 2\)</span>, the roots of <span class="math">\(f_n\)</span> are the <span class="math">\(X\)</span>-coordinates of points in <span class="math">\(E[n]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elleisnum">
<code class="descname">elleisnum</code><span class="sig-paren">(</span><em>w</em>, <em>k</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elleisnum" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(k\)</span> being an even positive integer, computes the numerical value of the
Eisenstein series of weight <span class="math">\(k\)</span> at the lattice <span class="math">\(w\)</span>, as given by
<code class="docutils literal"><span class="pre">ellperiods</span></code>, namely</p>
<div class="math">
\[(2i \Pi/\omega_2)^k
(1 + 2/\zeta(1-k) \sum_{n &gt;= 1} n^{k-1}q^n / (1-q^n)),\]</div>
<p>where <span class="math">\(q = \exp(2i\Pi \tau)\)</span> and <span class="math">\(\tau := \omega_1/\omega_2\)</span> belongs to the
complex upper half-plane. It is also possible to directly input <span class="math">\(w = 
[\omega_1,\omega_2]\)</span>, or an elliptic curve <span class="math">\(E\)</span> as given by <code class="docutils literal"><span class="pre">ellinit</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? w = ellperiods([1,I]);
? elleisnum(w, 4)
%2 = 2268.8726415508062275167367584190557607
? elleisnum(w, 6)
%3 = -3.977978632282564763 E-33
? E = ellinit([1, 0]);
? elleisnum(E, 4, 1)
%5 = -47.999999999999999999999999999999999998
</pre></div>
</div>
<p>When <em>flag</em> is non-zero and <span class="math">\(k = 4\)</span> or 6, returns the elliptic invariants <span class="math">\(g_2\)</span>
or <span class="math">\(g_3\)</span>, such that</p>
<div class="math">
\[y^2 = 4x^3 - g_2 x - g_3\]</div>
<p>is a Weierstrass equation for <span class="math">\(E\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elleta">
<code class="descname">elleta</code><span class="sig-paren">(</span><em>w</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elleta" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the quasi-periods <span class="math">\([\eta_1,\eta_2]\)</span>
associated to the lattice basis <span class="math">\(w = [\omega_1, \omega_2]\)</span>.
Alternatively, <em>w</em> can be an elliptic curve <span class="math">\(E\)</span> as output by
<code class="docutils literal"><span class="pre">ellinit</span></code>, in which case, the quasi periods associated to the period
lattice basis <code class="docutils literal"><span class="pre">:math:`E</span></code>.omega` (namely, <code class="docutils literal"><span class="pre">:math:`E</span></code>.eta`) are returned.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? elleta([1, I])
%1 = [3.141592653589793238462643383, 9.424777960769379715387930149*I]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellformaldifferential">
<code class="descname">ellformaldifferential</code><span class="sig-paren">(</span><em>E</em>, <em>serprec=-1</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellformaldifferential" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(\omega := dx / (2y+a_1x+a_3)\)</span> be the invariant differential form
associated to the model <span class="math">\(E\)</span> of some elliptic curve (<code class="docutils literal"><span class="pre">ellinit</span></code> form),
and <span class="math">\(\eta := x(t)\omega\)</span>. Return <span class="math">\(n\)</span> terms (<code class="docutils literal"><span class="pre">seriesprecision</span></code> by default)
of <span class="math">\(f(t),g(t)\)</span> two power series in the formal parameter <span class="math">\(t = -x/y\)</span> such that
<span class="math">\(\omega = f(t) dt\)</span>, <span class="math">\(\eta = g(t) dt\)</span>:</p>
<div class="math">
\[f(t) = 1+a_1 t + (a_1^2 + a_2) t^2 +..., 
g(t) = t^{-2} +...\]</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([-1,1/4]); [f,g] = ellformaldifferential(E,7,&#39;t);
? f
%2 = 1 - 2*t^4 + 3/4*t^6 + O(t^7)
? g
%3 = t^-2 - t^2 + 1/2*t^4 + O(t^5)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellformalexp">
<code class="descname">ellformalexp</code><span class="sig-paren">(</span><em>E</em>, <em>serprec=-1</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellformalexp" title="Permalink to this definition">¶</a></dt>
<dd><p>The elliptic formal exponential <code class="docutils literal"><span class="pre">Exp</span></code> attached to <span class="math">\(E\)</span> is the
isomorphism from the formal additive law to the formal group of <span class="math">\(E\)</span>. It is
normalized so as to be the inverse of the elliptic logarithm (see
<code class="docutils literal"><span class="pre">ellformallog</span></code>): <span class="math">\(Exp o L = \mathrm{Id}\)</span>. Return <span class="math">\(n\)</span> terms of this
power series:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E=ellinit([-1,1/4]); Exp = ellformalexp(E,10,&#39;z)
%1 = z + 2/5*z^5 - 3/28*z^7 + 2/15*z^9 + O(z^11)
? L = ellformallog(E,10,&#39;t);
? subst(Exp,z,L)
%3 = t + O(t^11)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellformallog">
<code class="descname">ellformallog</code><span class="sig-paren">(</span><em>E</em>, <em>serprec=-1</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellformallog" title="Permalink to this definition">¶</a></dt>
<dd><p>The formal elliptic logarithm is a series <span class="math">\(L\)</span> in <span class="math">\(t K[[t]]\)</span>
such that <span class="math">\(d L = \omega = dx / (2y + a_1x + a_3)\)</span>, the canonical invariant
differential attached to the model <span class="math">\(E\)</span>. It gives an isomorphism
from the formal group of <span class="math">\(E\)</span> to the additive formal group.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([-1,1/4]); L = ellformallog(E, 9, &#39;t)
%1 = t - 2/5*t^5 + 3/28*t^7 + 2/3*t^9 + O(t^10)
? [f,g] = ellformaldifferential(E,8,&#39;t);
? L&#39; - f
%3 = O(t^8)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellformalpoint">
<code class="descname">ellformalpoint</code><span class="sig-paren">(</span><em>E</em>, <em>serprec=-1</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellformalpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(E\)</span> is an elliptic curve, return the coordinates <span class="math">\(x(t), y(t)\)</span> in the
formal group of the elliptic curve <span class="math">\(E\)</span> in the formal parameter <span class="math">\(t = -x/y\)</span>
at <span class="math">\(oo\)</span>:</p>
<div class="math">
\[x = t^{-2} -a_1 t^{-1} - a_2 - a_3 t +...\]</div>
<div class="math">
\[y = - t^{-3} -a_1 t^{-2} - a_2t^{-1} -a_3 +...\]</div>
<p>Return <span class="math">\(n\)</span> terms (<code class="docutils literal"><span class="pre">seriesprecision</span></code> by default) of these two power
series, whose coefficients are in <span class="math">\(\mathbb{Z}[a_1,a_2,a_3,a_4,a_6]\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([0,0,1,-1,0]); [x,y] = ellformalpoint(E,8,&#39;t);
? x
%2 = t^-2 - t + t^2 - t^4 + 2*t^5 + O(t^6)
? y
%3 = -t^-3 + 1 - t + t^3 - 2*t^4 + O(t^5)
? E = ellinit([0,1/2]); ellformalpoint(E,7)
%4 = [x^-2 - 1/2*x^4 + O(x^5), -x^-3 + 1/2*x^3 + O(x^4)]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellformalw">
<code class="descname">ellformalw</code><span class="sig-paren">(</span><em>E</em>, <em>serprec=-1</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellformalw" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the formal power series <span class="math">\(w\)</span> associated to the elliptic curve <span class="math">\(E\)</span>,
in the variable <span class="math">\(t\)</span>:</p>
<div class="math">
\[w(t) = t^3 + a_1 t^4 + (a_2 + a_1^2) t^5 +...+ O(t^{n+3}),\]</div>
<p>which is the formal expansion of <span class="math">\(-1/y\)</span> in the formal parameter <span class="math">\(t := -x/y\)</span>
at <span class="math">\(oo\)</span> (take <span class="math">\(n = seriesprecision\)</span> if <span class="math">\(n\)</span> is omitted). The
coefficients of <span class="math">\(w\)</span> belong to <span class="math">\(\mathbb{Z}[a_1,a_2,a_3,a_4,a_6]\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E=ellinit([3,2,-4,-2,5]); ellformalw(E, 5, &#39;t)
%1 = t^3 + 3*t^4 + 11*t^5 + 35*t^6 + 101*t^7 + O(t^8)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellfromeqn">
<code class="descname">ellfromeqn</code><span class="sig-paren">(</span><em>P</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellfromeqn" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a genus <span class="math">\(1\)</span> plane curve, defined by the affine equation <span class="math">\(f(x,y) = 0\)</span>,
return the coefficients <span class="math">\([a_1,a_2,a_3,a_4,a_6]\)</span> of a Weierstrass equation
for its Jacobian. This allows to recover a Weierstrass model for an elliptic
curve given by a general plane cubic or by a binary quartic or biquadratic
model.</p>
<p>The function implements the <span class="math">\(f :---&gt;&nbsp;f^*\)</span> formulae of Artin, Tate and
Villegas (Advances in Math. 198 (2005), pp. 366&#8211;382).</p>
<p>In the example below, the function is used to convert between twisted Edwards
coordinates and Weierstrass coordinates.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? e = ellfromeqn(a*x^2+y^2-(1+d*x^2*y^2))
%1 = [0, -a - d, 0, -4*d*a, 4*d*a^2 + 4*d^2*a]
? E = ellinit(ellfromeqn(y^2-x^2 - 1 +(121665/121666*x^2*y^2)),2^255-19);
? ellcard(E)
%2 = 57896044618658097711785492504343953926856930875039260848015607506283634007912
</pre></div>
</div>
<p>The elliptic curve associated to the sum of two cubes is given by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? ellfromeqn(x^3+y^3-a)
%1 = [0, 0, -9*a, 0, -27*a^2]
</pre></div>
</div>
<p><strong>Congruent number problem:.</strong>
Let <span class="math">\(n\)</span> be an integer,
if <span class="math">\(a^2+b^2 = c^2\)</span> and <span class="math">\(a b = 2 n\)</span>,
then by substituting <span class="math">\(b\)</span> by <span class="math">\(2 n/a\)</span> in the first equation,
we get <span class="math">\(((a^2+(2 n/a)^2)-c^2) a^2 = 0\)</span>.
We set <span class="math">\(x = a\)</span>, <span class="math">\(y = a c\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? ellfromeqn((x^2+(2*n/x)^2-(y/x)^2)*x^2)
%1 = [0, 0, 0, -16*n^2, 0]
</pre></div>
</div>
<p>For example <span class="math">\(23\)</span> is congruent since the curve has a point of infinite order,
namely:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? ellheegner(ellinit(subst([0,0,0,-16*n^2,0],n,23)))
%2 = [168100/289, 68053440/4913]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellfromj">
<code class="descname">ellfromj</code><span class="sig-paren">(</span><em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellfromj" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coefficients <span class="math">\([a_1,a_2,a_3,a_4,a_6]\)</span> of a fixed elliptic curve
with <span class="math">\(j\)</span>-invariant <span class="math">\(j\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellgenerators">
<code class="descname">ellgenerators</code><span class="sig-paren">(</span><em>E</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellgenerators" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(E\)</span> is an elliptic curve over the rationals, return a <span class="math">\(\mathbb{Z}\)</span>-basis of the
free part of the Mordell-Weil group associated to <span class="math">\(E\)</span>. This relies on
the <code class="docutils literal"><span class="pre">elldata</span></code> database being installed and referencing the curve, and so
is only available for curves over <span class="math">\(\mathbb{Z}\)</span> of small conductors.
If <span class="math">\(E\)</span> is an elliptic curve over a finite field <span class="math">\(\mathbb{F}_q\)</span> as output by
<code class="docutils literal"><span class="pre">ellinit</span></code>, return a minimal set of generators for the group <span class="math">\(E(\mathbb{F}_q)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellglobalred">
<code class="descname">ellglobalred</code><span class="sig-paren">(</span><em>E</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellglobalred" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the arithmetic conductor, the global
minimal model of <span class="math">\(E\)</span> and the global Tamagawa number <span class="math">\(c\)</span>.
<span class="math">\(E\)</span> must be an <code class="docutils literal"><span class="pre">ell</span></code> structure as output by <code class="docutils literal"><span class="pre">ellinit</span></code>, defined over
<span class="math">\(\mathbb{Q}\)</span>. The result is a vector <span class="math">\([N,v,c,F,L]\)</span>, where</p>
<ul class="simple">
<li><span class="math">\(N\)</span> is the arithmetic conductor of the curve,</li>
<li><span class="math">\(v\)</span> gives the coordinate change for <span class="math">\(E\)</span> over <span class="math">\(\mathbb{Q}\)</span> to the minimal
integral model (see <code class="docutils literal"><span class="pre">ellminimalmodel</span></code>),</li>
<li><span class="math">\(c\)</span> is the product of the local Tamagawa numbers <span class="math">\(c_p\)</span>, a quantity
which enters in the Birch and Swinnerton-Dyer conjecture,</li>
<li><span class="math">\(F\)</span> is the factorization of <span class="math">\(N\)</span> over <span class="math">\(\mathbb{Z}\)</span>.</li>
<li><span class="math">\(L\)</span> is a vector, whose <span class="math">\(i\)</span>-th entry contains the local data
at the <span class="math">\(i\)</span>-th prime divisor of <span class="math">\(N\)</span>, i.e. <code class="docutils literal"><span class="pre">L[i]</span> <span class="pre">=</span> <span class="pre">elllocalred(E,F[i,1])</span></code>,
where the local coordinate change has been deleted and replaced by a 0.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellgroup">
<code class="descname">ellgroup</code><span class="sig-paren">(</span><em>E</em>, <em>p=None</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellgroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(E\)</span> be an <code class="docutils literal"><span class="pre">ell</span></code> structure as output by <code class="docutils literal"><span class="pre">ellinit</span></code>, defined over
<span class="math">\(\mathbb{Q}\)</span> or a finite field <span class="math">\(\mathbb{F}_q\)</span>. The argument <span class="math">\(p\)</span> is best left omitted if the
curve is defined over a finite field, and must be a prime number otherwise.
This function computes the structure of the group <span class="math">\(E(\mathbb{F}_q) ~ \mathbb{Z}/d_1\mathbb{Z}
x \mathbb{Z}/d_2\mathbb{Z}\)</span>, with <span class="math">\(d_2 \| d_1\)</span>.</p>
<p>If the curve is defined over <span class="math">\(\mathbb{Q}\)</span>, <span class="math">\(p\)</span> must be explicitly given and the
function computes the structure of the reduction over <span class="math">\(\mathbb{F}_p\)</span>; the
equation need not be minimal at <span class="math">\(p\)</span>, but a minimal model will be more
efficient. The reduction is allowed to be singular, and we return the
structure of the (cyclic) group of non-singular points in this case.</p>
<p>If the flag is <span class="math">\(0\)</span> (default), return <span class="math">\([d_1]\)</span> or <span class="math">\([d_1, d_2]\)</span>, if <span class="math">\(d_2 &gt; 1\)</span>.
If the flag is <span class="math">\(1\)</span>, return a triple <span class="math">\([h,cyc,gen]\)</span>, where
<span class="math">\(h\)</span> is the curve cardinality, <em>cyc</em> gives the group structure as a
product of cyclic groups (as per <span class="math">\(flag = 0\)</span>). More precisely, if <span class="math">\(d_2 &gt; 1\)</span>,
the output is <span class="math">\([d_1d_2, [d_1,d_2],[P,Q]]\)</span> where <span class="math">\(P\)</span> is
of order <span class="math">\(d_1\)</span> and <span class="math">\([P,Q]\)</span> generates the curve.
<strong>Caution.</strong> It is not guaranteed that <span class="math">\(Q\)</span> has order <span class="math">\(d_2\)</span>, which in
the worst case requires an expensive discrete log computation. Only that
<code class="docutils literal"><span class="pre">ellweilpairing(E,</span> <span class="pre">P,</span> <span class="pre">Q,</span> <span class="pre">d1)</span></code> has order <span class="math">\(d_2\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([0,1]); \\ y^2 = x^3 + 0.x + 1, defined over Q
? ellgroup(E, 7)
%2 = [6, 2] \\ Z/6 x Z/2, non-cyclic
? E = ellinit([0,1] * Mod(1,11)); \\ defined over F_11
? ellgroup(E) \\ no need to repeat 11
%4 = [12]
? ellgroup(E, 11) \\ ... but it also works
%5 = [12]
? ellgroup(E, 13) \\ ouch, inconsistent input!
 *** at top-level: ellgroup(E,13)
 *** ^--------------
 *** ellgroup: inconsistent moduli in Rg_to_Fp:
 11
 13
? ellgroup(E, 7, 1)
%6 = [12, [6, 2], [[Mod(2, 7), Mod(4, 7)], [Mod(4, 7), Mod(4, 7)]]]
</pre></div>
</div>
<p>If <span class="math">\(E\)</span> is defined over <span class="math">\(\mathbb{Q}\)</span>, we allow singular reduction and in this case we
return the structure of the group of non-singular points, satisfying
<span class="math">\(\#E_{ns}(\mathbb{F}_p) = p - a_p\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([0,5]);
? ellgroup(E, 5, 1)
%2 = [5, [5], [[Mod(4, 5), Mod(2, 5)]]]
? ellap(E, 5)
%3 = 0 \\ additive reduction at 5
? E = ellinit([0,-1,0,35,0]);
? ellgroup(E, 5, 1)
%5 = [4, [4], [[Mod(2, 5), Mod(2, 5)]]]
? ellap(E, 5)
%6 = 1 \\ split multiplicative reduction at 5
? ellgroup(E, 7, 1)
%7 = [8, [8], [[Mod(3, 7), Mod(5, 7)]]]
? ellap(E, 7)
%8 = -1 \\ non-split multiplicative reduction at 7
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellheegner">
<code class="descname">ellheegner</code><span class="sig-paren">(</span><em>E</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellheegner" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(E\)</span> be an elliptic curve over the rationals, assumed to be of
(analytic) rank <span class="math">\(1\)</span>. This returns a non-torsion rational point on the curve,
whose canonical height is equal to the product of the elliptic regulator by the
analytic Sha.</p>
<p>This uses the Heegner point method, described in Cohen GTM 239; the complexity
is proportional to the product of the square root of the conductor and the
height of the point (thus, it is preferable to apply it to strong Weil curves).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([-157^2,0]);
? u = ellheegner(E); print(u[1], &quot;\n&quot;, u[2])
69648970982596494254458225/166136231668185267540804
538962435089604615078004307258785218335/67716816556077455999228495435742408
? ellheegner(ellinit([0,1])) \\ E has rank 0 !
 *** at top-level: ellheegner(E=ellinit
 *** ^--------------------
 *** ellheegner: The curve has even analytic rank.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellheight">
<code class="descname">ellheight</code><span class="sig-paren">(</span><em>E</em>, <em>P</em>, <em>Q=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellheight" title="Permalink to this definition">¶</a></dt>
<dd><p>Global Néron-Tate height <span class="math">\(h(P)\)</span> of the point <span class="math">\(P\)</span> on the elliptic curve
<span class="math">\(E/\mathbb{Q}\)</span>, using the normalization in Cremona&#8217;s <em>Algorithms for modular
elliptic curves</em>. <span class="math">\(E\)</span> must be an <code class="docutils literal"><span class="pre">ell</span></code> as output by <code class="docutils literal"><span class="pre">ellinit</span></code>; it
needs not be given by a minimal model although the computation will be faster
if it is.</p>
<p>If the argument <span class="math">\(Q\)</span> is present, computes the value of the bilinear
form <span class="math">\((h(P+Q)-h(P-Q)) / 4\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellheightmatrix">
<code class="descname">ellheightmatrix</code><span class="sig-paren">(</span><em>E</em>, <em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellheightmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> being a vector of points, this
function outputs the Gram matrix of <span class="math">\(x\)</span> with respect to the Néron-Tate
height, in other words, the <span class="math">\((i,j)\)</span> component of the matrix is equal to
<code class="docutils literal"><span class="pre">ellbil(:math:`E</span></code>,x[<span class="math">\(i\)</span>],x[<span class="math">\(j\)</span>])`. The rank of this matrix, at least in some
approximate sense, gives the rank of the set of points, and if <span class="math">\(x\)</span> is a
basis of the Mordell-Weil group of <span class="math">\(E\)</span>, its determinant is equal to
the regulator of <span class="math">\(E\)</span>. Note our height normalization follows Cremona&#8217;s
<em>Algorithms for modular elliptic curves</em>: this matrix should be divided
by 2 to be in accordance with, e.g., Silverman&#8217;s normalizations.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellidentify">
<code class="descname">ellidentify</code><span class="sig-paren">(</span><em>E</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellidentify" title="Permalink to this definition">¶</a></dt>
<dd><p>Look up the elliptic curve <span class="math">\(E\)</span>, defined by an arbitrary model over <span class="math">\(\mathbb{Q}\)</span>,
in the <code class="docutils literal"><span class="pre">elldata</span></code> database.
Return <code class="docutils literal"><span class="pre">[[N,</span> <span class="pre">M,</span> <span class="pre">G],</span> <span class="pre">C]</span></code> where <span class="math">\(N\)</span> is the curve name in Cremona&#8217;s
elliptic curve database, <span class="math">\(M\)</span> is the minimal model, <span class="math">\(G\)</span> is a <span class="math">\(\mathbb{Z}\)</span>-basis of
the free part of the Mordell-Weil group <span class="math">\(E(\mathbb{Q})\)</span> and <span class="math">\(C\)</span> is the
change of coordinates change, suitable for <code class="docutils literal"><span class="pre">ellchangecurve</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellinit">
<code class="descname">ellinit</code><span class="sig-paren">(</span><em>x</em>, <em>D=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an <code class="docutils literal"><span class="pre">ell</span></code> structure, associated to the elliptic curve <span class="math">\(E\)</span>.
<span class="math">\(E\)</span> is either</p>
<ul class="simple">
<li>a <span class="math">\(5\)</span>-component vector <span class="math">\([a_1,a_2,a_3,a_4,a_6]\)</span> defining the elliptic
curve with Weierstrass equation</li>
</ul>
<div class="math">
\[Y^2 + a_1 XY + a_3 Y = X^3 + a_2 X^2 + a_4 X + a_6,\]</div>
<ul class="simple">
<li>a <span class="math">\(2\)</span>-component vector <span class="math">\([a_4,a_6]\)</span> defining the elliptic
curve with short Weierstrass equation</li>
</ul>
<div class="math">
\[Y^2 = X^3 + a_4 X + a_6,\]</div>
<ul class="simple">
<li>a character string in Cremona&#8217;s notation, e.g. <code class="docutils literal"><span class="pre">&quot;11a1&quot;</span></code>, in which
case the curve is retrieved from the <code class="docutils literal"><span class="pre">elldata</span></code> database if available.</li>
</ul>
<p>The optional argument <span class="math">\(D\)</span> describes the domain over which the curve is
defined:</p>
<ul class="simple">
<li>the <code class="docutils literal"><span class="pre">t_INT</span></code> <span class="math">\(1\)</span> (default): the field of rational numbers <span class="math">\(\mathbb{Q}\)</span>.</li>
<li>a <code class="docutils literal"><span class="pre">t_INT</span></code> <span class="math">\(p\)</span>, where <span class="math">\(p\)</span> is a prime number: the prime finite field
<span class="math">\(\mathbb{F}_p\)</span>.</li>
<li>an <code class="docutils literal"><span class="pre">t_INTMOD</span></code> <code class="docutils literal"><span class="pre">Mod(a,</span> <span class="pre">p)</span></code>, where <span class="math">\(p\)</span> is a prime number: the
prime finite field <span class="math">\(\mathbb{F}_p\)</span>.</li>
<li>a <code class="docutils literal"><span class="pre">t_FFELT</span></code>, as returned by <code class="docutils literal"><span class="pre">ffgen</span></code>: the corresponding finite
field <span class="math">\(\mathbb{F}_q\)</span>.</li>
<li>a <code class="docutils literal"><span class="pre">t_PADIC</span></code>, <span class="math">\(O(p^n)\)</span>: the field <span class="math">\(\mathbb{Q}_p\)</span>, where <span class="math">\(p\)</span>-adic quantities
will be computed to a relative accuracy of <span class="math">\(n\)</span> digits. We advise to input a
model defined over <span class="math">\(\mathbb{Q}\)</span> for such curves. In any case, if you input an
approximate model with <code class="docutils literal"><span class="pre">t_PADIC</span></code> coefficients, it will be replaced by a lift
to <span class="math">\(\mathbb{Q}\)</span> (an exact model &#8220;close&#8221; to the one that was input) and all quantities
will then be computed in terms of this lifted model, at the given accuracy.</li>
<li>a <code class="docutils literal"><span class="pre">t_REAL</span></code> <span class="math">\(x\)</span>: the field <span class="math">\(\mathbb{C}\)</span> of complex numbers, where floating
point quantities are by default computed to a relative accuracy of
<code class="docutils literal"><span class="pre">precision</span></code><span class="math">\((x)\)</span>. If no such argument is given, the value of
<code class="docutils literal"><span class="pre">realprecision</span></code> at the time <code class="docutils literal"><span class="pre">ellinit</span></code> is called will be used.</li>
<li>a number field <span class="math">\(K\)</span>, given by a <code class="docutils literal"><span class="pre">nf</span></code> or <code class="docutils literal"><span class="pre">bnf</span></code> structure.</li>
<li>a prime ideal <span class="math">\(p\)</span>, given by a <code class="docutils literal"><span class="pre">prid</span></code> structure; valid if
<span class="math">\(x\)</span> is a curve defined over a number field <span class="math">\(K\)</span> and the equation is integral
and minimal at <span class="math">\(p\)</span>.</li>
</ul>
<p>This argument <span class="math">\(D\)</span> is indicative: the curve coefficients are checked for
compatibility, possibly changing <span class="math">\(D\)</span>; for instance if <span class="math">\(D = 1\)</span> and
an <code class="docutils literal"><span class="pre">t_INTMOD</span></code> is found. If inconsistencies are detected, an error is
raised:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? ellinit([1 + O(5), 1], O(7));
 *** at top-level: ellinit([1+O(5),1],O
 *** ^--------------------
 *** ellinit: inconsistent moduli in ellinit: 7 != 5
</pre></div>
</div>
<p>If the curve coefficients are too general to fit any of the
above domain categories, only basic operations, such as point addition, will
be supported later.</p>
<p>If the curve (seen over the domain <span class="math">\(D\)</span>) is singular, fail and return an
empty vector <span class="math">\([]\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([0,0,0,0,1]); \\ y^2 = x^3 + 1, over Q
? E = ellinit([0,1]); \\ the same curve, short form
? E = ellinit(&quot;36a1&quot;); \\ sill the same curve, Cremona&#39;s notations
? E = ellinit([0,1], 2) \\ over F2: singular curve
%4 = []
? E = ellinit([&#39;a4,&#39;a6] * Mod(1,5)); \\ over F_5[a4,a6], basic support !
</pre></div>
</div>
<p>The result of <code class="docutils literal"><span class="pre">ellinit</span></code> is an <em>ell</em> structure. It contains at least
the following information in its components:</p>
<div class="math">
\[a_1,a_2,a_3,a_4,a_6,b_2,b_4,b_6,b_8,c_4,c_6,\Delta,j.\]</div>
<p>All are accessible via member functions. In particular, the discriminant is
<code class="docutils literal"><span class="pre">:math:`E</span></code>.disc`, and the <span class="math">\(j\)</span>-invariant is <code class="docutils literal"><span class="pre">:math:`E</span></code>.j`.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([a4, a6]);
? E.disc
%2 = -64*a4^3 - 432*a6^2
? E.j
%3 = -6912*a4^3/(-4*a4^3 - 27*a6^2)
</pre></div>
</div>
<p>Further components contain domain-specific data, which are in general dynamic:
only computed when needed, and then cached in the structure.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([2,3], 10^60+7); \\ E over F_p, p large
? ellap(E)
time = 4,440 ms.
%2 = -1376268269510579884904540406082
? ellcard(E); \\ now instantaneous !
time = 0 ms.
? ellgenerators(E);
time = 5,965 ms.
? ellgenerators(E); \\ second time instantaneous
time = 0 ms.
</pre></div>
</div>
<p>See the description of member functions related to elliptic curves at the
beginning of this section.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellisogeny">
<code class="descname">ellisogeny</code><span class="sig-paren">(</span><em>E</em>, <em>G</em>, <em>only_image=0</em>, <em>x=None</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellisogeny" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an elliptic curve <span class="math">\(E\)</span>, a finite subgroup <span class="math">\(G\)</span> of <span class="math">\(E\)</span> is given either
as a generating point <span class="math">\(P\)</span> (for a cyclic <span class="math">\(G\)</span>) or as a polynomial whose roots
vanish on the <span class="math">\(x\)</span>-coordinates of the non-zero elements of <span class="math">\(G\)</span> (general case
and more efficient if available). This function returns the
<span class="math">\([a_1,a_2,a_3,a_4,a_6]\)</span> invariants of the quotient elliptic curve <span class="math">\(E/G\)</span> and
(if <em>only_image</em> is zero (the default)) a vector of rational
functions <span class="math">\([f, g, h]\)</span> such that the isogeny <span class="math">\(E \to E/G\)</span> is given by <span class="math">\((x,y)
:---&gt;(f(x)/h(x)^2, g(x,y)/h(x)^3)\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([0,1]);
? elltors(E)
%2 = [6, [6], [[2, 3]]]
? ellisogeny(E, [2,3], 1) \\ Weierstrass model for E/&lt;P&gt;
%3 = [0, 0, 0, -135, -594]
? ellisogeny(E,[-1,0])
%4 = [[0,0,0,-15,22], [x^3+2*x^2+4*x+3, y*x^3+3*y*x^2-2*y, x+1]]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellisogenyapply">
<code class="descname">ellisogenyapply</code><span class="sig-paren">(</span><em>f</em>, <em>g</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellisogenyapply" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an isogeny of elliptic curves <span class="math">\(f:E'\to E\)</span> (being the result of a call
to <code class="docutils literal"><span class="pre">ellisogeny</span></code>), apply <span class="math">\(f\)</span> to <span class="math">\(g\)</span>:</p>
<ul class="simple">
<li>if <span class="math">\(g\)</span> is a point <span class="math">\(P\)</span> in the domain of <span class="math">\(f\)</span>, return the image <span class="math">\(f(P)\)</span>;</li>
<li>if <span class="math">\(g:E&quot;\to E'\)</span> is a compatible isogeny, return the composite
isogeny <span class="math">\(f o g: E&quot;\to E\)</span>.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? one = ffgen(101, &#39;t)^0;
? E = ellinit([6, 53, 85, 32, 34] * one);
? P = [84, 71] * one;
? ellorder(E, P)
%4 = 5
? [F, f] = ellisogeny(E, P); \\ f: E-&gt;F = E/&lt;P&gt;
? ellisogenyapply(f, P)
%6 = [0]
? F = ellinit(F);
? Q = [89, 44] * one;
? ellorder(F, Q)
%9 = 2
? [G, g] = ellisogeny(F, Q); \\ g: F-&gt;G = F/&lt;Q&gt;
? gof = ellisogenyapply(g, f); \\ gof: E -&gt; G
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellisomat">
<code class="descname">ellisomat</code><span class="sig-paren">(</span><em>E</em>, <em>fl=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellisomat" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an elliptic curve <span class="math">\(E\)</span> defined over <span class="math">\(\mathbb{Q}\)</span>, compute representatives of the
isomorphism classes of elliptic curves <span class="math">\(\mathbb{Q}\)</span>-isogenous to <span class="math">\(E\)</span>. The function
returns a vector <span class="math">\([L,M]\)</span> where <span class="math">\(L\)</span> is a list of couples <span class="math">\([E_i, f_i, g_i]\)</span>, where
<span class="math">\(E_i\)</span> is an elliptic curve, <span class="math">\(f_i\)</span> is a rational isogeny from <span class="math">\(E\)</span> to <span class="math">\(E_i\)</span>,
<span class="math">\(g_i\)</span> is the dual isogeny of <span class="math">\(f_i\)</span> from <span class="math">\(E_i\)</span> to <span class="math">\(E\)</span>,
and <span class="math">\(M\)</span> is the matrix such that <span class="math">\(M_{i,j}\)</span> is the degree of the isogeny between
<span class="math">\(E_i\)</span> and <span class="math">\(E_j\)</span>.
Furthermore the first curve <span class="math">\(E_1\)</span> is isomorphic to <span class="math">\(E\)</span> by <span class="math">\(f_1\)</span>.
If the flag <span class="math">\(fl = 1\)</span>, the <span class="math">\(f_i\)</span> are not computed, and <span class="math">\(L\)</span> is actually the
list of the curves <span class="math">\(E_i\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit(&quot;14a1&quot;);
? [L,M]=ellisomat(E);
? L
? apply(x-&gt;x[1],L)
%4 = [[215/48,-5291/864],[-675/16,6831/32],[-8185/48,-742643/864],
 [-1705/48,-57707/864],[-13635/16,306207/32],[-131065/48,-47449331/864]]
? L[2][2]
%5 = [x^3+3/4*x^2+19/2*x-311/12,
 1/2*x^4+(y+1)*x^3+(y-4)*x^2+(-9*y+23)*x+(55*y+55/2),x+1/3]
? L[2][3]
%6 = [1/9*x^3-1/4*x^2-141/16*x+5613/64,
 -1/18*x^4+(1/27*y-1/3)*x^3+(-1/12*y+87/16)*x^2+(49/16*y-48)*x
 +(-3601/64*y+16947/512),x-3/4]
? M
%7 = [1,3,3,2,6,6;3,1,9,6,2,18;3,9,1,6,18,2;2,6,6,1,3,3;6,2,18,3,1,9;6,18,2,3,9,1]
? apply(E-&gt;ellidentify(ellinit(E[1]))[1][1],L)
%8 = [&quot;14a1&quot;,&quot;14a4&quot;,&quot;14a3&quot;,&quot;14a2&quot;,&quot;14a6&quot;,&quot;14a5&quot;]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellisoncurve">
<code class="descname">ellisoncurve</code><span class="sig-paren">(</span><em>E</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellisoncurve" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives 1 (i.e.&nbsp;true) if the point <span class="math">\(z\)</span> is on the elliptic curve <span class="math">\(E\)</span>, 0
otherwise. If <span class="math">\(E\)</span> or <span class="math">\(z\)</span> have imprecise coefficients, an attempt is made to
take this into account, i.e.&nbsp;an imprecise equality is checked, not a precise
one. It is allowed for <span class="math">\(z\)</span> to be a vector of points in which case a vector
(of the same type) is returned.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellissupersingular">
<code class="descname">ellissupersingular</code><span class="sig-paren">(</span><em>E</em>, <em>p=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellissupersingular" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1 if the elliptic curve <span class="math">\(E\)</span> defined over Q or a finite field is supersingular
at <span class="math">\(p\)</span>, and <span class="math">\(0\)</span> otherwise.
If the curve is defined over <span class="math">\(\mathbb{Q}\)</span>, <span class="math">\(p\)</span> must be explicitly given and have good
reduction at <span class="math">\(p\)</span>.
Alternatively, <span class="math">\(E\)</span> can be given byt its <span class="math">\(j\)</span>-invariant in a finite field. In
this case <span class="math">\(p\)</span> must be omitted.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? g = ffprimroot(ffgen(7^5))
%1 = x^3 + 2*x^2 + 3*x + 1
? [g^n | n &lt;- [1 .. 7^5 - 1], ellissupersingular(g^n)]
%2 = [6]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellj">
<code class="descname">ellj</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellj" title="Permalink to this definition">¶</a></dt>
<dd><p>Elliptic <span class="math">\(j\)</span>-invariant. <span class="math">\(x\)</span> must be a complex number
with positive imaginary part, or convertible into a power series or a
<span class="math">\(p\)</span>-adic number with positive valuation.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elllocalred">
<code class="descname">elllocalred</code><span class="sig-paren">(</span><em>E</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elllocalred" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Kodaira type of the local fiber of the elliptic curve
<span class="math">\(E\)</span> at <span class="math">\(p\)</span>. <span class="math">\(E\)</span> must be an <code class="docutils literal"><span class="pre">ell</span></code> structure as output by
<code class="docutils literal"><span class="pre">ellinit</span></code>, over <span class="math">\(\mathbb{Q}\)</span> (<span class="math">\(p\)</span> a rational prime) or a number field <span class="math">\(K\)</span> (<span class="math">\(p\)</span>
a maximal ideal given by a <code class="docutils literal"><span class="pre">prid</span></code> structure), and is assumed to have all
its coefficients <span class="math">\(a_i\)</span> integral.
The result is a 4-component vector <span class="math">\([f,kod,v,c]\)</span>. Here <span class="math">\(f\)</span> is the exponent of
<span class="math">\(p\)</span> in the arithmetic conductor of <span class="math">\(E\)</span>, and <span class="math">\(kod\)</span> is the Kodaira type which
is coded as follows:</p>
<p>1 means good reduction (type I:math:<span class="math">\(_0\)</span>), 2, 3 and 4 mean types II, III and IV
respectively, <span class="math">\(4+\nu\)</span> with <span class="math">\(\nu &gt; 0\)</span> means type I:math:<span class="math">\(_\nu\)</span>;
finally the opposite values <span class="math">\(-1\)</span>, <span class="math">\(-2\)</span>, etc.&nbsp;refer to the starred types
I:math:<span class="math">\(_0^*\)</span>, II:math:<span class="math">\(^*\)</span>, etc. The third component <span class="math">\(v\)</span> is itself a vector <span class="math">\([u,r,s,t]\)</span>
giving the coordinate changes done during the local reduction;
<span class="math">\(u = 1\)</span> if and only if the given equation was already minimal at <span class="math">\(p\)</span>.
Finally, the last component <span class="math">\(c\)</span> is the local Tamagawa number <span class="math">\(c_p\)</span>.</p>
<p><strong>Caveat.</strong> If <span class="math">\(E\)</span> is not defined over <span class="math">\(\mathbb{Q}\)</span>, the current
implementation requires that <span class="math">\(p\)</span> be above a prime <span class="math">\(&gt;= 5\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elllog">
<code class="descname">elllog</code><span class="sig-paren">(</span><em>E</em>, <em>P</em>, <em>G</em>, <em>o=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elllog" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two points <span class="math">\(P\)</span> and <span class="math">\(G\)</span> on the elliptic curve <span class="math">\(E/\mathbb{F}_q\)</span>, returns the
discrete logarithm of <span class="math">\(P\)</span> in base <span class="math">\(G\)</span>, i.e. the smallest non-negative
integer <span class="math">\(n\)</span> such that <span class="math">\(P = [n]G\)</span>.
See <code class="docutils literal"><span class="pre">znlog</span></code> for the limitations of the underlying discrete log algorithms.
If present, <span class="math">\(o\)</span> represents the order of <span class="math">\(G\)</span>, see <code class="docutils literal"><span class="pre">DLfun</span></code> (in the PARI manual);
the preferred format for this parameter is <code class="docutils literal"><span class="pre">[N,</span> <span class="pre">factor(N)]</span></code>, where <span class="math">\(N\)</span>
is the order of <span class="math">\(G\)</span>.</p>
<p>If no <span class="math">\(o\)</span> is given, assume that <span class="math">\(G\)</span> generates the curve.
The function also assumes that <span class="math">\(P\)</span> is a multiple of <span class="math">\(G\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? a = ffgen(ffinit(2,8),&#39;a);
? E = ellinit([a,1,0,0,1]); \\ over F_{2^8}
? x = a^3; y = ellordinate(E,x)[1];
? P = [x,y]; G = ellmul(E, P, 113);
? ord = [242, factor(242)]; \\ P generates a group of order 242. Initialize.
? ellorder(E, G, ord)
%4 = 242
? e = elllog(E, P, G, ord)
%5 = 15
? ellmul(E,G,e) == P
%6 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elllseries">
<code class="descname">elllseries</code><span class="sig-paren">(</span><em>E</em>, <em>s</em>, <em>A=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elllseries" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(E\)</span> being an elliptic curve, given by an arbitrary model over <span class="math">\(\mathbb{Q}\)</span> as output
by <code class="docutils literal"><span class="pre">ellinit</span></code>, this function computes the value of the <span class="math">\(L\)</span>-series of <span class="math">\(E\)</span> at
the (complex) point <span class="math">\(s\)</span>. This function uses an <span class="math">\(O(N^{1/2})\)</span> algorithm, where
<span class="math">\(N\)</span> is the conductor.</p>
<p>The optional parameter <span class="math">\(A\)</span> fixes a cutoff point for the integral and is best
left omitted; the result must be independent of <span class="math">\(A\)</span>, up to
<code class="docutils literal"><span class="pre">realprecision</span></code>, so this allows to check the function&#8217;s accuracy.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellminimaltwist">
<code class="descname">ellminimaltwist</code><span class="sig-paren">(</span><em>E</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellminimaltwist" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(E\)</span> be an elliptic curve defined over <span class="math">\(\mathbb{Q}\)</span>, return
a discriminant <span class="math">\(D\)</span> such that the twist of <span class="math">\(E\)</span> by <span class="math">\(D\)</span> is minimal among all
possible quadratic twists, i.e. if <span class="math">\(flag = 0\)</span>, its minimal model has minimal
discriminant, or if <span class="math">\(flag = 1\)</span>, it has minimal conductor.</p>
<p>In the example below, we find a curve with <span class="math">\(j\)</span>-invariant <span class="math">\(3\)</span> and minimal
conductor.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E=ellminimalmodel(ellinit(ellfromj(3)));
? ellglobalred(E)[1]
%2 = 357075
? D = ellminimaltwist(E,1)
%3 = -15
? E2=ellminimalmodel(ellinit(elltwist(E,D)));
? ellglobalred(E2)[1]
%5 = 14283
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellmoddegree">
<code class="descname">ellmoddegree</code><span class="sig-paren">(</span><em>e</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellmoddegree" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(e\)</span> being an elliptic curve defined over <span class="math">\(\mathbb{Q}\)</span> output by <code class="docutils literal"><span class="pre">ellinit</span></code>,
compute the modular degree of <span class="math">\(e\)</span> divided by the square of
the Manin constant. Return <span class="math">\([D, err]\)</span>, where <span class="math">\(D\)</span> is a rational number and
err is exponent of the truncation error.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellmul">
<code class="descname">ellmul</code><span class="sig-paren">(</span><em>E</em>, <em>z</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes <span class="math">\([n]z\)</span>, where <span class="math">\(z\)</span> is a point on the elliptic curve <span class="math">\(E\)</span>. The
exponent <span class="math">\(n\)</span> is in <span class="math">\(\mathbb{Z}\)</span>, or may be a complex quadratic integer if the curve <span class="math">\(E\)</span>
has complex multiplication by <span class="math">\(n\)</span> (if not, an error message is issued).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? Ei = ellinit([1,0]); z = [0,0];
? ellmul(Ei, z, 10)
%2 = [0] \\ unsurprising: z has order 2
? ellmul(Ei, z, I)
%3 = [0, 0] \\ Ei has complex multiplication by Z[i]
? ellmul(Ei, z, quadgen(-4))
%4 = [0, 0] \\ an alternative syntax for the same query
? Ej = ellinit([0,1]); z = [-1,0];
? ellmul(Ej, z, I)
 *** at top-level: ellmul(Ej,z,I)
 *** ^--------------
 *** ellmul: not a complex multiplication in ellmul.
? ellmul(Ej, z, 1+quadgen(-3))
%6 = [1 - w, 0]
</pre></div>
</div>
<p>The simple-minded algorithm for the CM case assumes that we are in
characteristic <span class="math">\(0\)</span>, and that the quadratic order to which <span class="math">\(n\)</span> belongs has
small discriminant.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellneg">
<code class="descname">ellneg</code><span class="sig-paren">(</span><em>E</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellneg" title="Permalink to this definition">¶</a></dt>
<dd><p>Opposite of the point <span class="math">\(z\)</span> on elliptic curve <span class="math">\(E\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellnonsingularmultiple">
<code class="descname">ellnonsingularmultiple</code><span class="sig-paren">(</span><em>E</em>, <em>P</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellnonsingularmultiple" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an elliptic curve <span class="math">\(E/\mathbb{Q}\)</span> (more precisely, a model defined over <span class="math">\(\mathbb{Q}\)</span>
of a curve) and a rational point <span class="math">\(P belongs to E(\mathbb{Q})\)</span>, returns the pair <span class="math">\([R,n]\)</span>,
where <span class="math">\(n\)</span> is the least positive integer such that <span class="math">\(R := [n]P\)</span> has good
reduction at every prime. More precisely, its image in a minimal model is
everywhere non-singular.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? e = ellinit(&quot;57a1&quot;); P = [2,-2];
? ellnonsingularmultiple(e, P)
%2 = [[1, -1], 2]
? e = ellinit(&quot;396b2&quot;); P = [35, -198];
? [R,n] = ellnonsingularmultiple(e, P);
? n
%5 = 12
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellorder">
<code class="descname">ellorder</code><span class="sig-paren">(</span><em>E</em>, <em>z</em>, <em>o=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the order of the point <span class="math">\(z\)</span> on the elliptic
curve <span class="math">\(E\)</span>, defined over a finite field or a number field.
Return (the impossible value) zero if the point has infinite order.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([-157^2,0]); \\ the &quot;157-is-congruent&quot; curve
? P = [2,2]; ellorder(E, P)
%2 = 2
? P = ellheegner(E); ellorder(E, P) \\ infinite order
%3 = 0
? K = nfinit(polcyclo(11,t)); E=ellinit(&quot;11a3&quot;, K); T = elltors(E);
? ellorder(E, T.gen[1])
%5 = 25
? E = ellinit(ellfromj(ffgen(5^10)));
? ellcard(E)
%7 = 9762580
? P = random(E); ellorder(E, P)
%8 = 4881290
? p = 2^160+7; E = ellinit([1,2], p);
? N = ellcard(E)
%9 = 1461501637330902918203686560289225285992592471152
? o = [N, factor(N)];
? for(i=1,100, ellorder(E,random(E)))
time = 260 ms.
</pre></div>
</div>
<p>The parameter <span class="math">\(o\)</span>, is now mostly useless, and kept for backward
compatibility. If present, it represents a non-zero multiple of the order
of <span class="math">\(z\)</span>, see <code class="docutils literal"><span class="pre">DLfun</span></code> (in the PARI manual); the preferred format for this parameter is
<code class="docutils literal"><span class="pre">[ord,</span> <span class="pre">factor(ord)]</span></code>, where <code class="docutils literal"><span class="pre">ord</span></code> is the cardinality of the curve.
It is no longer needed since PARI is now able to compute it over large
finite fields (was restricted to small prime fields at the time this feature
was introduced), <em>and</em> caches the result in <span class="math">\(E\)</span> so that it is computed
and factored only once. Modifying the last example, we see that including
this extra parameter provides no improvement:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? o = [N, factor(N)];
? for(i=1,100, ellorder(E,random(E),o))
time = 260 ms.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellordinate">
<code class="descname">ellordinate</code><span class="sig-paren">(</span><em>E</em>, <em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellordinate" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a 0, 1 or 2-component vector containing
the <span class="math">\(y\)</span>-coordinates of the points of the curve <span class="math">\(E\)</span> having <span class="math">\(x\)</span> as
<span class="math">\(x\)</span>-coordinate.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellpadicL">
<code class="descname">ellpadicL</code><span class="sig-paren">(</span><em>E</em>, <em>p</em>, <em>n</em>, <em>s=None</em>, <em>r=0</em>, <em>D=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellpadicL" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value (or <span class="math">\(r\)</span>-th derivative) on a character <span class="math">\(\chi^s\)</span> of
<span class="math">\(\mathbb{Z}_p^*\)</span> of the <span class="math">\(p\)</span>-adic <span class="math">\(L\)</span>-function of the elliptic curve <span class="math">\(E/\mathbb{Q}\)</span>, twisted by
<span class="math">\(D\)</span>, given modulo <span class="math">\(p^n\)</span>.</p>
<p><strong>Characters.</strong> The set of continuous characters of
<span class="math">\({Gal}(\mathbb{Q}(\mu_{p^{ oo }})/ \mathbb{Q})\)</span> is identified to <span class="math">\(\mathbb{Z}_p^*\)</span> via the
cyclotomic character <span class="math">\(\chi\)</span> with values in <span class="math">\(\overline{\mathbb{Q}_p}^*\)</span>. Denote by
<span class="math">\(\tau:\mathbb{Z}_p^*\to\mathbb{Z}_p^*\)</span> the Teichmüller character, with values
in the <span class="math">\((p-1)\)</span>-th roots of <span class="math">\(1\)</span> for <span class="math">\(p != 2\)</span>, and <span class="math">\({-1,1}\)</span> for <span class="math">\(p = 2\)</span>;
finally, let
<span class="math">\(&lt;\chi&gt;= \chi \tau^{-1}\)</span>, with values in <span class="math">\(1 + 2p\mathbb{Z}_p\)</span>.
In GP, the continuous character of
<span class="math">\({Gal}(\mathbb{Q}(\mu_{p^{ oo }})/ \mathbb{Q})\)</span> given by <span class="math">\(&lt;\chi&gt;^{s_1}
\tau^{s_2}\)</span> is represented by the pair of integers <span class="math">\(s = (s_1,s_2)\)</span>, with <span class="math">\(s_1
belongs to \mathbb{Z}_p\)</span> and <span class="math">\(s_2 mod p-1\)</span> for <span class="math">\(p &gt; 2\)</span>, (resp. mod <span class="math">\(2\)</span> for <span class="math">\(p = 2\)</span>); <span class="math">\(s\)</span>
may be also an integer, representing <span class="math">\((s,s)\)</span> or <span class="math">\(\chi^s\)</span>.</p>
<p><strong>The :math:`p</strong>-adic <span class="math">\(L\)</span> function.`
The <span class="math">\(p\)</span>-adic <span class="math">\(L\)</span> function <span class="math">\(L_p\)</span> is defined on the set of continuous
characters of <span class="math">\({Gal}(\mathbb{Q}(\mu_{p^{ oo }})/ \mathbb{Q})\)</span>, as <span class="math">\(\int_{\mathbb{Z}_p^*}
\chi^s d \mu\)</span> for a certain <span class="math">\(p\)</span>-adic distribution <span class="math">\(\mu\)</span> on <span class="math">\(\mathbb{Z}_p^*\)</span>. The
derivative is given by</p>
<div class="math">
\[L_p^{(r)}(E, \chi^s) = \int_{\mathbb{Z}_p^*} \log_p^r(a) \chi^s(a) d\mu(a).\]</div>
<p>More precisely:</p>
<ul class="simple">
<li>When <span class="math">\(E\)</span> has good supersingular reduction, <span class="math">\(L_p\)</span> takes its
values in <span class="math">\(\mathbb{Q}_p \otimes H^1_{dR}(E/\mathbb{Q})\)</span> and satisfies</li>
</ul>
<div class="math">
\[ \begin{align}\begin{aligned}  (1-p^{-1} F)^{-2} L_p(E, \chi^0) = (L(E,1) / \Omega).\omega\\where :math:`F` is the Frobenius, :math:`L(E,1)` is the value of the complex :math:`L`
function at :math:`1`, :math:`\omega` is the Néron differential
and :math:`\Omega` the attached period on :math:`E(\mathbb{R})`. Here, :math:`\chi^0` represents
the trivial character.\end{aligned}\end{align} \]</div>
<p>The function returns the components of <span class="math">\(L_p^{(r)}(E,\chi^s)\)</span> in
the basis <span class="math">\((\omega, F(\omega))\)</span>.</p>
<ul class="simple">
<li>When <span class="math">\(E\)</span> has ordinary good reduction, this method only defines
the projection of <span class="math">\(L_p(E,\chi^s)\)</span> on the <span class="math">\(\alpha\)</span>-eigenspace,
where <span class="math">\(\alpha\)</span> is the unit eigenvalue for <span class="math">\(F\)</span>. This is what the function
returns. We have</li>
</ul>
<div class="math">
\[(1- \alpha^{-1})^{-2} L_{p,\alpha}(E,\chi^0) = L(E,1) / \Omega.\]</div>
<p>Two supersingular examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? cxL(e) = bestappr( ellL1(e) / e.omega[1] );

? e = ellinit(&quot;17a1&quot;); p=3; \\ supersingular, a3 = 0
? L = ellpadicL(e,p,4);
? F = [0,-p;1,ellap(e,p)]; \\ Frobenius matrix in the basis (omega,F(omega))
? (1-p^(-1)*F)^-2 * L / cxL(e)
%5 = [1 + O(3^5), O(3^5)]~ \\ [1,0]~

? e = ellinit(&quot;116a1&quot;); p=3; \\ supersingular, a3 != 0~
? L = ellpadicL(e,p,4);
? F = [0,-p; 1,ellap(e,p)];
? (1-p^(-1)*F)^-2*L~ / cxL(e)
%9 = [1 + O(3^4), O(3^5)]~
</pre></div>
</div>
<p>Good ordinary reduction:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? e = ellinit(&quot;17a1&quot;); p=5; ap = ellap(e,p)
%1 = -2 \\ ordinary
? L = ellpadicL(e,p,4)
%2 = 4 + 3*5 + 4*5^2 + 2*5^3 + O(5^4)
? al = padicappr(x^2 - ap*x + p, ap + O(p^7))[1];
? (1-al^(-1))^(-2) * L / cxL(e)
%4 = 1 + O(5^4)
</pre></div>
</div>
<p>Twist and Teichmüller:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? e = ellinit(&quot;17a1&quot;); p=5; \\ ordinary
\\ 2nd derivative at \tau^1, twist by -7
? ellpadicL(e, p, 4, [0,1], 2, -7)
%2 = 2*5^2 + 5^3 + O(5^4)
</pre></div>
</div>
<p>This function is a special case of <code class="docutils literal"><span class="pre">mspadicL</span></code>, and it also appears
as the first term of <code class="docutils literal"><span class="pre">mspadicseries</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? e = ellinit(&quot;17a1&quot;); p=5;
? L = ellpadicL(e,p,4)
%2 = 4 + 3*5 + 4*5^2 + 2*5^3 + O(5^4)
? [M,phi] = msfromell(e, 1);
? Mp = mspadicinit(M, p, 4);
? mu = mspadicmoments(Mp, phi);
? mspadicL(mu)
%6 = 4 + 3*5 + 4*5^2 + 2*5^3 + 2*5^4 + 5^5 + O(5^6)
? mspadicseries(mu)
%7 = (4 + 3*5 + 4*5^2 + 2*5^3 + 2*5^4 + 5^5 + O(5^6))
 + (3 + 3*5 + 5^2 + 5^3 + O(5^4))*x
 + (2 + 3*5 + 5^2 + O(5^3))*x^2
 + (3 + 4*5 + 4*5^2 + O(5^3))*x^3
 + (3 + 2*5 + O(5^2))*x^4 + O(x^5)
</pre></div>
</div>
<p>These are more cumbersome than <code class="docutils literal"><span class="pre">ellpadicL</span></code> but allow to
compute at different characters, or successive derivatives, or to
twist by a quadratic character essentially for the cost of a single call to
<code class="docutils literal"><span class="pre">ellpadicL</span></code> due to precomputations.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellpadicfrobenius">
<code class="descname">ellpadicfrobenius</code><span class="sig-paren">(</span><em>E</em>, <em>p</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellpadicfrobenius" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(p &gt; 2\)</span> is a prime and <span class="math">\(E\)</span> is a elliptic curve on <span class="math">\(\mathbb{Q}\)</span> with good
reduction at <span class="math">\(p\)</span>, return the matrix of the Frobenius endomorphism <span class="math">\(\varphi\)</span> on
the crystalline module <span class="math">\(D_p(E) = \mathbb{Q}_p \otimes H^1_{dR}(E/\mathbb{Q})\)</span> with respect to
the basis of the given model <span class="math">\((\omega, \eta = x \omega)\)</span>, where
<span class="math">\(\omega = dx/(2 y+a_1 x+a_3)\)</span> is the invariant differential.
The characteristic polynomial of <span class="math">\(\varphi\)</span> is <span class="math">\(x^2 - a_p x + p\)</span>.
The matrix is computed to absolute <span class="math">\(p\)</span>-adic precision <span class="math">\(p^n\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([1,-1,1,0,0]);
? F = ellpadicfrobenius(E,5,3);
? lift(F)
%3 =
[120 29]

[ 55 5]
? charpoly(F)
%4 = x^2 + O(5^3)*x + (5 + O(5^3))
? ellap(E, 5)
%5 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellpadicheight">
<code class="descname">ellpadicheight</code><span class="sig-paren">(</span><em>E</em>, <em>p</em>, <em>n</em>, <em>P</em>, <em>Q=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellpadicheight" title="Permalink to this definition">¶</a></dt>
<dd><p>Cyclotomic <span class="math">\(p\)</span>-adic height of the rational point <span class="math">\(P\)</span> on the elliptic curve
<span class="math">\(E\)</span> (defined over <span class="math">\(\mathbb{Q}\)</span>), given to <span class="math">\(n\)</span> <span class="math">\(p\)</span>-adic digits.
If the argument <span class="math">\(Q\)</span> is present, computes the value of the bilinear
form <span class="math">\((h(P+Q)-h(P-Q)) / 4\)</span>.</p>
<p>Let <span class="math">\(D_{dR}(E) := H^1_{dR}(E) \otimes_\mathbb{Q} \mathbb{Q}_p\)</span> be the <span class="math">\(\mathbb{Q}_p\)</span> vector space
spanned by <span class="math">\(\omega\)</span>
(invariant differential <span class="math">\(dx/(2y+a_1x+a3)\)</span> related to the given model) and
<span class="math">\(\eta = x \omega\)</span>. Then the cyclotomic <span class="math">\(p\)</span>-adic height associates to
<span class="math">\(P belongs to E(\mathbb{Q})\)</span> an element <span class="math">\(f \omega + g\eta\)</span> in <span class="math">\(D_{dR}\)</span>.
This routine returns the vector <span class="math">\([f, g]\)</span> to <span class="math">\(n\)</span> <span class="math">\(p\)</span>-adic digits.</p>
<p>If <span class="math">\(P belongs to E(\mathbb{Q})\)</span> is in the kernel of reduction mod <span class="math">\(p\)</span> and if its reduction
at all finite places is non singular, then <span class="math">\(g = -(\log_E P)^2\)</span>, where
<span class="math">\(\log_E\)</span> is the logarithm for the formal group of <span class="math">\(E\)</span> at <span class="math">\(p\)</span>.</p>
<p>If furthermore the model is of the form <span class="math">\(Y^2 = X^3 + a X + b\)</span> and <span class="math">\(P = (x,y)\)</span>,
then</p>
<div class="math">
\[f = \log_p(denominator(x)) - 2 \log_p(\sigma(P))\]</div>
<p>where <span class="math">\(\sigma(P)\)</span> is given by <code class="docutils literal"><span class="pre">ellsigma</span></code><span class="math">\((E,P)\)</span>.</p>
<p>Recall (<em>Advanced topics in the arithmetic of elliptic
curves</em>, Theorem&nbsp;3.2) that the local height function over the complex numbers
is of the form</p>
<div class="math">
\[\lambda(z) = -\log (\|E.disc\|) / 6 + \Re(z \eta(z)) - 2 \log(
\sigma(z).\]</div>
<p>(N.B. our normalization for local and global heights is twice that of
Silverman&#8217;s).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([1,-1,1,0,0]); P = [0,0];
? ellpadicheight(E,5,4, P)
%2 = [3*5 + 5^2 + 2*5^3 + O(5^4), 5^2 + 4*5^4 + O(5^6)]
? E = ellinit(&quot;11a1&quot;); P = [5,5]; \\ torsion point
? ellpadicheight(E,19,6, P)
%4 = O(19^6)
? E = ellinit([0,0,1,-4,2]); P = [-2,1];
? ellpadicheight(E,3,5, P)
%6 = [2*3^2 + 2*3^3 + 3^4 + O(3^5), 2*3^2 + 3^4 + 2*3^5 + 3^6 + O(3^7)]
? ellpadicheight(E,3,5, P, elladd(E,P,P))
</pre></div>
</div>
<p>One can replace the parameter <span class="math">\(p\)</span> prime by a vector <span class="math">\([p,[a,b]]\)</span>, in which
case the routine returns the <span class="math">\(p\)</span>-adic number <span class="math">\(af + bg\)</span>.</p>
<p>When <span class="math">\(E\)</span> has good ordinary reduction at <span class="math">\(p\)</span>, the &#8220;canonical&#8221;
<span class="math">\(p\)</span>-adic height is given by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">s2</span> <span class="o">=</span> <span class="n">ellpadics2</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">ellpadicheight</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="p">[</span><span class="n">p</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="n">s2</span><span class="p">]],</span> <span class="n">n</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
</pre></div>
</div>
<p>Since <span class="math">\(s_2\)</span> does not depend on <span class="math">\(P\)</span>, it is preferable to
compute it only once:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit(&quot;5077a1&quot;); p = 5; n = 7;
? s2 = ellpadics2(E,p,n);
? M = ellpadicheightmatrix(E,[p,[1,-s2]], n, E.gen);
? matdet(M) \\ p-adic regulator
%4 = 5 + 5^2 + 4*5^3 + 2*5^4 + 2*5^5 + 5^6 + O(5^7)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellpadicheightmatrix">
<code class="descname">ellpadicheightmatrix</code><span class="sig-paren">(</span><em>E</em>, <em>p</em>, <em>n</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellpadicheightmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(v\)</span> being a vector of points, this function outputs the Gram matrix of
<span class="math">\(v\)</span> with respect to the cyclotomic <span class="math">\(p\)</span>-adic height, given to <span class="math">\(n\)</span> <span class="math">\(p\)</span>-adic
digits; in other words, the <span class="math">\((i,j)\)</span> component of the matrix is equal to
<code class="docutils literal"><span class="pre">ellpadicheight</span></code><span class="math">\((E,p,n, v[i],v[j]) = [f,g]\)</span>.</p>
<p>See <code class="docutils literal"><span class="pre">ellpadicheight</span></code>; in particular one can replace the parameter <span class="math">\(p\)</span>
prime by a vector <span class="math">\([p,[a,b]]\)</span>, in which case the routine returns the matrix
containing the <span class="math">\(p\)</span>-adic numbers <span class="math">\(af + bg\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellpadiclog">
<code class="descname">ellpadiclog</code><span class="sig-paren">(</span><em>E</em>, <em>p</em>, <em>n</em>, <em>P</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellpadiclog" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <span class="math">\(E\)</span> defined over <span class="math">\(K = \mathbb{Q}\)</span> or <span class="math">\(\mathbb{Q}_p\)</span> and <span class="math">\(P = [x,y]\)</span> on <span class="math">\(E(K)\)</span> in the
kernel of reduction mod <span class="math">\(p\)</span>, let <span class="math">\(t(P) = -x/y\)</span> be the formal group
parameter; this function returns <span class="math">\(L(t)\)</span>, where <span class="math">\(L\)</span> denotes the formal
logarithm (mapping the formal group of <span class="math">\(E\)</span> to the additive formal group)
attached to the canonical invariant differential:
<span class="math">\(dL = dx/(2y + a_1x + a_3)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellpadics2">
<code class="descname">ellpadics2</code><span class="sig-paren">(</span><em>E</em>, <em>p</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellpadics2" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(p &gt; 2\)</span> is a prime and <span class="math">\(E/\mathbb{Q}\)</span> is a elliptic curve with ordinary good
reduction at <span class="math">\(p\)</span>, returns the slope of the unit eigenvector
of <code class="docutils literal"><span class="pre">ellpadicfrobenius(E,p,n)</span></code>, i.e. the action of Frobenius <span class="math">\(\varphi\)</span> on
the crystalline module <span class="math">\(D_p(E) = \mathbb{Q}_p \otimes H^1_{dR}(E/\mathbb{Q})\)</span> in the basis of
the given model <span class="math">\((\omega, \eta = x \omega)\)</span>, where <span class="math">\(\omega\)</span> is the invariant
differential <span class="math">\(dx/(2 y+a_1 x+a_3)\)</span>. In other words, <span class="math">\(\eta + s_2\omega\)</span>
is an eigenvector for the unit eigenvalue of <span class="math">\(\varphi\)</span>.</p>
<p>This slope is the unique <span class="math">\(c belongs to 3^{-1}\mathbb{Z}_p\)</span> such that the odd solution
<span class="math">\(\sigma(t) = t + O(t^2)\)</span> of</p>
<div class="math">
\[- d((1)/(\sigma) (d \sigma)/(\omega))
= (x(t) + c) \omega\]</div>
<p>is in <span class="math">\(t\mathbb{Z}_p[[t]]\)</span>.</p>
<p>It is equal to <span class="math">\(b_2/12 - E_2/12\)</span> where <span class="math">\(E_2\)</span> is the value of the Katz
<span class="math">\(p\)</span>-adic Eisenstein series of weight 2 on <span class="math">\((E,\omega)\)</span>. This is
used to construct a canonical <span class="math">\(p\)</span>-adic height when <span class="math">\(E\)</span> has good ordinary
reduction at <span class="math">\(p\)</span> as follows</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">s2</span> <span class="o">=</span> <span class="n">ellpadics2</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">h</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">n</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">=</span> <span class="n">ellpadicheight</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="p">[</span><span class="n">p</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="n">s2</span><span class="p">]],</span><span class="n">n</span><span class="p">,</span> <span class="n">P</span><span class="p">);</span>
</pre></div>
</div>
<p>Since <span class="math">\(s_2\)</span> does not depend on the point <span class="math">\(P\)</span>, we compute it
only once.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellperiods">
<code class="descname">ellperiods</code><span class="sig-paren">(</span><em>w</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellperiods" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(w\)</span> describe a complex period lattice (<span class="math">\(w = [w_1,w_2]\)</span>
or an <code class="docutils literal"><span class="pre">ellinit</span></code> structure). Returns normalized periods <span class="math">\([W_1,W_2]\)</span> generating
the same lattice such that <span class="math">\(\tau := W_1/W_2\)</span> has positive imaginary part
and lies in the standard fundamental domain for <span class="math">\({SL}_2(\mathbb{Z})\)</span>.</p>
<p>If <span class="math">\(flag = 1\)</span>, the function returns <span class="math">\([[W_1,W_2], [\eta_1,\eta_2]]\)</span>, where
<span class="math">\(\eta_1\)</span> and <span class="math">\(\eta_2\)</span> are the quasi-periods associated to
<span class="math">\([W_1,W_2]\)</span>, satisfying <span class="math">\(\eta_1 W_2 - \eta_2 W_1 = 2 i \Pi\)</span>.</p>
<p>The output of this function is meant to be used as the first argument
given to ellwp, ellzeta, ellsigma or elleisnum. Quasi-periods are
needed by ellzeta and ellsigma only.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellpointtoz">
<code class="descname">ellpointtoz</code><span class="sig-paren">(</span><em>E</em>, <em>P</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellpointtoz" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(E/\mathbb{C} ~ \mathbb{C}/\Lambda\)</span> is a complex elliptic curve (<span class="math">\(\Lambda = 
E.omega\)</span>),
computes a complex number <span class="math">\(z\)</span>, well-defined modulo the lattice <span class="math">\(\Lambda\)</span>,
corresponding to the point <span class="math">\(P\)</span>; i.e.&nbsp;such that
<span class="math">\(P = [\wp_\Lambda(z),\wp'_\Lambda(z)]\)</span>
satisfies the equation</p>
<div class="math">
\[y^2 = 4x^3 - g_2 x - g_3,\]</div>
<p>where <span class="math">\(g_2\)</span>, <span class="math">\(g_3\)</span> are the elliptic invariants.</p>
<p>If <span class="math">\(E\)</span> is defined over <span class="math">\(\mathbb{R}\)</span> and <span class="math">\(P belongs to E(\mathbb{R})\)</span>, we have more precisely, <span class="math">\(0 \leq
\Re(t) &lt; w1\)</span> and <span class="math">\(0 &lt;= \Im(t) &lt; \Im(w2)\)</span>, where <span class="math">\((w1,w2)\)</span> are the real and
complex periods of <span class="math">\(E\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([0,1]); P = [2,3];
? z = ellpointtoz(E, P)
%2 = 3.5054552633136356529375476976257353387
? ellwp(E, z)
%3 = 2.0000000000000000000000000000000000000
? ellztopoint(E, z) - P
%4 = [6.372367644529809109 E-58, 7.646841173435770930 E-57]
? ellpointtoz(E, [0]) \\ the point at infinity
%5 = 0
</pre></div>
</div>
<p>If <span class="math">\(E/\mathbb{Q}_p\)</span> has multiplicative reduction, then <span class="math">\(E/\bar{\mathbb{Q}_p}\)</span> is analytically
isomorphic to <span class="math">\(\bar{\mathbb{Q}}_p^*/q^\mathbb{Z}\)</span> (Tate curve) for some <span class="math">\(p\)</span>-adic integer <span class="math">\(q\)</span>.
The behaviour is then as follows:</p>
<ul class="simple">
<li>If the reduction is split (<span class="math">\(E.tate[2]\)</span> is a <code class="docutils literal"><span class="pre">t_PADIC</span></code>), we have
an isomorphism <span class="math">\(\phi: E(\mathbb{Q}_p) ~ \mathbb{Q}_p^*/q^\mathbb{Z}\)</span> and the function returns
<span class="math">\(\phi(P) belongs to \mathbb{Q}_p\)</span>.</li>
<li>If the reduction is <em>not</em> split (<span class="math">\(E.tate[2]\)</span> is a
<code class="docutils literal"><span class="pre">t_POLMOD</span></code>), we only have an isomorphism <span class="math">\(\phi: E(K) ~ K^*/q^\mathbb{Z}\)</span> over
the unramified quadratic extension <span class="math">\(K/\mathbb{Q}_p\)</span>. In this case, the output
<span class="math">\(\phi(P) belongs to K\)</span> is a <code class="docutils literal"><span class="pre">t_POLMOD</span></code>.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([0,-1,1,0,0], O(11^5)); P = [0,0];
? [u2,u,q] = E.tate; type(u) \\ split multiplicative reduction
%2 = &quot;t_PADIC&quot;
? ellmul(E, P, 5) \\ P has order 5
%3 = [0]
? z = ellpointtoz(E, [0,0])
%4 = 3 + 11^2 + 2*11^3 + 3*11^4 + O(11^5)
? z^5
%5 = 1 + O(11^5)
? E = ellinit(ellfromj(1/4), O(2^6)); x=1/2; y=ellordinate(E,x)[1];
? z = ellpointtoz(E,[x,y]); \\ t_POLMOD of t_POL with t_PADIC coeffs
? liftint(z) \\ lift all p-adics
%8 = Mod(8*u + 7, u^2 + 437)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellpow">
<code class="descname">ellpow</code><span class="sig-paren">(</span><em>E</em>, <em>z</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated alias for <code class="docutils literal"><span class="pre">ellmul</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellrootno">
<code class="descname">ellrootno</code><span class="sig-paren">(</span><em>E</em>, <em>p=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellrootno" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(E\)</span> being an <code class="docutils literal"><span class="pre">ell</span></code> structure over <span class="math">\(\mathbb{Q}\)</span> as output by <code class="docutils literal"><span class="pre">ellinit</span></code>,
this function computes the local root number of its <span class="math">\(L\)</span>-series at the place
<span class="math">\(p\)</span> (at the infinite place if <span class="math">\(p = 0\)</span>). If <span class="math">\(p\)</span> is omitted, return the global
root number. Note that the global root number is the sign of the functional
equation and conjecturally is the parity of the rank of the \idx{Mordell-Weil
group}. The equation for <span class="math">\(E\)</span> needs not be minimal at <span class="math">\(p\)</span>, but if the model
is already minimal the function will run faster.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellsearch">
<code class="descname">ellsearch</code><span class="sig-paren">(</span><em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellsearch" title="Permalink to this definition">¶</a></dt>
<dd><p>This function finds all curves in the <code class="docutils literal"><span class="pre">elldata</span></code> database satisfying
the constraint defined by the argument <span class="math">\(N\)</span>:</p>
<ul class="simple">
<li>if <span class="math">\(N\)</span> is a character string, it selects a given curve, e.g.
<code class="docutils literal"><span class="pre">&quot;11a1&quot;</span></code>, or curves in the given isogeny class, e.g. <code class="docutils literal"><span class="pre">&quot;11a&quot;</span></code>, or
curves with given conductor, e.g. <code class="docutils literal"><span class="pre">&quot;11&quot;</span></code>;</li>
<li>if <span class="math">\(N\)</span> is a vector of integers, it encodes the same constraints
as the character string above, according to the <code class="docutils literal"><span class="pre">ellconvertname</span></code>
correspondance, e.g. <code class="docutils literal"><span class="pre">[11,0,1]</span></code> for <code class="docutils literal"><span class="pre">&quot;11a1&quot;</span></code>, <code class="docutils literal"><span class="pre">[11,0]</span></code> for
<code class="docutils literal"><span class="pre">&quot;11a&quot;</span></code> and <code class="docutils literal"><span class="pre">[11]</span></code> for <code class="docutils literal"><span class="pre">&quot;11&quot;</span></code>;</li>
<li>if <span class="math">\(N\)</span> is an integer, curves with conductor <span class="math">\(N\)</span> are selected.</li>
</ul>
<p>If <span class="math">\(N\)</span> is a full curve name, e.g. <code class="docutils literal"><span class="pre">&quot;11a1&quot;</span></code> or <code class="docutils literal"><span class="pre">[11,0,1]</span></code>,
the output format is <span class="math">\([N, [a_1,a_2,a_3,a_4,a_6], G]\)</span> where
<span class="math">\([a_1,a_2,a_3,a_4,a_6]\)</span> are the coefficients of the Weierstrass equation of
the curve and <span class="math">\(G\)</span> is a <span class="math">\(\mathbb{Z}\)</span>-basis of the free part of the \idx{Mordell-Weil
group} associated to the curve.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? ellsearch(&quot;11a3&quot;)
%1 = [&quot;11a3&quot;, [0, -1, 1, 0, 0], []]
? ellsearch([11,0,3])
%2 = [&quot;11a3&quot;, [0, -1, 1, 0, 0], []]
</pre></div>
</div>
<p>If <span class="math">\(N\)</span> is not a full curve name, then the output is a vector of all matching
curves in the above format:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? ellsearch(&quot;11a&quot;)
%1 = [[&quot;11a1&quot;, [0, -1, 1, -10, -20], []],
 [&quot;11a2&quot;, [0, -1, 1, -7820, -263580], []],
 [&quot;11a3&quot;, [0, -1, 1, 0, 0], []]]
? ellsearch(&quot;11b&quot;)
%2 = []
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellsigma">
<code class="descname">ellsigma</code><span class="sig-paren">(</span><em>L</em>, <em>z=None</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellsigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the value at <span class="math">\(z\)</span> of the Weierstrass <span class="math">\(\sigma\)</span> function attached to
the lattice <span class="math">\(L\)</span> as given by <code class="docutils literal"><span class="pre">ellperiods</span></code><span class="math">\((,1)\)</span>: including quasi-periods
is useful, otherwise there are recomputed from scratch for each new <span class="math">\(z\)</span>.</p>
<div class="math">
\[\sigma(z, L) = z \prod_{\omega belongs to L^*} (1 -
(z)/(\omega))e^{(z)/(\omega) + (z^2)/(2\omega^2)}.\]</div>
<p>It is also possible to directly input <span class="math">\(L = [\omega_1,\omega_2]\)</span>,
or an elliptic curve <span class="math">\(E\)</span> as given by <code class="docutils literal"><span class="pre">ellinit</span></code> (<span class="math">\(L = E.omega\)</span>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? w = ellperiods([1,I], 1);
? ellsigma(w, 1/2)
%2 = 0.47494937998792065033250463632798296855
? E = ellinit([1,0]);
? ellsigma(E) \\ at &#39;x, implicitly at default seriesprecision
%4 = x + 1/60*x^5 - 1/10080*x^9 - 23/259459200*x^13 + O(x^17)
</pre></div>
</div>
<p>If <span class="math">\(flag = 1\)</span>, computes an arbitrary determination of <span class="math">\(\log(\sigma(z))\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellsub">
<code class="descname">ellsub</code><span class="sig-paren">(</span><em>E</em>, <em>z1</em>, <em>z2</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellsub" title="Permalink to this definition">¶</a></dt>
<dd><p>Difference of the points <span class="math">\(z1\)</span> and <span class="math">\(z2\)</span> on the
elliptic curve corresponding to <span class="math">\(E\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elltaniyama">
<code class="descname">elltaniyama</code><span class="sig-paren">(</span><em>E</em>, <em>serprec=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elltaniyama" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the modular parametrization of the elliptic curve <span class="math">\(E/\mathbb{Q}\)</span>,
where <span class="math">\(E\)</span> is an <code class="docutils literal"><span class="pre">ell</span></code> structure as output by <code class="docutils literal"><span class="pre">ellinit</span></code>. This returns
a two-component vector <span class="math">\([u,v]\)</span> of power series, given to <span class="math">\(d\)</span> significant
terms (<code class="docutils literal"><span class="pre">seriesprecision</span></code> by default), characterized by the following two
properties. First the point <span class="math">\((u,v)\)</span> satisfies the equation of the elliptic
curve. Second, let <span class="math">\(N\)</span> be the conductor of <span class="math">\(E\)</span> and <span class="math">\(\Phi: X_0(N)\to E\)</span>
be a modular parametrization; the pullback by <span class="math">\(\Phi\)</span> of the
Néron differential <span class="math">\(du/(2v+a_1u+a_3)\)</span> is equal to <span class="math">\(2i\Pi
f(z)dz\)</span>, a holomorphic differential form. The variable used in the power
series for <span class="math">\(u\)</span> and <span class="math">\(v\)</span> is <span class="math">\(x\)</span>, which is implicitly understood to be equal to
<span class="math">\(\exp(2i\Pi z)\)</span>.</p>
<p>The algorithm assumes that <span class="math">\(E\)</span> is a <em>strong</em> Weil curve
and that the Manin constant is equal to 1: in fact, <span class="math">\(f(x) = \sum_{n &gt; 0}
ellan(E, n) x^n\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elltatepairing">
<code class="descname">elltatepairing</code><span class="sig-paren">(</span><em>E</em>, <em>P</em>, <em>Q</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elltatepairing" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Tate pairing of the two points <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> on the elliptic
curve <span class="math">\(E\)</span>. The point <span class="math">\(P\)</span> must be of <span class="math">\(m\)</span>-torsion.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elltors">
<code class="descname">elltors</code><span class="sig-paren">(</span><em>E</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elltors" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(E\)</span> is an elliptic curve defined over a number field or a finite field,
outputs the torsion subgroup of <span class="math">\(E\)</span> as a 3-component vector <code class="docutils literal"><span class="pre">[t,v1,v2]</span></code>,
where <code class="docutils literal"><span class="pre">t</span></code> is the order of the torsion group, <code class="docutils literal"><span class="pre">v1</span></code> gives the structure
of the torsion group as a product of cyclic groups (sorted by decreasing
order), and <code class="docutils literal"><span class="pre">v2</span></code> gives generators for these cyclic groups. <span class="math">\(E\)</span> must be an
<code class="docutils literal"><span class="pre">ell</span></code> structure as output by <code class="docutils literal"><span class="pre">ellinit</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([-1,0]);
? elltors(E)
%1 = [4, [2, 2], [[0, 0], [1, 0]]]
</pre></div>
</div>
<p>Here, the torsion subgroup is isomorphic to <span class="math">\(\mathbb{Z}/2\mathbb{Z} x \mathbb{Z}/2\mathbb{Z}\)</span>, with
generators <span class="math">\([0,0]\)</span> and <span class="math">\([1,0]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.elltwist">
<code class="descname">elltwist</code><span class="sig-paren">(</span><em>E</em>, <em>P=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.elltwist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coefficients <span class="math">\([a_1,a_2,a_3,a_4,a_6]\)</span> of the twist of the
elliptic curve <span class="math">\(E\)</span> by the quadratic extension of the coefficient ring
defined by <span class="math">\(P\)</span> (when <span class="math">\(P\)</span> is a polynomial) or <code class="docutils literal"><span class="pre">quadpoly(P)</span></code> when <span class="math">\(P\)</span> is an
integer. If <span class="math">\(E\)</span> is defined over a finite field, then <span class="math">\(P\)</span> can be omitted,
in which case a random model of the unique non-trivial twist is returned.</p>
<p>Example: Twist by discriminant <span class="math">\(-3\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? elltwist(ellinit([0,a2,0,a4,a6]),-3)
%1 = [0,-3*a2,0,9*a4,-27*a6]
</pre></div>
</div>
<p>Twist by the Artin-Shreier extension given by <span class="math">\(x^2+x+T\)</span> in
characteristic <span class="math">\(2\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? lift(elltwist(ellinit([a1,a2,a3,a4,a6]*Mod(1,2)),x^2+x+T))
%1 = [a1,a2+a1^2*T,a3,a4,a6+a3^2*T]
</pre></div>
</div>
<p>Twist of an elliptic curve defined over a finite field:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E=ellinit([1,7]*Mod(1,19));lift(elltwist(E))
%1 = [0,0,0,11,12]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellweilpairing">
<code class="descname">ellweilpairing</code><span class="sig-paren">(</span><em>E</em>, <em>P</em>, <em>Q</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellweilpairing" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Weil pairing of the two points of <span class="math">\(m\)</span>-torsion <span class="math">\(P\)</span> and <span class="math">\(Q\)</span>
on the elliptic curve <span class="math">\(E\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellwp">
<code class="descname">ellwp</code><span class="sig-paren">(</span><em>w</em>, <em>z=None</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellwp" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the value at <span class="math">\(z\)</span> of the Weierstrass <span class="math">\(\wp\)</span> function attached to
the lattice <span class="math">\(w\)</span> as given by <code class="docutils literal"><span class="pre">ellperiods</span></code>. It is also possible to
directly input <span class="math">\(w = [\omega_1,\omega_2]\)</span>, or an elliptic curve <span class="math">\(E\)</span> as given
by <code class="docutils literal"><span class="pre">ellinit</span></code> (<span class="math">\(w = E.omega\)</span>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? w = ellperiods([1,I]);
? ellwp(w, 1/2)
%2 = 6.8751858180203728274900957798105571978
? E = ellinit([1,1]);
? ellwp(E, 1/2)
%4 = 3.9413112427016474646048282462709151389
</pre></div>
</div>
<p>One can also compute the series expansion around <span class="math">\(z = 0\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([1,0]);
? ellwp(E) \\ &#39;x implicitly at default seriesprecision
%5 = x^-2 - 1/5*x^2 + 1/75*x^6 - 2/4875*x^10 + O(x^14)
? ellwp(E, x + O(x^12)) \\ explicit precision
%6 = x^-2 - 1/5*x^2 + 1/75*x^6 + O(x^9)
</pre></div>
</div>
<p>Optional <em>flag</em> means 0 (default): compute only <span class="math">\(\wp(z)\)</span>, 1: compute
<span class="math">\([\wp(z),\wp'(z)]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellxn">
<code class="descname">ellxn</code><span class="sig-paren">(</span><em>E</em>, <em>n</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellxn" title="Permalink to this definition">¶</a></dt>
<dd><p>In standard notation, for any affine point <span class="math">\(P = (v,w)\)</span> on the
curve <span class="math">\(E\)</span>, we have</p>
<div class="math">
\[[n]P = (\phi_n(P)\psi_n(P) : \omega_n(P) : \psi_n(P)^3)\]</div>
<p>for some polynomials <span class="math">\(\phi_n,\omega_n,\psi_n\)</span> in
<span class="math">\(\mathbb{Z}[a_1,a_2,a_3,a_4,a_6][v,w]\)</span>. This function returns
<span class="math">\([\phi_n(P),\psi_n(P)^2]\)</span>, which give the numerator and denominator of
the abcissa of <span class="math">\([n]P\)</span> and depend only on <span class="math">\(v\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellzeta">
<code class="descname">ellzeta</code><span class="sig-paren">(</span><em>w</em>, <em>z=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellzeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the value at <span class="math">\(z\)</span> of the Weierstrass <span class="math">\(\zeta\)</span> function attached to
the lattice <span class="math">\(w\)</span> as given by <code class="docutils literal"><span class="pre">ellperiods</span></code><span class="math">\((,1)\)</span>: including quasi-periods
is useful, otherwise there are recomputed from scratch for each new <span class="math">\(z\)</span>.</p>
<div class="math">
\[\zeta(z, L) = (1)/(z) + z^2\sum_{\omega belongs to L^*}
(1)/(\omega^2(z-\omega)).\]</div>
<p>It is also possible to directly input <span class="math">\(w = [\omega_1,\omega_2]\)</span>,
or an elliptic curve <span class="math">\(E\)</span> as given by <code class="docutils literal"><span class="pre">ellinit</span></code> (<span class="math">\(w = E.omega\)</span>).
The quasi-periods of <span class="math">\(\zeta\)</span>, such that</p>
<div class="math">
\[\zeta(z + a\omega_1 + b\omega_2) = \zeta(z) + a\eta_1 + b\eta_2\]</div>
<p>for integers <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are obtained as <span class="math">\(\eta_i = 2\zeta(\omega_i/2)\)</span>.
Or using directly <code class="docutils literal"><span class="pre">elleta</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? w = ellperiods([1,I],1);
? ellzeta(w, 1/2)
%2 = 1.5707963267948966192313216916397514421
? E = ellinit([1,0]);
? ellzeta(E, E.omega[1]/2)
%4 = 0.84721308479397908660649912348219163647
</pre></div>
</div>
<p>One can also compute the series expansion around <span class="math">\(z = 0\)</span>
(the quasi-periods are useless in this case):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([0,1]);
? ellzeta(E) \\ at &#39;x, implicitly at default seriesprecision
%4 = x^-1 + 1/35*x^5 - 1/7007*x^11 + O(x^15)
? ellzeta(E, x + O(x^20)) \\ explicit precision
%5 = x^-1 + 1/35*x^5 - 1/7007*x^11 + 1/1440257*x^17 + O(x^18)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ellztopoint">
<code class="descname">ellztopoint</code><span class="sig-paren">(</span><em>E</em>, <em>z</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ellztopoint" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(E\)</span> being an <em>ell</em> as output by
<code class="docutils literal"><span class="pre">ellinit</span></code>, computes the coordinates <span class="math">\([x,y]\)</span> on the curve <span class="math">\(E\)</span>
corresponding to the complex number <span class="math">\(z\)</span>. Hence this is the inverse function
of <code class="docutils literal"><span class="pre">ellpointtoz</span></code>. In other words, if the curve is put in Weierstrass
form <span class="math">\(y^2 = 4x^3 - g_2x - g_3\)</span>, <span class="math">\([x,y]\)</span> represents the Weierstrass
<span class="math">\(\wp\)</span>-function and its derivative. More
precisely, we have</p>
<div class="math">
\[x = \wp(z) - b_2/12, y = \wp'(z) - (a_1 x + a_3)/2.\]</div>
<p>If <span class="math">\(z\)</span> is in the lattice defining <span class="math">\(E\)</span> over <span class="math">\(\mathbb{C}\)</span>, the result is the point at
infinity <span class="math">\([0]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.erfc">
<code class="descname">erfc</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.erfc" title="Permalink to this definition">¶</a></dt>
<dd><p>Complementary error function, analytic continuation of
<span class="math">\((2/\sqrt\Pi)\int_x^ oo e^{-t^2}dt = incgam(1/2,x^2)/\sqrt\Pi\)</span>,
where the latter expression extends the function definition from real <span class="math">\(x\)</span> to
all complex <span class="math">\(x != 0\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.errname">
<code class="descname">errname</code><span class="sig-paren">(</span><em>E</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.errname" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of the error message <code class="docutils literal"><span class="pre">E</span></code> as a string.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.eta">
<code class="descname">eta</code><span class="sig-paren">(</span><em>z</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.eta" title="Permalink to this definition">¶</a></dt>
<dd><p>Variants of Dedekind&#8217;s <span class="math">\(\eta\)</span> function.
If <span class="math">\(flag = 0\)</span>, return <span class="math">\(\prod_{n = 1}^ oo (1-q^n)\)</span>, where <span class="math">\(q\)</span> depends on <span class="math">\(x\)</span>
in the following way:</p>
<ul class="simple">
<li><span class="math">\(q = e^{2i\Pi x}\)</span> if <span class="math">\(x\)</span> is a <em>complex number</em> (which must then
have positive imaginary part); notice that the factor <span class="math">\(q^{1/24}\)</span> is
missing!</li>
<li><span class="math">\(q = x\)</span> if <span class="math">\(x\)</span> is a <code class="docutils literal"><span class="pre">t_PADIC</span></code>, or can be converted to a
<em>power series</em> (which must then have positive valuation).</li>
</ul>
<p>If <span class="math">\(flag\)</span> is non-zero, <span class="math">\(x\)</span> is converted to a complex number and we return the
true <span class="math">\(\eta\)</span> function, <span class="math">\(q^{1/24}\prod_{n = 1}^ oo (1-q^n)\)</span>,
where <span class="math">\(q = e^{2i\Pi x}\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.eulerphi">
<code class="descname">eulerphi</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.eulerphi" title="Permalink to this definition">¶</a></dt>
<dd><p>Euler&#8217;s <span class="math">\(\phi\)</span> (totient) function of the
integer <span class="math">\(\|x\|\)</span>, in other words <span class="math">\(\|(\mathbb{Z}/x\mathbb{Z})^*\|\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? eulerphi(40)
%1 = 16
</pre></div>
</div>
<p>According to this definition we let <span class="math">\(\phi(0) := 2\)</span>, since <span class="math">\(\mathbb{Z}^ *= {-1,1}\)</span>;
this is consistent with <code class="docutils literal"><span class="pre">znstar(0)</span></code>: we have \kbd{znstar:math:<span class="math">\((n)\)</span>.no = 
eulerphi(n)} for all <span class="math">\(n belongs to \mathbb{Z}\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.exp">
<code class="descname">exp</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential of <span class="math">\(x\)</span>.
<span class="math">\(p\)</span>-adic arguments with positive valuation are accepted.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.expm1">
<code class="descname">expm1</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.expm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <span class="math">\(\exp(x)-1\)</span>, computed in a way that is also accurate
when the real part of <span class="math">\(x\)</span> is near <span class="math">\(0\)</span>.
A naive direct computation would suffer from catastrophic cancellation;
PARI&#8217;s direct computation of <span class="math">\(\exp(x)\)</span> alleviates this well known problem at
the expense of computing <span class="math">\(\exp(x)\)</span> to a higher accuracy when <span class="math">\(x\)</span> is small.
Using <code class="docutils literal"><span class="pre">expm1</span></code> is recommended instead:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? default(realprecision, 10000); x = 1e-100;
? a = expm1(x);
time = 4 ms.
? b = exp(x)-1;
time = 28 ms.
? default(realprecision, 10040); x = 1e-100;
? c = expm1(x); \\ reference point
? abs(a-c)/c \\ relative error in expm1(x)
%7 = 0.E-10017
? abs(b-c)/c \\ relative error in exp(x)-1
%8 = 1.7907031188259675794 E-9919
</pre></div>
</div>
<p>As the example above shows, when <span class="math">\(x\)</span> is near <span class="math">\(0\)</span>,
<code class="docutils literal"><span class="pre">expm1</span></code> is both faster and more accurate than <code class="docutils literal"><span class="pre">exp(x)-1</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.factor">
<code class="descname">factor</code><span class="sig-paren">(</span><em>x</em>, <em>lim=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.factor" title="Permalink to this definition">¶</a></dt>
<dd><p>General factorization function, where <span class="math">\(x\)</span> is a
rational (including integers), a complex number with rational
real and imaginary parts, or a rational function (including polynomials).
The result is a two-column matrix: the first contains the irreducibles
dividing <span class="math">\(x\)</span> (rational or Gaussian primes, irreducible polynomials),
and the second the exponents. By convention, <span class="math">\(0\)</span> is factored as <span class="math">\(0^1\)</span>.</p>
<p><strong>:math:</strong>mathbb{Q}` and <span class="math">\(\mathbb{Q}(i)\)</span>.`
See <code class="docutils literal"><span class="pre">factorint</span></code> for more information about the algorithms used.
The rational or Gaussian primes are in fact <em>pseudoprimes</em>
(see <code class="docutils literal"><span class="pre">ispseudoprime</span></code>), a priori not rigorously proven primes. In fact,
any factor which is <span class="math">\(&lt;= 2^{64}\)</span> (whose norm is <span class="math">\(&lt;= 2^{64}\)</span> for an
irrational Gaussian prime) is a genuine prime. Use <code class="docutils literal"><span class="pre">isprime</span></code> to prove
primality of other factors, as in</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? fa = factor(2^2^7 + 1)
%1 =
[59649589127497217 1]

[5704689200685129054721 1]

? isprime( fa[,1] )
%2 = [1, 1]~ \\ both entries are proven primes
</pre></div>
</div>
<p>Another possibility is to set the global default <code class="docutils literal"><span class="pre">factor_proven</span></code>, which
will perform a rigorous primality proof for each pseudoprime factor.</p>
<p>A <code class="docutils literal"><span class="pre">t_INT</span></code> argument <em>lim</em> can be added, meaning that we look only for
prime factors <span class="math">\(p &lt; lim\)</span>. The limit <em>lim</em> must be non-negative.
In this case, all but the last factor are proven primes, but the remaining
factor may actually be a proven composite! If the remaining factor is less
than <span class="math">\(lim^2\)</span>, then it is prime.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? factor(2^2^7 +1, 10^5)
%3 =
[340282366920938463463374607431768211457 1]
</pre></div>
</div>
<p><strong>Deprecated feature.</strong> Setting <span class="math">\(lim = 0\)</span> is the same
as setting it to <span class="math">\(primelimit + 1\)</span>. Don&#8217;t use this: it is unwise to
rely on global variables when you can specify an explicit argument.</p>
<p>This routine uses trial division and perfect power tests, and should not be
used for huge values of <em>lim</em> (at most <span class="math">\(10^9\)</span>, say):
<code class="docutils literal"><span class="pre">factorint(,</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">8)</span></code> will in general be faster. The latter does not
guarantee that all small
prime factors are found, but it also finds larger factors, and in a much more
efficient way.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? F = (2^2^7 + 1) * 1009 * 100003; factor(F, 10^5) \\ fast, incomplete
time = 0 ms.
%4 =
[1009 1]

[34029257539194609161727850866999116450334371 1]

? factor(F, 10^9) \\ very slow
time = 6,892 ms.
%6 =
[1009 1]

[100003 1]

[340282366920938463463374607431768211457 1]

? factorint(F, 1+8) \\ much faster, all small primes were found
time = 12 ms.
%7 =
[1009 1]

[100003 1]

[340282366920938463463374607431768211457 1]

? factor(F) \\ complete factorisation
time = 112 ms.
%8 =
[1009 1]

[100003 1]

[59649589127497217 1]

[5704689200685129054721 1]
</pre></div>
</div>
<p>Over <span class="math">\(\mathbb{Q}\)</span>, the prime factors are sorted in increasing order.</p>
<p><strong>Rational functions.</strong>
The polynomials or rational functions to be factored must have scalar
coefficients. In particular PARI does not know how to factor
<em>multivariate</em> polynomials. The following domains are currently
supported: <span class="math">\(\mathbb{Q}\)</span>, <span class="math">\(\mathbb{R}\)</span>, <span class="math">\(\mathbb{C}\)</span>, <span class="math">\(\mathbb{Q}_p\)</span>, finite fields and number fields.
See <code class="docutils literal"><span class="pre">factormod</span></code> and <code class="docutils literal"><span class="pre">factorff</span></code> for
the algorithms used over finite fields, <code class="docutils literal"><span class="pre">factornf</span></code> for the algorithms
over number fields. Over <span class="math">\(\mathbb{Q}\)</span>, van Hoeij&#8217;s method is used, which is
able to cope with hundreds of modular factors.</p>
<p>The routine guesses a sensible ring over which to factor: the
smallest ring containing all coefficients, taking into account quotient
structures induced by <code class="docutils literal"><span class="pre">t_INTMOD</span></code>&nbsp;s and <code class="docutils literal"><span class="pre">t_POLMOD</span></code>&nbsp;s (e.g.&nbsp;if a coefficient
in <span class="math">\(\mathbb{Z}/n\mathbb{Z}\)</span> is known, all rational numbers encountered are first mapped to
<span class="math">\(\mathbb{Z}/n\mathbb{Z}\)</span>; different moduli will produce an error). Factoring modulo a
non-prime number is not supported; to factor in <span class="math">\(\mathbb{Q}_p\)</span>, use <code class="docutils literal"><span class="pre">t_PADIC</span></code>
coefficients not <code class="docutils literal"><span class="pre">t_INTMOD</span></code> modulo <span class="math">\(p^n\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? T = x^2+1;
? factor(T); \\ over Q
? factor(T*Mod(1,3)) \\ over F_3
? factor(T*ffgen(ffinit(3,2,&#39;t))^0) \\ over F_{3^2}
? factor(T*Mod(Mod(1,3), t^2+t+2)) \\ over F_{3^2}, again
? factor(T*(1 + O(3^6)) \\ over Q_3, precision 6
? factor(T*1.) \\ over R, current precision
? factor(T*(1.+0.*I)) \\ over C
? factor(T*Mod(1, y^3-2)) \\ over Q(2^{1/3})
</pre></div>
</div>
<p>In most cases, it is clearer and simpler to call an
explicit variant than to rely on the generic <code class="docutils literal"><span class="pre">factor</span></code> function and
the above detection mechanism:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? factormod(T, 3) \\ over F_3
? factorff(T, 3, t^2+t+2)) \\ over F_{3^2}
? factorpadic(T, 3,6) \\ over Q_3, precision 6
? nffactor(y^3-2, T) \\ over Q(2^{1/3})
? polroots(T) \\ over C
</pre></div>
</div>
<p>Note that factorization of polynomials is done up to
multiplication by a constant. In particular, the factors of rational
polynomials will have integer coefficients, and the content of a polynomial
or rational function is discarded and not included in the factorization. If
needed, you can always ask for the content explicitly:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? factor(t^2 + 5/2*t + 1)
%1 =
[2*t + 1 1]

[t + 2 1]

? content(t^2 + 5/2*t + 1)
%2 = 1/2
</pre></div>
</div>
<p>The irreducible factors are sorted by increasing degree.
See also <code class="docutils literal"><span class="pre">nffactor</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.factorback">
<code class="descname">factorback</code><span class="sig-paren">(</span><em>f</em>, <em>e=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.factorback" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives back the factored object
corresponding to a factorization. The integer <span class="math">\(1\)</span> corresponds to the empty
factorization.</p>
<p>If <span class="math">\(e\)</span> is present, <span class="math">\(e\)</span> and <span class="math">\(f\)</span> must be vectors of the same length (<span class="math">\(e\)</span> being
integral), and the corresponding factorization is the product of the
<span class="math">\(f[i]^{e[i]}\)</span>.</p>
<p>If not, and <span class="math">\(f\)</span> is vector, it is understood as in the preceding case with <span class="math">\(e\)</span>
a vector of 1s: we return the product of the <span class="math">\(f[i]\)</span>. Finally, <span class="math">\(f\)</span> can be a
regular factorization, as produced with any <code class="docutils literal"><span class="pre">factor</span></code> command. A few
examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? factor(12)
%1 =
[2 2]

[3 1]

? factorback(%)
%2 = 12
? factorback([2,3], [2,1]) \\ 2^3 * 3^1
%3 = 12
? factorback([5,2,3])
%4 = 30
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.factorcantor">
<code class="descname">factorcantor</code><span class="sig-paren">(</span><em>x</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.factorcantor" title="Permalink to this definition">¶</a></dt>
<dd><p>Factors the polynomial <span class="math">\(x\)</span> modulo the
prime <span class="math">\(p\)</span>, using distinct degree plus
Cantor-Zassenhaus. The coefficients of <span class="math">\(x\)</span> must be
operation-compatible with <span class="math">\(\mathbb{Z}/p\mathbb{Z}\)</span>. The result is a two-column matrix, the
first column being the irreducible polynomials dividing <span class="math">\(x\)</span>, and the second
the exponents. If you want only the <em>degrees</em> of the irreducible
polynomials (for example for computing an <span class="math">\(L\)</span>-function), use
<span class="math">\(factormod(x,p,1)\)</span>. Note that the <code class="docutils literal"><span class="pre">factormod</span></code> algorithm is
usually faster than <code class="docutils literal"><span class="pre">factorcantor</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.factorff">
<code class="descname">factorff</code><span class="sig-paren">(</span><em>x</em>, <em>p=None</em>, <em>a=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.factorff" title="Permalink to this definition">¶</a></dt>
<dd><p>Factors the polynomial <span class="math">\(x\)</span> in the field
<span class="math">\(\mathbb{F}_q\)</span> defined by the irreducible polynomial <span class="math">\(a\)</span> over <span class="math">\(\mathbb{F}_p\)</span>. The
coefficients of <span class="math">\(x\)</span> must be operation-compatible with <span class="math">\(\mathbb{Z}/p\mathbb{Z}\)</span>. The result
is a two-column matrix: the first column contains the irreducible factors of
<span class="math">\(x\)</span>, and the second their exponents. If all the coefficients of <span class="math">\(x\)</span> are in
<span class="math">\(\mathbb{F}_p\)</span>, a much faster algorithm is applied, using the computation of
isomorphisms between finite fields.</p>
<p>Either <span class="math">\(a\)</span> or <span class="math">\(p\)</span> can omitted (in which case both are ignored) if x has
<code class="docutils literal"><span class="pre">t_FFELT</span></code> coefficients; the function then becomes identical to <code class="docutils literal"><span class="pre">factor</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? factorff(x^2 + 1, 5, y^2+3) \\ over F_5[y]/(y^2+3) ~ F_25
%1 =
[Mod(Mod(1, 5), Mod(1, 5)*y^2 + Mod(3, 5))*x
 + Mod(Mod(2, 5), Mod(1, 5)*y^2 + Mod(3, 5)) 1]

[Mod(Mod(1, 5), Mod(1, 5)*y^2 + Mod(3, 5))*x
 + Mod(Mod(3, 5), Mod(1, 5)*y^2 + Mod(3, 5)) 1]
? t = ffgen(y^2 + Mod(3,5), &#39;t); \\ a generator for F_25 as a t_FFELT
? factorff(x^2 + 1) \\ not enough information to determine the base field
 *** at top-level: factorff(x^2+1)
 *** ^---------------
 *** factorff: incorrect type in factorff.
? factorff(x^2 + t^0) \\ make sure a coeff. is a t_FFELT
%3 =
[x + 2 1]

[x + 3 1]
? factorff(x^2 + t + 1)
%11 =
[x + (2*t + 1) 1]

[x + (3*t + 4) 1]
</pre></div>
</div>
<p>Notice that the second syntax is easier to use and much more readable.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.factorint">
<code class="descname">factorint</code><span class="sig-paren">(</span><em>x</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.factorint" title="Permalink to this definition">¶</a></dt>
<dd><p>Factors the integer <span class="math">\(n\)</span> into a product of
pseudoprimes (see <code class="docutils literal"><span class="pre">ispseudoprime</span></code>), using a combination of the
Shanks SQUFOF and Pollard Rho method (with modifications due to
Brent), Lenstra&#8217;s ECM (with modifications by Montgomery), and
MPQS (the latter adapted from the LiDIA code with the kind
permission of the LiDIA maintainers), as well as a search for pure powers.
The output is a two-column matrix as for <code class="docutils literal"><span class="pre">factor</span></code>: the first column
contains the &#8220;prime&#8221; divisors of <span class="math">\(n\)</span>, the second one contains the
(positive) exponents.</p>
<p>By convention <span class="math">\(0\)</span> is factored as <span class="math">\(0^1\)</span>, and <span class="math">\(1\)</span> as the empty factorization;
also the divisors are by default not proven primes is they are larger than
<span class="math">\(2^{64}\)</span>, they only failed the BPSW compositeness test (see
<code class="docutils literal"><span class="pre">ispseudoprime</span></code>). Use <code class="docutils literal"><span class="pre">isprime</span></code> on the result if you want to
guarantee primality or set the <code class="docutils literal"><span class="pre">factor_proven</span></code> default to <span class="math">\(1\)</span>.
Entries of the private prime tables (see <code class="docutils literal"><span class="pre">addprimes</span></code>) are also included
as is.</p>
<p>This gives direct access to the integer factoring engine called by most
arithmetical functions. <em>flag</em> is optional; its binary digits mean 1: avoid
MPQS, 2: skip first stage ECM (we may still fall back to it later), 4: avoid
Rho and SQUFOF, 8: don&#8217;t run final ECM (as a result, a huge composite may be
declared to be prime). Note that a (strong) probabilistic primality test is
used; thus composites might not be detected, although no example is known.</p>
<p>You are invited to play with the flag settings and watch the internals at
work by using <code class="docutils literal"><span class="pre">gp</span></code>&#8216;s <code class="docutils literal"><span class="pre">debug</span></code> default parameter (level 3 shows
just the outline, 4 turns on time keeping, 5 and above show an increasing
amount of internal details).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.factormod">
<code class="descname">factormod</code><span class="sig-paren">(</span><em>x</em>, <em>p</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.factormod" title="Permalink to this definition">¶</a></dt>
<dd><p>Factors the polynomial <span class="math">\(x\)</span> modulo the prime integer <span class="math">\(p\)</span>, using
Berlekamp. The coefficients of <span class="math">\(x\)</span> must be operation-compatible with
<span class="math">\(\mathbb{Z}/p\mathbb{Z}\)</span>. The result is a two-column matrix, the first column being the
irreducible polynomials dividing <span class="math">\(x\)</span>, and the second the exponents. If <span class="math">\(flag\)</span>
is non-zero, outputs only the <em>degrees</em> of the irreducible polynomials
(for example, for computing an <span class="math">\(L\)</span>-function). A different algorithm for
computing the mod <span class="math">\(p\)</span> factorization is <code class="docutils literal"><span class="pre">factorcantor</span></code> which is sometimes
faster.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.factornf">
<code class="descname">factornf</code><span class="sig-paren">(</span><em>x</em>, <em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.factornf" title="Permalink to this definition">¶</a></dt>
<dd><p>Factorization of the univariate polynomial <span class="math">\(x\)</span>
over the number field defined by the (univariate) polynomial <span class="math">\(t\)</span>. <span class="math">\(x\)</span> may
have coefficients in <span class="math">\(\mathbb{Q}\)</span> or in the number field. The algorithm reduces to
factorization over <span class="math">\(\mathbb{Q}\)</span> (Trager&#8217;s trick). The direct approach of
<code class="docutils literal"><span class="pre">nffactor</span></code>, which uses van Hoeij&#8217;s method in a relative setting, is
in general faster.</p>
<p>The main variable of <span class="math">\(t\)</span> must be of <em>lower</em> priority than that of <span class="math">\(x\)</span>
(see <code class="docutils literal"><span class="pre">priority</span></code> (in the PARI manual)). However if non-rational number field elements
occur (as polmods or polynomials) as coefficients of <span class="math">\(x\)</span>, the variable of
these polmods <em>must</em> be the same as the main variable of <span class="math">\(t\)</span>. For
example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? factornf(x^2 + Mod(y, y^2+1), y^2+1);
? factornf(x^2 + y, y^2+1); \\ these two are OK
? factornf(x^2 + Mod(z,z^2+1), y^2+1)
 *** at top-level: factornf(x^2+Mod(z,z
 *** ^--------------------
 *** factornf: inconsistent data in rnf function.
? factornf(x^2 + z, y^2+1)
 *** at top-level: factornf(x^2+z,y^2+1
 *** ^--------------------
 *** factornf: incorrect variable in rnf function.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.factorpadic">
<code class="descname">factorpadic</code><span class="sig-paren">(</span><em>pol</em>, <em>p</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.factorpadic" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(p\)</span>-adic factorization
of the polynomial <em>pol</em> to precision <span class="math">\(r\)</span>, the result being a
two-column matrix as in <code class="docutils literal"><span class="pre">factor</span></code>. Note that this is not the same
as a factorization over <span class="math">\(\mathbb{Z}/p^r\mathbb{Z}\)</span> (polynomials over that ring do not form a
unique factorization domain, anyway), but approximations in <span class="math">\(\mathbb{Q}/p^r\mathbb{Z}\)</span> of
the true factorization in <span class="math">\(\mathbb{Q}_p[X]\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? factorpadic(x^2 + 9, 3,5)
%1 =
[(1 + O(3^5))*x^2 + O(3^5)*x + (3^2 + O(3^5)) 1]
? factorpadic(x^2 + 1, 5,3)
%2 =
[ (1 + O(5^3))*x + (2 + 5 + 2*5^2 + O(5^3)) 1]

[(1 + O(5^3))*x + (3 + 3*5 + 2*5^2 + O(5^3)) 1]
</pre></div>
</div>
<p>The factors are normalized so that their leading coefficient is a power of
<span class="math">\(p\)</span>. The method used is a modified version of the round 4 algorithm of
Zassenhaus.</p>
<p>If <em>pol</em> has inexact <code class="docutils literal"><span class="pre">t_PADIC</span></code> coefficients, this is not always
well-defined; in this case, the polynomial is first made integral by dividing
out the <span class="math">\(p\)</span>-adic content, then lifted to <span class="math">\(\mathbb{Z}\)</span> using <code class="docutils literal"><span class="pre">truncate</span></code>
coefficientwise.
Hence we actually factor exactly a polynomial which is only <span class="math">\(p\)</span>-adically
close to the input. To avoid pitfalls, we advise to only factor polynomials
with exact rational coefficients.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ffgen">
<code class="descname">ffgen</code><span class="sig-paren">(</span><em>q</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ffgen" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <code class="docutils literal"><span class="pre">t_FFELT</span></code> generator for the finite field with <span class="math">\(q\)</span> elements;
<span class="math">\(q = p^f\)</span> must be a prime power. This functions computes an irreducible
monic polynomial <span class="math">\(P belongs to \mathbb{F}_p[X]\)</span> of degree&nbsp;<span class="math">\(f\)</span> (via <code class="docutils literal"><span class="pre">ffinit</span></code>) and
returns <span class="math">\(g = X (mod P(X))\)</span>. If <code class="docutils literal"><span class="pre">v</span></code> is given, the variable name is used
to display <span class="math">\(g\)</span>, else the variable <span class="math">\(x\)</span> is used.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? g = ffgen(8, &#39;t);
? g.mod
%2 = t^3 + t^2 + 1
? g.p
%3 = 2
? g.f
%4 = 3
? ffgen(6)
 *** at top-level: ffgen(6)
 *** ^--------
 *** ffgen: not a prime number in ffgen: 6.
</pre></div>
</div>
<p>Alternative syntax: instead of a prime power <span class="math">\(q = p^f\)</span>, one may
input the pair <span class="math">\([p,f]\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? g = ffgen([2,4], &#39;t);
? g.p
%2 = 2
? g.mod
%3 = t^4 + t^3 + t^2 + t + 1
</pre></div>
</div>
<p>Finally, one may input
directly the polynomial <span class="math">\(P\)</span> (monic, irreducible, with <code class="docutils literal"><span class="pre">t_INTMOD</span></code>
coefficients), and the function returns the generator <span class="math">\(g = X (mod P(X))\)</span>,
inferring <span class="math">\(p\)</span> from the coefficients of <span class="math">\(P\)</span>. If <code class="docutils literal"><span class="pre">v</span></code> is given, the
variable name is used to display <span class="math">\(g\)</span>, else the variable of the polynomial
<span class="math">\(P\)</span> is used. If <span class="math">\(P\)</span> is not irreducible, we create an invalid object and
behaviour of functions dealing with the resulting <code class="docutils literal"><span class="pre">t_FFELT</span></code>
is undefined; in fact, it is much more costly to test <span class="math">\(P\)</span> for
irreducibility than it would be to produce it via <code class="docutils literal"><span class="pre">ffinit</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ffinit">
<code class="descname">ffinit</code><span class="sig-paren">(</span><em>p</em>, <em>n</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ffinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a monic polynomial of degree <span class="math">\(n\)</span> which is irreducible over
<span class="math">\(\mathbb{F}_p\)</span>, where <span class="math">\(p\)</span> is assumed to be prime. This function uses a fast variant
of Adleman and Lenstra&#8217;s algorithm.</p>
<p>It is useful in conjunction with <code class="docutils literal"><span class="pre">ffgen</span></code>; for instance if
<code class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">ffinit(3,2)</span></code>, you can represent elements in <span class="math">\(\mathbb{F}_{3^2}\)</span> in term of
<code class="docutils literal"><span class="pre">g</span> <span class="pre">=</span> <span class="pre">ffgen(P,'t)</span></code>. This can be abbreviated as
<code class="docutils literal"><span class="pre">g</span> <span class="pre">=</span> <span class="pre">ffgen(3^2,</span> <span class="pre">'t)</span></code>, where the defining polynomial <span class="math">\(P\)</span> can be later
recovered as <code class="docutils literal"><span class="pre">g.mod</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.fflog">
<code class="descname">fflog</code><span class="sig-paren">(</span><em>x</em>, <em>g</em>, <em>o=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.fflog" title="Permalink to this definition">¶</a></dt>
<dd><p>Discrete logarithm of the finite field element <span class="math">\(x\)</span> in base <span class="math">\(g\)</span>, i.e.&nbsp;
an <span class="math">\(e\)</span> in <span class="math">\(\mathbb{Z}\)</span> such that <span class="math">\(g^e = o\)</span>. If
present, <span class="math">\(o\)</span> represents the multiplicative order of <span class="math">\(g\)</span>, see
<code class="docutils literal"><span class="pre">DLfun</span></code> (in the PARI manual); the preferred format for
this parameter is <code class="docutils literal"><span class="pre">[ord,</span> <span class="pre">factor(ord)]</span></code>, where <code class="docutils literal"><span class="pre">ord</span></code> is the
order of <span class="math">\(g\)</span>. It may be set as a side effect of calling <code class="docutils literal"><span class="pre">ffprimroot</span></code>.</p>
<p>If no <span class="math">\(o\)</span> is given, assume that <span class="math">\(g\)</span> is a primitive root. The result is
undefined if <span class="math">\(e\)</span> does not exist. This function uses</p>
<ul class="simple">
<li>a combination of generic discrete log algorithms (see <code class="docutils literal"><span class="pre">znlog</span></code>)</li>
<li>a cubic sieve index calculus algorithm for large fields of degree at
least <span class="math">\(5\)</span>.</li>
<li>Coppersmith&#8217;s algorithm for fields of characteristic at most <span class="math">\(5\)</span>.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? t = ffgen(ffinit(7,5));
? o = fforder(t)
%2 = 5602 \\ not a primitive root.
? fflog(t^10,t)
%3 = 10
? fflog(t^10,t, o)
%4 = 10
? g = ffprimroot(t, &amp;o);
? o \\ order is 16806, bundled with its factorization matrix
%6 = [16806, [2, 1; 3, 1; 2801, 1]]
? fforder(g, o)
%7 = 16806
? fflog(g^10000, g, o)
%8 = 10000
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ffnbirred">
<code class="descname">ffnbirred</code><span class="sig-paren">(</span><em>q</em>, <em>n</em>, <em>fl=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ffnbirred" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the number of monic irreducible polynomials over <span class="math">\(\mathbb{F}_q\)</span> of degree exactly <span class="math">\(n\)</span>,
(<span class="math">\(flag = 0\)</span> or omitted) or at most <span class="math">\(n\)</span> (<span class="math">\(flag = 1\)</span>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.fforder">
<code class="descname">fforder</code><span class="sig-paren">(</span><em>x</em>, <em>o=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.fforder" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplicative order of the finite field element <span class="math">\(x\)</span>. If <span class="math">\(o\)</span> is
present, it represents a multiple of the order of the element,
see <code class="docutils literal"><span class="pre">DLfun</span></code> (in the PARI manual); the preferred format for
this parameter is <code class="docutils literal"><span class="pre">[N,</span> <span class="pre">factor(N)]</span></code>, where <code class="docutils literal"><span class="pre">N</span></code> is the cardinality
of the multiplicative group of the underlying finite field.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? t = ffgen(ffinit(nextprime(10^8), 5));
? g = ffprimroot(t, &amp;o); \\ o will be useful!
? fforder(g^1000000, o)
time = 0 ms.
%5 = 5000001750000245000017150000600250008403
? fforder(g^1000000)
time = 16 ms. \\ noticeably slower, same result of course
%6 = 5000001750000245000017150000600250008403
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.floor">
<code class="descname">floor</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Floor of <span class="math">\(x\)</span>. When <span class="math">\(x\)</span> is in <span class="math">\(\mathbb{R}\)</span>, the result is the
largest integer smaller than or equal to <span class="math">\(x\)</span>. Applied to a rational function,
<span class="math">\(floor(x)\)</span> returns the Euclidean quotient of the numerator by the
denominator.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.fold">
<code class="descname">fold</code><span class="sig-paren">(</span><em>f</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.fold" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the <code class="docutils literal"><span class="pre">t_CLOSURE</span></code> <code class="docutils literal"><span class="pre">f</span></code> of arity <span class="math">\(2\)</span> to the entries of <code class="docutils literal"><span class="pre">A</span></code>
to return <code class="docutils literal"><span class="pre">f(...f(f(A[1],A[2]),A[3])...,A[#A])</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? fold((x,y)-&gt;x*y, [1,2,3,4])
%1 = 24
? fold((x,y)-&gt;[x,y], [1,2,3,4])
%2 = [[[1, 2], 3], 4]
? fold((x,f)-&gt;f(x), [2,sqr,sqr,sqr])
%3 = 256
? fold((x,y)-&gt;(x+y)/(1-x*y),[1..5])
%4 = -9/19
? bestappr(tan(sum(i=1,5,atan(i))))
%5 = -9/19
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.frac">
<code class="descname">frac</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.frac" title="Permalink to this definition">¶</a></dt>
<dd><p>Fractional part of <span class="math">\(x\)</span>. Identical to
<span class="math">\(x-{floor}(x)\)</span>. If <span class="math">\(x\)</span> is real, the result is in <span class="math">\([0,1[\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.fromdigits">
<code class="descname">fromdigits</code><span class="sig-paren">(</span><em>x</em>, <em>b=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.fromdigits" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the integer formed by the elements of <span class="math">\(x\)</span> seen as the digits of a
number in base <span class="math">\(b\)</span> (<span class="math">\(b = 10\)</span> by default). This is the reverse of <code class="docutils literal"><span class="pre">digits</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? digits(1234,5)
%1 = [1,4,4,1,4]
? fromdigits([1,4,4,1,4],5)
%2 = 1234
</pre></div>
</div>
<p>By convention, <span class="math">\(0\)</span> has no digits:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? fromdigits([])
%3 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoisexport">
<code class="descname">galoisexport</code><span class="sig-paren">(</span><em>gal</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoisexport" title="Permalink to this definition">¶</a></dt>
<dd><p><em>gal</em> being be a Galois group as output by <code class="docutils literal"><span class="pre">galoisinit</span></code>,
export the underlying permutation group as a string suitable
for (no flags or <span class="math">\(flag = 0\)</span>) GAP or (<span class="math">\(flag = 1\)</span>) Magma. The following example
compute the index of the underlying abstract group in the GAP library:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = galoisinit(x^6+108);
? s = galoisexport(G)
%2 = &quot;Group((1, 2, 3)(4, 5, 6), (1, 4)(2, 6)(3, 5))&quot;
? extern(&quot;echo \&quot;IdGroup(&quot;s&quot;);\&quot; | gap -q&quot;)
%3 = [6, 1]
? galoisidentify(G)
%4 = [6, 1]
</pre></div>
</div>
<p>This command also accepts subgroups returned by <code class="docutils literal"><span class="pre">galoissubgroups</span></code>.</p>
<p>To <em>import</em> a GAP permutation into gp (for <code class="docutils literal"><span class="pre">galoissubfields</span></code> for
instance), the following GAP function may be useful:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">PermToGP</span> <span class="p">:</span><span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
 <span class="k">return</span> <span class="n">Permuted</span><span class="p">([</span><span class="mf">1.</span><span class="o">.</span><span class="n">n</span><span class="p">],</span><span class="n">p</span><span class="p">);</span>
<span class="n">end</span><span class="p">;</span>

<span class="n">gap</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">26</span><span class="p">)(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)(</span><span class="mi">3</span><span class="p">,</span><span class="mi">17</span><span class="p">)(</span><span class="mi">4</span><span class="p">,</span><span class="mi">32</span><span class="p">)(</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">)(</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">)(</span><span class="mi">8</span><span class="p">,</span><span class="mi">24</span><span class="p">)(</span><span class="mi">10</span><span class="p">,</span><span class="mi">13</span><span class="p">)(</span><span class="mi">12</span><span class="p">,</span><span class="mi">15</span><span class="p">)(</span><span class="mi">14</span><span class="p">,</span><span class="mi">27</span><span class="p">)</span>
 <span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">22</span><span class="p">)(</span><span class="mi">18</span><span class="p">,</span><span class="mi">28</span><span class="p">)(</span><span class="mi">19</span><span class="p">,</span><span class="mi">20</span><span class="p">)(</span><span class="mi">21</span><span class="p">,</span><span class="mi">29</span><span class="p">)(</span><span class="mi">23</span><span class="p">,</span><span class="mi">31</span><span class="p">)(</span><span class="mi">25</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span>
<span class="n">gap</span><span class="o">&gt;</span> <span class="n">PermToGP</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">32</span><span class="p">);</span>
<span class="p">[</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span>
 <span class="mi">29</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">4</span> <span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoisfixedfield">
<code class="descname">galoisfixedfield</code><span class="sig-paren">(</span><em>gal</em>, <em>perm</em>, <em>flag=0</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoisfixedfield" title="Permalink to this definition">¶</a></dt>
<dd><p><em>gal</em> being be a Galois group as output by <code class="docutils literal"><span class="pre">galoisinit</span></code> and
<em>perm</em> an element of <span class="math">\(gal.group\)</span>, a vector of such elements
or a subgroup of <em>gal</em> as returned by galoissubgroups,
computes the fixed field of <em>gal</em> by the automorphism defined by the
permutations <em>perm</em> of the roots <span class="math">\(gal.roots\)</span>. <span class="math">\(P\)</span> is guaranteed to
be squarefree modulo <span class="math">\(gal.p\)</span>.</p>
<p>If no flags or <span class="math">\(flag = 0\)</span>, output format is the same as for <code class="docutils literal"><span class="pre">nfsubfield</span></code>,
returning <span class="math">\([P,x]\)</span> such that <span class="math">\(P\)</span> is a polynomial defining the fixed field, and
<span class="math">\(x\)</span> is a root of <span class="math">\(P\)</span> expressed as a polmod in <span class="math">\(gal.pol\)</span>.</p>
<p>If <span class="math">\(flag = 1\)</span> return only the polynomial <span class="math">\(P\)</span>.</p>
<p>If <span class="math">\(flag = 2\)</span> return <span class="math">\([P,x,F]\)</span> where <span class="math">\(P\)</span> and <span class="math">\(x\)</span> are as above and <span class="math">\(F\)</span> is the
factorization of <span class="math">\(gal.pol\)</span> over the field defined by <span class="math">\(P\)</span>, where
variable <span class="math">\(v\)</span> (<span class="math">\(y\)</span> by default) stands for a root of <span class="math">\(P\)</span>. The priority of <span class="math">\(v\)</span>
must be less than the priority of the variable of <span class="math">\(gal.pol\)</span> (see
<code class="docutils literal"><span class="pre">priority</span></code> (in the PARI manual)). Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = galoisinit(x^4+1);
? galoisfixedfield(G,G.group[2],2)
%2 = [x^2 + 2, Mod(x^3 + x, x^4 + 1), [x^2 - y*x - 1, x^2 + y*x - 1]]
</pre></div>
</div>
<p>computes the factorization <span class="math">\(x^4+1 = (x^2-\sqrt{-2}x-1)(x^2+\sqrt{-2}x-1)\)</span></p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoisidentify">
<code class="descname">galoisidentify</code><span class="sig-paren">(</span><em>gal</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoisidentify" title="Permalink to this definition">¶</a></dt>
<dd><p><em>gal</em> being be a Galois group as output by <code class="docutils literal"><span class="pre">galoisinit</span></code>,
output the isomorphism class of the underlying abstract group as a
two-components vector <span class="math">\([o,i]\)</span>, where <span class="math">\(o\)</span> is the group order, and <span class="math">\(i\)</span> is the
group index in the GAP4 Small Group library, by Hans Ulrich Besche, Bettina
Eick and Eamonn O&#8217;Brien.</p>
<p>This command also accepts subgroups returned by <code class="docutils literal"><span class="pre">galoissubgroups</span></code>.</p>
<p>The current implementation is limited to degree less or equal to <span class="math">\(127\)</span>.
Some larger &#8220;easy&#8221; orders are also supported.</p>
<p>The output is similar to the output of the function <code class="docutils literal"><span class="pre">IdGroup</span></code> in GAP4.
Note that GAP4 <code class="docutils literal"><span class="pre">IdGroup</span></code> handles all groups of order less than <span class="math">\(2000\)</span>
except <span class="math">\(1024\)</span>, so you can use <code class="docutils literal"><span class="pre">galoisexport</span></code> and GAP4 to identify large
Galois groups.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoisinit">
<code class="descname">galoisinit</code><span class="sig-paren">(</span><em>pol</em>, <em>den=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoisinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Galois group
and all necessary information for computing the fixed fields of the
Galois extension <span class="math">\(K/\mathbb{Q}\)</span> where <span class="math">\(K\)</span> is the number field defined by
<span class="math">\(pol\)</span> (monic irreducible polynomial in <span class="math">\(\mathbb{Z}[X]\)</span> or
a number field as output by <code class="docutils literal"><span class="pre">nfinit</span></code>). The extension <span class="math">\(K/\mathbb{Q}\)</span> must be
Galois with Galois group &#8220;weakly&#8221; super-solvable, see below;
returns 0 otherwise. Hence this permits to quickly check whether a polynomial
of order strictly less than <span class="math">\(36\)</span> is Galois or not.</p>
<p>The algorithm used is an improved version of the paper
&#8220;An efficient algorithm for the computation of Galois automorphisms&#8221;,
Bill Allombert, Math.&nbsp;Comp, vol.&nbsp;73, 245, 2001, pp.&nbsp;359&#8211;375.</p>
<p>A group <span class="math">\(G\)</span> is said to be &#8220;weakly&#8221; super-solvable if there exists a
normal series</p>
<p><span class="math">\({1} = H_0 \triangleleft H_1 \triangleleft...\triangleleft H_{n-1}
\triangleleft H_n\)</span></p>
<p>such that each <span class="math">\(H_i\)</span> is normal in <span class="math">\(G\)</span> and for <span class="math">\(i &lt; n\)</span>, each quotient group
<span class="math">\(H_{i+1}/H_i\)</span> is cyclic, and either <span class="math">\(H_n = G\)</span> (then <span class="math">\(G\)</span> is super-solvable) or
<span class="math">\(G/H_n\)</span> is isomorphic to either <span class="math">\(A_4\)</span> or <span class="math">\(S_4\)</span>.</p>
<p>In practice, almost all small groups are WKSS, the exceptions having order
36(1 exception), 48(2), 56(1), 60(1), 72(5), 75(1), 80(1), 96(10) and <span class="math">\(\geq
108\)</span>.</p>
<p>This function is a prerequisite for most of the <code class="docutils literal"><span class="pre">galois</span></code><span class="math">\(xxx\)</span> routines.
For instance:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">108</span><span class="p">;</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">galoisinit</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">galoissubgroups</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
<span class="n">vector</span><span class="p">(</span><span class="c1">#L, i, galoisisabelian(L[i],1))</span>
<span class="n">vector</span><span class="p">(</span><span class="c1">#L, i, galoisidentify(L[i]))</span>
</pre></div>
</div>
<p>The output is an 8-component vector <em>gal</em>.</p>
<p><span class="math">\(gal[1]\)</span> contains the polynomial <em>pol</em>
(<code class="docutils literal"><span class="pre">:emphasis:`gal</span></code>.pol`).</p>
<p><span class="math">\(gal[2]\)</span> is a three-components vector <span class="math">\([p,e,q]\)</span> where <span class="math">\(p\)</span> is a
prime number (<code class="docutils literal"><span class="pre">:emphasis:`gal</span></code>.p`) such that <em>pol</em> totally split
modulo <span class="math">\(p\)</span> , <span class="math">\(e\)</span> is an integer and <span class="math">\(q = p^e\)</span> (<code class="docutils literal"><span class="pre">:emphasis:`gal</span></code>.mod`) is the
modulus of the roots in <code class="docutils literal"><span class="pre">:emphasis:`gal</span></code>.roots`.</p>
<p><span class="math">\(gal[3]\)</span> is a vector <span class="math">\(L\)</span> containing the <span class="math">\(p\)</span>-adic roots of
<em>pol</em> as integers implicitly modulo <code class="docutils literal"><span class="pre">:emphasis:`gal</span></code>.mod`.
(<code class="docutils literal"><span class="pre">:emphasis:`gal</span></code>.roots`).</p>
<p><span class="math">\(gal[4]\)</span> is the inverse of the Vandermonde matrix of the
<span class="math">\(p\)</span>-adic roots of <em>pol</em>, multiplied by <span class="math">\(gal[5]\)</span>.</p>
<p><span class="math">\(gal[5]\)</span> is a multiple of the least common denominator of the
automorphisms expressed as polynomial in a root of <em>pol</em>.</p>
<p><span class="math">\(gal[6]\)</span> is the Galois group <span class="math">\(G\)</span> expressed as a vector of
permutations of <span class="math">\(L\)</span> (<code class="docutils literal"><span class="pre">:emphasis:`gal</span></code>.group`).</p>
<p><span class="math">\(gal[7]\)</span> is a generating subset <span class="math">\(S = [s_1,...,s_g]\)</span> of <span class="math">\(G\)</span>
expressed as a vector of permutations of <span class="math">\(L\)</span> (<code class="docutils literal"><span class="pre">:emphasis:`gal</span></code>.gen`).</p>
<p><span class="math">\(gal[8]\)</span> contains the relative orders <span class="math">\([o_1,...,o_g]\)</span> of
the generators of <span class="math">\(S\)</span> (<code class="docutils literal"><span class="pre">:emphasis:`gal</span></code>.orders`).</p>
<p>Let <span class="math">\(H_n\)</span> be as above, we have the following properties:</p>
<p>&nbsp;&nbsp;<strong>*</strong> if <span class="math">\(G/H_n ~ A_4\)</span> then <span class="math">\([o_1,...,o_g]\)</span> ends by
<span class="math">\([2,2,3]\)</span>.</p>
<p>&nbsp;&nbsp;<strong>*</strong> if <span class="math">\(G/H_n ~ S_4\)</span> then <span class="math">\([o_1,...,o_g]\)</span> ends by
<span class="math">\([2,2,3,2]\)</span>.</p>
<p>&nbsp;&nbsp;<strong>*</strong> for <span class="math">\(1 &lt;= i &lt;= g\)</span> the subgroup of <span class="math">\(G\)</span> generated by
<span class="math">\([s_1,...,s_g]\)</span> is normal, with the exception of <span class="math">\(i = g-2\)</span> in the
<span class="math">\(A_4\)</span> case and of <span class="math">\(i = g-3\)</span> in the <span class="math">\(S_A\)</span> case.</p>
<p>&nbsp;&nbsp;<strong>*</strong> the relative order <span class="math">\(o_i\)</span> of <span class="math">\(s_i\)</span> is its order in the
quotient group <span class="math">\(G/&lt;&nbsp;s_1,...,s_{i-1}&gt;\)</span>, with the same
exceptions.</p>
<p>&nbsp;&nbsp;<strong>*</strong> for any <span class="math">\(x belongs to G\)</span> there exists a unique family
<span class="math">\([e_1,...,e_g]\)</span> such that (no exceptions):</p>
<p>&#8211; for <span class="math">\(1 &lt;= i &lt;= g\)</span> we have <span class="math">\(0 &lt;= e_i &lt; o_i\)</span></p>
<p>&#8211; <span class="math">\(x = g_1^{e_1}g_2^{e_2}...g_n^{e_n}\)</span></p>
<p>If present <span class="math">\(den\)</span> must be a suitable value for <span class="math">\(gal[5]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoisisabelian">
<code class="descname">galoisisabelian</code><span class="sig-paren">(</span><em>gal</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoisisabelian" title="Permalink to this definition">¶</a></dt>
<dd><p><em>gal</em> being as output by <code class="docutils literal"><span class="pre">galoisinit</span></code>, return <span class="math">\(0\)</span> if
<em>gal</em> is not an abelian group, and the HNF matrix of <em>gal</em> over
<code class="docutils literal"><span class="pre">gal.gen</span></code> if <span class="math">\(fl = 0\)</span>, <span class="math">\(1\)</span> if <span class="math">\(fl = 1\)</span>.</p>
<p>This command also accepts subgroups returned by <code class="docutils literal"><span class="pre">galoissubgroups</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoisisnormal">
<code class="descname">galoisisnormal</code><span class="sig-paren">(</span><em>gal</em>, <em>subgrp</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoisisnormal" title="Permalink to this definition">¶</a></dt>
<dd><p><em>gal</em> being as output by <code class="docutils literal"><span class="pre">galoisinit</span></code>, and <em>subgrp</em> a subgroup
of <em>gal</em> as output by <code class="docutils literal"><span class="pre">galoissubgroups</span></code>,return <span class="math">\(1\)</span> if <em>subgrp</em> is a
normal subgroup of <em>gal</em>, else return 0.</p>
<p>This command also accepts subgroups returned by <code class="docutils literal"><span class="pre">galoissubgroups</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoispermtopol">
<code class="descname">galoispermtopol</code><span class="sig-paren">(</span><em>gal</em>, <em>perm</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoispermtopol" title="Permalink to this definition">¶</a></dt>
<dd><p><em>gal</em> being a
Galois group as output by <code class="docutils literal"><span class="pre">galoisinit</span></code> and <em>perm</em> a element of
<span class="math">\(gal.group\)</span>, return the polynomial defining the Galois
automorphism, as output by <code class="docutils literal"><span class="pre">nfgaloisconj</span></code>, associated with the
permutation <em>perm</em> of the roots <span class="math">\(gal.roots\)</span>. <em>perm</em> can
also be a vector or matrix, in this case, <code class="docutils literal"><span class="pre">galoispermtopol</span></code> is
applied to all components recursively.</p>
<p>Note that</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="o">=</span> <span class="n">galoisinit</span><span class="p">(</span><span class="n">pol</span><span class="p">);</span>
<span class="n">galoispermtopol</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">G</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span><span class="o">~</span>
</pre></div>
</div>
<p>is equivalent to <code class="docutils literal"><span class="pre">nfgaloisconj(pol)</span></code>, if degree of <em>pol</em> is greater
or equal to <span class="math">\(2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoissubcyclo">
<code class="descname">galoissubcyclo</code><span class="sig-paren">(</span><em>N</em>, <em>H=None</em>, <em>fl=0</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoissubcyclo" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the subextension
of <span class="math">\(\mathbb{Q}(\zeta_n)\)</span> fixed by the subgroup <span class="math">\(H \subset (\mathbb{Z}/n\mathbb{Z})^*\)</span>. By the
Kronecker-Weber theorem, all abelian number fields can be generated in this
way (uniquely if <span class="math">\(n\)</span> is taken to be minimal).</p>
<p>The pair <span class="math">\((n, H)\)</span> is deduced from the parameters <span class="math">\((N, H)\)</span> as follows</p>
<ul class="simple">
<li><span class="math">\(N\)</span> an integer: then <span class="math">\(n = N\)</span>; <span class="math">\(H\)</span> is a generator, i.e. an
integer or an integer modulo <span class="math">\(n\)</span>; or a vector of generators.</li>
<li><span class="math">\(N\)</span> the output of <code class="docutils literal"><span class="pre">znstar(:math:`n</span></code>)`. <span class="math">\(H\)</span> as in the first case
above, or a matrix, taken to be a HNF left divisor of the SNF for <span class="math">\((\mathbb{Z}/n\mathbb{Z})^*\)</span>
(of type <code class="docutils literal"><span class="pre">:math:`N</span></code>.cyc`), giving the generators of <span class="math">\(H\)</span> in terms of <code class="docutils literal"><span class="pre">:math:`N</span></code>.gen`.</li>
<li><span class="math">\(N\)</span> the output of <code class="docutils literal"><span class="pre">bnrinit(bnfinit(y),</span> <span class="pre">:math:`m</span></code>, 1)` where <span class="math">\(m\)</span> is a
module. <span class="math">\(H\)</span> as in the first case, or a matrix taken to be a HNF left
divisor of the SNF for the ray class group modulo <span class="math">\(m\)</span>
(of type <code class="docutils literal"><span class="pre">:math:`N</span></code>.cyc`), giving the generators of <span class="math">\(H\)</span> in terms of <code class="docutils literal"><span class="pre">:math:`N</span></code>.gen`.</li>
</ul>
<p>In this last case, beware that <span class="math">\(H\)</span> is understood relatively to <span class="math">\(N\)</span>; in
particular, if the infinite place does not divide the module, e.g if <span class="math">\(m\)</span> is
an integer, then it is not a subgroup of <span class="math">\((\mathbb{Z}/n\mathbb{Z})^*\)</span>, but of its quotient by
<span class="math">\({± 1}\)</span>.</p>
<p>If <span class="math">\(fl = 0\)</span>, compute a polynomial (in the variable <em>v</em>) defining
the subfield of <span class="math">\(\mathbb{Q}(\zeta_n)\)</span> fixed by the subgroup <em>H</em> of <span class="math">\((\mathbb{Z}/n\mathbb{Z})^*\)</span>.</p>
<p>If <span class="math">\(fl = 1\)</span>, compute only the conductor of the abelian extension, as a module.</p>
<p>If <span class="math">\(fl = 2\)</span>, output <span class="math">\([pol, N]\)</span>, where <span class="math">\(pol\)</span> is the polynomial as output when
<span class="math">\(fl = 0\)</span> and <span class="math">\(N\)</span> the conductor as output when <span class="math">\(fl = 1\)</span>.</p>
<p>The following function can be used to compute all subfields of
<span class="math">\(\mathbb{Q}(\zeta_n)\)</span> (of exact degree <code class="docutils literal"><span class="pre">d</span></code>, if <code class="docutils literal"><span class="pre">d</span></code> is set):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">polsubcyclo</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span>
<span class="p">{</span> <span class="n">my</span><span class="p">(</span><span class="n">bnr</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">IndexBound</span><span class="p">);</span>
 <span class="n">IndexBound</span> <span class="o">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="n">d</span><span class="p">]);</span>
 <span class="n">bnr</span> <span class="o">=</span> <span class="n">bnrinit</span><span class="p">(</span><span class="n">bnfinit</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="p">[</span><span class="n">n</span><span class="p">,[</span><span class="mi">1</span><span class="p">]],</span> <span class="mi">1</span><span class="p">);</span>
 <span class="n">L</span> <span class="o">=</span> <span class="n">subgrouplist</span><span class="p">(</span><span class="n">bnr</span><span class="p">,</span> <span class="n">IndexBound</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
 <span class="n">vector</span><span class="p">(</span><span class="c1">#L,i, galoissubcyclo(bnr,L[i]));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Setting <code class="docutils literal"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">subgrouplist(bnr,</span> <span class="pre">IndexBound)</span></code> would produce subfields of exact
conductor <span class="math">\(n oo\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoissubfields">
<code class="descname">galoissubfields</code><span class="sig-paren">(</span><em>G</em>, <em>flag=0</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoissubfields" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs all the subfields of the Galois group <em>G</em>, as a vector.
This works by applying <code class="docutils literal"><span class="pre">galoisfixedfield</span></code> to all subgroups. The meaning of
<em>flag</em> is the same as for <code class="docutils literal"><span class="pre">galoisfixedfield</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.galoissubgroups">
<code class="descname">galoissubgroups</code><span class="sig-paren">(</span><em>G</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.galoissubgroups" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs all the subgroups of the Galois group <code class="docutils literal"><span class="pre">gal</span></code>. A subgroup is a
vector [<em>gen</em>, <em>orders</em>], with the same meaning
as for <span class="math">\(gal.gen\)</span> and <span class="math">\(gal.orders\)</span>. Hence <em>gen</em> is a vector of
permutations generating the subgroup, and <em>orders</em> is the relatives
orders of the generators. The cardinality of a subgroup is the product of the
relative orders. Such subgroup can be used instead of a Galois group in the
following command: <code class="docutils literal"><span class="pre">galoisisabelian</span></code>, <code class="docutils literal"><span class="pre">galoissubgroups</span></code>,
<code class="docutils literal"><span class="pre">galoisexport</span></code> and <code class="docutils literal"><span class="pre">galoisidentify</span></code>.</p>
<p>To get the subfield fixed by a subgroup <em>sub</em> of <em>gal</em>, use</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">galoisfixedfield</span><span class="p">(</span><span class="n">gal</span><span class="p">,</span><span class="n">sub</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.gamma">
<code class="descname">gamma</code><span class="sig-paren">(</span><em>s</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>For <span class="math">\(s\)</span> a complex number, evaluates Euler&#8217;s gamma
function</p>
<div class="math">
\[\Gamma(s) = \int_0^ oo t^{s-1}\exp(-t)dt.\]</div>
<p>Error if <span class="math">\(s\)</span> is a non-positive integer, where <span class="math">\(\Gamma\)</span> has a pole.</p>
<p>For <span class="math">\(s\)</span> a <code class="docutils literal"><span class="pre">t_PADIC</span></code>, evaluates the Morita gamma function at <span class="math">\(s\)</span>, that
is the unique continuous <span class="math">\(p\)</span>-adic function on the <span class="math">\(p\)</span>-adic integers
extending <span class="math">\(\Gamma_p(k) = (-1)^k \prod_{j &lt; k}'j\)</span>, where the prime means that <span class="math">\(p\)</span>
does not divide <span class="math">\(j\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? gamma(1/4 + O(5^10))
%1= 1 + 4*5 + 3*5^4 + 5^6 + 5^7 + 4*5^9 + O(5^10)
? algdep(%,4)
%2 = x^4 + 4*x^2 + 5
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.gammah">
<code class="descname">gammah</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.gammah" title="Permalink to this definition">¶</a></dt>
<dd><p>Gamma function evaluated at the argument <span class="math">\(x+1/2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.gammamellininv">
<code class="descname">gammamellininv</code><span class="sig-paren">(</span><em>G</em>, <em>t</em>, <em>m=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.gammamellininv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value at <span class="math">\(t\)</span> of the inverse Mellin transform
<span class="math">\(G\)</span> initialized by <code class="docutils literal"><span class="pre">gammamellininvinit</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = gammamellininvinit([0]);
? gammamellininv(G, 2) - 2*exp(-Pi*2^2)
%2 = -4.484155085839414627 E-44
</pre></div>
</div>
<p>The alternative shortcut</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">gammamellininv</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>for</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">gammamellininv</span><span class="p">(</span><span class="n">gammamellininvinit</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">m</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>is available.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.gammamellininvasymp">
<code class="descname">gammamellininvasymp</code><span class="sig-paren">(</span><em>A</em>, <em>serprec=-1</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.gammamellininvasymp" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the first <span class="math">\(n\)</span> terms of the asymptotic expansion at infinity
of the <span class="math">\(m\)</span>-th derivative <span class="math">\(K^{(m)}(t)\)</span> of the inverse Mellin transform of the
function</p>
<div class="math">
\[f(s) = \Gamma_\mathbb{R}(s+a_1)...\Gamma_\mathbb{R}(s+a_d) ,\]</div>
<p>where <code class="docutils literal"><span class="pre">A</span></code> is the vector <span class="math">\([a_1,...,a_d]\)</span> and
<span class="math">\(\Gamma_\mathbb{R}(s) = \Pi^{-s/2} \Gamma(s/2)\)</span> (Euler&#8217;s <code class="docutils literal"><span class="pre">gamma</span></code>).
The result is a vector
<span class="math">\([M[1]...M[n]]\)</span> with M[1] = 1, such that</p>
<div class="math">
\[K^{(m)}(t) = \sqrt{2^{d+1}/d}t^{a+m(2/d-1)}e^{-d\Pi t^{2/d}}
\sum_{n &gt;= 0} M[n+1] (\Pi t^{2/d})^{-n}\]</div>
<p>with <span class="math">\(a = (1-d+\sum_{1 &lt;= j &lt;= d}a_j)/d\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.gammamellininvinit">
<code class="descname">gammamellininvinit</code><span class="sig-paren">(</span><em>A</em>, <em>m=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.gammamellininvinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize data for the computation by <code class="docutils literal"><span class="pre">gammamellininv</span></code> of
the <span class="math">\(m\)</span>-th derivative of the inverse Mellin transform of the function</p>
<div class="math">
\[f(s) = \Gamma_\mathbb{R}(s+a_1)...\Gamma_\mathbb{R}(s+a_d)\]</div>
<p>where <code class="docutils literal"><span class="pre">A</span></code> is the vector <span class="math">\([a_1,...,a_d]\)</span> and
<span class="math">\(\Gamma_\mathbb{R}(s) = \Pi^{-s/2} \Gamma(s/2)\)</span> (Euler&#8217;s <code class="docutils literal"><span class="pre">gamma</span></code>). This is the
special case of Meijer&#8217;s <span class="math">\(G\)</span> functions used to compute <span class="math">\(L\)</span>-values via the
approximate functional equation.</p>
<p><strong>Caveat.</strong> Contrary to the PARI convention, this function
guarantees an <em>absolute</em> (rather than relative) error bound.</p>
<p>For instance, the inverse Mellin transform of <span class="math">\(\Gamma_\mathbb{R}(s)\)</span> is
<span class="math">\(2\exp(-\Pi z^2)\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = gammamellininvinit([0]);
? gammamellininv(G, 2) - 2*exp(-Pi*2^2)
%2 = -4.484155085839414627 E-44
</pre></div>
</div>
<p>The inverse Mellin transform of <span class="math">\(\Gamma_\mathbb{R}(s+1)\)</span> is
<span class="math">\(2 z\exp(-\Pi z^2)\)</span>, and its second derivative is
<span class="math">\(4\Pi z \exp(-\Pi z^2)(2\Pi z^2 - 3)\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = gammamellininvinit([1], 2);
? a(z) = 4*Pi*z*exp(-Pi*z^2)*(2*Pi*z^2-3);
? b(z) = gammamellininv(G,z);
? t(z) = b(z) - a(z);
? t(3/2)
%3 = -1.4693679385278593850 E-39
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.gcd">
<code class="descname">gcd</code><span class="sig-paren">(</span><em>x</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.gcd" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the greatest common divisor of <span class="math">\(x\)</span> and <span class="math">\(y\)</span>.
If you also need the <span class="math">\(u\)</span> and <span class="math">\(v\)</span> such that <span class="math">\(x*u + y*v = \mathrm{gcd}(x,y)\)</span>,
use the <code class="docutils literal"><span class="pre">bezout</span></code> function. <span class="math">\(x\)</span> and <span class="math">\(y\)</span> can have rather quite general
types, for instance both rational numbers. If <span class="math">\(y\)</span> is omitted and <span class="math">\(x\)</span> is a
vector, returns the <span class="math">\({gcd}\)</span> of all components of <span class="math">\(x\)</span>, i.e.&nbsp;this is
equivalent to <code class="docutils literal"><span class="pre">content(x)</span></code>.</p>
<p>When <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are both given and one of them is a vector/matrix type,
the GCD is again taken recursively on each component, but in a different way.
If <span class="math">\(y\)</span> is a vector, resp.&nbsp;matrix, then the result has the same type as <span class="math">\(y\)</span>,
and components equal to <code class="docutils literal"><span class="pre">gcd(x,</span> <span class="pre">y[i])</span></code>, resp.&nbsp;<code class="docutils literal"><span class="pre">gcd(x,</span> <span class="pre">y[,i])</span></code>. Else
if <span class="math">\(x\)</span> is a vector/matrix the result has the same type as <span class="math">\(x\)</span> and an
analogous definition. Note that for these types, <code class="docutils literal"><span class="pre">gcd</span></code> is not
commutative.</p>
<p>The algorithm used is a naive Euclid except for the following inputs:</p>
<ul class="simple">
<li>integers: use modified right-shift binary (&#8220;plus-minus&#8221;
variant).</li>
<li>univariate polynomials with coefficients in the same number
field (in particular rational): use modular gcd algorithm.</li>
<li>general polynomials: use the subresultant algorithm if
coefficient explosion is likely (non modular coefficients).</li>
</ul>
<p>If <span class="math">\(u\)</span> and <span class="math">\(v\)</span> are polynomials in the same variable with <em>inexact</em>
coefficients, their gcd is defined to be scalar, so that</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? a = x + 0.0; gcd(a,a)
%1 = 1
? b = y*x + O(y); gcd(b,b)
%2 = y
? c = 4*x + O(2^3); gcd(c,c)
%3 = 4
</pre></div>
</div>
<p>A good quantitative check to decide whether such a
gcd &#8220;should be&#8221; non-trivial, is to use <code class="docutils literal"><span class="pre">polresultant</span></code>: a value
close to <span class="math">\(0\)</span> means that a small deformation of the inputs has non-trivial gcd.
You may also use <code class="docutils literal"><span class="pre">gcdext</span></code>, which does try to compute an approximate gcd
<span class="math">\(d\)</span> and provides <span class="math">\(u\)</span>, <span class="math">\(v\)</span> to check whether <span class="math">\(u x + v y\)</span> is close to <span class="math">\(d\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.gcdext">
<code class="descname">gcdext</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.gcdext" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <span class="math">\([u,v,d]\)</span> such that <span class="math">\(d\)</span> is the gcd of <span class="math">\(x,y\)</span>,
<span class="math">\(x*u+y*v = \mathrm{gcd}(x,y)\)</span>, and <span class="math">\(u\)</span> and <span class="math">\(v\)</span> minimal in a natural sense.
The arguments must be integers or polynomials.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? [u, v, d] = gcdext(32,102)
%1 = [16, -5, 2]
? d
%2 = 2
? gcdext(x^2-x, x^2+x-2)
%3 = [-1/2, 1/2, x - 1]
</pre></div>
</div>
<p>If <span class="math">\(x,y\)</span> are polynomials in the same variable and <em>inexact</em>
coefficients, then compute <span class="math">\(u,v,d\)</span> such that <span class="math">\(x*u+y*v = d\)</span>, where <span class="math">\(d\)</span>
approximately divides both and <span class="math">\(x\)</span> and <span class="math">\(y\)</span>; in particular, we do not obtain
<code class="docutils literal"><span class="pre">gcd(x,y)</span></code> which is <em>defined</em> to be a scalar in this case:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? a = x + 0.0; gcd(a,a)
%1 = 1

? gcdext(a,a)
%2 = [0, 1, x + 0.E-28]

? gcdext(x-Pi, 6*x^2-zeta(2))
%3 = [-6*x - 18.8495559, 1, 57.5726923]
</pre></div>
</div>
<p>For inexact inputs, the output is thus not well defined
mathematically, but you obtain explicit polynomials to check whether the
approximation is close enough for your needs.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.genus2red">
<code class="descname">genus2red</code><span class="sig-paren">(</span><em>P</em>, <em>p=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.genus2red" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(P\)</span> be a polynomial with rational coefficients.
Determines the reduction at <span class="math">\(p &gt; 2\)</span> of the (proper, smooth) genus&nbsp;2
curve <span class="math">\(C/\mathbb{Q}\)</span>, defined by the hyperelliptic equation <span class="math">\(y^2 = P\)</span>. (The
special fiber <span class="math">\(X_p\)</span> of the minimal regular model <span class="math">\(X\)</span> of <span class="math">\(C\)</span> over <span class="math">\(\mathbb{Z}\)</span>.)
The special syntax <code class="docutils literal"><span class="pre">genus2red</span></code><span class="math">\(([P,Q])\)</span> is also allowed, where the
polynomials <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> have integer coefficients, to represent the model
<span class="math">\(y^2 + Q(x)y = P(x)\)</span>.</p>
<p>If <span class="math">\(p\)</span> is omitted, determines the reduction type for all (odd) prime
divisors of the discriminant.</p>
<p>This function was rewritten from an implementation of Liu&#8217;s
algorithm by Cohen and Liu (1994), <code class="docutils literal"><span class="pre">genus2reduction-0.3</span></code>, see
<code class="docutils literal"><span class="pre">http://www.math.u-bordeaux.fr/~liu/G2R/</span></code>.</p>
<p><strong>CAVEAT.</strong> The function interface may change: for the
time being, it returns <span class="math">\([N,FaN, T, V]\)</span>
where <span class="math">\(N\)</span> is either the local conductor at <span class="math">\(p\)</span> or the
global conductor, <em>FaN</em> is its factorization, <span class="math">\(y^2 = T\)</span> defines a
minimal model over <span class="math">\(\mathbb{Z}[1/2]\)</span> and <span class="math">\(V\)</span> describes the reduction type at the
various considered&nbsp;<span class="math">\(p\)</span>. Unfortunately, the program is not complete for
<span class="math">\(p = 2\)</span>, and we may return the odd part of the conductor only: this is the
case if the factorization includes the (impossible) term <span class="math">\(2^{-1}\)</span>; if the
factorization contains another power of <span class="math">\(2\)</span>, then this is the exact local
conductor at <span class="math">\(2\)</span> and <span class="math">\(N\)</span> is the global conductor.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? default(debuglevel, 1);
? genus2red(x^6 + 3*x^3 + 63, 3)
(potential) stable reduction: [1, []]
reduction at p: [III{9}] page 184, [3, 3], f = 10
%1 = [59049, Mat([3, 10]), x^6 + 3*x^3 + 63, [3, [1, []],
 [&quot;[III{9}] page 184&quot;, [3, 3]]]]
? [N, FaN, T, V] = genus2red(x^3-x^2-1, x^2-x); \\ X_1(13), global reduction
p = 13
(potential) stable reduction: [5, [Mod(0, 13), Mod(0, 13)]]
reduction at p: [I{0}-II-0] page 159, [], f = 2
? N
%3 = 169
? FaN
%4 = Mat([13, 2]) \\ in particular, good reduction at 2 !
? T
%5 = x^6 + 58*x^5 + 1401*x^4 + 18038*x^3 + 130546*x^2 + 503516*x + 808561
? V
%6 = [[13, [5, [Mod(0, 13), Mod(0, 13)]], [&quot;[I{0}-II-0] page 159&quot;, []]]]
</pre></div>
</div>
<p>We now first describe the format of the vector <span class="math">\(V = V_p\)</span> in the case where
<span class="math">\(p\)</span> was specified (local reduction at&nbsp;<span class="math">\(p\)</span>): it is a triple <span class="math">\([p, stable,
red]\)</span>. The component <span class="math">\(stable = [type, vecj]\)</span> contains
information about the stable reduction after a field extension;
depending on <em>type</em>&nbsp;s, the stable reduction is</p>
<ul class="simple">
<li>1: smooth (i.e. the curve has potentially good reduction). The
Jacobian <span class="math">\(J(C)\)</span> has potentially good reduction.</li>
<li>2: an elliptic curve <span class="math">\(E\)</span> with an ordinary double point; <em>vecj</em>
contains <span class="math">\(j\)</span> mod <span class="math">\(p\)</span>, the modular invariant of <span class="math">\(E\)</span>. The (potential)
semi-abelian reduction of <span class="math">\(J(C)\)</span> is the extension of an elliptic curve (with
modular invariant <span class="math">\(j\)</span> mod <span class="math">\(p\)</span>) by a torus.</li>
<li>3: a projective line with two ordinary double points. The Jacobian
<span class="math">\(J(C)\)</span> has potentially multiplicative reduction.</li>
<li>4: the union of two projective lines crossing transversally at three
points. The Jacobian <span class="math">\(J(C)\)</span> has potentially multiplicative reduction.</li>
<li>5: the union of two elliptic curves <span class="math">\(E_1\)</span> and <span class="math">\(E_2\)</span> intersecting
transversally at one point; <em>vecj</em> contains their modular invariants
<span class="math">\(j_1\)</span> and <span class="math">\(j_2\)</span>, which may live in a quadratic extension of <span class="math">\(\mathbb{F}_p\)</span> and need
not be distinct. The Jacobian <span class="math">\(J(C)\)</span> has potentially good reduction,
isomorphic to the product of the reductions of <span class="math">\(E_1\)</span> and <span class="math">\(E_2\)</span>.</li>
<li>6: the union of an elliptic curve <span class="math">\(E\)</span> and a projective line which has
an ordinary double point, and these two components intersect transversally
at one point; <em>vecj</em> contains <span class="math">\(j\)</span> mod <span class="math">\(p\)</span>, the modular invariant of <span class="math">\(E\)</span>.
The (potential) semi-abelian reduction of <span class="math">\(J(C)\)</span> is the extension of an
elliptic curve (with modular invariant <span class="math">\(j\)</span> mod <span class="math">\(p\)</span>) by a torus.</li>
<li>7: as in type 6, but the two components are both singular. The
Jacobian <span class="math">\(J(C)\)</span> has potentially multiplicative reduction.</li>
</ul>
<p>The component <span class="math">\(red = [NUtype, neron]\)</span> contains two data
concerning the reduction at <span class="math">\(p\)</span> without any ramified field extension.</p>
<p>The <em>NUtype</em> is a <code class="docutils literal"><span class="pre">t_STR</span></code> describing the reduction at <span class="math">\(p\)</span> of <span class="math">\(C\)</span>,
following Namikawa-Ueno, <em>The complete classification of fibers in
pencils of curves of genus two</em>, Manuscripta Math., vol. 9, (1973), pages
143-186. The reduction symbol is followed by the corresponding page number in
this article.</p>
<p>The second datum <em>neron</em> is the group of connected components (over an
algebraic closure of <span class="math">\(\mathbb{F}_p\)</span>) of the Néron model of <span class="math">\(J(C)\)</span>, given as a
finite abelian group (vector of elementary divisors).</p>
<p>If <span class="math">\(p = 2\)</span>, the <em>red</em> component may be omitted altogether (and
replaced by <code class="docutils literal"><span class="pre">[]</span></code>, in the case where the program could not compute it.
When <span class="math">\(p\)</span> was not specified, <span class="math">\(V\)</span> is the vector of all <span class="math">\(V_p\)</span>, for all
considered <span class="math">\(p\)</span>.</p>
<p><strong>Notes about Namikawa-Ueno types.</strong></p>
<ul class="simple">
<li>A lower index is denoted between braces: for instance,
<code class="docutils literal"><span class="pre">[I{2}-II-5]</span></code> means <code class="docutils literal"><span class="pre">[I_2-II-5]</span></code>.</li>
<li>If <span class="math">\(K\)</span> and <span class="math">\(K'\)</span> are Kodaira symbols for singular fibers of elliptic
curves, <code class="docutils literal"><span class="pre">[:math:`K</span></code>-<span class="math">\(K'\)</span>-m]` and <code class="docutils literal"><span class="pre">[:math:`K'</span></code>-<span class="math">\(K\)</span>-m]` are the same.</li>
<li><code class="docutils literal"><span class="pre">[:math:`K</span></code>-<span class="math">\(K'\)</span>-<span class="math">\(-1\)</span>]` is <code class="docutils literal"><span class="pre">[:math:`K'</span></code>-<span class="math">\(K\)</span>-<span class="math">\(\alpha\)</span>]` in the notation of
Namikawa-Ueno.</li>
<li>The figure <code class="docutils literal"><span class="pre">[2I_0-m]</span></code> in Namikawa-Ueno, page 159, must be denoted
by <code class="docutils literal"><span class="pre">[2I_0-(m+1)]</span></code>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.hammingweight">
<code class="descname">hammingweight</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.hammingweight" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(x\)</span> is a <code class="docutils literal"><span class="pre">t_INT</span></code>, return the binary Hamming weight of <span class="math">\(\|x\|\)</span>. Otherwise
<span class="math">\(x\)</span> must be of type <code class="docutils literal"><span class="pre">t_POL</span></code>, <code class="docutils literal"><span class="pre">t_VEC</span></code>, <code class="docutils literal"><span class="pre">t_COL</span></code>, <code class="docutils literal"><span class="pre">t_VECSMALL</span></code>, or
<code class="docutils literal"><span class="pre">t_MAT</span></code> and the function returns the number of non-zero coefficients of
<span class="math">\(x\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? hammingweight(15)
%1 = 4
? hammingweight(x^100 + 2*x + 1)
%2 = 3
? hammingweight([Mod(1,2), 2, Mod(0,3)])
%3 = 2
? hammingweight(matid(100))
%4 = 100
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.hilbert">
<code class="descname">hilbert</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>p=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.hilbert" title="Permalink to this definition">¶</a></dt>
<dd><p>Hilbert symbol of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> modulo the prime <span class="math">\(p\)</span>, <span class="math">\(p = 0\)</span> meaning
the place at infinity (the result is undefined if <span class="math">\(p != 0\)</span> is not prime).</p>
<p>It is possible to omit <span class="math">\(p\)</span>, in which case we take <span class="math">\(p = 0\)</span> if both <span class="math">\(x\)</span>
and <span class="math">\(y\)</span> are rational, or one of them is a real number. And take <span class="math">\(p = q\)</span>
if one of <span class="math">\(x\)</span>, <span class="math">\(y\)</span> is a <code class="docutils literal"><span class="pre">t_INTMOD</span></code> modulo <span class="math">\(q\)</span> or a <span class="math">\(q\)</span>-adic. (Incompatible
types will raise an error.)</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.hyperellcharpoly">
<code class="descname">hyperellcharpoly</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.hyperellcharpoly" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(X\)</span> being a non-singular hyperelliptic curve defined over a finite field,
return the characteristic polynomial of the Frobenius automorphism.
<span class="math">\(X\)</span> can be given either by a squarefree polynomial <span class="math">\(P\)</span> such that
<span class="math">\(X: y^2 = P(x)\)</span> or by a vector <span class="math">\([P,Q]\)</span> such that
<span class="math">\(X: y^2 + Q(x) y = P(x)\)</span> and <span class="math">\(Q^2+4 P\)</span> is squarefree.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.hyperellpadicfrobenius">
<code class="descname">hyperellpadicfrobenius</code><span class="sig-paren">(</span><em>Q</em>, <em>p</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.hyperellpadicfrobenius" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(X\)</span> be the curve defined by <span class="math">\(y^2 = Q(x)\)</span>, where <span class="math">\(Q\)</span> is a polynomial of
degree <span class="math">\(d\)</span> over <span class="math">\(\mathbb{Q}\)</span> and <span class="math">\(p &gt;= d\)</span> a prime such that <span class="math">\(X\)</span> has good reduction
at <span class="math">\(p\)</span> return the matrix of the Frobenius endomorphism <span class="math">\(\varphi\)</span> on the
crystalline module <span class="math">\(D_p(X) = \mathbb{Q}_p \otimes H^1_{dR}(X/\mathbb{Q})\)</span> with respect to the
basis of the given model <span class="math">\((\omega, x \omega,...,x^{g-1} \omega)\)</span>, where
<span class="math">\(\omega = dx/(2 y)\)</span> is the invariant differential, where <span class="math">\(g\)</span> is the genus of
<span class="math">\(X\)</span> (either <span class="math">\(d = 2 g+1\)</span> or <span class="math">\(d = 2 g+2\)</span>). The characteristic polynomial of
<span class="math">\(\varphi\)</span> is the numerator of the zeta-function of the reduction of the curve
<span class="math">\(X\)</span> modulo <span class="math">\(p\)</span>. The matrix is computed to absolute <span class="math">\(p\)</span>-adic precision <span class="math">\(p^n\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.hyperu">
<code class="descname">hyperu</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.hyperu" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(U\)</span>-confluent hypergeometric function with
parameters <span class="math">\(a\)</span> and <span class="math">\(b\)</span>. The parameters <span class="math">\(a\)</span> and <span class="math">\(b\)</span> can be complex but
the present implementation requires <span class="math">\(x\)</span> to be positive.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealadd">
<code class="descname">idealadd</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealadd" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of the two ideals <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in the number field <span class="math">\(nf\)</span>. The
result is given in HNF.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(x^2 + 1);
? a = idealadd(K, 2, x + 1) \\ ideal generated by 2 and 1+I
%2 =
[2 1]

[0 1]
? pr = idealprimedec(K, 5)[1]; \\ a prime ideal above 5
? idealadd(K, a, pr) \\ coprime, as expected
%4 =
[1 0]

[0 1]
</pre></div>
</div>
<p>This function cannot be used to add arbitrary <span class="math">\(\mathbb{Z}\)</span>-modules, since it assumes
that its arguments are ideals:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? b = Mat([1,0]~);
? idealadd(K, b, b) \\ only square t_MATs represent ideals
*** idealadd: non-square t_MAT in idealtyp.
? c = [2, 0; 2, 0]; idealadd(K, c, c) \\ non-sense
%6 =
[2 0]

[0 2]
? d = [1, 0; 0, 2]; idealadd(K, d, d) \\ non-sense
%7 =
[1 0]

[0 1]
</pre></div>
</div>
<p>In the last two examples, we get wrong results since the
matrices <span class="math">\(c\)</span> and <span class="math">\(d\)</span> do not correspond to an ideal: the <span class="math">\(\mathbb{Z}\)</span>-span of their
columns (as usual interpreted as coordinates with respect to the integer basis
<code class="docutils literal"><span class="pre">K.zk</span></code>) is not an <span class="math">\(O_K\)</span>-module. To add arbitrary <span class="math">\(\mathbb{Z}\)</span>-modules generated
by the columns of matrices <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, use <code class="docutils literal"><span class="pre">mathnf(concat(A,B))</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealaddtoone">
<code class="descname">idealaddtoone</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealaddtoone" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> and <span class="math">\(y\)</span> being two co-prime
integral ideals (given in any form), this gives a two-component row vector
<span class="math">\([a,b]\)</span> such that <span class="math">\(a belongs to x\)</span>, <span class="math">\(b belongs to y\)</span> and <span class="math">\(a+b = 1\)</span>.</p>
<p>The alternative syntax <span class="math">\(idealaddtoone(nf,v)\)</span>, is supported, where
<span class="math">\(v\)</span> is a <span class="math">\(k\)</span>-component vector of ideals (given in any form) which sum to
<span class="math">\(\mathbb{Z}_K\)</span>. This outputs a <span class="math">\(k\)</span>-component vector <span class="math">\(e\)</span> such that <span class="math">\(e[i] belongs to x[i]\)</span> for
<span class="math">\(1 &lt;= i &lt;= k\)</span> and <span class="math">\(\sum_{1 &lt;= i &lt;= k}e[i] = 1\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealappr">
<code class="descname">idealappr</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealappr" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(x\)</span> is a fractional ideal
(given in any form), gives an element <span class="math">\(\alpha\)</span> in <span class="math">\(nf\)</span> such that for
all prime ideals <span class="math">\(p\)</span> such that the valuation of <span class="math">\(x\)</span> at <span class="math">\(p\)</span> is
non-zero, we have <span class="math">\(v_{p}(\alpha) = v_{p}(x)\)</span>, and
<span class="math">\(v_{p}(\alpha) &gt;= 0\)</span> for all other <span class="math">\(p\)</span>.</p>
<p>If <span class="math">\(flag\)</span> is non-zero, <span class="math">\(x\)</span> must be given as a prime ideal factorization, as
output by <code class="docutils literal"><span class="pre">idealfactor</span></code>, but possibly with zero or negative exponents.
This yields an element <span class="math">\(\alpha\)</span> such that for all prime ideals <span class="math">\(p\)</span>
occurring in <span class="math">\(x\)</span>, <span class="math">\(v_{p}(\alpha)\)</span> is equal to the exponent of
<span class="math">\(p\)</span> in <span class="math">\(x\)</span>, and for all other prime ideals,
<span class="math">\(v_{p}(\alpha) &gt;= 0\)</span>. This generalizes <span class="math">\(idealappr(nf,x,0)\)</span>
since zero exponents are allowed. Note that the algorithm used is slightly
different, so that</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">idealappr</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">idealfactor</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>may not be the same as <code class="docutils literal"><span class="pre">idealappr(nf,x,1)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealchinese">
<code class="descname">idealchinese</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealchinese" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> being a prime ideal factorization
(i.e.&nbsp;a 2 by 2 matrix whose first column contains prime ideals, and the second
column integral exponents), <span class="math">\(y\)</span> a vector of elements in <span class="math">\(nf\)</span> indexed by
the ideals in <span class="math">\(x\)</span>, computes an element <span class="math">\(b\)</span> such that</p>
<p><span class="math">\(v_{p}(b - y_{p}) &gt;= v_{p}(x)\)</span> for all prime ideals
in <span class="math">\(x\)</span> and <span class="math">\(v_{p}(b) &gt;= 0\)</span> for all other <span class="math">\(p\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(t^2-2);
? x = idealfactor(K, 2^2*3)
%2 =
[[2, [0, 1]~, 2, 1, [0, 2; 1, 0]] 4]

[ [3, [3, 0]~, 1, 2, 1] 1]
? y = [t,1];
? idealchinese(K, x, y)
%4 = [4, -3]~
</pre></div>
</div>
<p>The argument <span class="math">\(x\)</span> may also be of the form <span class="math">\([x, s]\)</span> where the first component
is as above and <span class="math">\(s\)</span> is a vector of signs, with <span class="math">\(r_1\)</span> components
<span class="math">\(s_i\)</span> in <span class="math">\({-1,0,1}\)</span>:
if <span class="math">\(\sigma_i\)</span> denotes the <span class="math">\(i\)</span>-th real embedding of the number field,
the element <span class="math">\(b\)</span> returned satisfies further
<span class="math">\(s_i sign(\sigma_i(b)) &gt;= 0\)</span> for all <span class="math">\(i\)</span>. In other words, the sign is
fixed to <span class="math">\(s_i\)</span> at the <span class="math">\(i\)</span>-th embedding whenever <span class="math">\(s_i\)</span> is non-zero.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? idealchinese(K, [x, [1,1]], y)
%5 = [16, -3]~
? idealchinese(K, [x, [-1,-1]], y)
%6 = [-20, -3]~
? idealchinese(K, [x, [1,-1]], y)
%7 = [4, -3]~
</pre></div>
</div>
<p>If <span class="math">\(y\)</span> is omitted, return a data structure which can be used in
place of <span class="math">\(x\)</span> in later calls and allows to solve many chinese remainder
problems for a given <span class="math">\(x\)</span> more efficiently.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? C = idealchinese(K, [x, [1,1]]);
? idealchinese(K, C, y) \\ as above
%9 = [16, -3]~
? for(i=1,10^4, idealchinese(K,C,y)) \\ ... but faster !
time = 80 ms.
? for(i=1,10^4, idealchinese(K,[x,[1,1]],y))
time = 224 ms.
</pre></div>
</div>
<p>Finally, this structure is itself allowed in place of <span class="math">\(x\)</span>, the
new <span class="math">\(s\)</span> overriding the one already present in the structure. This allows to
initialize for different sign conditions more efficiently when the underlying
ideal factorization remains the same.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? D = idealchinese(K, [C, [1,-1]]); \\ replaces [1,1]
? idealchinese(K, D, y)
%13 = [4, -3]~
? for(i=1,10^4,idealchinese(K,[C,[1,-1]])) \\ faster than starting from scratch
time = 40 ms.
? for(i=1,10^4,idealchinese(K,[x,[1,-1]]))
time = 128 ms.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealcoprime">
<code class="descname">idealcoprime</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealcoprime" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two integral ideals <span class="math">\(x\)</span> and <span class="math">\(y\)</span>
in the number field <span class="math">\(nf\)</span>, returns a <span class="math">\(\beta\)</span> in the field,
such that <span class="math">\(\beta.x\)</span> is an integral ideal coprime to <span class="math">\(y\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealdiv">
<code class="descname">idealdiv</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>y</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Quotient <span class="math">\(x.y^{-1}\)</span> of the two ideals <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in the number
field <span class="math">\(nf\)</span>. The result is given in HNF.</p>
<p>If <span class="math">\(flag\)</span> is non-zero, the quotient <span class="math">\(x.y^{-1}\)</span> is assumed to be an
integral ideal. This can be much faster when the norm of the quotient is
small even though the norms of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are large.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealfactor">
<code class="descname">idealfactor</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealfactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Factors into prime ideal powers the
ideal <span class="math">\(x\)</span> in the number field <span class="math">\(nf\)</span>. The output format is similar to the
<code class="docutils literal"><span class="pre">factor</span></code> function, and the prime ideals are represented in the form
output by the <code class="docutils literal"><span class="pre">idealprimedec</span></code> function, i.e.&nbsp;as 5-element vectors.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealfactorback">
<code class="descname">idealfactorback</code><span class="sig-paren">(</span><em>nf</em>, <em>f</em>, <em>e=None</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealfactorback" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives back the ideal corresponding to a factorization. The integer <span class="math">\(1\)</span>
corresponds to the empty factorization.
If <span class="math">\(e\)</span> is present, <span class="math">\(e\)</span> and <span class="math">\(f\)</span> must be vectors of the same length (<span class="math">\(e\)</span> being
integral), and the corresponding factorization is the product of the
<span class="math">\(f[i]^{e[i]}\)</span>.</p>
<p>If not, and <span class="math">\(f\)</span> is vector, it is understood as in the preceding case with <span class="math">\(e\)</span>
a vector of 1s: we return the product of the <span class="math">\(f[i]\)</span>. Finally, <span class="math">\(f\)</span> can be a
regular factorization, as produced by <code class="docutils literal"><span class="pre">idealfactor</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2+1); idealfactor(nf, 4 + 2*y)
%1 =
[[2, [1, 1]~, 2, 1, [1, 1]~] 2]

[[5, [2, 1]~, 1, 1, [-2, 1]~] 1]

? idealfactorback(nf, %)
%2 =
[10 4]

[0 2]

? f = %1[,1]; e = %1[,2]; idealfactorback(nf, f, e)
%3 =
[10 4]

[0 2]

? % == idealhnf(nf, 4 + 2*y)
%4 = 1
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">flag</span></code> is non-zero, perform ideal reductions (<code class="docutils literal"><span class="pre">idealred</span></code>) along the
way. This is most useful if the ideals involved are all <em>extended</em>
ideals (for instance with trivial principal part), so that the principal parts
extracted by <code class="docutils literal"><span class="pre">idealred</span></code> are not lost. Here is an example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? f = vector(#f, i, [f[i], [;]]); \\ transform to extended ideals
? idealfactorback(nf, f, e, 1)
%6 = [[1, 0; 0, 1], [2, 1; [2, 1]~, 1]]
? nffactorback(nf, %[2])
%7 = [4, 2]~
</pre></div>
</div>
<p>The extended ideal returned in <code class="docutils literal"><span class="pre">%6</span></code> is the trivial ideal <span class="math">\(1\)</span>, extended
with a principal generator given in factored form. We use <code class="docutils literal"><span class="pre">nffactorback</span></code>
to recover it in standard form.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealfrobenius">
<code class="descname">idealfrobenius</code><span class="sig-paren">(</span><em>nf</em>, <em>gal</em>, <em>pr</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealfrobenius" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(K\)</span> be the number field defined by <span class="math">\(nf\)</span> and assume <span class="math">\(K/\mathbb{Q}\)</span> be a
Galois extension with Galois group given <code class="docutils literal"><span class="pre">gal</span> <span class="pre">=</span> <span class="pre">galoisinit(nf)</span></code>,
and that <span class="math">\(pr\)</span> is the prime ideal <span class="math">\(P\)</span> in prid format, and that
<span class="math">\(P\)</span> is unramified.
This function returns a permutation of <code class="docutils literal"><span class="pre">gal.group</span></code> which defines the
automorphism <span class="math">\(\sigma = (P\over K/\mathbb{Q} )\)</span>, i.e the Frobenius
element associated to <span class="math">\(P\)</span>. If <span class="math">\(p\)</span> is the unique prime number
in <span class="math">\(P\)</span>, then <span class="math">\(\sigma(x) = x^p mod \P\)</span> for all <span class="math">\(x belongs to \mathbb{Z}_K\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(polcyclo(31));
? gal = galoisinit(nf);
? pr = idealprimedec(nf,101)[1];
? g = idealfrobenius(nf,gal,pr);
? galoispermtopol(gal,g)
%5 = x^8
</pre></div>
</div>
<p>This is correct since <span class="math">\(101 = 8 mod 31\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealhnf">
<code class="descname">idealhnf</code><span class="sig-paren">(</span><em>nf</em>, <em>u</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealhnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the Hermite normal form of the ideal <span class="math">\(u\mathbb{Z}_K+v\mathbb{Z}_K\)</span>, where <span class="math">\(u\)</span>
and <span class="math">\(v\)</span> are elements of the number field <span class="math">\(K\)</span> defined by <em>nf</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^3 - 2);
? idealhnf(nf, 2, y+1)
%2 =
[1 0 0]

[0 1 0]

[0 0 1]
? idealhnf(nf, y/2, [0,0,1/3]~)
%3 =
[1/3 0 0]

[0 1/6 0]

[0 0 1/6]
</pre></div>
</div>
<p>If <span class="math">\(b\)</span> is omitted, returns the HNF of the ideal defined by <span class="math">\(u\)</span>: <span class="math">\(u\)</span> may be an
algebraic number (defining a principal ideal), a maximal ideal (as given by
<code class="docutils literal"><span class="pre">idealprimedec</span></code> or <code class="docutils literal"><span class="pre">idealfactor</span></code>), or a matrix whose columns give
generators for the ideal. This last format is a little complicated, but
useful to reduce general modules to the canonical form once in a while:</p>
<ul class="simple">
<li>if strictly less than <span class="math">\(N = [K:\mathbb{Q}]\)</span> generators are given, <span class="math">\(u\)</span>
is the <span class="math">\(\mathbb{Z}_K\)</span>-module they generate,</li>
<li>if <span class="math">\(N\)</span> or more are given, it is <em>assumed</em> that they form a
<span class="math">\(\mathbb{Z}\)</span>-basis of the ideal, in particular that the matrix has maximal rank <span class="math">\(N\)</span>.
This acts as <code class="docutils literal"><span class="pre">mathnf</span></code> since the <span class="math">\(\mathbb{Z}_K\)</span>-module structure is (taken for
granted hence) not taken into account in this case.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? idealhnf(nf, idealprimedec(nf,2)[1])
%4 =
[2 0 0]

[0 1 0]

[0 0 1]
? idealhnf(nf, [1,2;2,3;3,4])
%5 =
[1 0 0]

[0 1 0]

[0 0 1]
</pre></div>
</div>
<p>Finally, when <span class="math">\(K\)</span> is quadratic with discriminant <span class="math">\(D_K\)</span>, we
allow <span class="math">\(u =\)</span> <code class="docutils literal"><span class="pre">Qfb(a,b,c)</span></code>, provided <span class="math">\(b^2 - 4ac = D_K\)</span>. As usual,
this represents the ideal <span class="math">\(a \mathbb{Z} + (1/2)(-b + \sqrt{D_K}) \mathbb{Z}\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(x^2 - 60); K.disc
%1 = 60
? idealhnf(K, qfbprimeform(60,2))
%2 =
[2 1]

[0 1]
? idealhnf(K, Qfb(1,2,3))
 *** at top-level: idealhnf(K,Qfb(1,2,3
 *** ^--------------------
 *** idealhnf: Qfb(1, 2, 3) has discriminant != 60 in idealhnf.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealintersect">
<code class="descname">idealintersect</code><span class="sig-paren">(</span><em>nf</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealintersect" title="Permalink to this definition">¶</a></dt>
<dd><p>Intersection of the two ideals
<span class="math">\(A\)</span> and <span class="math">\(B\)</span> in the number field <span class="math">\(nf\)</span>. The result is given in HNF.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(x^2+1);
? idealintersect(nf, 2, x+1)
%2 =
[2 0]

[0 2]
</pre></div>
</div>
<p>This function does not apply to general <span class="math">\(\mathbb{Z}\)</span>-modules, e.g.&nbsp;orders, since its
arguments are replaced by the ideals they generate. The following script
intersects <span class="math">\(\mathbb{Z}\)</span>-modules <span class="math">\(A\)</span> and <span class="math">\(B\)</span> given by matrices of compatible
dimensions with integer coefficients:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ZM_intersect</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span> <span class="o">=</span>
<span class="p">{</span> <span class="n">my</span><span class="p">(</span><span class="n">Ker</span> <span class="o">=</span> <span class="n">matkerint</span><span class="p">(</span><span class="n">concat</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)));</span>
 <span class="n">mathnf</span><span class="p">(</span> <span class="n">A</span> <span class="o">*</span> <span class="n">Ker</span><span class="p">[</span><span class="mf">1.</span><span class="o">.</span><span class="c1">#A,] )</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealinv">
<code class="descname">idealinv</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse of the ideal <span class="math">\(x\)</span> in the
number field <span class="math">\(nf\)</span>, given in HNF. If <span class="math">\(x\)</span> is an extended
ideal, its principal part is suitably
updated: i.e. inverting <span class="math">\([I,t]\)</span>, yields <span class="math">\([I^{-1}, 1/t]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ideallist">
<code class="descname">ideallist</code><span class="sig-paren">(</span><em>nf</em>, <em>bound</em>, <em>flag=4</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ideallist" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the list
of all ideals of norm less or equal to <em>bound</em> in the number field
<em>nf</em>. The result is a row vector with exactly <em>bound</em> components.
Each component is itself a row vector containing the information about
ideals of a given norm, in no specific order, depending on the value of
<span class="math">\(flag\)</span>:</p>
<p>The possible values of <span class="math">\(flag\)</span> are:</p>
<p>&nbsp;&nbsp;0: give the <em>bid</em> associated to the ideals, without generators.</p>
<p>&nbsp;&nbsp;1: as 0, but include the generators in the <em>bid</em>.</p>
<p>&nbsp;&nbsp;2: in this case, <em>nf</em> must be a <em>bnf</em> with units. Each
component is of the form <span class="math">\([bid,U]\)</span>, where <em>bid</em> is as case 0
and <span class="math">\(U\)</span> is a vector of discrete logarithms of the units. More precisely, it
gives the <code class="docutils literal"><span class="pre">ideallog</span></code>&nbsp;s with respect to <em>bid</em> of <code class="docutils literal"><span class="pre">bnf.tufu</span></code>.
This structure is technical, and only meant to be used in conjunction with
<code class="docutils literal"><span class="pre">bnrclassnolist</span></code> or <code class="docutils literal"><span class="pre">bnrdisclist</span></code>.</p>
<p>&nbsp;&nbsp;3: as 2, but include the generators in the <em>bid</em>.</p>
<p>&nbsp;&nbsp;4: give only the HNF of the ideal.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(x^2+1);
? L = ideallist(nf, 100);
? L[1]
%3 = [[1, 0; 0, 1]] \\ A single ideal of norm 1
? #L[65]
%4 = 4 \\ There are 4 ideals of norm 4 in Z[i]
</pre></div>
</div>
<p>If one wants more information, one could do instead:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(x^2+1);
? L = ideallist(nf, 100, 0);
? l = L[25]; vector(#l, i, l[i].clgp)
%3 = [[20, [20]], [16, [4, 4]], [20, [20]]]
? l[1].mod
%4 = [[25, 18; 0, 1], []]
? l[2].mod
%5 = [[5, 0; 0, 5], []]
? l[3].mod
%6 = [[25, 7; 0, 1], []]
</pre></div>
</div>
<p>where we ask for the structures of the <span class="math">\((\mathbb{Z}[i]/I)^*\)</span> for all
three ideals of norm <span class="math">\(25\)</span>. In fact, for all moduli with finite part of norm
<span class="math">\(25\)</span> and trivial Archimedean part, as the last 3 commands show. See
<code class="docutils literal"><span class="pre">ideallistarch</span></code> to treat general moduli.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ideallistarch">
<code class="descname">ideallistarch</code><span class="sig-paren">(</span><em>nf</em>, <em>list</em>, <em>arch</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ideallistarch" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list</em> is a vector of vectors of bid&#8217;s, as output by <code class="docutils literal"><span class="pre">ideallist</span></code> with
flag <span class="math">\(0\)</span> to <span class="math">\(3\)</span>. Return a vector of vectors with the same number of
components as the original <em>list</em>. The leaves give information about
moduli whose finite part is as in original list, in the same order, and
Archimedean part is now <em>arch</em> (it was originally trivial). The
information contained is of the same kind as was present in the input; see
<code class="docutils literal"><span class="pre">ideallist</span></code>, in particular the meaning of <em>flag</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? bnf = bnfinit(x^2-2);
? bnf.sign
%2 = [2, 0] \\ two places at infinity
? L = ideallist(bnf, 100, 0);
? l = L[98]; vector(#l, i, l[i].clgp)
%4 = [[42, [42]], [36, [6, 6]], [42, [42]]]
? La = ideallistarch(bnf, L, [1,1]); \\ add them to the modulus
? l = La[98]; vector(#l, i, l[i].clgp)
%6 = [[168, [42, 2, 2]], [144, [6, 6, 2, 2]], [168, [42, 2, 2]]]
</pre></div>
</div>
<p>Of course, the results above are obvious: adding <span class="math">\(t\)</span> places at infinity will
add <span class="math">\(t\)</span> copies of <span class="math">\(\mathbb{Z}/2\mathbb{Z}\)</span> to the ray class group. The following application
is more typical:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? L = ideallist(bnf, 100, 2); \\ units are required now
? La = ideallistarch(bnf, L, [1,1]);
? H = bnrclassnolist(bnf, La);
? H[98];
%4 = [2, 12, 2]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ideallog">
<code class="descname">ideallog</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>bid</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ideallog" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(nf\)</span> is a number field,
<em>bid</em> is as output by <code class="docutils literal"><span class="pre">idealstar(nf,</span> <span class="pre">D,...)</span></code> and <span class="math">\(x\)</span> a
non-necessarily integral element of <em>nf</em> which must have valuation
equal to 0 at all prime ideals in the support of <span class="math">\(D\)</span>. This function
computes the discrete logarithm of <span class="math">\(x\)</span> on the generators given in
<code class="docutils literal"><span class="pre">:emphasis:`bid</span></code>.gen`. In other words, if <span class="math">\(g_i\)</span> are these generators, of orders
<span class="math">\(d_i\)</span> respectively, the result is a column vector of integers <span class="math">\((x_i)\)</span> such
that <span class="math">\(0 &lt;= x_i &lt; d_i\)</span> and</p>
<div class="math">
\[x = \prod_i g_i^{x_i} (mod ^*D) .\]</div>
<p>Note that when the support of <code class="docutils literal"><span class="pre">D</span></code> contains places at infinity, this
congruence implies also sign conditions on the associated real embeddings.
See <code class="docutils literal"><span class="pre">znlog</span></code> for the limitations of the underlying discrete log algorithms.</p>
<p>When <em>nf</em> is omitted, take it to be the rational number field. In that
case, <span class="math">\(x\)</span> must be a <code class="docutils literal"><span class="pre">t_INT</span></code> and <em>bid</em> must have been initialized by
<code class="docutils literal"><span class="pre">idealstar(,N)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealmin">
<code class="descname">idealmin</code><span class="sig-paren">(</span><em>nf</em>, <em>ix</em>, <em>vdir=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealmin" title="Permalink to this definition">¶</a></dt>
<dd><p><em>This function is useless and kept for backward compatibility only,
use :literal:`idealred`</em>. Computes a pseudo-minimum of the ideal <span class="math">\(x\)</span> in the
direction <em>vdir</em> in the number field <em>nf</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealmul">
<code class="descname">idealmul</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>y</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Ideal multiplication of the ideals <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in the number field
<em>nf</em>; the result is the ideal product in HNF. If either <span class="math">\(x\)</span> or <span class="math">\(y\)</span>
are extended ideals, their principal part is suitably
updated: i.e. multiplying <span class="math">\([I,t]\)</span>, <span class="math">\([J,u]\)</span> yields <span class="math">\([IJ, tu]\)</span>; multiplying
<span class="math">\(I\)</span> and <span class="math">\([J, u]\)</span> yields <span class="math">\([IJ, u]\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(x^2 + 1);
? idealmul(nf, 2, x+1)
%2 =
[4 2]

[0 2]
? idealmul(nf, [2, x], x+1) \\ extended ideal * ideal
%3 = [[4, 2; 0, 2], x]
? idealmul(nf, [2, x], [x+1, x]) \\ two extended ideals
%4 = [[4, 2; 0, 2], [-1, 0]~]
</pre></div>
</div>
<p>If <span class="math">\(flag\)</span> is non-zero, reduce the result using <code class="docutils literal"><span class="pre">idealred</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealnorm">
<code class="descname">idealnorm</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the norm of the ideal&nbsp;<span class="math">\(x\)</span> in the number field&nbsp;<span class="math">\(nf\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealnumden">
<code class="descname">idealnumden</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealnumden" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <span class="math">\([A,B]\)</span>, where <span class="math">\(A,B\)</span> are coprime integer ideals
such that <span class="math">\(x = A/B\)</span>, in the number field <span class="math">\(nf\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(x^2+1);
? idealnumden(nf, (x+1)/2)
%2 = [[1, 0; 0, 1], [2, 1; 0, 1]]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealpow">
<code class="descname">idealpow</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>k</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the <span class="math">\(k\)</span>-th power of
the ideal <span class="math">\(x\)</span> in the number field <span class="math">\(nf\)</span>; <span class="math">\(k belongs to \mathbb{Z}\)</span>.
If <span class="math">\(x\)</span> is an extended
ideal, its principal part is suitably
updated: i.e. raising <span class="math">\([I,t]\)</span> to the <span class="math">\(k\)</span>-th power, yields <span class="math">\([I^k, t^k]\)</span>.</p>
<p>If <span class="math">\(flag\)</span> is non-zero, reduce the result using <code class="docutils literal"><span class="pre">idealred</span></code>, <em>throughout
the (binary) powering process</em>; in particular, this is <em>not</em> the same
as <span class="math">\(idealpow(nf,x,k)\)</span> followed by reduction.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealprimedec">
<code class="descname">idealprimedec</code><span class="sig-paren">(</span><em>nf</em>, <em>p</em>, <em>f=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealprimedec" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the prime ideal
decomposition of the (positive) prime number <span class="math">\(p\)</span> in the number field <span class="math">\(K\)</span>
represented by <em>nf</em>. If a non-prime <span class="math">\(p\)</span> is given the result is undefined.
If <span class="math">\(f\)</span> is present and non-zero, restrict the result to primes of residue
degree <span class="math">\(&lt;= f\)</span>.</p>
<p>The result is a vector of <em>prid</em> structures, each representing one of the
prime ideals above <span class="math">\(p\)</span> in the number field <span class="math">\(nf\)</span>. The representation
<span class="math">\(pr = [p,a,e,f,mb]\)</span> of a prime ideal means the following: <span class="math">\(a\)</span> and
is an algebraic integer in the maximal order <span class="math">\(\mathbb{Z}_K\)</span> and the prime ideal is
equal to <span class="math">\(p = p\mathbb{Z}_K + a\mathbb{Z}_K\)</span>;
<span class="math">\(e\)</span> is the ramification index; <span class="math">\(f\)</span> is the residual index;
finally, <em>mb</em> is the multiplication table associated to the algebraic
integer <span class="math">\(b\)</span> is such that <span class="math">\(p^{-1} = \mathbb{Z}_K+ b/ p\mathbb{Z}_K\)</span>, which is used
internally to compute valuations. In other words if <span class="math">\(p\)</span> is inert,
then <em>mb</em> is the integer <span class="math">\(1\)</span>, and otherwise it&#8217;s a square <code class="docutils literal"><span class="pre">t_MAT</span></code>
whose <span class="math">\(j\)</span>-th column is <span class="math">\(b.nf.zk[j]\)</span>.</p>
<p>The algebraic number <span class="math">\(a\)</span> is guaranteed to have a
valuation equal to 1 at the prime ideal (this is automatic if <span class="math">\(e &gt; 1\)</span>).</p>
<p>The components of <code class="docutils literal"><span class="pre">pr</span></code> should be accessed by member functions: <code class="docutils literal"><span class="pre">pr.p</span></code>,
<code class="docutils literal"><span class="pre">pr.e</span></code>, <code class="docutils literal"><span class="pre">pr.f</span></code>, and <code class="docutils literal"><span class="pre">pr.gen</span></code> (returns the vector <span class="math">\([p,a]\)</span>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(x^3-2);
? P = idealprimedec(K, 5);
? #P \\ 2 primes above 5 in Q(2^(1/3))
%3 = 2
? [p1,p2] = P;
? [p1.e, p1.f] \\ the first is unramified of degree 1
%5 = [1, 1]
? [p2.e, p2.f] \\ the second is unramified of degree 2
%6 = [1, 2]
? p1.gen
%7 = [5, [2, 1, 0]~]
? nfbasistoalg(K, %[2]) \\ a uniformizer for p1
%8 = Mod(x + 2, x^3 - 2)
? #idealprimedec(K, 5, 1) \\ restrict to f = 1
%9 = 1 \\ now only p1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealprincipalunits">
<code class="descname">idealprincipalunits</code><span class="sig-paren">(</span><em>nf</em>, <em>pr</em>, <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealprincipalunits" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a prime ideal in <code class="docutils literal"><span class="pre">idealprimedec</span></code> format,
returns the multiplicative group <span class="math">\((1 + pr) / (1 + pr^k)\)</span> as an
abelian group. This function is much faster than <code class="docutils literal"><span class="pre">idealstar</span></code> when the
norm of <em>pr</em> is large, since it avoids (useless) work in the
multiplicative group of the residue field.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^2+1);
? P = idealprimedec(K,2)[1];
? G = idealprincipalunits(K, P, 20);
? G.cyc
%4 = [512, 256, 4] \\ Z/512 x Z/256 x Z/4
? G.gen
%5 = [[-1, -2]~, 1021, [0, -1]~] \\ minimal generators of given order
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealramgroups">
<code class="descname">idealramgroups</code><span class="sig-paren">(</span><em>nf</em>, <em>gal</em>, <em>pr</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealramgroups" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(K\)</span> be the number field defined by <em>nf</em> and assume that <span class="math">\(K/\mathbb{Q}\)</span> is
Galois with Galois group <span class="math">\(G\)</span> given by <code class="docutils literal"><span class="pre">gal</span> <span class="pre">=</span> <span class="pre">galoisinit(nf)</span></code>.
Let <em>pr</em> be the prime ideal <span class="math">\(P\)</span> in prid format.
This function returns a vector <span class="math">\(g\)</span> of subgroups of <code class="docutils literal"><span class="pre">gal</span></code>
as follow:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">g[1]</span></code> is the decomposition group of <span class="math">\(P\)</span>,</li>
<li><code class="docutils literal"><span class="pre">g[2]</span></code> is <span class="math">\(G_0(P)\)</span>, the inertia group of <span class="math">\(P\)</span>,</li>
</ul>
<p>and for <span class="math">\(i &gt;= 2\)</span>,</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">g[i]</span></code> is <span class="math">\(G_{i-2}(P)\)</span>, the <span class="math">\(i-2\)</span>-th \idx{ramification
group} of <span class="math">\(P\)</span>.</li>
</ul>
<p>The length of <span class="math">\(g\)</span> is the number of non-trivial groups in the
sequence, thus is <span class="math">\(0\)</span> if <span class="math">\(e = 1\)</span> and <span class="math">\(f = 1\)</span>, and <span class="math">\(1\)</span> if <span class="math">\(f &gt; 1\)</span> and <span class="math">\(e = 1\)</span>.
The following function computes the cardinality of a subgroup of <span class="math">\(G\)</span>,
as given by the components of <span class="math">\(g\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">card</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">=</span><span class="n">my</span><span class="p">(</span><span class="n">o</span><span class="o">=</span><span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> <span class="n">prod</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="c1">#o,o[i]);</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf=nfinit(x^6+3); gal=galoisinit(nf); pr=idealprimedec(nf,3)[1];
? g = idealramgroups(nf, gal, pr);
? apply(card,g)
%3 = [6, 6, 3, 3, 3] \\ cardinalities of the G_i
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf=nfinit(x^6+108); gal=galoisinit(nf); pr=idealprimedec(nf,2)[1];
? iso=idealramgroups(nf,gal,pr)[2]
%5 = [[Vecsmall([2, 3, 1, 5, 6, 4])], Vecsmall([3])]
? nfdisc(galoisfixedfield(gal,iso,1))
%6 = -3
</pre></div>
</div>
<p>The field fixed by the inertia group of <span class="math">\(2\)</span> is not ramified at
<span class="math">\(2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealred">
<code class="descname">idealred</code><span class="sig-paren">(</span><em>nf</em>, <em>I</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealred" title="Permalink to this definition">¶</a></dt>
<dd><p>LLL reduction of
the ideal <span class="math">\(I\)</span> in the number field <em>nf</em>, along the direction <span class="math">\(v\)</span>.
The <span class="math">\(v\)</span> parameter is best left omitted, but if it is present, it must
be an <span class="math">\(nf.r1 + nf.r2\)</span>-component vector of <em>non-negative</em>
integers. (What counts is the relative magnitude of the entries: if all
entries are equal, the effect is the same as if the vector had been omitted.)</p>
<p>This function finds a &#8220;small&#8221; <span class="math">\(a\)</span> in <span class="math">\(I\)</span> (see the end for technical details).
The result is the Hermite normal form of
the &#8220;reduced&#8221; ideal <span class="math">\(J = r I/a\)</span>, where <span class="math">\(r\)</span> is the unique rational number such
that <span class="math">\(J\)</span> is integral and primitive. (This is usually not a reduced ideal in
the sense of Buchmann.)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^2+1);
? P = idealprimedec(K,5)[1];
? idealred(K, P)
%3 =
[1 0]

[0 1]
</pre></div>
</div>
<p>More often than not, a principal ideal yields the unit
ideal as above. This is a quick and dirty way to check if ideals are principal,
but it is not a necessary condition: a non-trivial result does not prove that
the ideal is non-principal. For guaranteed results, see <code class="docutils literal"><span class="pre">bnfisprincipal</span></code>,
which requires the computation of a full <code class="docutils literal"><span class="pre">bnf</span></code> structure.</p>
<p>If the input is an extended ideal <span class="math">\([I,s]\)</span>, the output is <span class="math">\([J,sa/r]\)</span>; this way,
one can keep track of the principal ideal part:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? idealred(K, [P, 1])
%5 = [[1, 0; 0, 1], [-2, 1]~]
</pre></div>
</div>
<p>meaning that <span class="math">\(P\)</span> is generated by <span class="math">\([-2, 1]&nbsp;\)</span>. The number field element in the
extended part is an algebraic number in any form <em>or</em> a factorization
matrix (in terms of number field elements, not ideals!). In the latter case,
elements stay in factored form, which is a convenient way to avoid
coefficient explosion; see also <code class="docutils literal"><span class="pre">idealpow</span></code>.</p>
<p><strong>Technical note.</strong> The routine computes an LLL-reduced
basis for the lattice <span class="math">\(I\)</span> equipped with the quadratic form</p>
<div class="math">
\[\|\| x \|\|_v^2 = \sum_{i = 1}^{r_1+r_2} 2^{v_i}\varepsilon_i\|\sigma_i(x)\|^2,\]</div>
<p>where as usual the <span class="math">\(\sigma_i\)</span> are the (real and) complex embeddings and
<span class="math">\(\varepsilon_i = 1\)</span>, resp.&nbsp;<span class="math">\(2\)</span>, for a real, resp.&nbsp;complex place. The element
<span class="math">\(a\)</span> is simply the first vector in the LLL basis. The only reason you may want
to try to change some directions and set some <span class="math">\(v_i != 0\)</span> is to randomize
the elements found for a fixed ideal, which is heuristically useful in index
calculus algorithms like <code class="docutils literal"><span class="pre">bnfinit</span></code> and <code class="docutils literal"><span class="pre">bnfisprincipal</span></code>.</p>
<p><strong>Even more technical note.</strong> In fact, the above is a white lie.
We do not use <span class="math">\(\|\|.\|\|_v\)</span> exactly but a rescaled rounded variant which
gets us faster and simpler LLLs. There&#8217;s no harm since we are not using any
theoretical property of <span class="math">\(a\)</span> after all, except that it belongs to <span class="math">\(I\)</span> and is
&#8220;expected to be small&#8221;.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealstar">
<code class="descname">idealstar</code><span class="sig-paren">(</span><em>nf</em>, <em>N</em>, <em>flag=1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealstar" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs a <code class="docutils literal"><span class="pre">bid</span></code> structure,
necessary for computing in the finite abelian group <span class="math">\(G = (\mathbb{Z}_K/N)^*\)</span>. Here,
<em>nf</em> is a number field and <span class="math">\(N\)</span> is a <em>modulus</em>: either an ideal in any
form, or a row vector whose first component is an ideal and whose second
component is a row vector of <span class="math">\(r_1\)</span> 0 or 1. Ideals can also be given
by a factorization into prime ideals, as produced by <code class="docutils literal"><span class="pre">idealfactor</span></code>.</p>
<p>This <em>bid</em> is used in <code class="docutils literal"><span class="pre">ideallog</span></code> to compute discrete logarithms. It
also contains useful information which can be conveniently retrieved as
<code class="docutils literal"><span class="pre">:emphasis:`bid</span></code>.mod` (the modulus),
<code class="docutils literal"><span class="pre">:emphasis:`bid</span></code>.clgp` (<span class="math">\(G\)</span> as a finite abelian group),
<code class="docutils literal"><span class="pre">:emphasis:`bid</span></code>.no` (the cardinality of <span class="math">\(G\)</span>),
<code class="docutils literal"><span class="pre">:emphasis:`bid</span></code>.cyc` (elementary divisors) and
<code class="docutils literal"><span class="pre">:emphasis:`bid</span></code>.gen` (generators).</p>
<p>If <span class="math">\(flag = 1\)</span> (default), the result is a <code class="docutils literal"><span class="pre">bid</span></code> structure without
generators: they are well defined but not explicitly computed, which saves
time.</p>
<p>If <span class="math">\(flag = 2\)</span>, as <span class="math">\(flag = 1\)</span>, but including generators.</p>
<p>If <span class="math">\(flag = 0\)</span>, only outputs <span class="math">\((\mathbb{Z}_K/N)^*\)</span> as an abelian group,
i.e as a 3-component vector <span class="math">\([h,d,g]\)</span>: <span class="math">\(h\)</span> is the order, <span class="math">\(d\)</span> is the vector of
SNF cyclic components and <span class="math">\(g\)</span> the corresponding
generators.</p>
<p>If <em>nf</em> is omitted, we take it to be the rational number fields, <span class="math">\(N\)</span> must
be an integer and we return the structure of <span class="math">\((\mathbb{Z}/N\mathbb{Z})^*\)</span>. In other words
<code class="docutils literal"><span class="pre">idealstar(,</span> <span class="pre">N,</span> <span class="pre">flag)</span></code> is short for</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">idealstar</span><span class="p">(</span><span class="n">nfinit</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">N</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>
</pre></div>
</div>
<p>but much faster.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealtwoelt">
<code class="descname">idealtwoelt</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>a=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealtwoelt" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a two-element
representation of the ideal <span class="math">\(x\)</span> in the number field <span class="math">\(nf\)</span>, combining a
random search and an approximation theorem; <span class="math">\(x\)</span> is an ideal
in any form (possibly an extended ideal, whose principal part is ignored)</p>
<ul class="simple">
<li>When called as <code class="docutils literal"><span class="pre">idealtwoelt(nf,x)</span></code>, the result is a row vector
<span class="math">\([a,\alpha]\)</span> with two components such that <span class="math">\(x = a\mathbb{Z}_K+\alpha\mathbb{Z}_K\)</span> and <span class="math">\(a\)</span> is
chosen to be the positive generator of <span class="math">\(x\cap\mathbb{Z}\)</span>, unless <span class="math">\(x\)</span> was given as a
principal ideal (in which case we may choose <span class="math">\(a = 0\)</span>). The algorithm
uses a fast lazy factorization of <span class="math">\(x\cap \mathbb{Z}\)</span> and runs in randomized
polynomial time.</li>
<li>When called as <code class="docutils literal"><span class="pre">idealtwoelt(nf,x,a)</span></code> with an explicit non-zero <span class="math">\(a\)</span>
supplied as third argument, the function assumes that <span class="math">\(a belongs to x\)</span> and returns
<span class="math">\(\alpha belongs to x\)</span> such that <span class="math">\(x = a\mathbb{Z}_K + \alpha\mathbb{Z}_K\)</span>. Note that we must factor
<span class="math">\(a\)</span> in this case, and the algorithm is generally much slower than the
default variant.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.idealval">
<code class="descname">idealval</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>pr</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.idealval" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the valuation of the ideal <span class="math">\(x\)</span> at the prime ideal <em>pr</em> in the
number field <span class="math">\(nf\)</span>, where <em>pr</em> is in <code class="docutils literal"><span class="pre">idealprimedec</span></code> format.
The valuation of the <span class="math">\(0\)</span> ideal is <code class="docutils literal"><span class="pre">+oo</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.imag">
<code class="descname">imag</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Imaginary part of <span class="math">\(x\)</span>. When <span class="math">\(x\)</span> is a quadratic number, this is the
coefficient of <span class="math">\(\omega\)</span> in the &#8220;canonical&#8221; integral basis <span class="math">\((1,\omega)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.incgam">
<code class="descname">incgam</code><span class="sig-paren">(</span><em>s</em>, <em>x</em>, <em>g=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.incgam" title="Permalink to this definition">¶</a></dt>
<dd><p>Incomplete gamma function <span class="math">\(\int_x^ oo e^{-t}t^{s-1}dt\)</span>, extended by
analytic continuation to all complex <span class="math">\(x, s\)</span> not both <span class="math">\(0\)</span>. The relative error
is bounded in terms of the precision of <span class="math">\(s\)</span> (the accuracy of <span class="math">\(x\)</span> is ignored
when determining the output precision). When <span class="math">\(g\)</span> is given, assume that
<span class="math">\(g = \Gamma(s)\)</span>. For small <span class="math">\(\|x\|\)</span>, this will speed up the computation.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.incgamc">
<code class="descname">incgamc</code><span class="sig-paren">(</span><em>s</em>, <em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.incgamc" title="Permalink to this definition">¶</a></dt>
<dd><p>Complementary incomplete gamma function.
The arguments <span class="math">\(x\)</span> and <span class="math">\(s\)</span> are complex numbers such that <span class="math">\(s\)</span> is not a pole of
<span class="math">\(\Gamma\)</span> and <span class="math">\(\|x\|/(\|s\|+1)\)</span> is not much larger than 1 (otherwise the
convergence is very slow). The result returned is <span class="math">\(\int_0^x
e^{-t}t^{s-1}dt\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.intformal">
<code class="descname">intformal</code><span class="sig-paren">(</span><em>x</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.intformal" title="Permalink to this definition">¶</a></dt>
<dd><p>formal integration of <span class="math">\(x\)</span> with respect to the variable <span class="math">\(v\)</span> (wrt.
the main variable if <span class="math">\(v\)</span> is omitted). Since PARI cannot represent
logarithmic or arctangent terms, any such term in the result will yield an
error:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? intformal(x^2)
%1 = 1/3*x^3
? intformal(x^2, y)
%2 = y*x^2
? intformal(1/x)
*** at top-level: intformal(1/x)
*** ^--------------
*** intformal: domain error in intformal: residue(series, pole) != 0
</pre></div>
</div>
<p>The argument <span class="math">\(x\)</span> can be of any type. When <span class="math">\(x\)</span> is a rational function, we
assume that the base ring is an integral domain of characteristic zero.</p>
<p>By definition, the main variable of a <code class="docutils literal"><span class="pre">t_POLMOD</span></code> is the main variable
among the coefficients from its two polynomial components
(representative and modulus); in other words, assuming a polmod represents an
element of <span class="math">\(R[X]/(T(X))\)</span>, the variable <span class="math">\(X\)</span> is a mute variable and the
integral is taken with respect to the main variable used in the base ring <span class="math">\(R\)</span>.
In particular, it is meaningless to integrate with respect to the main
variable of <code class="docutils literal"><span class="pre">x.mod</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? intformal(Mod(1,x^2+1), &#39;x)
*** intformal: incorrect priority in intformal: variable x = x
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.intnuminit">
<code class="descname">intnuminit</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>m=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.intnuminit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize tables for integration from
<span class="math">\(a\)</span> to <span class="math">\(b\)</span>, where <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are coded as in <code class="docutils literal"><span class="pre">intnum</span></code>. Only the
compactness, the possible existence of singularities, the speed of decrease
or the oscillations at infinity are taken into account, and not the values.
For instance <code class="docutils literal"><span class="pre">intnuminit(-1,1)</span></code> is equivalent to <code class="docutils literal"><span class="pre">intnuminit(0,Pi)</span></code>,
and <code class="docutils literal"><span class="pre">intnuminit([0,-1/2],oo)</span></code> is equivalent to
<code class="docutils literal"><span class="pre">intnuminit([-1,-1/2],</span> <span class="pre">-oo)</span></code>; on the other hand, the order matters
and
<code class="docutils literal"><span class="pre">intnuminit([0,-1/2],</span> <span class="pre">[1,-1/3])</span></code> is <em>not</em> equivalent to
<code class="docutils literal"><span class="pre">intnuminit([0,-1/3],</span> <span class="pre">[1,-1/2])</span></code> !</p>
<p>If <span class="math">\(m\)</span> is multiply the default number of sampling points by <span class="math">\(2^m\)</span> (increasing
the running time by a similar factor).</p>
<p>The result is technical and liable to change in the future, but we document
it here for completeness. Let <span class="math">\(x = \phi(t)\)</span>, <span class="math">\(t belongs to ]- oo , oo [\)</span> be an
internally chosen change of variable, achieving double exponential decrease of
the integrand at infinity. The integrator <code class="docutils literal"><span class="pre">intnum</span></code> will compute</p>
<div class="math">
\[h \sum_{\|n\| &lt; N} \phi'(nh) F(\phi(nh))\]</div>
<p>for some integration step <span class="math">\(h\)</span> and truncation parameter <span class="math">\(N\)</span>.
In basic use, let</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">w0</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">wp</span><span class="p">,</span> <span class="n">xm</span><span class="p">,</span> <span class="n">wm</span><span class="p">]</span> <span class="o">=</span> <span class="n">intnuminit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><span class="math">\(h\)</span> is the integration step</li>
<li><span class="math">\(x_0 = \phi(0)\)</span> and <span class="math">\(w_0 = \phi'(0)\)</span>,</li>
<li><em>xp</em> contains the <span class="math">\(\phi(nh)\)</span>, <span class="math">\(0 &lt; n &lt; N\)</span>,</li>
<li><em>xm</em> contains the <span class="math">\(\phi(nh)\)</span>, <span class="math">\(0 &lt; -n &lt; N\)</span>, or is empty.</li>
<li><em>wp</em> contains the <span class="math">\(\phi'(nh)\)</span>, <span class="math">\(0 &lt; n &lt; N\)</span>,</li>
<li><em>wm</em> contains the <span class="math">\(\phi'(nh)\)</span>, <span class="math">\(0 &lt; -n &lt; N\)</span>, or is empty.</li>
</ul>
<p>The arrays <em>xm</em> and <em>wm</em> are left empty when <span class="math">\(\phi\)</span> is an odd
function. In complicated situations when non-default behaviour is specified at
end points, <code class="docutils literal"><span class="pre">intnuminit</span></code> may return up to <span class="math">\(3\)</span> such arrays, corresponding
to a splitting of up to <span class="math">\(3\)</span> integrals of basic type.</p>
<p>If the functions to be integrated later are of the form <span class="math">\(F = f(t) k(t,z)\)</span>
for some kernel <span class="math">\(k\)</span> (e.g. Fourier, Laplace, Mellin,...), it is
useful to also precompute the values of <span class="math">\(f(\phi(nh))\)</span>, which is accomplished
by <code class="docutils literal"><span class="pre">intfuncinit</span></code>. The hard part is to determine the behaviour
of <span class="math">\(F\)</span> at endpoints, depending on <span class="math">\(z\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.isfundamental">
<code class="descname">isfundamental</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.isfundamental" title="Permalink to this definition">¶</a></dt>
<dd><p>True (1) if <span class="math">\(x\)</span> is equal to 1 or to the discriminant of a quadratic
field, false (0) otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ispowerful">
<code class="descname">ispowerful</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ispowerful" title="Permalink to this definition">¶</a></dt>
<dd><p>True (1) if <span class="math">\(x\)</span> is a powerful integer, false (0) if not;
an integer is powerful if and only if its valuation at all primes dividing
<span class="math">\(x\)</span> is greater than 1.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? ispowerful(50)
%1 = 0
? ispowerful(100)
%2 = 1
? ispowerful(5^3*(10^1000+1)^2)
%3 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.isprime">
<code class="descname">isprime</code><span class="sig-paren">(</span><em>x</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.isprime" title="Permalink to this definition">¶</a></dt>
<dd><p>True (1) if <span class="math">\(x\)</span> is a prime
number, false (0) otherwise. A prime number is a positive integer having
exactly two distinct divisors among the natural numbers, namely 1 and
itself.</p>
<p>This routine proves or disproves rigorously that a number is prime, which can
be very slow when <span class="math">\(x\)</span> is indeed prime and has more than <span class="math">\(1000\)</span> digits, say.
Use <code class="docutils literal"><span class="pre">ispseudoprime</span></code> to quickly check for compositeness. See also
<code class="docutils literal"><span class="pre">factor</span></code>. It accepts vector/matrices arguments, and is then applied
componentwise.</p>
<p>If <span class="math">\(flag = 0\)</span>, use a combination of Baillie-PSW pseudo primality test (see
<code class="docutils literal"><span class="pre">ispseudoprime</span></code>), Selfridge &#8220;<span class="math">\(p-1\)</span>&#8221; test if <span class="math">\(x-1\)</span> is smooth enough, and
Adleman-Pomerance-Rumely-Cohen-Lenstra (APRCL) for general <span class="math">\(x\)</span>.</p>
<p>If <span class="math">\(flag = 1\)</span>, use Selfridge-Pocklington-Lehmer &#8220;<span class="math">\(p-1\)</span>&#8221; test and output a
primality certificate as follows: return</p>
<ul class="simple">
<li>0 if <span class="math">\(x\)</span> is composite,</li>
<li>1 if <span class="math">\(x\)</span> is small enough that passing Baillie-PSW test guarantees
its primality (currently <span class="math">\(x &lt; 2^{64}\)</span>, as checked by Jan Feitsma),</li>
<li><span class="math">\(2\)</span> if <span class="math">\(x\)</span> is a large prime whose primality could only sensibly be
proven (given the algorithms implemented in PARI) using the APRCL test.</li>
<li>Otherwise (<span class="math">\(x\)</span> is large and <span class="math">\(x-1\)</span> is smooth) output a three column
matrix as a primality certificate. The first column contains prime
divisors <span class="math">\(p\)</span> of <span class="math">\(x-1\)</span> (such that <span class="math">\(\prod p^{v_p(x-1)} &gt; x^{1/3}\)</span>), the second
the corresponding elements <span class="math">\(a_p\)</span> as in Proposition&nbsp;8.3.1 in GTM&nbsp;138 , and the
third the output of isprime(p,1).</li>
</ul>
<p>The algorithm fails if one of the pseudo-prime factors is not prime, which is
exceedingly unlikely and well worth a bug report. Note that if you monitor
<code class="docutils literal"><span class="pre">isprime</span></code> at a high enough debug level, you may see warnings about
untested integers being declared primes. This is normal: we ask for partial
factorisations (sufficient to prove primality if the unfactored part is not
too large), and <code class="docutils literal"><span class="pre">factor</span></code> warns us that the cofactor hasn&#8217;t been tested.
It may or may not be tested later, and may or may not be prime. This does
not affect the validity of the whole <code class="docutils literal"><span class="pre">isprime</span></code> procedure.</p>
<p>If <span class="math">\(flag = 2\)</span>, use APRCL.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ispseudoprime">
<code class="descname">ispseudoprime</code><span class="sig-paren">(</span><em>x</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ispseudoprime" title="Permalink to this definition">¶</a></dt>
<dd><p>True (1) if <span class="math">\(x\)</span> is a strong pseudo
prime (see below), false (0) otherwise. If this function returns false, <span class="math">\(x\)</span>
is not prime; if, on the other hand it returns true, it is only highly likely
that <span class="math">\(x\)</span> is a prime number. Use <code class="docutils literal"><span class="pre">isprime</span></code> (which is of course much
slower) to prove that <span class="math">\(x\)</span> is indeed prime.
The function accepts vector/matrices arguments, and is then applied
componentwise.</p>
<p>If <span class="math">\(flag = 0\)</span>, checks whether <span class="math">\(x\)</span> is a Baillie-Pomerance-Selfridge-Wagstaff
pseudo prime (strong Rabin-Miller pseudo prime for base <span class="math">\(2\)</span>, followed by
strong Lucas test for the sequence <span class="math">\((P,-1)\)</span>, <span class="math">\(P\)</span> smallest positive integer
such that <span class="math">\(P^2 - 4\)</span> is not a square mod <span class="math">\(x\)</span>).</p>
<p>There are no known composite numbers passing this test, although it is
expected that infinitely many such numbers exist. In particular, all
composites <span class="math">\(&lt;= 2^{64}\)</span> are correctly detected (checked using
<code class="docutils literal"><span class="pre">http://www.cecm.sfu.ca/Pseudoprimes/index-2-to-64.html</span></code>).</p>
<p>If <span class="math">\(flag &gt; 0\)</span>, checks whether <span class="math">\(x\)</span> is a strong Miller-Rabin pseudo prime for
<span class="math">\(flag\)</span> randomly chosen bases (with end-matching to catch square roots of <span class="math">\(-1\)</span>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.issquarefree">
<code class="descname">issquarefree</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.issquarefree" title="Permalink to this definition">¶</a></dt>
<dd><p>True (1) if <span class="math">\(x\)</span> is squarefree, false (0) if not. Here <span class="math">\(x\)</span> can be an
integer or a polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.kronecker">
<code class="descname">kronecker</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.kronecker" title="Permalink to this definition">¶</a></dt>
<dd><p>Kronecker symbol <span class="math">\((x\|y)\)</span>, where <span class="math">\(x\)</span> and <span class="math">\(y\)</span> must be of type integer. By
definition, this is the extension of Legendre symbol to <span class="math">\(\mathbb{Z} x \mathbb{Z}\)</span>
by total multiplicativity in both arguments with the following special rules
for <span class="math">\(y = 0, -1\)</span> or <span class="math">\(2\)</span>:</p>
<ul class="simple">
<li><span class="math">\((x\|0) = 1\)</span> if <span class="math">\(\|x \|= 1\)</span> and <span class="math">\(0\)</span> otherwise.</li>
<li><span class="math">\((x\|-1) = 1\)</span> if <span class="math">\(x &gt;= 0\)</span> and <span class="math">\(-1\)</span> otherwise.</li>
<li><span class="math">\((x\|2) = 0\)</span> if <span class="math">\(x\)</span> is even and <span class="math">\(1\)</span> if <span class="math">\(x = 1,-1 mod 8\)</span> and <span class="math">\(-1\)</span>
if <span class="math">\(x = 3,-3 mod 8\)</span>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lambertw">
<code class="descname">lambertw</code><span class="sig-paren">(</span><em>y</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lambertw" title="Permalink to this definition">¶</a></dt>
<dd><p>Lambert <span class="math">\(W\)</span> function, solution of the implicit equation <span class="math">\(xe^x = y\)</span>,
for <span class="math">\(y &gt; 0\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lcm">
<code class="descname">lcm</code><span class="sig-paren">(</span><em>x</em>, <em>y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lcm" title="Permalink to this definition">¶</a></dt>
<dd><p>Least common multiple of <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, i.e.&nbsp;such
that <span class="math">\(\mathrm{lcm}(x,y)*\mathrm{gcd}(x,y) = x*y\)</span>, up to units. If <span class="math">\(y\)</span> is omitted and <span class="math">\(x\)</span>
is a vector, returns the <span class="math">\({lcm}\)</span> of all components of <span class="math">\(x\)</span>.
For integer arguments, return the non-negative {lcm}.</p>
<p>When <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are both given and one of them is a vector/matrix type,
the LCM is again taken recursively on each component, but in a different way.
If <span class="math">\(y\)</span> is a vector, resp.&nbsp;matrix, then the result has the same type as <span class="math">\(y\)</span>,
and components equal to <code class="docutils literal"><span class="pre">lcm(x,</span> <span class="pre">y[i])</span></code>, resp.&nbsp;<code class="docutils literal"><span class="pre">lcm(x,</span> <span class="pre">y[,i])</span></code>. Else
if <span class="math">\(x\)</span> is a vector/matrix the result has the same type as <span class="math">\(x\)</span> and an
analogous definition. Note that for these types, <code class="docutils literal"><span class="pre">lcm</span></code> is not
commutative.</p>
<p>Note that <code class="docutils literal"><span class="pre">lcm(v)</span></code> is quite different from</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">l</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">#v, l = lcm(l, v[i]))</span>
</pre></div>
</div>
<p>Indeed, <code class="docutils literal"><span class="pre">lcm(v)</span></code> is a scalar, but <code class="docutils literal"><span class="pre">l</span></code> may not be (if one of
the <code class="docutils literal"><span class="pre">v[i]</span></code> is a vector/matrix). The computation uses a divide-conquer tree
and should be much more efficient, especially when using the GMP
multiprecision kernel (and more subquadratic algorithms become available):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? v = vector(10^5, i, random);
? lcm(v);
time = 546 ms.
? l = v[1]; for (i = 1, #v, l = lcm(l, v[i]))
time = 4,561 ms.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.length">
<code class="descname">length</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Length of <span class="math">\(x\)</span>; <code class="docutils literal"><span class="pre">#</span></code><span class="math">\(x\)</span> is a shortcut for <code class="docutils literal"><span class="pre">length</span></code><span class="math">\((x)\)</span>.
This is mostly useful for</p>
<ul class="simple">
<li>vectors: dimension (0 for empty vectors),</li>
<li>lists: number of entries (0 for empty lists),</li>
<li>matrices: number of columns,</li>
<li>character strings: number of actual characters (without
trailing <code class="docutils literal"><span class="pre">0</span></code>, should you expect it from <span class="math">\(C\)</span> <code class="docutils literal"><span class="pre">char*</span></code>).</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? #&quot;a string&quot;
%1 = 8
? #[3,2,1]
%2 = 3
? #[]
%3 = 0
? #matrix(2,5)
%4 = 5
? L = List([1,2,3,4]); #L
%5 = 4
</pre></div>
</div>
<p>The routine is in fact defined for arbitrary GP types, but is awkward and
useless in other cases: it returns the number of non-code words in <span class="math">\(x\)</span>, e.g.
the effective length minus 2 for integers since the <code class="docutils literal"><span class="pre">t_INT</span></code> type has two code
words.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lex">
<code class="descname">lex</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lex" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the result of a lexicographic comparison
between <span class="math">\(x\)</span> and <span class="math">\(y\)</span> (as <span class="math">\(-1\)</span>, <span class="math">\(0\)</span> or <span class="math">\(1\)</span>). This is to be interpreted in quite
a wide sense: It is admissible to compare objects of different types
(scalars, vectors, matrices), provided the scalars can be compared, as well
as vectors/matrices of different lengths. The comparison is recursive.</p>
<p>In case all components are equal up to the smallest length of the operands,
the more complex is considered to be larger. More precisely, the longest is
the largest; when lengths are equal, we have matrix <span class="math">\(&gt;\)</span> vector <span class="math">\(&gt;\)</span> scalar.
For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? lex([1,3], [1,2,5])
%1 = 1
? lex([1,3], [1,3,-1])
%2 = -1
? lex([1], [[1]])
%3 = -1
? lex([1], [1]~)
%4 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfun">
<code class="descname">lfun</code><span class="sig-paren">(</span><em>L</em>, <em>s</em>, <em>D=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfun" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the L-function value <span class="math">\(L(s)\)</span>, or if <code class="docutils literal"><span class="pre">D</span></code> is set, the
derivative of order <code class="docutils literal"><span class="pre">D</span></code> at <span class="math">\(s\)</span>. The parameter
<code class="docutils literal"><span class="pre">L</span></code> is either an Lmath, an Ldata (created by <code class="docutils literal"><span class="pre">lfuncreate</span></code>, or an
Linit (created by <code class="docutils literal"><span class="pre">lfuninit</span></code>), preferrably the latter if many values
are to be computed.</p>
<p>The argument <span class="math">\(s\)</span> is also allowed to be a power series; for instance, if <span class="math">\(s = 
\alpha + x + O(x^n)\)</span>, the function returns the Taylor expansion of order <span class="math">\(n\)</span>
around <span class="math">\(\alpha\)</span>. The result is given with absolute error less than <span class="math">\(2^{-B}\)</span>,
where <span class="math">\(B = {realbitprecision}\)</span>.</p>
<p><strong>Caveat.</strong> The requested precision has a major impact on runtimes.
It is advised to manipulate precision via <code class="docutils literal"><span class="pre">realbitprecision</span></code> as
explained above instead of <code class="docutils literal"><span class="pre">realprecision</span></code> as the latter allows less
granularity: <code class="docutils literal"><span class="pre">realprecision</span></code> increases by increments of 64 bits, i.e. 19
decimal digits at a time.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? lfun(x^2+1, 2) \\ Lmath: Dedekind zeta for Q(i) at 2
%1 = 1.5067030099229850308865650481820713960

? L = lfuncreate(ellinit(&quot;5077a1&quot;)); \\ Ldata: Hasse-Weil zeta function
? lfun(L, 1+x+O(x^4)) \\ zero of order 3 at the central point
%3 = 0.E-58 - 5.[...] E-40*x + 9.[...] E-40*x^2 + 1.7318[...]*x^3 + O(x^4)

\\ Linit: zeta(1/2+it), |t| &lt; 100, and derivative
? L = lfuninit(1, [100], 1);
? T = lfunzeros(L, [1,25]);
%5 = [14.134725[...], 21.022039[...]]
? z = 1/2 + I*T[1];
? abs( lfun(L, z) )
%7 = 8.7066865533412207420780392991125136196 E-39
? abs( lfun(L, z 1) )
%8 = 0.79316043335650611601389756527435211412 \\ simple zero
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunabelianrelinit">
<code class="descname">lfunabelianrelinit</code><span class="sig-paren">(</span><em>bnfL</em>, <em>bnfK</em>, <em>polrel</em>, <em>sdom</em>, <em>der=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunabelianrelinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <code class="docutils literal"><span class="pre">Linit</span></code> structure associated to the Dedekind zeta function
of the number field <span class="math">\(L\)</span> (see <code class="docutils literal"><span class="pre">lfuninit</span></code>), given a subfield <span class="math">\(K\)</span> such that
<span class="math">\(L/K\)</span> is abelian.
Here <code class="docutils literal"><span class="pre">polrel</span></code> defines <span class="math">\(L\)</span> over <span class="math">\(K\)</span>, as usual with the priority of the
variable of <code class="docutils literal"><span class="pre">bnfK</span></code> lower than that of <code class="docutils literal"><span class="pre">polrel</span></code>.
<code class="docutils literal"><span class="pre">sdom</span></code> and <code class="docutils literal"><span class="pre">der</span></code> are as in <code class="docutils literal"><span class="pre">lfuninit</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? D = -47; K = bnfinit(y^2-D);
? rel = quadhilbert(D); T = rnfequation(K.pol, rel); \\ degree 10
? L = lfunabelianrelinit(T,K,rel, [2,0,0]); \\ at 2
time = 84 ms.
? lfun(L, 2)
%4 = 1.0154213394402443929880666894468182650
? lfun(T, 2) \\ using parisize &gt; 300MB
time = 652 ms.
%5 = 1.0154213394402443929880666894468182656
</pre></div>
</div>
<p>As the example shows, using the (abelian) relative structure
is more efficient than a direct computation. The difference becomes drastic
as the absolute degree increases while the subfield degree remains constant.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunan">
<code class="descname">lfunan</code><span class="sig-paren">(</span><em>L</em>, <em>n</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunan" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the first <span class="math">\(n\)</span> terms of the Dirichlet series attached to the
<span class="math">\(L\)</span>-function given by <code class="docutils literal"><span class="pre">L</span></code> (<code class="docutils literal"><span class="pre">Lmath</span></code>, <code class="docutils literal"><span class="pre">Ldata</span></code> or <code class="docutils literal"><span class="pre">Linit</span></code>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? lfunan(1, 10) \\ Riemann zeta
%1 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
? lfunan(5, 10) \\ Dirichlet L-function for kronecker(5,.)
%2 = [1, -1, -1, 1, 0, 1, -1, -1, 1, 0]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunartin">
<code class="descname">lfunartin</code><span class="sig-paren">(</span><em>nf</em>, <em>gal</em>, <em>M</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunartin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <code class="docutils literal"><span class="pre">Ldata</span></code> structure associated to the
Artin <span class="math">\(L\)</span>-function associated to the representation <span class="math">\(\rho\)</span> of the Galois group
of the extension <span class="math">\(K/\mathbb{Q}\)</span>, defined over the cyclotomic field <span class="math">\(\mathbb{Q}(\zeta_n)\)</span>,
where <em>nf</em> is the nfinit structure associated to <span class="math">\(K\)</span>,
<em>gal</em> is the galoisinit structure associated to <span class="math">\(K/\mathbb{Q}\)</span>, and <span class="math">\(M\)</span> is
the vector of the image of the generators <code class="docutils literal"><span class="pre">:emphasis:`gal</span></code>.gen` by <span class="math">\(\rho\)</span>.
The elements of <span class="math">\(M\)</span> are matrices with polynomial entries, whose variable
is understood as the complex number <span class="math">\(\exp(2 i \Pi/n)\)</span>.</p>
<p>In the following example we build the Artin <span class="math">\(L\)</span>-functions associated to the two
irreducible degree <span class="math">\(2\)</span> representations of the dihedral group <span class="math">\(D_{10}\)</span> defined
over <span class="math">\(\mathbb{Q}(\zeta_5)\)</span>, for the extension <span class="math">\(H/\mathbb{Q}\)</span> where <span class="math">\(H\)</span> is the Hilbert class
field of <span class="math">\(\mathbb{Q}(\sqrt{-47})\)</span>.
We show numerically some identities involving Dedekind <span class="math">\(\zeta\)</span> functions and
Hecke <span class="math">\(L\)</span> series.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? P = quadhilbert(-47);
? N = nfinit(nfsplitting(P));
? G = galoisinit(N);
? L1 = lfunartin(N,G, [[a,0;0,a^-1],[0,1;1,0]], 5);
? L2 = lfunartin(N,G, [[a^2,0;0,a^-2],[0,1;1,0]], 5);
? s = 1 + x + O(x^4);
? lfun(1,s)*lfun(-47,s)*lfun(L1,s)^2*lfun(L2,s)^2 - lfun(N,s)
%6 ~ 0
? lfun(1,s)*lfun(L1,s)*lfun(L2,s) - lfun(P,s)
%7 ~ 0
? bnr = bnrinit(bnfinit(x^2+47),1,1);
? lfun([bnr,[1]], s) - lfun(L1, s)
%9 ~ 0
? lfun([bnr,[1]], s) - lfun(L1, s)
%10 ~ 0
</pre></div>
</div>
<p>The first identity is the factorisation of the regular representation of
<span class="math">\(D_{10}\)</span>, the second the factorisation of the natural representation of
<span class="math">\(D_{10}\subset S_5\)</span>, the next two are the expressions of the degree <span class="math">\(2\)</span>
representations as induced from degree <span class="math">\(1\)</span> representations.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfuncheckfeq">
<code class="descname">lfuncheckfeq</code><span class="sig-paren">(</span><em>L</em>, <em>t=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfuncheckfeq" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the data associated to an <span class="math">\(L\)</span>-function (<code class="docutils literal"><span class="pre">Lmath</span></code>, <code class="docutils literal"><span class="pre">Ldata</span></code>
or <code class="docutils literal"><span class="pre">Linit</span></code>), check whether the functional equation is satisfied.
This is most useful for an <code class="docutils literal"><span class="pre">Ldata</span></code> constructed &#8220;by hand&#8221;, via
<code class="docutils literal"><span class="pre">lfuncreate</span></code>, to detect mistakes.</p>
<p>If the function has poles, the polar part must be specified. The routine
returns a bit accuracy <span class="math">\(b\)</span> such that <span class="math">\(\|w - ^{w}\| &lt; 2^{b}\)</span>, where <span class="math">\(w\)</span> is
the root number contained in <code class="docutils literal"><span class="pre">data</span></code>, and <span class="math">\(^{w}\)</span> is a computed value
derived from <span class="math">\(\overline{\theta}(t)\)</span> and <span class="math">\(\theta(1/t)\)</span> at some <span class="math">\(t != 0\)</span> and
the assumed functional equation. Of course, a large negative value of the
order of <code class="docutils literal"><span class="pre">realbitprecision</span></code> is expected.</p>
<p>If <span class="math">\(t\)</span> is given, it should be close to the unit disc for efficiency and
such that <span class="math">\(\overline{\theta}(t) != 0\)</span>. We then check the functional
equation at that <span class="math">\(t\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \pb 128 \\ 128 bits of accuracy
? default(realbitprecision)
%1 = 128
? L = lfuncreate(1); \\ Riemann zeta
? lfuncheckfeq(L)
%3 = -124
</pre></div>
</div>
<p>i.e. the given data is consistent to within 4 bits for the
particular check consisting of estimating the root number from all other
given quantities. Checking away from the unit disc will either fail with
a precision error, or give disappointing results (if <span class="math">\(\theta(1/t)\)</span> is
large it will be computed with a large absolute error)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? lfuncheckfeq(L, 2+I)
%4 = -115
? lfuncheckfeq(L,10)
 *** at top-level: lfuncheckfeq(L,10)
 *** ^------------------
 *** lfuncheckfeq: precision too low in lfuncheckfeq.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunconductor">
<code class="descname">lfunconductor</code><span class="sig-paren">(</span><em>L</em>, <em>ab=None</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunconductor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the conductor of the given <span class="math">\(L\)</span>-function
(if the structure contains a conductor, it is ignored);
<span class="math">\(ab = [a,b]\)</span> is the interval where we expect to find the conductor;
it may be given as a single scalar <span class="math">\(b\)</span>, in which case we look in <span class="math">\([1,b]\)</span>.
Increasing <code class="docutils literal"><span class="pre">ab</span></code> slows down the program but gives better accuracy for the
result.</p>
<p>If <code class="docutils literal"><span class="pre">flag</span></code> is <span class="math">\(0\)</span> (default), give either the conductor found as an
integer, or a vector (possibly empty) of conductors found. If <code class="docutils literal"><span class="pre">flag</span></code> is
<span class="math">\(1\)</span>, same but give the computed floating point approximations to the
conductors found, without rounding to integers. It <code class="docutils literal"><span class="pre">flag</span></code> is <span class="math">\(2\)</span>, give
all the conductors found, even those far from integers.</p>
<p><strong>Caveat.</strong> This is a heuristic program and the result is not
proven in any way:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? L = lfuncreate(857); \\ Dirichlet L function for kronecker(857,.)
? \p19
realprecision = 19 significant digits
? lfunconductor(L)
%2 = [17, 857]
? lfunconductor(L,,1) \\ don&#39;t round
%3 = [16.99999999999999999, 857.0000000000000000]

? \p38
realprecision = 38 significant digits
? lfunconductor(L)
%4 = 857
</pre></div>
</div>
<p><strong>Note.</strong> This program should only be used if the primes dividing the
conductor are unknown, which is rare. If they are known, a direct
search through possible prime exponents using <code class="docutils literal"><span class="pre">lfuncheckfeq</span></code> will
be more efficient and rigorous:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([0,0,0,4,0]); /* Elliptic curve y^2 = x^3+4x */
? E.disc \\ |disc E| = 2^12
%2 = -4096
\\ create Ldata by hand. Guess that root number is 1 and conductor N
? L(N) = lfuncreate([n-&gt;ellan(E,n), 0, [0,1], 1, N, 1]);
? fordiv(E.disc, d, print(d,&quot;: &quot;,lfuncheckfeq(L(d))))
1: 0
2: 0
4: -1
8: -2
16: -3
32: -127
64: -3
128: -2
256: -2
512: -1
1024: -1
2048: 0
4096: 0
? lfunconductor(L(1)) \\ lfunconductor ignores conductor = 1 in Ldata !
%5 = 32
</pre></div>
</div>
<p>The above code assumed that root number was <span class="math">\(1\)</span>;
had we set it to <span class="math">\(-1\)</span>, none of the <code class="docutils literal"><span class="pre">lfuncheckfeq</span></code> values would have been
acceptable:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? L2(N) = lfuncreate([n-&gt;ellan(E,n), 0, [0,1], 1, N, -1]);
? [ lfuncheckfeq(L2(d)) | d&lt;-divisors(E.disc) ]
%7 = [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, -1, -1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfuncost">
<code class="descname">lfuncost</code><span class="sig-paren">(</span><em>L</em>, <em>sdom=None</em>, <em>der=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfuncost" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the cost of running
<code class="docutils literal"><span class="pre">lfuninit(L,sdom,der)</span></code> at current bit precision. Returns <span class="math">\([t,b]\)</span>, to
indicate that <span class="math">\(t\)</span> coefficients <span class="math">\(a_n\)</span> will be computed, as well as <span class="math">\(t\)</span> values of
<code class="docutils literal"><span class="pre">gammamellininv</span></code>, all at bit accuracy <span class="math">\(b\)</span>.
A subsequent call to <code class="docutils literal"><span class="pre">lfun</span></code> at <span class="math">\(s\)</span> evaluates a polynomial of degree <span class="math">\(t\)</span>
at <span class="math">\(\exp(h s)\)</span> for some real parameter <span class="math">\(h\)</span>, at the same bit accuracy <span class="math">\(b\)</span>.
If <span class="math">\(L\)</span> is already an <code class="docutils literal"><span class="pre">Linit</span></code>, then <em>sdom</em> and <em>der</em> are ignored
and are best left omitted; the bit accuracy is also inferred from <span class="math">\(L\)</span>: in
short we get an estimate of the cost of using that particular <code class="docutils literal"><span class="pre">Linit</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \pb 128
? lfuncost(1, [100]) \\ for zeta(1/2+I*t), |t| &lt; 100
%1 = [7, 242] \\ 7 coefficients, 242 bits
? lfuncost(1, [1/2, 100]) \\ for zeta(s) in the critical strip, |Im s| &lt; 100
%2 = [7, 246] \\ now 246 bits
? lfuncost(1, [100], 10) \\ for zeta(1/2+I*t), |t| &lt; 100
%3 = [8, 263] \\ 10th derivative increases the cost by a small amount
? lfuncost(1, [10^5])
%3 = [158, 113438] \\ larger imaginary part: huge accuracy increase

? L = lfuncreate(polcyclo(5)); \\ Dedekind zeta for Q(zeta_5)
? lfuncost(L, [100]) \\ at s = 1/2+I*t), |t| &lt; 100
%5 = [11457, 582]
? lfuncost(L, [200]) \\ twice higher
%6 = [36294, 1035]
? lfuncost(L, [10^4]) \\ much higher: very costly !
%7 = [70256473, 45452]
? \pb 256
? lfuncost(L, [100]); \\ doubling bit accuracy
%8 = [17080, 710]
</pre></div>
</div>
<p>In fact, some <span class="math">\(L\)</span> functions can be factorized algebraically
by the <code class="docutils literal"><span class="pre">lfuninit</span></code> call, e.g. the Dedekind zeta function of abelian
fields, leading to much faster evaluations than the above upper bounds.
In that case, the function returns a vector of costs as above for each
individual function in the product actually evaluated:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? L = lfuncreate(polcyclo(5)); \\ Dedekind zeta for Q(zeta_5)
? lfuncost(L, [100]) \\ a priori cost
%2 = [11457, 582]
? L = lfuninit(L, [100]); \\ actually perform all initializations
? lfuncost(L)
%4 = [[16, 242], [16, 242], [7, 242]]
</pre></div>
</div>
<p>The Dedekind function of this abelian quartic fields
is the product of four Dirichlet <span class="math">\(L\)</span>-functions attached to the trivial
character, a non-trivial real character and two complex conjugate
characters. The non-trivial characters happen to have the same conductor
(hence same evaluation costs), and correspond to two evaluations only
since the two conjugate characters are evaluated simultaneously.
For a total of three <span class="math">\(L\)</span>-functions evaluations, which explains the three
components above. Note that the actual cost is much lower than the a priori
cost in this case.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfuncreate">
<code class="descname">lfuncreate</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfuncreate" title="Permalink to this definition">¶</a></dt>
<dd><p>This low-level routine creates <code class="docutils literal"><span class="pre">Ldata</span></code> structures, needed by
<em>lfun</em> functions, describing an <span class="math">\(L\)</span>-function and its functional equation.
You are urged to use a high-level constructor when one is available,
and this function accepts them, see <code class="docutils literal"><span class="pre">??lfun</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? L = lfuncreate(1); \\ Riemann zeta
? L = lfuncreate(5); \\ Dirichlet L-function for quadratic character (5/.)
? L = lfuncreate(x^2+1); \\ Dedekind zeta for Q(i)
? L = lfuncreate(ellinit([0,1])); \\ L-function of E/Q: y^2=x^3+1
</pre></div>
</div>
<p>One can then use, e.g., <code class="docutils literal"><span class="pre">Lfun(L,s)</span></code> to directly
evaluate the respective <span class="math">\(L\)</span>-functions at <span class="math">\(s\)</span>, or <code class="docutils literal"><span class="pre">lfuninit(L,</span> <span class="pre">[c,w,h]</span></code>
to initialize computations in the rectangular box <span class="math">\(\Re(s-c) &lt;= w\)</span>,
<span class="math">\(\Im(s) &lt;= h\)</span>.</p>
<p>We now describe the low-level interface, used to input non-builtin
<span class="math">\(L\)</span>-functions. The input is now a <span class="math">\(6\)</span> or <span class="math">\(7\)</span> component vector
<span class="math">\(V = [dir,real,Vga,k,N,eps,r]\)</span>, whose components are as follows:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">V[1]</span> <span class="pre">=</span> <span class="pre">dir</span></code> encodes the Dirichlet series coefficients. The
preferred format is a closure of arity 1: <code class="docutils literal"><span class="pre">n-</span> <span class="pre">&gt;</span> <span class="pre">vector(n,i,a(i))</span></code> giving
the vector of the first <span class="math">\(n\)</span> coefficients. The closure is allowed to return
a vector of more than <span class="math">\(n\)</span> coefficients (only the first <span class="math">\(n\)</span> will be
considered) or even less than <span class="math">\(n\)</span>, in which case loss of accuracy will occur
and a warning that <code class="docutils literal"><span class="pre">#an</span></code> is less than expected is issued. This
allows to precompute and store a fixed large number of Dirichlet
coefficients in a vector <span class="math">\(v\)</span> and use the closure <code class="docutils literal"><span class="pre">n-</span> <span class="pre">&gt;</span> <span class="pre">v</span></code>, which
does not depend on <span class="math">\(n\)</span>. As a shorthand for this latter case, you can input
the vector <span class="math">\(v\)</span> itself instead of the closure.</li>
</ul>
<p>A second format is a closure of arity 2 <code class="docutils literal"><span class="pre">(p,d)-</span> <span class="pre">&gt;</span> <span class="pre">L(p)</span></code> giving the local
factor <span class="math">\(L_p\)</span> at <span class="math">\(p\)</span> as a rational function, to be evaluated at <span class="math">\(p^{-s}\)</span> as
in <code class="docutils literal"><span class="pre">direuler</span></code>; <span class="math">\(d\)</span> is set to the floor of <span class="math">\(\log_p(n)\)</span>, where <span class="math">\(n\)</span> is
the total number of Dirichlet coefficients <span class="math">\((a_1,...,a_n)\)</span> that will be
computed in this way. This parameter <span class="math">\(d\)</span> allows to compute only part of <span class="math">\(L_p\)</span>
when <span class="math">\(p\)</span> is large and <span class="math">\(L_p\)</span> expensive to compute, but it can of course be
ignored by the closure.</p>
<p>Finally one can describe separately the generic Dirichlet coefficients
and the bad local factors by setting <span class="math">\(dir = [an, [p_1,L^{-1}_{p_1}],
...,[p_k,L^{-1}_{p_k}]]\)</span>, where <code class="docutils literal"><span class="pre">an</span></code> describes the generic coefficients
in one of the two formats above, except that coefficients <span class="math">\(a_n\)</span> with
<span class="math">\(p_i \| n\)</span> for some <span class="math">\(i &lt;= k\)</span> will be ignored. The subsequent pairs <span class="math">\([p,
L_p^{-1}]\)</span> give the bad primes and corresponding <em>inverse</em> local
factors.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">V[2]</span> <span class="pre">=</span> <span class="pre">real</span></code> is set to <span class="math">\(0\)</span> if the function is self-dual (this makes
things faster), to <span class="math">\(1\)</span> if the dual of the <span class="math">\(L\)</span>-function is its conjugate, and
to the Dirichlet series coefficients of the dual function encoded as above
otherwise. Note that the only difference between <span class="math">\(0\)</span> and <span class="math">\(1\)</span> is efficiency.</li>
<li><code class="docutils literal"><span class="pre">V[3]</span> <span class="pre">=</span> <span class="pre">Vga</span></code> is the vector of <span class="math">\(\alpha_j\)</span> such that the gamma
factor of the <span class="math">\(L\)</span>-function is equal to</li>
</ul>
<div class="math">
\[ \begin{align}\begin{aligned}  \gamma_A(s) = \prod_{1 &lt;= j &lt;= d}\Gamma_{\mathbb{R}}(s+\alpha_j),\\where :math:`\Gamma_{\mathbb{R}}(s) = \Pi^{-s/2}\Gamma(s/2)`.
This same syntax is used in the :literal:`gammamellininv` functions.
In particular the length :math:`d` of :literal:`Vga` is the degree of the :math:`L`-function.
In the present implementation, the :math:`\alpha_j` are assumed to be exact
rational numbers. However when calling theta functions with :emphasis:`complex`
(as opposed to real) arguments, determination problems occur which may
give wrong results when the :math:`\alpha_j` are not integral.\end{aligned}\end{align} \]</div>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">V[4]</span> <span class="pre">=</span> <span class="pre">k</span></code> is a positive integer <span class="math">\(k\)</span>. The functional equation relates
values at <span class="math">\(s\)</span> and <span class="math">\(k-s\)</span>. For instance, for an Artin <span class="math">\(L\)</span>-series such as a
Dedekind zeta function we have <span class="math">\(k = 1\)</span>, for an elliptic curve <span class="math">\(k = 2\)</span>, and
for a modular form, <span class="math">\(k\)</span> is its weight. For motivic <span class="math">\(L\)</span>-functions, the
<em>motivic</em> weight <span class="math">\(w\)</span> is <span class="math">\(w = k-1\)</span>.</li>
<li><code class="docutils literal"><span class="pre">V[5]</span> <span class="pre">=</span> <span class="pre">N</span></code> is the conductor, an integer <span class="math">\(N &gt;= 1\)</span>, such that
<span class="math">\(\Lambda(s) = N^{s/2}\gamma_A(s)L(s)\)</span> with <span class="math">\(\gamma_A(s)\)</span> as above.</li>
<li><code class="docutils literal"><span class="pre">V[6]</span> <span class="pre">=</span> <span class="pre">eps</span></code> is the root number <span class="math">\(\varepsilon\)</span>, i.e., the
complex number of modulus <span class="math">\(1\)</span> such that
<span class="math">\(\Lambda(k-s) = \varepsilon\overline{\Lambda(\overline{s})}\)</span>.</li>
<li>The last optional component <code class="docutils literal"><span class="pre">V[7]</span> <span class="pre">=</span> <span class="pre">r</span></code> encodes the poles of
the <span class="math">\(L\)</span>-function (<em>not</em> of the <span class="math">\(\Lambda\)</span>-function), and should be
omitted if there are no poles.</li>
</ul>
<p>The coding is as follows: either <span class="math">\(r\)</span> is a complex scalar, in which case
it is understood that it represents the residue of <span class="math">\(L(s)\)</span> at <span class="math">\(s = k\)</span>
(this is the usual situation, for instance for Dedekind zeta functions).
In this case, <span class="math">\(r\)</span> can be set to <span class="math">\(0\)</span> (but not omitted) if unknown, and it
will be computed.</p>
<p>Or <span class="math">\(r\)</span> is a vector of <span class="math">\(2\)</span>-component vectors <span class="math">\([\beta,P_{\beta}(x)]\)</span>, where
the <span class="math">\(\beta\)</span> are the poles of the <span class="math">\(L\)</span>-function, and <span class="math">\(P_{\beta}(x)\)</span> is its
polar part, so that <span class="math">\(L(s) ~ P_\beta(s-\beta)\)</span> in a neighbourhood of
<span class="math">\(\beta\)</span>. For instance <span class="math">\(r/x+O(1)\)</span> for a simple pole at <span class="math">\(\beta\)</span>
or <span class="math">\(r_1/x^2+r_2/x+O(1)\)</span> for a double pole.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfundiv">
<code class="descname">lfundiv</code><span class="sig-paren">(</span><em>L1</em>, <em>L2</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfundiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the <code class="docutils literal"><span class="pre">Ldata</span></code> structure (without initialization) corresponding
to the quotient of the Dirichlet series <span class="math">\(L_1\)</span> and <span class="math">\(L_2\)</span> given by
<code class="docutils literal"><span class="pre">L1</span></code> and <code class="docutils literal"><span class="pre">L2</span></code>. Assume that <span class="math">\(v_z(L_1) &gt;= v_z(L_2)\)</span> at all
complex numbers <span class="math">\(z\)</span>: the construction may not create new poles, nor increase
the order of existing ones.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunetaquo">
<code class="descname">lfunetaquo</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunetaquo" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <code class="docutils literal"><span class="pre">Ldata</span></code> structure associated to the <span class="math">\(L\)</span> function
associated to the modular form
<span class="math">\(z:---&gt;\prod_{i = 1}^n \eta(M_{i,1} z)^{M_{i,2}}\)</span>
It is currently assumed that <span class="math">\(f\)</span> is a self-dual cuspidal form on
<span class="math">\(\Gamma_0(N)\)</span> for some <span class="math">\(N\)</span>.
For instance, the <span class="math">\(L\)</span>-function <span class="math">\(\sum \tau(n) n^{-s}\)</span>
associated to Ramanujan&#8217;s <span class="math">\(\Delta\)</span> function is encoded as follows</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? L = lfunetaquo(Mat([1,24]));
? lfunan(L, 100) \\ first 100 values of tau(n)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfungenus2">
<code class="descname">lfungenus2</code><span class="sig-paren">(</span><em>F</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfungenus2" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <code class="docutils literal"><span class="pre">Ldata</span></code> structure associated to the <span class="math">\(L\)</span> function
associated to the genus-2 curve defined by <span class="math">\(y^2 = F(x)\)</span> or
<span class="math">\(y^2+Q(x) y = P(x)\)</span> if <span class="math">\(F = [P,Q]\)</span>.
Currently, the model needs to be minimal at 2, and if the conductor
is even, its valuation at <span class="math">\(2\)</span> might be incorrect (a warning is issued).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunhardy">
<code class="descname">lfunhardy</code><span class="sig-paren">(</span><em>L</em>, <em>t</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunhardy" title="Permalink to this definition">¶</a></dt>
<dd><p>Variant of the Hardy <span class="math">\(Z\)</span>-function given by <code class="docutils literal"><span class="pre">L</span></code>, used for
plotting or locating zeros of <span class="math">\(L(k/2+it)\)</span> on the critical line.
The precise definition is as
follows: if as usual <span class="math">\(k/2\)</span> is the center of the critical strip, <span class="math">\(d\)</span> is the
degree, <span class="math">\(\alpha_j\)</span> the entries of <code class="docutils literal"><span class="pre">Vga</span></code> giving the gamma factors,
and <span class="math">\(\varepsilon\)</span> the root number, then if we set
<span class="math">\(s = k/2+it = \rho e^{i\theta}\)</span> and
<span class="math">\(E = (d(k/2-1)+\sum_{1 &lt;= j &lt;= d}\alpha_j)/2\)</span>, the computed function at <span class="math">\(t\)</span> is
equal to</p>
<div class="math">
\[Z(t) = \varepsilon^{-1/2}\Lambda(s).\|s\|^{-E}e^{dt\theta/2} ,\]</div>
<p>which is a real function of <span class="math">\(t\)</span> for self-dual <span class="math">\(\Lambda\)</span>,
vanishing exactly when <span class="math">\(L(k/2+it)\)</span> does on the critical line. The
normalizing factor <span class="math">\(\|s\|^{-E}e^{dt\theta/2}\)</span> compensates the
exponential decrease of <span class="math">\(\gamma_A(s)\)</span> as <span class="math">\(t\to oo\)</span> so that
<span class="math">\(Z(t) ~ 1\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? T = 100; \\ maximal height
? L = lfuninit(1, [T]); \\ initialize for zeta(1/2+it), |t|&lt;T
? \p19 \\ no need for large accuracy
? ploth(t = 0, T, lfunhardy(L,t))
</pre></div>
</div>
<p>Using <code class="docutils literal"><span class="pre">lfuninit</span></code> is critical for this particular
applications since thousands of values are computed. Make sure to initialize
up to the maximal <span class="math">\(t\)</span> needed: otherwise expect to see many warnings for
unsufficient initialization and suffer major slowdowns.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfuninit">
<code class="descname">lfuninit</code><span class="sig-paren">(</span><em>L</em>, <em>sdom</em>, <em>der=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfuninit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initalization function for all functions linked to the
computation of the <span class="math">\(L\)</span>-function <span class="math">\(L(s)\)</span> encoded by <code class="docutils literal"><span class="pre">L</span></code>, where
<span class="math">\(s\)</span> belongs to the rectangular domain <span class="math">\(sdom = [center,w,h]\)</span>
centered on the real axis, <span class="math">\(\|\Re(s)-center\| &lt;= w\)</span>, <span class="math">\(\|\Im(s)\| &lt;= h\)</span>,
where all three components of <code class="docutils literal"><span class="pre">sdom</span></code> are real and <span class="math">\(w\)</span>, <span class="math">\(h\)</span> are
non-negative. <code class="docutils literal"><span class="pre">der</span></code> is the maximum order of derivation that will be used.
The subdomain <span class="math">\([k/2, 0, h]\)</span> on the critical line (up to height <span class="math">\(h\)</span>)
can be encoded as <span class="math">\([h]\)</span> for brevity. The subdomain <span class="math">\([k/2, w, h]\)</span>
centered on the critical line can be encoded as <span class="math">\([w, h]\)</span> for brevity.</p>
<p>The argument <code class="docutils literal"><span class="pre">L</span></code> is an <code class="docutils literal"><span class="pre">Lmath</span></code>, an <code class="docutils literal"><span class="pre">Ldata</span></code> or an <code class="docutils literal"><span class="pre">Linit</span></code>. See
<code class="docutils literal"><span class="pre">??Ldata</span></code> and <code class="docutils literal"><span class="pre">??lfuncreate</span></code> for how to create it.</p>
<p>The height <span class="math">\(h\)</span> of the domain is a <em>crucial</em> parameter: if you only
need <span class="math">\(L(s)\)</span> for real <span class="math">\(s\)</span>, set <span class="math">\(h\)</span> to&nbsp;0.
The running time is roughly proportional to</p>
<div class="math">
\[(B / d+\Pi h/4)^{d/2+3}N^{1/2},\]</div>
<p>where <span class="math">\(B\)</span> is the default bit accuracy, <span class="math">\(d\)</span> is the degree of the
<span class="math">\(L\)</span>-function, and <span class="math">\(N\)</span> is the conductor (the exponent <span class="math">\(d/2+3\)</span> is reduced
to <span class="math">\(d/2+2\)</span> when <span class="math">\(d = 1\)</span> and <span class="math">\(d = 2\)</span>). There is also a dependency on <span class="math">\(w\)</span>,
which is less crucial, but make sure to use the smallest rectangular
domain that you need.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? L0 = lfuncreate(1); \\ Riemann zeta
? L = lfuninit(L0, [1/2, 0, 100]); \\ for zeta(1/2+it), |t| &lt; 100
? lfun(L, 1/2 + I)
? L = lfuninit(L0, [100]); \\ same as above !
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunlambda">
<code class="descname">lfunlambda</code><span class="sig-paren">(</span><em>L</em>, <em>s</em>, <em>D=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunlambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the completed <span class="math">\(L\)</span>-function <span class="math">\(\Lambda(s) = N^{s/2}\gamma(s)L(s)\)</span>,
or if <code class="docutils literal"><span class="pre">D</span></code> is set, the derivative of order <code class="docutils literal"><span class="pre">D</span></code> at <span class="math">\(s\)</span>.
The parameter <code class="docutils literal"><span class="pre">L</span></code> is either an <code class="docutils literal"><span class="pre">Lmath</span></code>, an <code class="docutils literal"><span class="pre">Ldata</span></code> (created by
<code class="docutils literal"><span class="pre">lfuncreate</span></code>, or an <code class="docutils literal"><span class="pre">Linit</span></code> (created by <code class="docutils literal"><span class="pre">lfuninit</span></code>), preferrably the
latter if many values are to be computed.</p>
<p>The result is given with absolute error less than <span class="math">\(2^{-B}\|\gamma(s)N^{s/2}\|\)</span>,
where <span class="math">\(B = {realbitprecision}\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunmfpeters">
<code class="descname">lfunmfpeters</code><span class="sig-paren">(</span><em>L</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunmfpeters" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">L</span></code> corresponding to a normalized eigenform but <strong>not</strong>
to the output of <code class="docutils literal"><span class="pre">lfunsymsq</span></code>, returns the Petersson square of the
form, computed using the symmetric square.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? e = ellinit([-2,1]);
? L = lfuncreate(e);
? lfunmfpeters(L) * (2*Pi)^2 / e.area
%2 = 0.99999999999999999999999999999999999999
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunmfspec">
<code class="descname">lfunmfspec</code><span class="sig-paren">(</span><em>L</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunmfspec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">[valeven,valodd,omminus,omplus]</span></code>,
where <code class="docutils literal"><span class="pre">valeven</span></code> (resp., <code class="docutils literal"><span class="pre">valodd</span></code>) is the vector of even (resp., odd)
periods of the modular form given by <code class="docutils literal"><span class="pre">L</span></code>, and <code class="docutils literal"><span class="pre">omminus</span></code> and
<code class="docutils literal"><span class="pre">omplus</span></code> the corresponding real numbers <span class="math">\(\omega^-\)</span> and <span class="math">\(\omega^+\)</span>
normalized in a noncanonical way. For the moment, only for modular forms of even weight.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunmul">
<code class="descname">lfunmul</code><span class="sig-paren">(</span><em>L1</em>, <em>L2</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the <code class="docutils literal"><span class="pre">Ldata</span></code> structure (without initialization) corresponding
to the product of the Dirichlet series given by <code class="docutils literal"><span class="pre">L1</span></code> and
<code class="docutils literal"><span class="pre">L2</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunorderzero">
<code class="descname">lfunorderzero</code><span class="sig-paren">(</span><em>L</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunorderzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the order of the possible zero of the <span class="math">\(L\)</span>-function at the
center <span class="math">\(k/2\)</span> of the critical strip; return <span class="math">\(0\)</span> if <span class="math">\(L(k/2)\)</span> does not vanish.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunqf">
<code class="descname">lfunqf</code><span class="sig-paren">(</span><em>Q</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunqf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <code class="docutils literal"><span class="pre">Ldata</span></code> structure associated to the <span class="math">\(\Theta\)</span> function
of the lattice associated to the definite positive quadratic form <span class="math">\(Q\)</span>.
This function assumes that the associated <span class="math">\(L\)</span>-function is self-dual,
but not necessarily the lattice itself. In particular, if <span class="math">\(Q\)</span> is
two-dimensional, then <span class="math">\(L\)</span> is always self-dual.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunrootres">
<code class="descname">lfunrootres</code><span class="sig-paren">(</span><em>data</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunrootres" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the <code class="docutils literal"><span class="pre">Ldata</span></code> associated to an <span class="math">\(L\)</span>-function (or the output of
<code class="docutils literal"><span class="pre">lfunthetainit</span></code>), compute the root number and the residues.
The output is a 3-component vector <span class="math">\([r,R,w]\)</span>, where <span class="math">\(r\)</span> is the
residue of <span class="math">\(L(s)\)</span> at the unique pole, <span class="math">\(R\)</span> is the residue of <span class="math">\(\Lambda(s)\)</span>,
and <span class="math">\(w\)</span> is the root number. In the present implementation,</p>
<ul class="simple">
<li>either the polar part must be completely known (and is then arbitrary):
the function determines the root number,</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? L = lfunmul(1,1); \\ zeta^2
? [r,R,w] = lfunrootres(L);
? r \\ single pole at 1, double
%3 = [[1, 1.[...]*x^-2 + 1.1544[...]*x^-1 + O(x^0)]]
? w
%4 = 1
? R \\ double pole at 0 and 1
%5 = [[1,[...]], [0,[...]]
</pre></div>
</div>
<ul class="simple">
<li>or at most a single pole is allowed: the function computes both
the root number and the residue (<span class="math">\(0\)</span> if no pole).</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunsymsq">
<code class="descname">lfunsymsq</code><span class="sig-paren">(</span><em>L</em>, <em>known=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunsymsq" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the <code class="docutils literal"><span class="pre">Ldata</span></code> corresponding to the symmetric square of the modular
form <code class="docutils literal"><span class="pre">L</span></code>, including the search for the conductor and bad Euler
factors. <code class="docutils literal"><span class="pre">known</span></code>, if present, is the vector
<code class="docutils literal"><span class="pre">[conductor,[list</span> <span class="pre">of</span> <span class="pre">Euler</span> <span class="pre">factors]]</span></code>, where each Euler factor is of the form
<span class="math">\([p, a_p]\)</span> corresponding to the factor <span class="math">\(1/(1 - a_pp^{-s})\)</span>. The result
can then be used with the usual <code class="docutils literal"><span class="pre">lfunxxx</span></code> functions.
Warning: in the present implementation,
only missing Euler factors of degree at most 1 are supported (this is
sufficient in most cases, and always if <span class="math">\(N\)</span> is squarefree).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunsymsqspec">
<code class="descname">lfunsymsqspec</code><span class="sig-paren">(</span><em>L</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunsymsqspec" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">L</span></code> corresponding either to a normalized eigenform or to the
output of <code class="docutils literal"><span class="pre">lfunsymsq</span></code>, returns <code class="docutils literal"><span class="pre">[val,</span> <span class="pre">om2]</span></code>, where <code class="docutils literal"><span class="pre">val</span></code> is
the vector of special values of the symmetric square of the modular form
on the right of the critical strip, and <code class="docutils literal"><span class="pre">om2</span></code> is a period, not
canonically normalized (so that if for instance the form has rational
coefficients, <code class="docutils literal"><span class="pre">om2</span></code> is a rational multiple both of the Petersson square
of the form and of the product <span class="math">\(\omega^+\omega^-\)</span> of the special values
output by <code class="docutils literal"><span class="pre">lfunmfspec</span></code>).
For the moment, only for modular forms of even weight.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfuntheta">
<code class="descname">lfuntheta</code><span class="sig-paren">(</span><em>data</em>, <em>t</em>, <em>m=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfuntheta" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value of the <span class="math">\(m\)</span>-th derivative
at <span class="math">\(t\)</span> of the theta function associated to the <span class="math">\(L\)</span>-function given by <code class="docutils literal"><span class="pre">data</span></code>.
<code class="docutils literal"><span class="pre">data</span></code> can be either the standard <span class="math">\(L\)</span>-function data, or the output of
<code class="docutils literal"><span class="pre">lfunthetainit</span></code>.
The theta function is defined by the formula
<span class="math">\(\Theta(t) = \sum_{n &gt;= 1}a(n)K(nt/\sqrt(N))\)</span>, where <span class="math">\(a(n)\)</span> are the coefficients
of the Dirichlet series, <span class="math">\(N\)</span> is the conductor, and <span class="math">\(K\)</span> is the inverse Mellin
transform of the gamma product defined by the <code class="docutils literal"><span class="pre">Vga</span></code> component.
Its Mellin transform is equal to <span class="math">\(\Lambda(s)-P(s)\)</span>, where <span class="math">\(\Lambda(s)\)</span>
is the completed <span class="math">\(L\)</span>-function and the rational function <span class="math">\(P(s)\)</span> its polar part.
In particular, if the <span class="math">\(L\)</span>-function is the <span class="math">\(L\)</span>-function of a modular form
<span class="math">\(f(\tau) = \sum_{n &gt;= 0}a(n)q^n\)</span> with <span class="math">\(q = \exp(2\Pi i\tau)\)</span>, we have
<span class="math">\(\Theta(t) = 2(f(it/\sqrt{N})-a(0))\)</span>. Note that an easy theorem on modular
forms implies that <span class="math">\(a(0)\)</span> can be recovered by the formula <span class="math">\(a(0) = -L(f,0)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunthetacost">
<code class="descname">lfunthetacost</code><span class="sig-paren">(</span><em>L</em>, <em>tdom=None</em>, <em>m=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunthetacost" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the cost of running
<code class="docutils literal"><span class="pre">lfunthetainit(L,tdom,m)</span></code> at current bit precision. Returns the number of
coefficients <span class="math">\(a_n\)</span> that would be computed. This also estimates the
cost of a subsequent evaluation <code class="docutils literal"><span class="pre">lfuntheta</span></code>, which must compute
that many values of <code class="docutils literal"><span class="pre">gammamellininv</span></code> at the current bit precision.
If <span class="math">\(L\)</span> is already an <code class="docutils literal"><span class="pre">Linit</span></code>, then <em>tdom</em> and <span class="math">\(m\)</span> are ignored
and are best left omitted: we get an estimate of the cost of using that
particular <code class="docutils literal"><span class="pre">Linit</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \pb 1000
? L = lfuncreate(1); \\ Riemann zeta
? lfunthetacost(L); \\ cost for theta(t), t real &gt;= 1
%1 = 15
? lfunthetacost(L, 1 + I); \\ cost for theta(1+I). Domain error !
 *** at top-level: lfunthetacost(1,1+I)
 *** ^--------------------
 *** lfunthetacost: domain error in lfunthetaneed: arg t &gt; 0.785
? lfunthetacost(L, 1 + I/2) \\ for theta(1+I/2).
%2 = 23
? lfunthetacost(L, 1 + I/2, 10) \\ for theta^((10))(1+I/2).
%3 = 24
? lfunthetacost(L, [2, 1/10]) \\ cost for theta(t), |t| &gt;= 2, |arg(t)| &lt; 1/10
%4 = 8

? L = lfuncreate( ellinit([1,1]) );
? lfunthetacost(L) \\ for t &gt;= 1
%6 = 2471
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunthetainit">
<code class="descname">lfunthetainit</code><span class="sig-paren">(</span><em>L</em>, <em>tdom=None</em>, <em>m=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunthetainit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initalization function for evaluating the <span class="math">\(m\)</span>-th derivative of theta
functions with argument <span class="math">\(t\)</span> in domain <em>tdom</em>. By default (<em>tdom</em>
omitted), <span class="math">\(t\)</span> is real, <span class="math">\(t &gt;= 1\)</span>. Otherwise, <em>tdom</em> may be</p>
<ul class="simple">
<li>a positive real scalar <span class="math">\(\rho\)</span>: <span class="math">\(t\)</span> is real, <span class="math">\(t &gt;= \rho\)</span>.</li>
<li>a non-real complex number: compute at this particular <span class="math">\(t\)</span>; this
allows to compute <span class="math">\(\theta(z)\)</span> for any complex <span class="math">\(z\)</span> satisfying <span class="math">\(|z| &gt;= |t|\)</span>
and <span class="math">\(|\arg z| &lt;= |\arg t|\)</span>; we must have <span class="math">\(|2 \arg z / d| &lt; \Pi/2\)</span>, where
<span class="math">\(d\)</span> is the degree of the <span class="math">\(\Gamma\)</span> factor.</li>
<li>a pair <span class="math">\([\rho,\alpha]\)</span>: assume that <span class="math">\(\|t\| &gt;= \rho\)</span> and <span class="math">\(\|\arg t\| \leq
\alpha\)</span>; we must have <span class="math">\(|2\alpha / d| &lt; \Pi/2\)</span>, where <span class="math">\(d\)</span> is the degree of
the <span class="math">\(\Gamma\)</span> factor.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \p500
? L = lfuncreate(1); \\ Riemann zeta
? t = 1+I/2;
? lfuntheta(L, t); \\ direct computation
time = 30 ms.
? T = lfunthetainit(L, 1+I/2);
time = 30 ms.
? lfuntheta(T, t); \\ instantaneous
</pre></div>
</div>
<p>The <span class="math">\(T\)</span> structure would allow to quickly compute <span class="math">\(\theta(z)\)</span>
for any <span class="math">\(z\)</span> in the cone delimited by <span class="math">\(t\)</span> as explained above. On the other hand</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? lfuntheta(T,I)
 *** at top-level: lfuntheta(T,I)
 *** ^--------------
 *** lfuntheta: domain error in lfunthetaneed: arg t &gt; 0.785398163397448
</pre></div>
</div>
<p>The initialization is equivalent to</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? lfunthetainit(L, [abs(t), arg(t)])
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lfunzeros">
<code class="descname">lfunzeros</code><span class="sig-paren">(</span><em>L</em>, <em>lim</em>, <em>divz=8</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lfunzeros" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">lim</span></code> being either an upper limit or a real interval, computes an
ordered list of zeros of <span class="math">\(L(s)\)</span> on the critical line up to the given
upper limit or in the given interval. Use a naive algorithm which may miss
some zeros: it assumes that two consecutive zeros at height <span class="math">\(T &gt;= 1\)</span>
differ at least by <span class="math">\(2\Pi/\omega\)</span>, where</p>
<div class="math">
\[\omega := divz.(d\log(T/2\Pi) +d+ 2\log(N/(\Pi/2)^d)).\]</div>
<p>To use a finer search mesh, set divz to some integral value
larger than the default ( = 8).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? lfunzeros(1, 30) \\ zeros of Rieman zeta up to height 30
%1 = [14.134[...], 21.022[...], 25.010[...]]
? #lfunzeros(1, [100,110]) \\ count zeros with 100 &lt;= Im(s) &lt;= 110
%2 = 4
</pre></div>
</div>
<p>The algorithm also assumes that all zeros are simple except
possibly on the real axis at <span class="math">\(s = k/2\)</span> and that there are no poles in the
search interval.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lift">
<code class="descname">lift</code><span class="sig-paren">(</span><em>x</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lift" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(v\)</span> is omitted, lifts intmods from <span class="math">\(\mathbb{Z}/n\mathbb{Z}\)</span> in <span class="math">\(\mathbb{Z}\)</span>,
<span class="math">\(p\)</span>-adics from <span class="math">\(\mathbb{Q}_p\)</span> to <span class="math">\(\mathbb{Q}\)</span> (as <code class="docutils literal"><span class="pre">truncate</span></code>), and polmods to
polynomials. Otherwise, lifts only polmods whose modulus has main
variable&nbsp;<span class="math">\(v\)</span>. <code class="docutils literal"><span class="pre">t_FFELT</span></code> are not lifted, nor are List elements: you may
convert the latter to vectors first, or use <code class="docutils literal"><span class="pre">apply(lift,L)</span></code>. More
generally, components for which such lifts are meaningless (e.g. character
strings) are copied verbatim.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? lift(Mod(5,3))
%1 = 2
? lift(3 + O(3^9))
%2 = 3
? lift(Mod(x,x^2+1))
%3 = x
? lift(Mod(x,x^2+1))
%4 = x
</pre></div>
</div>
<p>Lifts are performed recursively on an object components, but only
by <em>one level</em>: once a <code class="docutils literal"><span class="pre">t_POLMOD</span></code> is lifted, the components of
the result are <em>not</em> lifted further.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? lift(x * Mod(1,3) + Mod(2,3))
%4 = x + 2
? lift(x * Mod(y,y^2+1) + Mod(2,3))
%5 = y*x + Mod(2, 3) \\ do you understand this one?
? lift(x * Mod(y,y^2+1) + Mod(2,3), &#39;x)
%6 = Mod(y, y^2 + 1)*x + Mod(Mod(2, 3), y^2 + 1)
? lift(%, y)
%7 = y*x + Mod(2, 3)
</pre></div>
</div>
<p>To recursively lift all components not only by one level,
but as long as possible, use <code class="docutils literal"><span class="pre">liftall</span></code>. To lift only <code class="docutils literal"><span class="pre">t_INTMOD</span></code>&nbsp;s and
<code class="docutils literal"><span class="pre">t_PADIC</span></code>&nbsp;s components, use <code class="docutils literal"><span class="pre">liftint</span></code>. To lift only <code class="docutils literal"><span class="pre">t_POLMOD</span></code>&nbsp;s
components, use <code class="docutils literal"><span class="pre">liftpol</span></code>. Finally, <code class="docutils literal"><span class="pre">centerlift</span></code> allows to lift
<code class="docutils literal"><span class="pre">t_INTMOD</span></code>&nbsp;s and <code class="docutils literal"><span class="pre">t_PADIC</span></code>&nbsp;s using centered residues (lift of smallest
absolute value).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.liftall">
<code class="descname">liftall</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.liftall" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively lift all components of <span class="math">\(x\)</span> from <span class="math">\(\mathbb{Z}/n\mathbb{Z}\)</span> to <span class="math">\(\mathbb{Z}\)</span>,
from <span class="math">\(\mathbb{Q}_p\)</span> to <span class="math">\(\mathbb{Q}\)</span> (as <code class="docutils literal"><span class="pre">truncate</span></code>), and polmods to
polynomials. <code class="docutils literal"><span class="pre">t_FFELT</span></code> are not lifted, nor are List elements: you may
convert the latter to vectors first, or use <code class="docutils literal"><span class="pre">apply(liftall,L)</span></code>. More
generally, components for which such lifts are meaningless (e.g. character
strings) are copied verbatim.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? liftall(x * (1 + O(3)) + Mod(2,3))
%1 = x + 2
? liftall(x * Mod(y,y^2+1) + Mod(2,3)*Mod(z,z^2))
%2 = y*x + 2*z
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.liftint">
<code class="descname">liftint</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.liftint" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively lift all components of <span class="math">\(x\)</span> from <span class="math">\(\mathbb{Z}/n\mathbb{Z}\)</span> to <span class="math">\(\mathbb{Z}\)</span> and
from <span class="math">\(\mathbb{Q}_p\)</span> to <span class="math">\(\mathbb{Q}\)</span> (as <code class="docutils literal"><span class="pre">truncate</span></code>).
<code class="docutils literal"><span class="pre">t_FFELT</span></code> are not lifted, nor are List elements: you may
convert the latter to vectors first, or use <code class="docutils literal"><span class="pre">apply(liftint,L)</span></code>. More
generally, components for which such lifts are meaningless (e.g. character
strings) are copied verbatim.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? liftint(x * (1 + O(3)) + Mod(2,3))
%1 = x + 2
? liftint(x * Mod(y,y^2+1) + Mod(2,3)*Mod(z,z^2))
%2 = Mod(y, y^2 + 1)*x + Mod(Mod(2*z, z^2), y^2 + 1)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.liftpol">
<code class="descname">liftpol</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.liftpol" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively lift all components of <span class="math">\(x\)</span> which are polmods to
polynomials. <code class="docutils literal"><span class="pre">t_FFELT</span></code> are not lifted, nor are List elements: you may
convert the latter to vectors first, or use <code class="docutils literal"><span class="pre">apply(liftpol,L)</span></code>. More
generally, components for which such lifts are meaningless (e.g. character
strings) are copied verbatim.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? liftpol(x * (1 + O(3)) + Mod(2,3))
%1 = (1 + O(3))*x + Mod(2, 3)
? liftpol(x * Mod(y,y^2+1) + Mod(2,3)*Mod(z,z^2))
%2 = y*x + Mod(2, 3)*z
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lindep">
<code class="descname">lindep</code><span class="sig-paren">(</span><em>v</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lindep" title="Permalink to this definition">¶</a></dt>
<dd><p>finds a small non-trivial integral linear
combination between components of <span class="math">\(v\)</span>. If none can be found return an empty
vector.</p>
<p>If <span class="math">\(v\)</span> is a vector with real/complex entries we use a floating point
(variable precision) LLL algorithm. If <span class="math">\(flag = 0\)</span> the accuracy is chosen
internally using a crude heuristic. If <span class="math">\(flag &gt; 0\)</span> the computation is done with
an accuracy of <span class="math">\(flag\)</span> decimal digits. To get meaningful results in the latter
case, the parameter <span class="math">\(flag\)</span> should be smaller than the number of correct
decimal digits in the input.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? lindep([sqrt(2), sqrt(3), sqrt(2)+sqrt(3)])
%1 = [-1, -1, 1]~
</pre></div>
</div>
<p>If <span class="math">\(v\)</span> is <span class="math">\(p\)</span>-adic, <span class="math">\(flag\)</span> is ignored and the algorithm LLL-reduces a
suitable (dual) lattice.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? lindep([1, 2 + 3 + 3^2 + 3^3 + 3^4 + O(3^5)])
%2 = [1, -2]~
</pre></div>
</div>
<p>If <span class="math">\(v\)</span> is a matrix, <span class="math">\(flag\)</span> is ignored and the function returns a non trivial
kernel vector (combination of the columns).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? lindep([1,2,3;4,5,6;7,8,9])
%3 = [1, -2, 1]~
</pre></div>
</div>
<p>If <span class="math">\(v\)</span> contains polynomials or power series over some base field, finds a
linear relation with coefficients in the field.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? lindep([x*y, x^2 + y, x^2*y + x*y^2, 1])
%4 = [y, y, -1, -y^2]~
</pre></div>
</div>
<p>For better control, it is preferable to use <code class="docutils literal"><span class="pre">t_POL</span></code> rather
than <code class="docutils literal"><span class="pre">t_SER</span></code> in the input, otherwise one gets a linear combination which is
<span class="math">\(t\)</span>-adically small, but not necessarily <span class="math">\(0\)</span>. Indeed, power series are first
converted to the minimal absolute accuracy occurring among the entries of <span class="math">\(v\)</span>
(which can cause some coefficients to be ignored), then truncated to
polynomials:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? v = [t^2+O(t^4), 1+O(t^2)]; L=lindep(v)
%1 = [1, 0]~
? v*L
%2 = t^2+O(t^4) \\ small but not 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.listinsert">
<code class="descname">listinsert</code><span class="sig-paren">(</span><em>L</em>, <em>x</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.listinsert" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts the object <span class="math">\(x\)</span> at
position <span class="math">\(n\)</span> in <span class="math">\(L\)</span> (which must be of type <code class="docutils literal"><span class="pre">t_LIST</span></code>). This has
complexity <span class="math">\(O(\#L - n + 1)\)</span>: all the
remaining elements of <em>list</em> (from position <span class="math">\(n+1\)</span> onwards) are shifted
to the right.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.listpop">
<code class="descname">listpop</code><span class="sig-paren">(</span><em>list</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.listpop" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the <span class="math">\(n\)</span>-th element of the list
<em>list</em> (which must be of type <code class="docutils literal"><span class="pre">t_LIST</span></code>). If <span class="math">\(n\)</span> is omitted,
or greater than the list current length, removes the last element.
If the list is already empty, do nothing. This runs in time <span class="math">\(O(\#L - n + 1)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.listput">
<code class="descname">listput</code><span class="sig-paren">(</span><em>list</em>, <em>x</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.listput" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <span class="math">\(n\)</span>-th element of the list
<em>list</em> (which must be of type <code class="docutils literal"><span class="pre">t_LIST</span></code>) equal to <span class="math">\(x\)</span>. If <span class="math">\(n\)</span> is omitted,
or greater than the list length, appends <span class="math">\(x\)</span>. The function returns the
inserted element.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? L = List();
? listput(L, 1)
%2 = 1
? listput(L, 2)
%3 = 2
? L
%4 = List([1, 2])
</pre></div>
</div>
<p>You may put an element into an occupied cell (not changing the
list length), but it is easier to use the standard <code class="docutils literal"><span class="pre">list[n]</span> <span class="pre">=</span> <span class="pre">x</span></code>
construct.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? listput(L, 3, 1) \\ insert at position 1
%5 = 3
? L
%6 = List([3, 2])
? L[2] = 4 \\ simpler
%7 = List([3, 4])
? L[10] = 1 \\ can&#39;t insert beyond the end of the list
 *** at top-level: L[10]=1
 *** ^------
 *** non-existent component: index &gt; 2
? listput(L, 1, 10) \\ but listput can
%8 = 1
? L
%9 = List([3, 2, 1])
</pre></div>
</div>
<p>This function runs in time <span class="math">\(O(\#L)\)</span> in the worst case (when the list must
be reallocated), but in time <span class="math">\(O(1)\)</span> on average: any number of successive
<code class="docutils literal"><span class="pre">listput</span></code>&nbsp;s run in time <span class="math">\(O(\#L)\)</span>, where <span class="math">\(\#L\)</span> denotes the list
<em>final</em> length.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.listsort">
<code class="descname">listsort</code><span class="sig-paren">(</span><em>L</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.listsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the <code class="docutils literal"><span class="pre">t_LIST</span></code> <em>list</em> in place, with respect to the (somewhat
arbitrary) universal comparison function <code class="docutils literal"><span class="pre">cmp</span></code>. In particular, the
ordering is the same as for sets and <code class="docutils literal"><span class="pre">setsearch</span></code> can be used on a sorted
list.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? L = List([1,2,4,1,3,-1]); listsort(L); L
%1 = List([-1, 1, 1, 2, 3, 4])
? setsearch(L, 4)
%2 = 6
? setsearch(L, -2)
%3 = 0
</pre></div>
</div>
<p>This is faster than the <code class="docutils literal"><span class="pre">vecsort</span></code> command since the list
is sorted in place: no copy is made. No value returned.</p>
<p>If <span class="math">\(flag\)</span> is non-zero, suppresses all repeated coefficients.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.lngamma">
<code class="descname">lngamma</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.lngamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of the logarithm of the gamma function of <span class="math">\(x\)</span>. This
function is analytic on the complex plane with non-positive integers
removed, and can have much larger arguments than <code class="docutils literal"><span class="pre">gamma</span></code> itself.</p>
<p>For <span class="math">\(x\)</span> a power series such that <span class="math">\(x(0)\)</span> is not a pole of <code class="docutils literal"><span class="pre">gamma</span></code>,
compute the Taylor expansion. (PARI only knows about regular power series
and can&#8217;t include logarithmic terms.)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? lngamma(1+x+O(x^2))
%1 = -0.57721566490153286060651209008240243104*x + O(x^2)
? lngamma(x+O(x^2))
 *** at top-level: lngamma(x+O(x^2))
 *** ^-----------------
 *** lngamma: domain error in lngamma: valuation != 0
? lngamma(-1+x+O(x^2))
 *** lngamma: Warning: normalizing a series with 0 leading term.
 *** at top-level: lngamma(-1+x+O(x^2))
 *** ^--------------------
 *** lngamma: domain error in intformal: residue(series, pole) != 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.log">
<code class="descname">log</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of the natural logarithm of
<span class="math">\(x belongs to \mathbb{C}^*\)</span>, i.e.&nbsp;such that <span class="math">\({Im(log}(x)) belongs to ]-\Pi,\Pi]\)</span>.
The branch cut lies
along the negative real axis, continuous with quadrant 2, i.e.&nbsp;such that
<span class="math">\(\lim_{b\to 0^+} \log (a+bi) = \log a\)</span> for <span class="math">\(a belongs to \mathbb{R}^*\)</span>. The result is complex
(with imaginary part equal to <span class="math">\(\Pi\)</span>) if <span class="math">\(x belongs to \mathbb{R}\)</span> and <span class="math">\(x &lt; 0\)</span>. In general,
the algorithm uses the formula</p>
<div class="math">
\[\log(x) ~ (\Pi)/(2{agm}(1, 4/s)) - m \log 2,\]</div>
<p>if <span class="math">\(s = x 2^m\)</span> is large enough. (The result is exact to <span class="math">\(B\)</span> bits provided
<span class="math">\(s &gt; 2^{B/2}\)</span>.) At low accuracies, the series expansion near <span class="math">\(1\)</span> is used.</p>
<p><span class="math">\(p\)</span>-adic arguments are also accepted for <span class="math">\(x\)</span>, with the convention that
<span class="math">\(\log(p) = 0\)</span>. Hence in particular <span class="math">\(\exp(\log(x))/x\)</span> is not in general equal to
1 but to a <span class="math">\((p-1)\)</span>-th root of unity (or <span class="math">\(±1\)</span> if <span class="math">\(p = 2\)</span>) times a power of <span class="math">\(p\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mapdelete">
<code class="descname">mapdelete</code><span class="sig-paren">(</span><em>M</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mapdelete" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes <span class="math">\(x\)</span> from the domain of the map <span class="math">\(M\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = Map([&quot;a&quot;,1; &quot;b&quot;,3; &quot;c&quot;,7]);
? mapdelete(M,&quot;b&quot;);
? Mat(M)
[&quot;a&quot; 1]

[&quot;c&quot; 7]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mapget">
<code class="descname">mapget</code><span class="sig-paren">(</span><em>M</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mapget" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the image of <span class="math">\(x\)</span> by the map <span class="math">\(M\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M=Map([&quot;a&quot;,23;&quot;b&quot;,43]);
? mapget(M,&quot;a&quot;)
%2 = 23
? mapget(M,&quot;b&quot;)
%3 = 43
</pre></div>
</div>
<p>Raises an exception when the key <span class="math">\(x\)</span> is not present in <span class="math">\(M\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? mapget(M,&quot;c&quot;)
 *** at top-level: mapget(M,&quot;c&quot;)
 *** ^-------------
 *** mapget: non-existent component in mapget: index not in map
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mapput">
<code class="descname">mapput</code><span class="sig-paren">(</span><em>M</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mapput" title="Permalink to this definition">¶</a></dt>
<dd><p>Associates <span class="math">\(x\)</span> to <span class="math">\(y\)</span> in the map <span class="math">\(M\)</span>. The value <span class="math">\(y\)</span> can be retrieved
with <code class="docutils literal"><span class="pre">mapget</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = Map();
? mapput(M, &quot;foo&quot;, 23);
? mapput(M, 7718, &quot;bill&quot;);
? mapget(M, &quot;foo&quot;)
%4 = 23
? mapget(M, 7718)
%5 = &quot;bill&quot;
? Vec(M) \\ keys
%6 = [7718, &quot;foo&quot;]
? Mat(M)
%7 =
[ 7718 &quot;bill&quot;]

[&quot;foo&quot; 23]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matadjoint">
<code class="descname">matadjoint</code><span class="sig-paren">(</span><em>M</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matadjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>adjoint matrix of <span class="math">\(M\)</span>, i.e.&nbsp;a matrix <span class="math">\(N\)</span>
of cofactors of <span class="math">\(M\)</span>, satisfying <span class="math">\(M*N = \det(M)*\mathrm{Id}\)</span>. <span class="math">\(M\)</span> must be a
(non-necessarily invertible) square matrix of dimension <span class="math">\(n\)</span>.
If <span class="math">\(flag\)</span> is 0 or omitted, we try to use Leverrier-Faddeev&#8217;s algorithm,
which assumes that <span class="math">\(n!\)</span> invertible. If it fails or <span class="math">\(flag = 1\)</span>,
compute <span class="math">\(T = charpoly(M)\)</span> independently first and return
<span class="math">\((-1)^{n-1} (T(x)-T(0))/x\)</span> evaluated at <span class="math">\(M\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? a = [1,2,3;3,4,5;6,7,8] * Mod(1,4);
%2 =
[Mod(1, 4) Mod(2, 4) Mod(3, 4)]

[Mod(3, 4) Mod(0, 4) Mod(1, 4)]

[Mod(2, 4) Mod(3, 4) Mod(0, 4)]
</pre></div>
</div>
<p>Both algorithms use <span class="math">\(O(n^4)\)</span> operations in the base ring, and are usually
slower than computing the characteristic polynomial or the inverse of <span class="math">\(M\)</span>
directly.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matalgtobasis">
<code class="descname">matalgtobasis</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matalgtobasis" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(nf\)</span> being a number field in <code class="docutils literal"><span class="pre">nfinit</span></code> format, and <span class="math">\(x\)</span> a
(row or column) vector or matrix, apply <code class="docutils literal"><span class="pre">nfalgtobasis</span></code> to each entry
of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matbasistoalg">
<code class="descname">matbasistoalg</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matbasistoalg" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(nf\)</span> being a number field in <code class="docutils literal"><span class="pre">nfinit</span></code> format, and <span class="math">\(x\)</span> a
(row or column) vector or matrix, apply <code class="docutils literal"><span class="pre">nfbasistoalg</span></code> to each entry
of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matcompanion">
<code class="descname">matcompanion</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matcompanion" title="Permalink to this definition">¶</a></dt>
<dd><p>The left companion matrix to the non-zero polynomial <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matconcat">
<code class="descname">matconcat</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matconcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <code class="docutils literal"><span class="pre">t_MAT</span></code> built from the entries of <span class="math">\(v\)</span>, which may
be a <code class="docutils literal"><span class="pre">t_VEC</span></code> (concatenate horizontally), a <code class="docutils literal"><span class="pre">t_COL</span></code> (concatenate
vertically), or a <code class="docutils literal"><span class="pre">t_MAT</span></code> (concatenate vertically each column, and
concatenate vertically the resulting matrices). The entries of <span class="math">\(v\)</span> are always
considered as matrices: they can themselves be <code class="docutils literal"><span class="pre">t_VEC</span></code> (seen as a row
matrix), a <code class="docutils literal"><span class="pre">t_COL</span></code> seen as a column matrix), a <code class="docutils literal"><span class="pre">t_MAT</span></code>, or a scalar (seen
as an <span class="math">\(1 x 1\)</span> matrix).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A=[1,2;3,4]; B=[5,6]~; C=[7,8]; D=9;
? matconcat([A, B]) \\ horizontal
%1 =
[1 2 5]

[3 4 6]
? matconcat([A, C]~) \\ vertical
%2 =
[1 2]

[3 4]

[7 8]
? matconcat([A, B; C, D]) \\ block matrix
%3 =
[1 2 5]

[3 4 6]

[7 8 9]
</pre></div>
</div>
<p>If the dimensions of the entries to concatenate do not match up, the above
rules are extended as follows:</p>
<ul class="simple">
<li>each entry <span class="math">\(v_{i,j}\)</span> of <span class="math">\(v\)</span> has a natural length and height: <span class="math">\(1 x 
1\)</span> for a scalar, <span class="math">\(1 x n\)</span> for a <code class="docutils literal"><span class="pre">t_VEC</span></code> of length <span class="math">\(n\)</span>, <span class="math">\(n x 1\)</span>
for a <code class="docutils literal"><span class="pre">t_COL</span></code>, <span class="math">\(m x n\)</span> for an <span class="math">\(m x n\)</span> <code class="docutils literal"><span class="pre">t_MAT</span></code></li>
<li>let <span class="math">\(H_i\)</span> be the maximum over <span class="math">\(j\)</span> of the lengths of the <span class="math">\(v_{i,j}\)</span>,
let <span class="math">\(L_j\)</span> be the maximum over <span class="math">\(i\)</span> of the heights of the <span class="math">\(v_{i,j}\)</span>.
The dimensions of the <span class="math">\((i,j)\)</span>-th block in the concatenated matrix are
<span class="math">\(H_i x L_j\)</span>.</li>
<li>a scalar <span class="math">\(s = v_{i,j}\)</span> is considered as <span class="math">\(s\)</span> times an identity matrix
of the block dimension <span class="math">\(\min (H_i,L_j)\)</span></li>
<li>blocks are extended by 0 columns on the right and 0 rows at the
bottom, as needed.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? matconcat([1, [2,3]~, [4,5,6]~]) \\ horizontal
%4 =
[1 2 4]

[0 3 5]

[0 0 6]
? matconcat([1, [2,3], [4,5,6]]~) \\ vertical
%5 =
[1 0 0]

[2 3 0]

[4 5 6]
? matconcat([B, C; A, D]) \\ block matrix
%6 =
[5 0 7 8]

[6 0 0 0]

[1 2 9 0]

[3 4 0 9]
? U=[1,2;3,4]; V=[1,2,3;4,5,6;7,8,9];
? matconcat(matdiagonal([U, V])) \\ block diagonal
%7 =
[1 2 0 0 0]

[3 4 0 0 0]

[0 0 1 2 3]

[0 0 4 5 6]

[0 0 7 8 9]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matdet">
<code class="descname">matdet</code><span class="sig-paren">(</span><em>x</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matdet" title="Permalink to this definition">¶</a></dt>
<dd><p>Determinant of the square matrix <span class="math">\(x\)</span>.</p>
<p>If <span class="math">\(flag = 0\)</span>, uses an appropriate algorithm depending on the coefficients:</p>
<ul class="simple">
<li>integer entries: modular method due to Dixon, Pernet and Stein.</li>
<li>real or <span class="math">\(p\)</span>-adic entries: classical Gaussian elimination using maximal
pivot.</li>
<li>intmod entries: classical Gaussian elimination using first non-zero
pivot.</li>
<li>other cases: Gauss-Bareiss.</li>
</ul>
<p>If <span class="math">\(flag = 1\)</span>, uses classical Gaussian elimination with appropriate pivoting
strategy (maximal pivot for real or <span class="math">\(p\)</span>-adic coefficients). This is usually
worse than the default.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matdetint">
<code class="descname">matdetint</code><span class="sig-paren">(</span><em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matdetint" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(B\)</span> be an <span class="math">\(m x n\)</span> matrix with integer coefficients. The
<em>determinant</em> <span class="math">\(D\)</span> of the lattice generated by the columns of <span class="math">\(B\)</span> is
the square root of <span class="math">\(\det(B^T B)\)</span> if <span class="math">\(B\)</span> has maximal rank <span class="math">\(m\)</span>, and <span class="math">\(0\)</span>
otherwise.</p>
<p>This function uses the Gauss-Bareiss algorithm to compute a positive
<em>multiple</em> of <span class="math">\(D\)</span>. When <span class="math">\(B\)</span> is square, the function actually returns
<span class="math">\(D = \|\det B\|\)</span>.</p>
<p>This function is useful in conjunction with <code class="docutils literal"><span class="pre">mathnfmod</span></code>, which needs to
know such a multiple. If the rank is maximal and the matrix non-square,
you can obtain <span class="math">\(D\)</span> exactly using</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">matdet</span><span class="p">(</span> <span class="n">mathnfmod</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">matdetint</span><span class="p">(</span><span class="n">B</span><span class="p">))</span> <span class="p">)</span>
</pre></div>
</div>
<p>Note that as soon as one of the dimensions gets large (<span class="math">\(m\)</span> or <span class="math">\(n\)</span> is larger
than 20, say), it will often be much faster to use <code class="docutils literal"><span class="pre">mathnf(B,</span> <span class="pre">1)</span></code> or
<code class="docutils literal"><span class="pre">mathnf(B,</span> <span class="pre">4)</span></code> directly.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matdiagonal">
<code class="descname">matdiagonal</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matdiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> being a vector, creates the diagonal matrix
whose diagonal entries are those of <span class="math">\(x\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? matdiagonal([1,2,3]);
%1 =
[1 0 0]

[0 2 0]

[0 0 3]
</pre></div>
</div>
<p>Block diagonal matrices are easily created using
<code class="docutils literal"><span class="pre">matconcat</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? U=[1,2;3,4]; V=[1,2,3;4,5,6;7,8,9];
? matconcat(matdiagonal([U, V]))
%1 =
[1 2 0 0 0]

[3 4 0 0 0]

[0 0 1 2 3]

[0 0 4 5 6]

[0 0 7 8 9]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mateigen">
<code class="descname">mateigen</code><span class="sig-paren">(</span><em>x</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mateigen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the (complex) eigenvectors of <span class="math">\(x\)</span> as columns of a matrix.
If <span class="math">\(flag = 1\)</span>, return <span class="math">\([L,H]\)</span>, where <span class="math">\(L\)</span> contains the
eigenvalues and <span class="math">\(H\)</span> the corresponding eigenvectors; multiple eigenvalues are
repeated according to the eigenspace dimension (which may be less
than the eigenvalue multiplicity in the characteristic polynomial).</p>
<p>This function first computes the characteristic polynomial of <span class="math">\(x\)</span> and
approximates its complex roots <span class="math">\((\lambda_i)\)</span>, then tries to compute the
eigenspaces as kernels of the <span class="math">\(x - \lambda_i\)</span>. This algorithm is
ill-conditioned and is likely to miss kernel vectors if some roots of the
characteristic polynomial are close, in particular if it has multiple roots.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A = [13,2; 10,14]; mateigen(A)
%1 =
[-1/2 2/5]

[ 1 1]
? [L,H] = mateigen(A, 1);
? L
%3 = [9, 18]
? H
%4 =
[-1/2 2/5]

[ 1 1]
</pre></div>
</div>
<p>For symmetric matrices, use <code class="docutils literal"><span class="pre">qfjacobi</span></code> instead; for Hermitian matrices,
compute</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">matconcat</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="n">B</span><span class="p">;</span> <span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">]);</span>
</pre></div>
</div>
<p>and apply <code class="docutils literal"><span class="pre">qfjacobi</span></code> to <span class="math">\(y\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matfrobenius">
<code class="descname">matfrobenius</code><span class="sig-paren">(</span><em>M</em>, <em>flag=0</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matfrobenius" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Frobenius form of
the square matrix <code class="docutils literal"><span class="pre">M</span></code>. If <span class="math">\(flag = 1\)</span>, returns only the elementary divisors as
a vector of polynomials in the variable <code class="docutils literal"><span class="pre">v</span></code>. If <span class="math">\(flag = 2\)</span>, returns a
two-components vector [F,B] where <code class="docutils literal"><span class="pre">F</span></code> is the Frobenius form and <code class="docutils literal"><span class="pre">B</span></code> is
the basis change so that <span class="math">\(M = B^{-1}FB\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mathess">
<code class="descname">mathess</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mathess" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a matrix similar to the square matrix <span class="math">\(x\)</span>, which is in upper Hessenberg
form (zero entries below the first subdiagonal).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mathnf">
<code class="descname">mathnf</code><span class="sig-paren">(</span><em>M</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mathnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(R\)</span> be a Euclidean ring, equal to <span class="math">\(\mathbb{Z}\)</span> or to <span class="math">\(K[X]\)</span> for some field
<span class="math">\(K\)</span>. If <span class="math">\(M\)</span> is a (not necessarily square) matrix with entries in <span class="math">\(R\)</span>, this
routine finds the <em>upper triangular</em> Hermite normal form of <span class="math">\(M\)</span>.
If the rank of <span class="math">\(M\)</span> is equal to its number of rows, this is a square
matrix. In general, the columns of the result form a basis of the <span class="math">\(R\)</span>-module
spanned by the columns of <span class="math">\(M\)</span>.</p>
<p>The values <span class="math">\(0,1,2,3\)</span> of <span class="math">\(flag\)</span> have a binary meaning, analogous to the one
in <code class="docutils literal"><span class="pre">matsnf</span></code>; in this case, binary digits of <span class="math">\(flag\)</span> mean:</p>
<ul class="simple">
<li>1 (complete output): if set, outputs <span class="math">\([H,U]\)</span>, where <span class="math">\(H\)</span> is the Hermite
normal form of <span class="math">\(M\)</span>, and <span class="math">\(U\)</span> is a transformation matrix such that <span class="math">\(MU = [0|H]\)</span>.
The matrix <span class="math">\(U\)</span> belongs to <span class="math">\({GL}(R)\)</span>. When <span class="math">\(M\)</span> has a large kernel, the
entries of <span class="math">\(U\)</span> are in general huge.</li>
<li>2 (generic input): <em>Deprecated</em>. If set, assume that <span class="math">\(R = K[X]\)</span> is
a polynomial ring; otherwise, assume that <span class="math">\(R = \mathbb{Z}\)</span>. This flag is now useless
since the routine always checks whether the matrix has integral entries.</li>
</ul>
<p>For these 4 values, we use a naive algorithm, which behaves well
in small dimension only. Larger values correspond to different algorithms,
are restricted to <em>integer</em> matrices, and all output the unimodular
matrix <span class="math">\(U\)</span>. From now on all matrices have integral entries.</p>
<ul class="simple">
<li><span class="math">\(flag = 4\)</span>, returns <span class="math">\([H,U]\)</span> as in &#8220;complete output&#8221; above, using a
variant of LLL reduction along the way. The matrix <span class="math">\(U\)</span> is provably
small in the <span class="math">\(L_2\)</span> sense, and in general close to optimal; but the
reduction is in general slow, although provably polynomial-time.</li>
</ul>
<p>If <span class="math">\(flag = 5\)</span>, uses Batut&#8217;s algorithm and output <span class="math">\([H,U,P]\)</span>, such that <span class="math">\(H\)</span> and
<span class="math">\(U\)</span> are as before and <span class="math">\(P\)</span> is a permutation of the rows such that <span class="math">\(P\)</span> applied
to <span class="math">\(MU\)</span> gives <span class="math">\(H\)</span>. This is in general faster than <span class="math">\(flag = 4\)</span> but the matrix <span class="math">\(U\)</span>
is usually worse; it is heuristically smaller than with the default algorithm.</p>
<p>When the matrix is dense and the dimension is large (bigger than 100, say),
<span class="math">\(flag = 4\)</span> will be fastest. When <span class="math">\(M\)</span> has maximal rank, then</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="n">mathnfmod</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">matdetint</span><span class="p">(</span><span class="n">M</span><span class="p">))</span>
</pre></div>
</div>
<p>will be even faster. You can then recover <span class="math">\(U\)</span> as <span class="math">\(M^{-1}H\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = matrix(3,4,i,j,random([-5,5]))
%1 =
[ 0 2 3 0]

[-5 3 -5 -5]

[ 4 3 -5 4]

? [H,U] = mathnf(M, 1);
? U
%3 =
[-1 0 -1 0]

[ 0 5 3 2]

[ 0 3 1 1]

[ 1 0 0 0]

? H
%5 =
[19 9 7]

[ 0 9 1]

[ 0 0 1]

? M*U
%6 =
[0 19 9 7]

[0 0 9 1]

[0 0 0 1]
</pre></div>
</div>
<p>For convenience, <span class="math">\(M\)</span> is allowed to be a <code class="docutils literal"><span class="pre">t_VEC</span></code>, which is then
automatically converted to a <code class="docutils literal"><span class="pre">t_MAT</span></code>, as per the <code class="docutils literal"><span class="pre">Mat</span></code> function.
For instance to solve the generalized extended gcd problem, one may use</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? v = [116085838, 181081878, 314252913,10346840];
? [H,U] = mathnf(v, 1);
? U
%2 =
[ 103 -603 15 -88]

[-146 13 -1208 352]

[ 58 220 678 -167]

[-362 -144 381 -101]
? v*U
%3 = [0, 0, 0, 1]
</pre></div>
</div>
<p>This also allows to input a matrix as a <code class="docutils literal"><span class="pre">t_VEC</span></code> of
<code class="docutils literal"><span class="pre">t_COL</span></code>&nbsp;s of the same length (which <code class="docutils literal"><span class="pre">Mat</span></code> would concatenate to
the <code class="docutils literal"><span class="pre">t_MAT</span></code> having those columns):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? v = [[1,0,4]~, [3,3,4]~, [0,-4,-5]~]; mathnf(v)
%1 =
[47 32 12]

[ 0 1 0]

[ 0 0 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mathnfmod">
<code class="descname">mathnfmod</code><span class="sig-paren">(</span><em>x</em>, <em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mathnfmod" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(x\)</span> is a (not necessarily square) matrix of
maximal rank with integer entries, and <span class="math">\(d\)</span> is a multiple of the (non-zero)
determinant of the lattice spanned by the columns of <span class="math">\(x\)</span>, finds the
<em>upper triangular</em> Hermite normal form of <span class="math">\(x\)</span>.</p>
<p>If the rank of <span class="math">\(x\)</span> is equal to its number of rows, the result is a square
matrix. In general, the columns of the result form a basis of the lattice
spanned by the columns of <span class="math">\(x\)</span>. Even when <span class="math">\(d\)</span> is known, this is in general
slower than <code class="docutils literal"><span class="pre">mathnf</span></code> but uses much less memory.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mathnfmodid">
<code class="descname">mathnfmodid</code><span class="sig-paren">(</span><em>x</em>, <em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mathnfmodid" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the (upper triangular)
Hermite normal form of <span class="math">\(x\)</span> concatenated with the diagonal
matrix with diagonal <span class="math">\(d\)</span>. Assumes that <span class="math">\(x\)</span> has integer entries.
Variant: if <span class="math">\(d\)</span> is an integer instead of a vector, concatenate <span class="math">\(d\)</span> times the
identity matrix.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? m=[0,7;-1,0;-1,-1]
%1 =
[ 0 7]

[-1 0]

[-1 -1]
? mathnfmodid(m, [6,2,2])
%2 =
[2 1 1]

[0 1 0]

[0 0 1]
? mathnfmodid(m, 10)
%3 =
[10 7 3]

[ 0 1 0]

[ 0 0 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mathouseholder">
<code class="descname">mathouseholder</code><span class="sig-paren">(</span><em>Q</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mathouseholder" title="Permalink to this definition">¶</a></dt>
<dd><p>applies a sequence <span class="math">\(Q\)</span> of Householder
transforms, as returned by <code class="docutils literal"><span class="pre">matqr</span></code><span class="math">\((M,1)\)</span> to the vector or matrix <span class="math">\(v\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matimage">
<code class="descname">matimage</code><span class="sig-paren">(</span><em>x</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a basis for the image of the
matrix <span class="math">\(x\)</span> as columns of a matrix. A priori the matrix can have entries of
any type. If <span class="math">\(flag = 0\)</span>, use standard Gauss pivot. If <span class="math">\(flag = 1\)</span>, use
<code class="docutils literal"><span class="pre">matsupplement</span></code> (much slower: keep the default flag!).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matimagecompl">
<code class="descname">matimagecompl</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matimagecompl" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the vector of the column indices which
are not extracted by the function <code class="docutils literal"><span class="pre">matimage</span></code>, as a permutation
(<code class="docutils literal"><span class="pre">t_VECSMALL</span></code>). Hence the number of
components of <code class="docutils literal"><span class="pre">matimagecompl(x)</span></code> plus the number of columns of
<code class="docutils literal"><span class="pre">matimage(x)</span></code> is equal to the number of columns of the matrix <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matindexrank">
<code class="descname">matindexrank</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matindexrank" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> being a matrix of rank <span class="math">\(r\)</span>, returns a vector with two
<code class="docutils literal"><span class="pre">t_VECSMALL</span></code> components <span class="math">\(y\)</span> and <span class="math">\(z\)</span> of length <span class="math">\(r\)</span> giving a list of rows
and columns respectively (starting from 1) such that the extracted matrix
obtained from these two vectors using <span class="math">\(vecextract(x,y,z)\)</span> is
invertible.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matintersect">
<code class="descname">matintersect</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matintersect" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> and <span class="math">\(y\)</span> being two matrices with the same
number of rows each of whose columns are independent, finds a basis of the
<span class="math">\(\mathbb{Q}\)</span>-vector space equal to the intersection of the spaces spanned by the
columns of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> respectively. The faster function
<code class="docutils literal"><span class="pre">idealintersect</span></code> can be used to intersect fractional ideals (projective
<span class="math">\(\mathbb{Z}_K\)</span> modules of rank <span class="math">\(1\)</span>); the slower but much more general function
<code class="docutils literal"><span class="pre">nfhnf</span></code> can be used to intersect general <span class="math">\(\mathbb{Z}_K\)</span>-modules.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matinverseimage">
<code class="descname">matinverseimage</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matinverseimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a matrix <span class="math">\(x\)</span> and
a column vector or matrix <span class="math">\(y\)</span>, returns a preimage <span class="math">\(z\)</span> of <span class="math">\(y\)</span> by <span class="math">\(x\)</span> if one
exists (i.e such that <span class="math">\(x z = y\)</span>), an empty vector or matrix otherwise. The
complete inverse image is <span class="math">\(z + {Ker} x\)</span>, where a basis of the kernel of
<span class="math">\(x\)</span> may be obtained by <code class="docutils literal"><span class="pre">matker</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = [1,2;2,4];
? matinverseimage(M, [1,2]~)
%2 = [1, 0]~
? matinverseimage(M, [3,4]~)
%3 = []~ \\ no solution
? matinverseimage(M, [1,3,6;2,6,12])
%4 =
[1 3 6]

[0 0 0]
? matinverseimage(M, [1,2;3,4])
%5 = [;] \\ no solution
? K = matker(M)
%6 =
[-2]

[1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matisdiagonal">
<code class="descname">matisdiagonal</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matisdiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true (1) if <span class="math">\(x\)</span> is a diagonal matrix, false (0) if not.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matker">
<code class="descname">matker</code><span class="sig-paren">(</span><em>x</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matker" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a basis for the kernel of the matrix <span class="math">\(x\)</span> as columns of a matrix.
The matrix can have entries of any type, provided they are compatible with
the generic arithmetic operations (<span class="math">\(+\)</span>, <span class="math">\(x\)</span> and <span class="math">\(/\)</span>).</p>
<p>If <span class="math">\(x\)</span> is known to have integral entries, set <span class="math">\(flag = 1\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matkerint">
<code class="descname">matkerint</code><span class="sig-paren">(</span><em>x</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matkerint" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives an LLL-reduced <span class="math">\(\mathbb{Z}\)</span>-basis
for the lattice equal to the kernel of the matrix <span class="math">\(x\)</span> with rational entries.</p>
<p><em>flag</em> is deprecated, kept for backward compatibility.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matmuldiagonal">
<code class="descname">matmuldiagonal</code><span class="sig-paren">(</span><em>x</em>, <em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matmuldiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Product of the matrix <span class="math">\(x\)</span> by the diagonal
matrix whose diagonal entries are those of the vector <span class="math">\(d\)</span>. Equivalent to,
but much faster than <span class="math">\(x*matdiagonal(d)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matmultodiagonal">
<code class="descname">matmultodiagonal</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matmultodiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Product of the matrices <span class="math">\(x\)</span> and <span class="math">\(y\)</span> assuming that the result is a
diagonal matrix. Much faster than <span class="math">\(x*y\)</span> in that case. The result is
undefined if <span class="math">\(x*y\)</span> is not diagonal.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matqr">
<code class="descname">matqr</code><span class="sig-paren">(</span><em>M</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <span class="math">\([Q,R]\)</span>, the QR-decomposition of the square invertible
matrix <span class="math">\(M\)</span> with real entries: <span class="math">\(Q\)</span> is orthogonal and <span class="math">\(R\)</span> upper triangular. If
<span class="math">\(flag = 1\)</span>, the orthogonal matrix is returned as a sequence of Householder
transforms: applying such a sequence is stabler and faster than
multiplication by the corresponding <span class="math">\(Q\)</span> matrix.
More precisely, if</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Q</span><span class="p">,</span><span class="n">R</span><span class="p">]</span> <span class="o">=</span> <span class="n">matqr</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
<span class="p">[</span><span class="n">q</span><span class="p">,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">matqr</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>then <span class="math">\(r = R\)</span> and <code class="docutils literal"><span class="pre">mathouseholder</span></code><span class="math">\((q, M)\)</span> is
(close to) <span class="math">\(R\)</span>; furthermore</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mathouseholder</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">matid</span><span class="p">(</span><span class="c1">#M)) == Q~</span>
</pre></div>
</div>
<p>the inverse of <span class="math">\(Q\)</span>. This function raises an error if the
precision is too low or <span class="math">\(x\)</span> is singular.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matrank">
<code class="descname">matrank</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matrank" title="Permalink to this definition">¶</a></dt>
<dd><p>Rank of the matrix <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matrixqz">
<code class="descname">matrixqz</code><span class="sig-paren">(</span><em>A</em>, <em>p=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matrixqz" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(A\)</span> being an <span class="math">\(m x n\)</span> matrix in <span class="math">\(M_{m,n}(\mathbb{Q})\)</span>, let
<span class="math">\({Im}_\mathbb{Q} A\)</span> (resp.&nbsp;<span class="math">\({Im}_\mathbb{Z} A\)</span>) the <span class="math">\(\mathbb{Q}\)</span>-vector space
(resp.&nbsp;the <span class="math">\(\mathbb{Z}\)</span>-module) spanned by the columns of <span class="math">\(A\)</span>. This function has
varying behavior depending on the sign of <span class="math">\(p\)</span>:</p>
<p>If <span class="math">\(p &gt;= 0\)</span>, <span class="math">\(A\)</span> is assumed to have maximal rank <span class="math">\(n &lt;= m\)</span>. The function
returns a matrix <span class="math">\(B belongs to M_{m,n}(\mathbb{Z})\)</span>, with <span class="math">\({Im}_\mathbb{Q} B = {Im}_\mathbb{Q} A\)</span>,
such that the GCD of all its <span class="math">\(n x n\)</span> minors is coprime to
<span class="math">\(p\)</span>; in particular, if <span class="math">\(p = 0\)</span> (default), this GCD is <span class="math">\(1\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? minors(x) = vector(#x[,1], i, matdet(x[^i,]));
? A = [3,1/7; 5,3/7; 7,5/7]; minors(A)
%1 = [4/7, 8/7, 4/7] \\ determinants of all 2x2 minors
? B = matrixqz(A)
%2 =
[3 1]

[5 2]

[7 3]
? minors(%)
%3 = [1, 2, 1] \\ B integral with coprime minors
</pre></div>
</div>
<p>If <span class="math">\(p = -1\)</span>, returns the HNF basis of the lattice <span class="math">\(\mathbb{Z}^n \cap {Im}_\mathbb{Z} A\)</span>.</p>
<p>If <span class="math">\(p = -2\)</span>, returns the HNF basis of the lattice <span class="math">\(\mathbb{Z}^n \cap {Im}_\mathbb{Q} A\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? matrixqz(A,-1)
%4 =
[8 5]

[4 3]

[0 1]

? matrixqz(A,-2)
%5 =
[2 -1]

[1 0]

[0 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matsize">
<code class="descname">matsize</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matsize" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> being a vector or matrix, returns a row vector
with two components, the first being the number of rows (1 for a row vector),
the second the number of columns (1 for a column vector).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matsnf">
<code class="descname">matsnf</code><span class="sig-paren">(</span><em>X</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matsnf" title="Permalink to this definition">¶</a></dt>
<dd><p>If <span class="math">\(X\)</span> is a (singular or non-singular) matrix outputs the vector of
elementary divisors of <span class="math">\(X\)</span>, i.e.&nbsp;the diagonal of the
Smith normal form of <span class="math">\(X\)</span>, normalized so that <span class="math">\(d_n \| d_{n-1} \| 
... \| d_1\)</span>.</p>
<p>The binary digits of <em>flag</em> mean:</p>
<p>1 (complete output): if set, outputs <span class="math">\([U,V,D]\)</span>, where <span class="math">\(U\)</span> and <span class="math">\(V\)</span> are two
unimodular matrices such that <span class="math">\(UXV\)</span> is the diagonal matrix <span class="math">\(D\)</span>. Otherwise
output only the diagonal of <span class="math">\(D\)</span>. If <span class="math">\(X\)</span> is not a square matrix, then <span class="math">\(D\)</span>
will be a square diagonal matrix padded with zeros on the left or the top.</p>
<p>2 (generic input): if set, allows polynomial entries, in which case the
input matrix must be square. Otherwise, assume that <span class="math">\(X\)</span> has integer
coefficients with arbitrary shape.</p>
<p>4 (cleanup): if set, cleans up the output. This means that elementary
divisors equal to <span class="math">\(1\)</span> will be deleted, i.e.&nbsp;outputs a shortened vector <span class="math">\(D'\)</span>
instead of <span class="math">\(D\)</span>. If complete output was required, returns <span class="math">\([U',V',D']\)</span> so
that <span class="math">\(U'XV' = D'\)</span> holds. If this flag is set, <span class="math">\(X\)</span> is allowed to be of the
form <span class="math">\(vector of elementary divisors' or :math:`[U,V,D]\)</span> as would normally be output with the cleanup flag
unset.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matsolve">
<code class="descname">matsolve</code><span class="sig-paren">(</span><em>M</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matsolve" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being an invertible matrix and <span class="math">\(B\)</span> a column
vector, finds the solution <span class="math">\(X\)</span> of <span class="math">\(MX = B\)</span>, using Dixon <span class="math">\(p\)</span>-adic lifting method
if <span class="math">\(M\)</span> and <span class="math">\(B\)</span> are integral and Gaussian elimination otherwise. This
has the same effect as, but is faster, than <span class="math">\(M^{-1}*B\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matsolvemod">
<code class="descname">matsolvemod</code><span class="sig-paren">(</span><em>M</em>, <em>D</em>, <em>B</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matsolvemod" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being any integral matrix,
<span class="math">\(D\)</span> a column vector of non-negative integer moduli, and <span class="math">\(B\)</span> an integral
column vector, gives a small integer solution to the system of congruences
<span class="math">\(\sum_i m_{i,j}x_j = b_i (mod d_i)\)</span> if one exists, otherwise returns
zero. Shorthand notation: <span class="math">\(B\)</span> (resp.&nbsp;<span class="math">\(D\)</span>) can be given as a single integer,
in which case all the <span class="math">\(b_i\)</span> (resp.&nbsp;<span class="math">\(d_i\)</span>) above are taken to be equal to <span class="math">\(B\)</span>
(resp.&nbsp;<span class="math">\(D\)</span>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = [1,2;3,4];
? matsolvemod(M, [3,4]~, [1,2]~)
%2 = [-2, 0]~
? matsolvemod(M, 3, 1) \\ M X = [1,1]~ over F_3
%3 = [-1, 1]~
? matsolvemod(M, [3,0]~, [1,2]~) \\ x + 2y = 1 (mod 3), 3x + 4y = 2 (in Z)
%4 = [6, -4]~
</pre></div>
</div>
<p>If <span class="math">\(flag = 1\)</span>, all solutions are returned in the form of a two-component row
vector <span class="math">\([x,u]\)</span>, where <span class="math">\(x\)</span> is a small integer solution to the system of
congruences and <span class="math">\(u\)</span> is a matrix whose columns give a basis of the homogeneous
system (so that all solutions can be obtained by adding <span class="math">\(x\)</span> to any linear
combination of columns of <span class="math">\(u\)</span>). If no solution exists, returns zero.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.matsupplement">
<code class="descname">matsupplement</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.matsupplement" title="Permalink to this definition">¶</a></dt>
<dd><p>Assuming that the columns of the matrix <span class="math">\(x\)</span>
are linearly independent (if they are not, an error message is issued), finds
a square invertible matrix whose first columns are the columns of <span class="math">\(x\)</span>,
i.e.&nbsp;supplement the columns of <span class="math">\(x\)</span> to a basis of the whole space.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? matsupplement([1;2])
%1 =
[1 0]

[2 1]
</pre></div>
</div>
<p>Raises an error if <span class="math">\(x\)</span> has 0 columns, since (due to a long standing design
bug), the dimension of the ambient space (the number of rows) is unknown in
this case:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? matsupplement(matrix(2,0))
 *** at top-level: matsupplement(matrix
 *** ^--------------------
 *** matsupplement: sorry, suppl [empty matrix] is not yet implemented.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mattranspose">
<code class="descname">mattranspose</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mattranspose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose of <span class="math">\(x\)</span> (also <span class="math">\(x~\)</span>).
This has an effect only on vectors and matrices.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the maximum of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> when they can be compared.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the maximum of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> when they can be compared.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.minpoly">
<code class="descname">minpoly</code><span class="sig-paren">(</span><em>A</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.minpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>minimal polynomial
of <span class="math">\(A\)</span> with respect to the variable <span class="math">\(v\)</span>., i.e. the monic polynomial <span class="math">\(P\)</span>
of minimal degree (in the variable <span class="math">\(v\)</span>) such that <span class="math">\(P(A) = 0\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.modreverse">
<code class="descname">modreverse</code><span class="sig-paren">(</span><em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.modreverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(z = Mod(A, T)\)</span> be a polmod, and <span class="math">\(Q\)</span> be its minimal
polynomial, which must satisfy <span class="math">\({deg}(Q) = {deg}(T)\)</span>.
Returns a &#8220;reverse polmod&#8221; <code class="docutils literal"><span class="pre">Mod(B,</span> <span class="pre">Q)</span></code>, which is a root of <span class="math">\(T\)</span>.</p>
<p>This is quite useful when one changes the generating element in algebraic
extensions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? u = Mod(x, x^3 - x -1); v = u^5;
? w = modreverse(v)
%2 = Mod(x^2 - 4*x + 1, x^3 - 5*x^2 + 4*x - 1)
</pre></div>
</div>
<p>which means that <span class="math">\(x^3 - 5x^2 + 4x -1\)</span> is another defining polynomial for the
cubic field</p>
<div class="math">
\[\mathbb{Q}(u) = \mathbb{Q}[x]/(x^3 - x - 1) = \mathbb{Q}[x]/(x^3 - 5x^2 + 4x - 1) = \mathbb{Q}(v),\]</div>
<p>and that <span class="math">\(u \to v^2 - 4v + 1\)</span> gives an explicit isomorphism. From this, it is
easy to convert elements between the <span class="math">\(A(u) belongs to \mathbb{Q}(u)\)</span> and <span class="math">\(B(v) belongs to \mathbb{Q}(v)\)</span>
representations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A = u^2 + 2*u + 3; subst(lift(A), &#39;x, w)
%3 = Mod(x^2 - 3*x + 3, x^3 - 5*x^2 + 4*x - 1)
? B = v^2 + v + 1; subst(lift(B), &#39;x, v)
%4 = Mod(26*x^2 + 31*x + 26, x^3 - x - 1)
</pre></div>
</div>
<p>If the minimal polynomial of <span class="math">\(z\)</span> has lower degree than expected, the routine
fails</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? u = Mod(-x^3 + 9*x, x^4 - 10*x^2 + 1)
? modreverse(u)
 *** modreverse: domain error in modreverse: deg(minpoly(z)) &lt; 4
 *** Break loop: type &#39;break&#39; to go back to GP prompt
break&gt; Vec( dbg_err() ) \\ ask for more info
[&quot;e_DOMAIN&quot;, &quot;modreverse&quot;, &quot;deg(minpoly(z))&quot;, &quot;&lt;&quot;, 4,
 Mod(-x^3 + 9*x, x^4 - 10*x^2 + 1)]
break&gt; minpoly(u)
x^2 - 8
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.moebius">
<code class="descname">moebius</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.moebius" title="Permalink to this definition">¶</a></dt>
<dd><p>Moebius <span class="math">\(\mu\)</span>-function of <span class="math">\(\|x\|\)</span>. <span class="math">\(x\)</span> must be of type integer.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msatkinlehner">
<code class="descname">msatkinlehner</code><span class="sig-paren">(</span><em>M</em>, <em>Q</em>, <em>H=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msatkinlehner" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(M\)</span> be a full modular symbol space of level <span class="math">\(N\)</span>,
as given by <code class="docutils literal"><span class="pre">msinit</span></code>, let <span class="math">\(Q \| N\)</span>, <span class="math">\((Q,N/Q) = 1\)</span>,
and let <span class="math">\(H\)</span> be a subspace stable under the Atkin-Lehner involution <span class="math">\(w_Q\)</span>.
Return the matrix of <span class="math">\(w_Q\)</span> acting on <span class="math">\(H\)</span> (<span class="math">\(M\)</span> if omitted).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(36,2); \\ M_2(Gamma_0(36))
? w = msatkinlehner(M,4); w^2 == 1
%2 = 1
? #w \\ involution acts on a 13-dimensional space
%3 = 13
? M = msinit(36,2, -1); \\ M_2(Gamma_0(36))^-
? w = msatkinlehner(M,4); w^2 == 1
%5 = 1
? #w
%6 = 4
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mscuspidal">
<code class="descname">mscuspidal</code><span class="sig-paren">(</span><em>M</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mscuspidal" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <code class="docutils literal"><span class="pre">msinit</span></code>,
return its cuspidal part <span class="math">\(S\)</span>. If <span class="math">\(flag = 1\)</span>, return
<span class="math">\([S,E]\)</span> its decomposition into cuspidal and Eisenstein parts.</p>
<p>A subspace is given by a structure allowing quick projection and
restriction of linear operators; its first component is
a matrix with integer coefficients whose columns form a <span class="math">\(\mathbb{Q}\)</span>-basis of
the subspace.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(2,8, 1); \\ M_8(Gamma_0(2))^+
? [S,E] = mscuspidal(M, 1);
? E[1] \\ 2-dimensional
%3 =
[0 -10]

[0 -15]

[0 -3]

[1 0]

? S[1] \\ 1-dimensional
%4 =
[ 3]

[30]

[ 6]

[-8]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mseisenstein">
<code class="descname">mseisenstein</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mseisenstein" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <code class="docutils literal"><span class="pre">msinit</span></code>,
return its Eisenstein subspace.
A subspace is given by a structure allowing quick projection and
restriction of linear operators; its first component is
a matrix with integer coefficients whose columns form a <span class="math">\(\mathbb{Q}\)</span>-basis of
the subspace.
This is the same basis as given by the second component of
<code class="docutils literal"><span class="pre">mscuspidal</span></code><span class="math">\((M, 1)\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(2,8, 1); \\ M_8(Gamma_0(2))^+
? E = mseisenstein(M);
? E[1] \\ 2-dimensional
%3 =
[0 -10]

[0 -15]

[0 -3]

[1 0]

? E == mscuspidal(M,1)[2]
%4 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mseval">
<code class="descname">mseval</code><span class="sig-paren">(</span><em>M</em>, <em>s</em>, <em>p=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mseval" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(\Delta := {Div}^0(\P^1 (\mathbb{Q}))\)</span>.
Let <span class="math">\(M\)</span> be a full modular symbol space, as given by <code class="docutils literal"><span class="pre">msinit</span></code>,
let <span class="math">\(s\)</span> be a modular symbol from <span class="math">\(M\)</span>, i.e. an element
of <span class="math">\({Hom}_G(\Delta, V)\)</span>, and let <span class="math">\(p = [a,b] belongs to \Delta\)</span> be a path between
two elements in <span class="math">\(\P^1(\mathbb{Q})\)</span>, return <span class="math">\(s(p) belongs to V\)</span>. The path extremities <span class="math">\(a\)</span> and
<span class="math">\(b\)</span> may be given as <code class="docutils literal"><span class="pre">t_INT</span></code>, <code class="docutils literal"><span class="pre">t_FRAC</span></code> or <span class="math">\(oo = (1:0)\)</span>.
The symbol <span class="math">\(s\)</span> is either</p>
<ul class="simple">
<li>a <code class="docutils literal"><span class="pre">t_COL</span></code> coding an element of a modular symbol subspace in terms of
the fixed basis of <span class="math">\({Hom}_G(\Delta,V)\)</span> chosen in <span class="math">\(M\)</span>; if <span class="math">\(M\)</span> was
initialized with a non-zero <em>sign</em> (<span class="math">\(+\)</span> or <span class="math">\(-\)</span>), then either the
basis for the full symbol space or the <span class="math">\(±\)</span>-part can be used (the dimension
being used to distinguish the two).</li>
<li>a <code class="docutils literal"><span class="pre">t_VEC</span></code> <span class="math">\((v_i)\)</span> of elements of <span class="math">\(V\)</span>, where the <span class="math">\(v_i = s(g_i)\)</span> give
the image of the generators <span class="math">\(g_i\)</span> of <span class="math">\(\Delta\)</span>, see <code class="docutils literal"><span class="pre">mspathgens</span></code>.
We assume that <span class="math">\(s\)</span> is a proper symbol, i.e.&nbsp;that the <span class="math">\(v_i\)</span> satisfy
the <code class="docutils literal"><span class="pre">mspathgens</span></code> relations.</li>
</ul>
<p>If <span class="math">\(p\)</span> is omitted, convert the symbol <span class="math">\(s\)</span> to the second form: a vector of
the <span class="math">\(s(g_i)\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(2,8,1); \\ M_8(Gamma_0(2))^+
? g = mspathgens(M)[1]
%2 = [[+oo, 0], [0, 1]]
? N = msnew(M)[1]; #N \\ Q-basis of new subspace, dimension 1
%3 = 1
? s = N[,1] \\ t_COL representation
%4 = [-3, 6, -8]~
? S = mseval(M, s) \\ t_VEC representation
%5 = [64*x^6-272*x^4+136*x^2-8, 384*x^5+960*x^4+192*x^3-672*x^2-432*x-72]
? mseval(M,s, g[1])
%6 = 64*x^6 - 272*x^4 + 136*x^2 - 8
? mseval(M,S, g[1])
%7 = 64*x^6 - 272*x^4 + 136*x^2 - 8
</pre></div>
</div>
<p>Note that the symbol should have values in
<span class="math">\(V = \mathbb{Q}[x,y]_{k-2}\)</span>, we return the de-homogenized values corresponding to <span class="math">\(y
= 1\)</span> instead.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msfromcusp">
<code class="descname">msfromcusp</code><span class="sig-paren">(</span><em>M</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msfromcusp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the modular symbol associated to the cusp
<span class="math">\(c\)</span>, where <span class="math">\(M\)</span> is a modular symbol space of level <span class="math">\(N\)</span>, associated to
<span class="math">\(G = \Gamma_0(N)\)</span>. The cusp <span class="math">\(c\)</span> in <span class="math">\(\P^1(\mathbb{Q})/G\)</span>
can be given either as <code class="docutils literal"><span class="pre">oo</span></code> (<span class="math">\(= (1:0)\)</span>), as a rational number <span class="math">\(a/b\)</span>
(<span class="math">\(= (a:b)\)</span>). The associated symbol maps the path <span class="math">\([b] - [a] belongs to 
{Div}^0 (\P^1(\mathbb{Q}))\)</span> to <span class="math">\(E_c(b) - E_c(a)\)</span>, where <span class="math">\(E_c(r)\)</span> is
<span class="math">\(0\)</span> when <span class="math">\(r != c\)</span> and <span class="math">\(X^{k-2} \| \gamma_r\)</span> otherwise, where
<span class="math">\(\gamma_r.r = (1:0)\)</span>. These symbol span the Eisenstein subspace
of <span class="math">\(M\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(2,8); \\ M_8(Gamma_0(2))
? E = mseisenstein(M);
? E[1] \\ two-dimensional
%3 =
[0 -10]

[0 -15]

[0 -3]

[1 0]

? s = msfromcusp(M,oo)
%4 = [0, 0, 0, 1]~
? mseval(M, s)
%5 = [1, 0]
? s = msfromcusp(M,1)
%6 = [-5/16, -15/32, -3/32, 0]~
? mseval(M,s)
%7 = [-x^6, -6*x^5 - 15*x^4 - 20*x^3 - 15*x^2 - 6*x - 1]
</pre></div>
</div>
<p>In case <span class="math">\(M\)</span> was initialized with a non-zero <em>sign</em>, the symbol is given
in terms of the fixed basis of the whole symbol space, not the <span class="math">\(+\)</span> or <span class="math">\(-\)</span>
part (to which it need not belong).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(2,8, 1); \\ M_8(Gamma_0(2))^+
? E = mseisenstein(M);
? E[1] \\ still two-dimensional, in a smaller space
%3 =
[ 0 -10]

[ 0 3]

[-1 0]

? s = msfromcusp(M,oo) \\ in terms of the basis for M_8(Gamma_0(2)) !
%4 = [0, 0, 0, 1]~
? mseval(M, s) \\ same symbol as before
%5 = [1, 0]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msfromell">
<code class="descname">msfromell</code><span class="sig-paren">(</span><em>E</em>, <em>sign=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msfromell" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(E/\mathbb{Q}\)</span> be an elliptic curve of conductor <span class="math">\(N\)</span>. For <span class="math">\(\varepsilon = 
±1\)</span>, we define the (cuspidal, new) modular symbol <span class="math">\(x^\varepsilon\)</span> in
<span class="math">\(H^1_c(X_0(N),\mathbb{Q})^\varepsilon\)</span> associated to
<span class="math">\(E\)</span>. For all primes <span class="math">\(p\)</span> not dividing <span class="math">\(N\)</span> we have
<span class="math">\(T_p(x^\varepsilon) = a_p x^\varepsilon\)</span>, where <span class="math">\(a_p = p+1-\#E(\mathbb{F}_p)\)</span>.</p>
<p>Let <span class="math">\(\Omega^ += E.omega[1]\)</span> be the real period of <span class="math">\(E\)</span>
(integration of the Néron differential <span class="math">\(dx/(2y+a_1x+a3)\)</span> on the connected
component of <span class="math">\(E(\mathbb{R})\)</span>, i.e.&nbsp;the generator of <span class="math">\(H_1(E,\mathbb{Z})^+\)</span>) normalized by
<span class="math">\(\Omega^+ &gt; 0\)</span>. Let <span class="math">\(i\Omega^-\)</span> the integral on a generator of <span class="math">\(H_1(E,\mathbb{Z})^-\)</span> with
<span class="math">\(\Omega^- belongs to \mathbb{R}_{ &gt; 0}\)</span>. If <span class="math">\(c_ oo\)</span> is the number of connected
components of <span class="math">\(E(\mathbb{R})\)</span>, <span class="math">\(\Omega^-\)</span> is equal to
<span class="math">\((-2/c_ oo ) x imag(E.omega[2])\)</span>.
The complex modular symbol is defined by</p>
<div class="math">
\[F: \delta \to 2i\Pi \int_{\delta} f(z) dz\]</div>
<p>The modular symbols <span class="math">\(x^\varepsilon\)</span> are normalized so that
<span class="math">\(F = x^+ \Omega^+ + x^- i\Omega^-\)</span>.
In particular, we have</p>
<div class="math">
\[x^+([0]-[ oo ]) = L(E,1) / \Omega^+,\]</div>
<p>which defines <span class="math">\(x^{±}\)</span> unless <span class="math">\(L(E,1) = 0\)</span>.
Furthermore, for all fundamental discriminants <span class="math">\(D\)</span> such
that <span class="math">\(\varepsilon.D &gt; 0\)</span>, we also have</p>
<div class="math">
\[\sum_{0 &lt;= a &lt; \|D\|} (D\|a) x^\varepsilon([a/\|D\|]-[ oo ])
= L(E,(D\|.),1) / \Omega^{\varepsilon},\]</div>
<p>where <span class="math">\((D\|.)\)</span> is the Kronecker symbol.
The period <span class="math">\(\Omega^-\)</span> is also <span class="math">\(2/c_ oo x\)</span> the real period
of the twist <span class="math">\(E^{(-4)} = elltwist(E,-4)\)</span>.</p>
<p>This function returns the pair <span class="math">\([M, x]\)</span>, where <span class="math">\(M\)</span> is
<code class="docutils literal"><span class="pre">msinit</span></code><span class="math">\((N,2)\)</span> and <span class="math">\(x\)</span> is <span class="math">\(x^{sign}\)</span> as above when <span class="math">\(sign = 
±1\)</span>, and <span class="math">\(x = [x^+,x^-]\)</span> when <em>sign</em> is <span class="math">\(0\)</span>.
The modular symbols <span class="math">\(x^±\)</span> are given as a <code class="docutils literal"><span class="pre">t_COL</span></code> (in terms
of the fixed basis of <span class="math">\({Hom}_G(\Delta,\mathbb{Q})\)</span> chosen in <span class="math">\(M\)</span>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E=ellinit([0,-1,1,-10,-20]); \\ X_0(11)
? [M,xp]= msfromell(E,1);
? xp
%3 = [1/5, -1/2, -1/2]~
? [M,x]= msfromell(E);
? x \\ both x^+ and x^-
%5 = [[1/5, -1/2, -1/2]~, [0, 1/2, -1/2]~]
? p = 23; (mshecke(M,p) - ellap(E,p))*x[1]
%6 = [0, 0, 0]~ \\ true at all primes, including p = 11; same for x[2]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msfromhecke">
<code class="descname">msfromhecke</code><span class="sig-paren">(</span><em>M</em>, <em>v</em>, <em>H=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msfromhecke" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a msinit <span class="math">\(M\)</span> and a vector <span class="math">\(v\)</span> of pairs <span class="math">\([p, P]\)</span> (where <span class="math">\(p\)</span> is prime
and <span class="math">\(P\)</span> is a polynomial with integer coefficients), return a basis of all
modular symbols such that <span class="math">\(P(T_p)(s) = 0\)</span>. If <span class="math">\(H\)</span> is present, it must
be a Hecke-stable subspace and we restrict to <span class="math">\(s belongs to H\)</span>. When <span class="math">\(T_p\)</span> has
a rational eigenvalue and <span class="math">\(P(x) = x-a_p\)</span> has degree <span class="math">\(1\)</span>, we also accept the
integer <span class="math">\(a_p\)</span> instead of <span class="math">\(P\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit([0,-1,1,-10,-20]) \\11a1
? ellap(E,2)
%2 = -2
? ellap(E,3)
%3 = -1
? M = msinit(11,2);
? S = msfromhecke(M, [[2,-2],[3,-1]])
%5 =
[ 1 1]

[-5 0]

[ 0 -5]
? mshecke(M, 2, S)
%6 =
[-2 0]

[ 0 -2]

? M = msinit(23,4);
? S = msfromhecke(M, [[5, x^4-14*x^3-244*x^2+4832*x-19904]]);
? factor( charpoly(mshecke(M,5,S)) )
%9 =
[x^4 - 14*x^3 - 244*x^2 + 4832*x - 19904 2]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msgetlevel">
<code class="descname">msgetlevel</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msgetlevel" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <code class="docutils literal"><span class="pre">msinit</span></code>, return
its level <span class="math">\(N\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msgetsign">
<code class="descname">msgetsign</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msgetsign" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <code class="docutils literal"><span class="pre">msinit</span></code>, return
its sign: <span class="math">\(±1\)</span> or 0 (unset).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(11,4, 1);
? msgetsign(M)
%2 = 1
? M = msinit(11,4);
? msgetsign(M)
%4 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msgetweight">
<code class="descname">msgetweight</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msgetweight" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <code class="docutils literal"><span class="pre">msinit</span></code>, return
its weight <span class="math">\(k\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(11,4);
? msgetweight(M)
%2 = 4
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mshecke">
<code class="descname">mshecke</code><span class="sig-paren">(</span><em>M</em>, <em>p</em>, <em>H=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mshecke" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <code class="docutils literal"><span class="pre">msinit</span></code>,
<span class="math">\(p\)</span> being a prime number, and <span class="math">\(H\)</span> being a Hecke-stable subspace (<span class="math">\(M\)</span> if
omitted) return the matrix of <span class="math">\(T_p\)</span> acting on <span class="math">\(H\)</span>
(<span class="math">\(U_p\)</span> if <span class="math">\(p\)</span> divides <span class="math">\(N\)</span>). Result is undefined if <span class="math">\(H\)</span> is not stable
by <span class="math">\(T_p\)</span> (resp.&nbsp;<span class="math">\(U_p\)</span>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(11,2); \\ M_2(Gamma_0(11))
? T2 = mshecke(M,2)
%2 =
[3 0 0]

[1 -2 0]

[1 0 -2]
? M = msinit(11,2, 1); \\ M_2(Gamma_0(11))^+
? T2 = mshecke(M,2)
%4 =
[ 3 0]

[-1 -2]

? N = msnew(M)[1] \\ Q-basis of new cuspidal subspace
%5 =
[-2]

[-5]

? p = 1009; mshecke(M, p, N) \\ action of T_1009 on N
%6 =
[-10]
? ellap(ellinit(&quot;11a1&quot;), p)
%7 = -10
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msinit">
<code class="descname">msinit</code><span class="sig-paren">(</span><em>G</em>, <em>V</em>, <em>sign=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <span class="math">\(G\)</span> a finite index subgroup of <span class="math">\({SL}(2,\mathbb{Z})\)</span>
and a finite dimensional representation <span class="math">\(V\)</span> of <span class="math">\({GL}(2,\mathbb{Q})\)</span>, creates a
space of modular symbols, the <span class="math">\(G\)</span>-module <span class="math">\({Hom}_G({Div}^0(\P^1
(\mathbb{Q})), V)\)</span>. This is canonically isomorphic to <span class="math">\(H^1_c(X(G), V)\)</span>, and allows to
compute modular forms for <span class="math">\(G\)</span>. If <em>sign</em> is present and non-zero, it
must be <span class="math">\(±1\)</span> and we consider the subspace defined by <span class="math">\({Ker} (\sigma -
sign)\)</span>, where <span class="math">\(\sigma\)</span> is induced by <code class="docutils literal"><span class="pre">[-1,0;0,1]</span></code>. Currently the
only supported groups are the <span class="math">\(\Gamma_0(N)\)</span>, coded by the integer <span class="math">\(N &gt; 1\)</span>.
The only supported representation is <span class="math">\(V_k = \mathbb{Q}[X,Y]_{k-2}\)</span>, coded by the
integer <span class="math">\(k &gt;= 2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msissymbol">
<code class="descname">msissymbol</code><span class="sig-paren">(</span><em>M</em>, <em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msissymbol" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <code class="docutils literal"><span class="pre">msinit</span></code>,
check whether <span class="math">\(s\)</span> is a modular symbol associated to <span class="math">\(M\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(7,8, 1); \\ M_8(Gamma_0(7))^+
? N = msnew(M)[1];
? s = N[,1];
? msissymbol(M, s)
%4 = 1
? S = mseval(M,s);
? msissymbol(M, S)
%6 = 1
? [g,R] = mspathgens(M); g
%7 = [[+oo, 0], [0, 1/2], [1/2, 1]]
? #R \\ 3 relations among the generators g_i
%8 = 3
? T = S; T[3]++; \\ randomly perturb S(g_3)
? msissymbol(M, T)
%10 = 0 \\ no longer satisfies the relations
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msnew">
<code class="descname">msnew</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msnew" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <code class="docutils literal"><span class="pre">msinit</span></code>,
return the <em>new</em> part of its cuspidal subspace. A subspace is given by
a structure allowing quick projection and restriction of linear operators;
its first component is a matrix with integer coefficients whose columns form
a <span class="math">\(\mathbb{Q}\)</span>-basis of the subspace.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(11,8, 1); \\ M_8(Gamma_0(11))^+
? N = msnew(M);
? #N[1] \\ 6-dimensional
%3 = 6
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msomseval">
<code class="descname">msomseval</code><span class="sig-paren">(</span><em>Mp</em>, <em>PHI</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msomseval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vectors of moments of the <span class="math">\(p\)</span>-adic distribution attached
to the path <code class="docutils literal"><span class="pre">path</span></code> by the overconvergent modular symbol <code class="docutils literal"><span class="pre">PHI</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(3,6,1);
? Mp= mspadicinit(M,5,10);
? phi = [5,-3,-1]~;
? msissymbol(M,phi)
%4 = 1
? PHI = mstooms(Mp,phi);
? ME = msomseval(Mp,PHI,[oo, 0]);
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mspadicL">
<code class="descname">mspadicL</code><span class="sig-paren">(</span><em>mu</em>, <em>s=None</em>, <em>r=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mspadicL" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value (or <span class="math">\(r\)</span>-th derivative)
on a character <span class="math">\(\chi^s\)</span> of <span class="math">\(\mathbb{Z}_p^*\)</span> of the <span class="math">\(p\)</span>-adic <span class="math">\(L\)</span>-function
attached to <code class="docutils literal"><span class="pre">mu</span></code>.</p>
<p>Let <span class="math">\(\Phi\)</span> be the <span class="math">\(p\)</span>-adic distribution-valued overconvergent symbol
attached to a modular symbol <span class="math">\(\phi\)</span> for <span class="math">\(\Gamma_0(N)\)</span> (eigenvector for
<span class="math">\(T_N(p)\)</span> for the eigenvalue <span class="math">\(a_p\)</span>). Then <span class="math">\(L_p(\Phi,\chi^s) = L_p(\mu,s)\)</span> is the
<span class="math">\(p\)</span>-adic <span class="math">\(L\)</span> function defined by</p>
<div class="math">
\[L_p(\Phi,\chi^s) = \int_{\mathbb{Z}_p^*} \chi^s(z) d\mu(z)\]</div>
<p>where <span class="math">\(\mu\)</span> is the distribution on <span class="math">\(\mathbb{Z}_p^*\)</span> defined by the restriction of
<span class="math">\(\Phi([ oo ]-[0])\)</span> to <span class="math">\(\mathbb{Z}_p^*\)</span>. The <span class="math">\(r\)</span>-th derivative is taken in
direction <span class="math">\(&lt;\chi&gt;\)</span>:</p>
<div class="math">
\[L_p^{(r)}(\Phi,\chi^s) = \int_{\mathbb{Z}_p^*} \chi^s(z) (\log z)^r d\mu(z).\]</div>
<p>In the argument list,</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">mu</span></code> is as returned by <code class="docutils literal"><span class="pre">mspadicmoments</span></code> (distributions
attached to <span class="math">\(\Phi\)</span> by restriction to discs <span class="math">\(a + p^\nu\mathbb{Z}_p\)</span>, <span class="math">\((a,p) = 1\)</span>).</li>
<li><span class="math">\(s = [s_1,s_2]\)</span> with <span class="math">\(s_1 belongs to \mathbb{Z} \subset \mathbb{Z}_p\)</span> and <span class="math">\(s_2 mod p-1\)</span> or
<span class="math">\(s_2 mod 2\)</span> for <span class="math">\(p = 2\)</span>, encoding the <span class="math">\(p\)</span>-adic character <span class="math">\(\chi^s := &lt;
\chi &gt;^{s_1} \tau^{s_2}\)</span>; here <span class="math">\(\chi\)</span> is the cyclotomic character from
<span class="math">\({Gal}(\mathbb{Q}_p(\mu_{p^ oo })/\mathbb{Q}_p)\)</span> to <span class="math">\(\mathbb{Z}_p^*\)</span>, and <span class="math">\(\tau\)</span> is the
Teichmüller character (for <span class="math">\(p &gt; 2\)</span> and the character of order 2 on
<span class="math">\((\mathbb{Z}/4\mathbb{Z})^*\)</span> if <span class="math">\(p = 2\)</span>); for convenience, the character <span class="math">\([s,s]\)</span> can also be
represented by the integer <span class="math">\(s\)</span>.</li>
</ul>
<p>When <span class="math">\(a_p\)</span> is a <span class="math">\(p\)</span>-adic unit, <span class="math">\(L_p\)</span> takes its values in <span class="math">\(\mathbb{Q}_p\)</span>.
When <span class="math">\(a_p\)</span> is not a unit, it takes its values in the
two-dimensional <span class="math">\(\mathbb{Q}_p\)</span>-vector space <span class="math">\(D_{cris}(M(\phi))\)</span> where <span class="math">\(M(\phi)\)</span> is
the &#8220;motive&#8221; attached to <span class="math">\(\phi\)</span>, and we return the two <span class="math">\(p\)</span>-adic components
with respect to some fixed <span class="math">\(\mathbb{Q}_p\)</span>-basis.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(3,6,1); phi=[5, -3, -1]~;
? msissymbol(M,phi)
%2 = 1
? Mp = mspadicinit(M, 5, 4);
? mu = mspadicmoments(Mp, phi); \\ no twist
\\ End of initializations

? mspadicL(mu,0) \\ L_p(chi^0)
%5 = 5 + 2*5^2 + 2*5^3 + 2*5^4 + ...
? mspadicL(mu,1) \\ L_p(chi), zero for parity reasons
%6 = [O(5^13)]~
? mspadicL(mu,2) \\ L_p(chi^2)
%7 = 3 + 4*5 + 4*5^2 + 3*5^5 + ...
? mspadicL(mu,[0,2]) \\ L_p(tau^2)
%8 = 3 + 5 + 2*5^2 + 2*5^3 + ...
? mspadicL(mu, [1,0]) \\ L_p(&lt;chi&gt;)
%9 = 3*5 + 2*5^2 + 5^3 + 2*5^7 + 5^8 + 5^10 + 2*5^11 + O(5^13)
? mspadicL(mu,0,1) \\ L_p&#39;(chi^0)
%10 = 2*5 + 4*5^2 + 3*5^3 + ...
? mspadicL(mu, 2, 1) \\ L_p&#39;(chi^2)
%11 = 4*5 + 3*5^2 + 5^3 + 5^4 + ...
</pre></div>
</div>
<p>Now several quadratic twists: <code class="docutils literal"><span class="pre">mstooms</span></code> is indicated.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? PHI = mstooms(Mp,phi);
? mu = mspadicmoments(Mp, PHI, 12); \\ twist by 12
? mspadicL(mu)
%14 = 5 + 5^2 + 5^3 + 2*5^4 + ...
? mu = mspadicmoments(Mp, PHI, 8); \\ twist by 8
? mspadicL(mu)
%16 = 2 + 3*5 + 3*5^2 + 2*5^4 + ...
? mu = mspadicmoments(Mp, PHI, -3); \\ twist by -3 &lt; 0
? mspadicL(mu)
%18 = O(5^13) \\ always 0, phi is in the + part and D &lt; 0
</pre></div>
</div>
<p>One can locate interesting symbols of level <span class="math">\(N\)</span> and weight <span class="math">\(k\)</span> with
<code class="docutils literal"><span class="pre">msnew</span></code> and <code class="docutils literal"><span class="pre">mssplit</span></code>. Note that instead of a symbol, one can
input a 1-dimensional Hecke-subspace from <code class="docutils literal"><span class="pre">mssplit</span></code>: the function will
automatically use the underlying basis vector.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M=msinit(5,4,1); \\ M_4(Gamma_0(5))^+
? L = mssplit(M, msnew(M)); \\ list of irreducible Hecke-subspaces
? phi = L[1]; \\ one Galois orbit of newforms
? #phi[1] \\... this one is rational
%4 = 1
? Mp = mspadicinit(M, 3, 4);
? mu = mspadicmoments(Mp, phi);
? mspadicL(mu)
%7 = 1 + 3 + 3^3 + 3^4 + 2*3^5 + 3^6 + O(3^9)

? M = msinit(11,8, 1); \\ M_8(Gamma_0(11))^+
? Mp = mspadicinit(M, 3, 4);
? L = mssplit(M, msnew(M));
? phi = L[1]; #phi[1] \\ ... this one is two-dimensional
%11 = 2
? mu = mspadicmoments(Mp, phi);
 *** at top-level: mu=mspadicmoments(Mp,ph
 *** ^--------------------
 *** mspadicmoments: incorrect type in mstooms [dim_Q (eigenspace) &gt; 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mspadicinit">
<code class="descname">mspadicinit</code><span class="sig-paren">(</span><em>M</em>, <em>p</em>, <em>n</em>, <em>flag=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mspadicinit" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <code class="docutils literal"><span class="pre">msinit</span></code>, and <span class="math">\(p\)</span>
a prime, initialize technical data needed to compute with overconvergent
modular symbols, modulo <span class="math">\(p^n\)</span>. If <span class="math">\(flag\)</span> is unset, allow
all symbols; else initialize only for a restricted range of symbols
depending on <span class="math">\(flag\)</span>: if <span class="math">\(flag = 0\)</span> restrict to ordinary symbols, else
restrict to symbols <span class="math">\(\phi\)</span> such that <span class="math">\(T_p(\phi) = a_p \phi\)</span>,
with <span class="math">\(v_p(a_p) &gt;= flag\)</span>, which is faster as <span class="math">\(flag\)</span> increases.
(The fastest initialization is obtained for <span class="math">\(flag = 0\)</span> where we only allow
ordinary symbols.) For supersingular eigensymbols, such that <span class="math">\(p \| a_p\)</span>, we
must further assume that <span class="math">\(p\)</span> does not divide the level.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit(&quot;11a1&quot;);
? [M,phi] = msfromell(E,1);
? ellap(E,3)
%3 = -1
? Mp = mspadicinit(M, 3, 10, 0); \\ commit to ordinary symbols
? PHI = mstooms(Mp,phi);
</pre></div>
</div>
<p>If we restrict the range of allowed symbols with <em>flag</em> (for faster
initialization), exceptions will occur if <span class="math">\(v_p(a_p)\)</span> violates this bound:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit(&quot;15a1&quot;);
? [M,phi] = msfromell(E,1);
? ellap(E,7)
%3 = 0
? Mp = mspadicinit(M,7,5,0); \\ restrict to ordinary symbols
? PHI = mstooms(Mp,phi)
*** at top-level: PHI=mstooms(Mp,phi)
*** ^---------------
*** mstooms: incorrect type in mstooms [v_p(ap) &gt; mspadicinit flag] (t_VEC).
? Mp = mspadicinit(M,7,5); \\ no restriction
? PHI = mstooms(Mp,phi);
</pre></div>
</div>
<p>This function uses <span class="math">\(O(N^2(n+k)^2p)\)</span> memory, where <span class="math">\(N\)</span> is the
level of <span class="math">\(M\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mspadicmoments">
<code class="descname">mspadicmoments</code><span class="sig-paren">(</span><em>Mp</em>, <em>PHI</em>, <em>D=1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mspadicmoments" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal"><span class="pre">Mp</span></code> from <code class="docutils literal"><span class="pre">mspadicinit</span></code>, an overconvergent
eigensymbol <code class="docutils literal"><span class="pre">PHI</span></code> from <code class="docutils literal"><span class="pre">mstooms</span></code> and a fundamental discriminant
<span class="math">\(D\)</span> coprime to <span class="math">\(p\)</span>,
let <span class="math">\(PHI^D\)</span> denote the twisted symbol. This function computes
the distribution <span class="math">\(\mu = PHI^D([0] - oo ]) \| \mathbb{Z}_p^*\)</span> restricted
to <span class="math">\(\mathbb{Z}_p^*\)</span>. More precisely, it returns
the moments of the <span class="math">\(p-1\)</span> distributions <span class="math">\(PHI^D([0]-[ oo ])
| (a + p\mathbb{Z}_p)\)</span>, <span class="math">\(0 &lt; a &lt; p\)</span>.
We also allow <code class="docutils literal"><span class="pre">PHI</span></code> to be given as a classical
symbol, which is then lifted to an overconvergent symbol by <code class="docutils literal"><span class="pre">mstooms</span></code>;
but this is wasteful if more than one twist is later needed.</p>
<p>The returned data <span class="math">\(\mu\)</span> (<span class="math">\(p\)</span>-adic distributions attached to <code class="docutils literal"><span class="pre">PHI</span></code>)
can then be used in <code class="docutils literal"><span class="pre">mspadicL</span></code> or <code class="docutils literal"><span class="pre">mspadicseries</span></code>.
This precomputation allows to quickly compute derivatives of different
orders or values at different characters.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(3,6, 1);
? phi = [5,-3,-1]~;
? msissymbol(M, phi)
%3 = 1
? p = 5; mshecke(M,p) * phi \\ eigenvector of T_5, a_5 = 6
%4 = [30, -18, -6]~
? Mp = mspadicinit(M, p, 10, 0); \\ restrict to ordinary symbols, mod p^10
? PHI = mstooms(Mp, phi);
? mu = mspadicmoments(Mp, PHI);
? mspadicL(mu)
%8 = 5 + 2*5^2 + 2*5^3 + ...
? mu = mspadicmoments(Mp, PHI, 12); \\ twist by 12
? mspadicL(mu)
%10 = 5 + 5^2 + 5^3 + 2*5^4 + ...
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mspadicseries">
<code class="descname">mspadicseries</code><span class="sig-paren">(</span><em>mu</em>, <em>i=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mspadicseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(\Phi\)</span> be the <span class="math">\(p\)</span>-adic distribution-valued overconvergent symbol
attached to a modular symbol <span class="math">\(\phi\)</span> for <span class="math">\(\Gamma_0(N)\)</span> (eigenvector for
<span class="math">\(T_N(p)\)</span> for the eigenvalue <span class="math">\(a_p\)</span>).
If <span class="math">\(\mu\)</span> is the distribution on <span class="math">\(\mathbb{Z}_p^*\)</span> defined by the restriction of
<span class="math">\(\Phi([ oo ]-[0])\)</span> to <span class="math">\(\mathbb{Z}_p^*\)</span>, let</p>
<div class="math">
\[^{L}_p(\mu,\tau^{i})(x)
= \int_{\mathbb{Z}_p^*} \tau^i(t) (1+x)^{\log_p(t)/\log_p(u)}d\mu(t)\]</div>
<p>Here, <span class="math">\(\tau\)</span> is the Teichmüller character and <span class="math">\(u\)</span> is a specific
multiplicative generator of <span class="math">\(1+2p\mathbb{Z}_p\)</span>. (Namely <span class="math">\(1+p\)</span> if <span class="math">\(p &gt; 2\)</span> or <span class="math">\(5\)</span>
if <span class="math">\(p = 2\)</span>.) To explain
the formula, let <span class="math">\(G_ oo := {Gal}(\mathbb{Q}(\mu_{p^{ oo }})/ \mathbb{Q})\)</span>,
let <span class="math">\(\chi:G_ oo \to \mathbb{Z}_p^*\)</span> be the cyclotomic character (isomorphism)
and <span class="math">\(\gamma\)</span> the element of <span class="math">\(G_ oo\)</span> such that <span class="math">\(\chi(\gamma) = u\)</span>;
then
<span class="math">\(\chi(\gamma)^{\log_p(t)/\log_p(u)} = &lt;&nbsp;t &gt;\)</span>.</p>
<p>The <span class="math">\(p\)</span>-padic precision of individual terms is maximal given the precision of
the overconvergent symbol <span class="math">\(\mu\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? [M,phi] = msfromell(ellinit(&quot;17a1&quot;),1);
? Mp = mspadicinit(M, 5,7);
? mu = mspadicmoments(Mp, phi,1); \\ overconvergent symbol
? mspadicseries(mu)
%4 = (4 + 3*5 + 4*5^2 + 2*5^3 + 2*5^4 + 5^5 + 4*5^6 + 3*5^7 + O(5^9)) \
 + (3 + 3*5 + 5^2 + 5^3 + 2*5^4 + 5^6 + O(5^7))*x \
 + (2 + 3*5 + 5^2 + 4*5^3 + 2*5^4 + O(5^5))*x^2 \
 + (3 + 4*5 + 4*5^2 + O(5^3))*x^3 \
 + (3 + O(5))*x^4 + O(x^5)
</pre></div>
</div>
<p>An example with non-zero Teichmüller:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? [M,phi] = msfromell(ellinit(&quot;11a1&quot;),1);
? Mp = mspadicinit(M, 3,10);
? mu = mspadicmoments(Mp, phi,1);
? mspadicseries(mu, 2)
%4 = (2 + 3 + 3^2 + 2*3^3 + 2*3^5 + 3^6 + 3^7 + 3^10 + 3^11 + O(3^12)) \
 + (1 + 3 + 2*3^2 + 3^3 + 3^5 + 2*3^6 + 2*3^8 + O(3^9))*x \
 + (1 + 2*3 + 3^4 + 2*3^5 + O(3^6))*x^2 \
 + (3 + O(3^2))*x^3 + O(x^4)
</pre></div>
</div>
<p>Supersingular example (not checked)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit(&quot;17a1&quot;); ellap(E,3)
%1 = 0
? [M,phi] = msfromell(E,1);
? Mp = mspadicinit(M, 3,7);
? mu = mspadicmoments(Mp, phi,1);
? mspadicseries(mu)
%5 = [(2*3^-1 + 1 + 3 + 3^2 + 3^3 + 3^4 + 3^5 + 3^6 + O(3^7)) \
 + (2 + 3^3 + O(3^5))*x \
 + (1 + 2*3 + O(3^2))*x^2 + O(x^3),\
 (3^-1 + 1 + 3 + 3^2 + 3^3 + 3^4 + 3^5 + 3^6 + O(3^7)) \
 + (1 + 2*3 + 2*3^2 + 3^3 + 2*3^4 + O(3^5))*x \
 + (3^-2 + 3^-1 + O(3^2))*x^2 + O(3^-2)*x^3 + O(x^4)]
</pre></div>
</div>
<p>Example with a twist:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit(&quot;11a1&quot;);
? [M,phi] = msfromell(E,1);
? Mp = mspadicinit(M, 3,10);
? mu = mspadicmoments(Mp, phi,5); \\ twist by 5
? L = mspadicseries(mu)
%5 = (2*3^2 + 2*3^4 + 3^5 + 3^6 + 2*3^7 + 2*3^10 + O(3^12)) \
 + (2*3^2 + 2*3^6 + 3^7 + 3^8 + O(3^9))*x \
 + (3^3 + O(3^6))*x^2 + O(3^2)*x^3 + O(x^4)
? mspadicL(mu)
%6 = [2*3^2 + 2*3^4 + 3^5 + 3^6 + 2*3^7 + 2*3^10 + O(3^12)]~
? ellpadicL(E,3,10,,5)
%7 = 2 + 2*3^2 + 3^3 + 2*3^4 + 2*3^5 + 3^6 + 2*3^7 + O(3^10)
? mspadicseries(mu,1) \\ must be 0
%8 = O(3^12) + O(3^9)*x + O(3^6)*x^2 + O(3^2)*x^3 + O(x^4)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mspathgens">
<code class="descname">mspathgens</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mspathgens" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(\Delta := {Div}^0(\P^1(\mathbb{Q}))\)</span>.
Let <span class="math">\(M\)</span> being a full modular symbol space, as given by <code class="docutils literal"><span class="pre">msinit</span></code>,
return a set of <span class="math">\(\mathbb{Z}[G]\)</span>-generators for <span class="math">\(\Delta\)</span>. The output
is <span class="math">\([g,R]\)</span>, where <span class="math">\(g\)</span> is a minimal system of generators and <span class="math">\(R\)</span>
the vector of <span class="math">\(\mathbb{Z}[G]\)</span>-relations between the given generators. A
relation is coded by a vector of pairs <span class="math">\([a_i,i]\)</span> with <span class="math">\(a_i belongs to \mathbb{Z}[G]\)</span>
and <span class="math">\(i\)</span> the index of a generator, so that <span class="math">\(\sum_i a_i g[i] = 0\)</span>.</p>
<p>An element <span class="math">\([v]-[u]\)</span> in <span class="math">\(\Delta\)</span> is coded by the &#8220;path&#8221; <span class="math">\([u,v]\)</span>,
where <code class="docutils literal"><span class="pre">oo</span></code> denotes the point at infinity <span class="math">\((1:0)\)</span> on the projective
line.
An element of <span class="math">\(\mathbb{Z}[G]\)</span> is coded by a &#8220;factorization matrix&#8221;: the first
column contains distinct elements of <span class="math">\(G\)</span>, and the second integers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(11,8); \\ M_8(Gamma_0(11))
? [g,R] = mspathgens(M);
? g
%3 = [[+oo, 0], [0, 1/3], [1/3, 1/2]] \\ 3 paths
? #R \\ a single relation
%4 = 1
? r = R[1]; #r \\ ...involving all 3 generators
%5 = 3
? r[1]
%6 = [[1, 1; [1, 1; 0, 1], -1], 1]
? r[2]
%7 = [[1, 1; [7, -2; 11, -3], -1], 2]
? r[3]
%8 = [[1, 1; [8, -3; 11, -4], -1], 3]
</pre></div>
</div>
<p>The given relation is of the form <span class="math">\(\sum_i (1-\gamma_i) g_i = 0\)</span>, with
<span class="math">\(\gamma_i belongs to \Gamma_0(11)\)</span>. There will always be a single relation involving
all generators (corresponding to a round trip along all cusps), then
relations involving a single generator (corresponding to <span class="math">\(2\)</span> and <span class="math">\(3\)</span>-torsion
elements in the group:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(2,8); \\ M_8(Gamma_0(2))
? [g,R] = mspathgens(M);
? g
%3 = [[+oo, 0], [0, 1]]
</pre></div>
</div>
<p>Note that the output depends only on the group <span class="math">\(G\)</span>, not on the
representation <span class="math">\(V\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mspathlog">
<code class="descname">mspathlog</code><span class="sig-paren">(</span><em>M</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mspathlog" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(\Delta := {Div}^0(\P^1(\mathbb{Q}))\)</span>.
Let <span class="math">\(M\)</span> being a full modular symbol space, as given by <code class="docutils literal"><span class="pre">msinit</span></code>,
encoding fixed <span class="math">\(\mathbb{Z}[G]\)</span>-generators <span class="math">\((g_i)\)</span> of <span class="math">\(\Delta\)</span> (see <code class="docutils literal"><span class="pre">mspathgens</span></code>).
A path <span class="math">\(p = [a,b]\)</span> between two elements in <span class="math">\(\P^1(\mathbb{Q})\)</span> corresponds to
<span class="math">\([b]-[a] belongs to \Delta\)</span>. The path extremities <span class="math">\(a\)</span> and <span class="math">\(b\)</span> may be given as
<code class="docutils literal"><span class="pre">t_INT</span></code>, <code class="docutils literal"><span class="pre">t_FRAC</span></code> or <span class="math">\(oo = (1:0)\)</span>.</p>
<p>Returns <span class="math">\((p_i)\)</span> in <span class="math">\(\mathbb{Z}[G]\)</span> such that <span class="math">\(p = \sum_i p_i g_i\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(2,8); \\ M_8(Gamma_0(2))
? [g,R] = mspathgens(M);
? g
%3 = [[+oo, 0], [0, 1]]
? p = mspathlog(M, [1/2,2/3]);
? p[1]
%5 =
[[1, 0; 2, 1] 1]

? p[2]
%6 =
[[1, 0; 0, 1] 1]

[[3, -1; 4, -1] 1]
</pre></div>
</div>
<p>Note that the output depends only on the group <span class="math">\(G\)</span>, not on the
representation <span class="math">\(V\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msqexpansion">
<code class="descname">msqexpansion</code><span class="sig-paren">(</span><em>M</em>, <em>projH</em>, <em>serprec=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msqexpansion" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <code class="docutils literal"><span class="pre">msinit</span></code>,
and <em>projH</em> being a projector on a Hecke-simple subspace (as given
by <code class="docutils literal"><span class="pre">mssplit</span></code>), return the Fourier coefficients <span class="math">\(a_n\)</span>, <span class="math">\(n &lt;= B\)</span> of the
corresponding normalized newform. If <span class="math">\(B\)</span> is omitted, use
<code class="docutils literal"><span class="pre">seriesprecision</span></code>.</p>
<p>This function uses a naive <span class="math">\(O(B^2 d^3)\)</span>
algorithm, where <span class="math">\(d = O(kN)\)</span> is the dimension of <span class="math">\(M_k(\Gamma_0(N))\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(11,2, 1); \\ M_2(Gamma_0(11))^+
? L = mssplit(M, msnew(M));
? msqexpansion(M,L[1], 20)
%3 = [1, -2, -1, 2, 1, 2, -2, 0, -2, -2, 1, -2, 4, 4, -1, -4, -2, 4, 0, 2]
? ellan(ellinit(&quot;11a1&quot;), 20)
%4 = [1, -2, -1, 2, 1, 2, -2, 0, -2, -2, 1, -2, 4, 4, -1, -4, -2, 4, 0, 2]
</pre></div>
</div>
<p>The shortcut <code class="docutils literal"><span class="pre">msqexpansion(M,</span> <span class="pre">s,</span> <span class="pre">B)</span></code> is available for
a symbol <span class="math">\(s\)</span>, provided it is a Hecke eigenvector:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? E = ellinit(&quot;11a1&quot;);
? [M,s]=msfromell(E);
? msqexpansion(M,s,10)
%3 = [1, -2, -1, 2, 1, 2, -2, 0, -2, -2]
? ellan(E, 10)
%4 = [1, -2, -1, 2, 1, 2, -2, 0, -2, -2]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mssplit">
<code class="descname">mssplit</code><span class="sig-paren">(</span><em>M</em>, <em>H</em>, <em>dimlim=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mssplit" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <code class="docutils literal"><span class="pre">msinit</span></code><span class="math">\((N,k,1)\)</span>
or <span class="math">\(msinit(N,k,-1)\)</span>
and <span class="math">\(H\)</span> being a Hecke-stable subspace of <code class="docutils literal"><span class="pre">msnew</span></code><span class="math">\((M)\)</span>, split <span class="math">\(H\)</span> into
Hecke-simple subspaces. If <code class="docutils literal"><span class="pre">dimlim</span></code> is present and positive, restrict to
subspaces of dimension <span class="math">\(&lt;= dimlim\)</span>.
A subspace is given by a structure allowing quick projection and restriction
of linear operators; its first component is a matrix with integer
coefficients whose columns form a <span class="math">\(\mathbb{Q}\)</span>-basis of the subspace.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(11,8, 1); \\ M_8(Gamma_0(11))^+
? L = mssplit(M, msnew(M));
? #L
%3 = 2
? f = msqexpansion(M,L[1],5); f[1].mod
%4 = x^2 + 8*x - 44
? lift(f)
%5 = [1, x, -6*x - 27, -8*x - 84, 20*x - 155]
? g = msqexpansion(M,L[2],5); g[1].mod
%6 = x^4 - 558*x^2 + 140*x + 51744
</pre></div>
</div>
<p>To a Hecke-simple subspace corresponds an orbit of
(normalized) newforms, defined over a number field. In the above example,
we printed the polynomials defining the said fields, as well as the first
5 Fourier coefficients (at the infinite cusp) of one such form.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.msstar">
<code class="descname">msstar</code><span class="sig-paren">(</span><em>M</em>, <em>H=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.msstar" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(M\)</span> being a full modular symbol space, as given by <code class="docutils literal"><span class="pre">msinit</span></code>,
return the matrix of the <code class="docutils literal"><span class="pre">*</span></code> involution, induced by complex conjugation,
acting on the (stable) subspace <span class="math">\(H\)</span> (<span class="math">\(M\)</span> if omitted).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(11,2); \\ M_2(Gamma_0(11))
? w = msstar(M);
? w^2 == 1
%3 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.mstooms">
<code class="descname">mstooms</code><span class="sig-paren">(</span><em>Mp</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.mstooms" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal"><span class="pre">Mp</span></code> from <code class="docutils literal"><span class="pre">mspadicinit</span></code>, lift the (classical) eigen symbol
<code class="docutils literal"><span class="pre">phi</span></code> to a <span class="math">\(p\)</span>-adic distribution-valued overconvergent symbol in the
sense of Pollack and Stevens. More precisely, let <span class="math">\(\phi\)</span> belong to the space
<span class="math">\(W\)</span> of modular symbols of level <span class="math">\(N\)</span>, <span class="math">\(v_p(N) &lt;= 1\)</span>, and weight <span class="math">\(k\)</span> which is
an eigenvector for the Hecke operator <span class="math">\(T_N(p)\)</span> for a non-zero eigenvalue
<span class="math">\(a_p\)</span> and let <span class="math">\(N_0 = {lcm}(N,p)\)</span>.</p>
<p>Under the action of <span class="math">\(T_{N_0}(p)\)</span>, <span class="math">\(\phi\)</span> generates a subspace <span class="math">\(W_\phi\)</span> of
dimension <span class="math">\(1\)</span> (if <span class="math">\(p \| N\)</span>) or <span class="math">\(2\)</span> (if <span class="math">\(p\)</span> does not divide <span class="math">\(N\)</span>) in the
space of modular symbols of level <span class="math">\(N_0\)</span>.</p>
<p>Let <span class="math">\(V_p = [p,0;0,1]\)</span> and <span class="math">\(C_p = [a_p,p^{k-1};-1,0]\)</span>.
When <span class="math">\(p \not \| N\)</span> and <span class="math">\(a_p\)</span> is divisible by <span class="math">\(p\)</span>, <code class="docutils literal"><span class="pre">mstooms</span></code>
returns the lift <span class="math">\(\Phi\)</span> of <span class="math">\((\phi,\phi\|_k V_p)\)</span> such that</p>
<div class="math">
\[T_{N_0}(p) \Phi = C_p \Phi\]</div>
<p>When <span class="math">\(p \not \| N\)</span> and <span class="math">\(a_p\)</span> is not divisible by <span class="math">\(p\)</span>, <code class="docutils literal"><span class="pre">mstooms</span></code>
returns the lift <span class="math">\(\Phi\)</span> of <span class="math">\(\phi - \alpha^{-1} \phi\|_k V_p\)</span>
which is an eigenvector of <span class="math">\(T_{N_0}(p)\)</span> for the unit eigenvalue
where <span class="math">\(\alpha^2 - a_p \alpha + p^{k-1} = 0\)</span>.</p>
<p>The resulting overconvergent eigensymbol can then be used in
<code class="docutils literal"><span class="pre">mspadicmoments</span></code>, then <code class="docutils literal"><span class="pre">mspadicL</span></code> or <code class="docutils literal"><span class="pre">mspadicseries</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(3,6, 1); p = 5;
? Tp = mshecke(M, p); factor(charpoly(Tp))
%2 =
[x - 3126 2]

[ x - 6 1]
? phi = matker(Tp - 6)[,1] \\ generator of p-Eigenspace, a_p = 6
%3 = [5, -3, -1]~
? Mp = mspadicinit(M, p, 10, 0); \\ restrict to ordinary symbols, mod p^10
? PHI = mstooms(Mp, phi);
? mu = mspadicmoments(Mp, PHI);
? mspadicL(mu)
%7 = 5 + 2*5^2 + 2*5^3 + ...
</pre></div>
</div>
<p>A non ordinary symbol.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = msinit(4,6,1); p = 3;
? Tp = mshecke(M, p); factor(charpoly(Tp))
%2 =
[x - 244 3]

[ x + 12 1]
? phi = matker(Tp + 12)[,1] \\ a_p = -12 is divisible by p = 3
%3 = [-1/32, -1/4, -1/32, 1]~
? msissymbol(M,phi)
%4 = 1
? Mp = mspadicinit(M,3,5,0);
? PHI = mstooms(Mp,phi);
 *** at top-level: PHI=mstooms(Mp,phi)
 *** ^---------------
 *** mstooms: incorrect type in mstooms [v_p(ap) &gt; mspadicinit flag] (t_VEC).
? Mp = mspadicinit(M,3,5,1);
? PHI = mstooms(Mp,phi);
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.newtonpoly">
<code class="descname">newtonpoly</code><span class="sig-paren">(</span><em>x</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.newtonpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the vector of the slopes of the Newton
polygon of the polynomial <span class="math">\(x\)</span> with respect to the prime number <span class="math">\(p\)</span>. The <span class="math">\(n\)</span>
components of the vector are in decreasing order, where <span class="math">\(n\)</span> is equal to the
degree of <span class="math">\(x\)</span>. Vertical slopes occur iff the constant coefficient of <span class="math">\(x\)</span> is
zero and are denoted by <code class="docutils literal"><span class="pre">LONG_MAX</span></code>, the biggest single precision
integer representable on the machine (<span class="math">\(2^{31}-1\)</span> (resp.&nbsp;<span class="math">\(2^{63}-1\)</span>) on 32-bit
(resp.&nbsp;64-bit) machines), see <code class="docutils literal"><span class="pre">valuation</span></code> (in the PARI manual).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nextprime">
<code class="descname">nextprime</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nextprime" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the smallest pseudoprime (see
<code class="docutils literal"><span class="pre">ispseudoprime</span></code>) greater than or equal to <span class="math">\(x\)</span>. <span class="math">\(x\)</span> can be of any real
type. Note that if <span class="math">\(x\)</span> is a pseudoprime, this function returns <span class="math">\(x\)</span> and not
the smallest pseudoprime strictly larger than <span class="math">\(x\)</span>. To rigorously prove that
the result is prime, use <code class="docutils literal"><span class="pre">isprime</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfalgtobasis">
<code class="descname">nfalgtobasis</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfalgtobasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an algebraic number <span class="math">\(x\)</span> in the number field <span class="math">\(nf\)</span>,
transforms it to a column vector on the integral basis <code class="docutils literal"><span class="pre">:emphasis:`nf</span></code>.zk`.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2 + 4);
? nf.zk
%2 = [1, 1/2*y]
? nfalgtobasis(nf, [1,1]~)
%3 = [1, 1]~
? nfalgtobasis(nf, y)
%4 = [0, 2]~
? nfalgtobasis(nf, Mod(y, y^2+4))
%5 = [0, 2]~
</pre></div>
</div>
<p>This is the inverse function of <code class="docutils literal"><span class="pre">nfbasistoalg</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfbasistoalg">
<code class="descname">nfbasistoalg</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfbasistoalg" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an algebraic number <span class="math">\(x\)</span> in the number field <em>nf</em>, transforms it
into <code class="docutils literal"><span class="pre">t_POLMOD</span></code> form.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2 + 4);
? nf.zk
%2 = [1, 1/2*y]
? nfbasistoalg(nf, [1,1]~)
%3 = Mod(1/2*y + 1, y^2 + 4)
? nfbasistoalg(nf, y)
%4 = Mod(y, y^2 + 4)
? nfbasistoalg(nf, Mod(y, y^2+4))
%5 = Mod(y, y^2 + 4)
</pre></div>
</div>
<p>This is the inverse function of <code class="docutils literal"><span class="pre">nfalgtobasis</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfcertify">
<code class="descname">nfcertify</code><span class="sig-paren">(</span><em>nf</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfcertify" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(nf\)</span> being as output by
<code class="docutils literal"><span class="pre">nfinit</span></code>, checks whether the integer basis is known unconditionally.
This is in particular useful when the argument to <code class="docutils literal"><span class="pre">nfinit</span></code> was of the
form <span class="math">\([T, listP]\)</span>, specifying a finite list of primes when
<span class="math">\(p\)</span>-maximality had to be proven, or a list of coprime integers to which
Buchmann-Lenstra algorithm was to be applied.</p>
<p>The function returns a vector of coprime composite integers. If this vector
is empty, then <code class="docutils literal"><span class="pre">nf.zk</span></code> and <code class="docutils literal"><span class="pre">nf.disc</span></code> are correct. Otherwise, the
result is dubious. In order to obtain a certified result, one must completely
factor each of the given integers, then <code class="docutils literal"><span class="pre">addprime</span></code> each of their prime
factors, then check whether <code class="docutils literal"><span class="pre">nfdisc(nf.pol)</span></code> is equal to <code class="docutils literal"><span class="pre">nf.disc</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfcompositum">
<code class="descname">nfcompositum</code><span class="sig-paren">(</span><em>nf</em>, <em>P</em>, <em>Q</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfcompositum" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <em>nf</em> be a number field structure attached to the field <span class="math">\(K\)</span>
and let <span class="math">\(P\)</span> and <span class="math">\(Q\)</span>
be squarefree polynomials in <span class="math">\(K[X]\)</span> in the same variable. Outputs
the simple factors of the étale <span class="math">\(K\)</span>-algebra <span class="math">\(A = K[X, Y] / (P(X), Q(Y))\)</span>.
The factors are given by a list of polynomials <span class="math">\(R\)</span> in <span class="math">\(K[X]\)</span>, attached to
the number field <span class="math">\(K[X]/ (R)\)</span>, and sorted by increasing degree (with respect
to lexicographic ordering for factors of equal degrees). Returns an error if
one of the polynomials is not squarefree.</p>
<p>Note that it is more efficient to reduce to the case where <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are
irreducible first. The routine will not perform this for you, since it may be
expensive, and the inputs are irreducible in most applications anyway. In
this case, there will be a single factor <span class="math">\(R\)</span> if and only if the number
fields defined by <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are linearly disjoint (their intersection is
<span class="math">\(K\)</span>).</p>
<p>The binary digits of <span class="math">\(flag\)</span> mean</p>
<p>1: outputs a vector of 4-component vectors <span class="math">\([R,a,b,k]\)</span>, where <span class="math">\(R\)</span>
ranges through the list of all possible compositums as above, and <span class="math">\(a\)</span>
(resp. <span class="math">\(b\)</span>) expresses the root of <span class="math">\(P\)</span> (resp. <span class="math">\(Q\)</span>) as an element of
<span class="math">\(K[X]/(R)\)</span>. Finally, <span class="math">\(k\)</span> is a small integer such that <span class="math">\(b + ka = X\)</span> modulo
<span class="math">\(R\)</span>.</p>
<p>2: assume that <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> define number fields that are linearly disjoint:
both polynomials are irreducible and the corresponding number fields
have no common subfield besides <span class="math">\(K\)</span>. This allows to save a costly
factorization over <span class="math">\(K\)</span>. In this case return the single simple factor
instead of a vector with one element.</p>
<p>A compositum is often defined by a complicated polynomial, which it is
advisable to reduce before further work. Here is an example involving
the field <span class="math">\(K(\zeta_5, 5^{1/10})\)</span>, <span class="math">\(K = \mathbb{Q}(\sqrt{5})\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^2-5);
? L = nfcompositum(K, x^5 - y, polcyclo(5), 1); \\ list of [R,a,b,k]
? [R, a] = L[1]; \\ pick the single factor, extract R,a (ignore b,k)
? lift(R) \\ defines the compositum
%4 = x^10 + (-5/2*y + 5/2)*x^9 + (-5*y + 20)*x^8 + (-20*y + 30)*x^7 + \
(-45/2*y + 145/2)*x^6 + (-71/2*y + 121/2)*x^5 + (-20*y + 60)*x^4 + \
(-25*y + 5)*x^3 + 45*x^2 + (-5*y + 15)*x + (-2*y + 6)
? a^5 - y \\ a fifth root of y
%5 = 0
? [T, X] = rnfpolredbest(K, R, 1);
? lift(T) \\ simpler defining polynomial for K[x]/(R)
%7 = x^10 + (-11/2*y + 25/2)
? liftall(X) \\  root of R in K[x]/(T(x))
%8 = (3/4*y + 7/4)*x^7 + (-1/2*y - 1)*x^5 + 1/2*x^2 + (1/4*y - 1/4)
? a = subst(a.pol, &#39;x, X); \\ a in the new coordinates
? liftall(a)
%10 = (-3/4*y - 7/4)*x^7 - 1/2*x^2
? a^5 - y
%11 = 0
</pre></div>
</div>
<p>The main variables of <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> must be the same and have higher priority
than that of <em>nf</em> (see&nbsp;<code class="docutils literal"><span class="pre">varhigher</span></code> and&nbsp;<code class="docutils literal"><span class="pre">varlower</span></code>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfdetint">
<code class="descname">nfdetint</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfdetint" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a pseudo-matrix <span class="math">\(x\)</span>, computes a
non-zero ideal contained in (i.e.&nbsp;multiple of) the determinant of <span class="math">\(x\)</span>. This
is particularly useful in conjunction with <code class="docutils literal"><span class="pre">nfhnfmod</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfdisc">
<code class="descname">nfdisc</code><span class="sig-paren">(</span><em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfdisc" title="Permalink to this definition">¶</a></dt>
<dd><p>field discriminant of the number field defined by the integral,
preferably monic, irreducible polynomial <span class="math">\(T(X)\)</span>. Returns the discriminant of
the number field <span class="math">\(\mathbb{Q}[X]/(T)\)</span>, using the Round <span class="math">\(4\)</span> algorithm.</p>
<p><strong>Local discriminants, valuations at certain primes.</strong></p>
<p>As in <code class="docutils literal"><span class="pre">nfbasis</span></code>, the argument <span class="math">\(T\)</span> can be replaced by <span class="math">\([T,listP]\)</span>,
where <code class="docutils literal"><span class="pre">listP</span></code> is as in <code class="docutils literal"><span class="pre">nfbasis</span></code>: a vector of
pairwise coprime integers (usually distinct primes), a factorization matrix,
or a single integer. In that case, the function returns the discriminant of
an order whose basis is given by <code class="docutils literal"><span class="pre">nfbasis(T,listP)</span></code>, which need not be
the maximal order, and whose valuation at a prime entry in <code class="docutils literal"><span class="pre">listP</span></code> is the
same as the valuation of the field discriminant.</p>
<p>In particular, if <code class="docutils literal"><span class="pre">listP</span></code> is <span class="math">\([p]\)</span> for a prime <span class="math">\(p\)</span>, we can
return the <span class="math">\(p\)</span>-adic discriminant of the maximal order of <span class="math">\(\mathbb{Z}_p[X]/(T)\)</span>,
as a power of <span class="math">\(p\)</span>, as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? padicdisc(T,p) = p^valuation(nfdisc(T,[p]), p);
? nfdisc(x^2 + 6)
%2 = -24
? padicdisc(x^2 + 6, 2)
%3 = 8
? padicdisc(x^2 + 6, 3)
%4 = 3
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltadd">
<code class="descname">nfeltadd</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltadd" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in
<em>nf</em>, computes their sum <span class="math">\(x+y\)</span> in the number field <span class="math">\(nf\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltdiv">
<code class="descname">nfeltdiv</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in
<em>nf</em>, computes their quotient <span class="math">\(x/y\)</span> in the number field <span class="math">\(nf\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltdiveuc">
<code class="descname">nfeltdiveuc</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltdiveuc" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in
<em>nf</em>, computes an algebraic integer <span class="math">\(q\)</span> in the number field <span class="math">\(nf\)</span>
such that the components of <span class="math">\(x-qy\)</span> are reasonably small. In fact, this is
functionally identical to <code class="docutils literal"><span class="pre">round(nfdiv(:emphasis:`nf</span></code>,x,y))`.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltdivmodpr">
<code class="descname">nfeltdivmodpr</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>y</em>, <em>pr</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltdivmodpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span>
and <span class="math">\(y\)</span> in <em>nf</em> and <em>pr</em> a prime ideal in <code class="docutils literal"><span class="pre">modpr</span></code> format (see
<code class="docutils literal"><span class="pre">nfmodprinit</span></code>), computes their quotient <span class="math">\(x / y\)</span> modulo the prime ideal
<em>pr</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltdivrem">
<code class="descname">nfeltdivrem</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltdivrem" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in
<em>nf</em>, gives a two-element row vector <span class="math">\([q,r]\)</span> such that <span class="math">\(x = qy+r\)</span>, <span class="math">\(q\)</span> is
an algebraic integer in <span class="math">\(nf\)</span>, and the components of <span class="math">\(r\)</span> are
reasonably small.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltmod">
<code class="descname">nfeltmod</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in
<em>nf</em>, computes an element <span class="math">\(r\)</span> of <span class="math">\(nf\)</span> of the form <span class="math">\(r = x-qy\)</span> with
<span class="math">\(q\)</span> and algebraic integer, and such that <span class="math">\(r\)</span> is small. This is functionally
identical to</p>
<div class="math">
\[x - nfmul(nf,round(nfdiv(nf,x,y)),y).\]</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltmul">
<code class="descname">nfeltmul</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in
<em>nf</em>, computes their product <span class="math">\(x*y\)</span> in the number field <span class="math">\(nf\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltmulmodpr">
<code class="descname">nfeltmulmodpr</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>y</em>, <em>pr</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltmulmodpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two elements <span class="math">\(x\)</span> and
<span class="math">\(y\)</span> in <em>nf</em> and <em>pr</em> a prime ideal in <code class="docutils literal"><span class="pre">modpr</span></code> format (see
<code class="docutils literal"><span class="pre">nfmodprinit</span></code>), computes their product <span class="math">\(x*y\)</span> modulo the prime ideal
<em>pr</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltnorm">
<code class="descname">nfeltnorm</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the absolute norm of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltpow">
<code class="descname">nfeltpow</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(x\)</span> in <em>nf</em>, and a positive or negative integer <span class="math">\(k\)</span>,
computes <span class="math">\(x^k\)</span> in the number field <span class="math">\(nf\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltpowmodpr">
<code class="descname">nfeltpowmodpr</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>k</em>, <em>pr</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltpowmodpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(x\)</span> in <em>nf</em>, an integer <span class="math">\(k\)</span> and a prime ideal
<em>pr</em> in <code class="docutils literal"><span class="pre">modpr</span></code> format
(see <code class="docutils literal"><span class="pre">nfmodprinit</span></code>), computes <span class="math">\(x^k\)</span> modulo the prime ideal <em>pr</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltreduce">
<code class="descname">nfeltreduce</code><span class="sig-paren">(</span><em>nf</em>, <em>a</em>, <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltreduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an ideal <em>id</em> in
Hermite normal form and an element <span class="math">\(a\)</span> of the number field <span class="math">\(nf\)</span>,
finds an element <span class="math">\(r\)</span> in <span class="math">\(nf\)</span> such that <span class="math">\(a-r\)</span> belongs to the ideal
and <span class="math">\(r\)</span> is small.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfeltreducemodpr">
<code class="descname">nfeltreducemodpr</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>pr</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfeltreducemodpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an element <span class="math">\(x\)</span> of the number field <span class="math">\(nf\)</span> and a prime ideal
<em>pr</em> in <code class="docutils literal"><span class="pre">modpr</span></code> format compute a canonical representative for the
class of <span class="math">\(x\)</span> modulo <em>pr</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfelttrace">
<code class="descname">nfelttrace</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfelttrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the absolute trace of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nffactor">
<code class="descname">nffactor</code><span class="sig-paren">(</span><em>nf</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nffactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Factorization of the univariate
polynomial <span class="math">\(T\)</span> over the number field <span class="math">\(nf\)</span> given by <code class="docutils literal"><span class="pre">nfinit</span></code>; <span class="math">\(T\)</span>
has coefficients in <span class="math">\(nf\)</span> (i.e.&nbsp;either scalar, polmod, polynomial or
column vector). The factors are sorted by increasing degree.</p>
<p>The main variable of <span class="math">\(nf\)</span> must be of <em>lower</em>
priority than that of <span class="math">\(T\)</span>, see <code class="docutils literal"><span class="pre">priority</span></code> (in the PARI manual). However if
the polynomial defining the number field occurs explicitly in the
coefficients of <span class="math">\(T\)</span> as modulus of a <code class="docutils literal"><span class="pre">t_POLMOD</span></code> or as a <code class="docutils literal"><span class="pre">t_POL</span></code>
coefficient, its main variable must be <em>the same</em> as the main variable
of <span class="math">\(T\)</span>. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2 + 1);
? nffactor(nf, x^2 + y); \\ OK
? nffactor(nf, x^2 + Mod(y, y^2+1)); \\  OK
? nffactor(nf, x^2 + Mod(z, z^2+1)); \\  WRONG
</pre></div>
</div>
<p>It is possible to input a defining polynomial for <em>nf</em>
instead, but this is in general less efficient since parts of an <code class="docutils literal"><span class="pre">nf</span></code>
structure will then be computed internally. This is useful in two
situations: when you do not need the <code class="docutils literal"><span class="pre">nf</span></code> elsewhere, or when you cannot
compute the field discriminant due to integer factorization difficulties. In
the latter case, if you must use a partial discriminant factorization (as
allowed by both <code class="docutils literal"><span class="pre">nfdisc</span></code> or <code class="docutils literal"><span class="pre">nfbasis</span></code>) to build a partially correct
<code class="docutils literal"><span class="pre">nf</span></code> structure, always input <code class="docutils literal"><span class="pre">nf.pol</span></code> to <code class="docutils literal"><span class="pre">nffactor</span></code>, and not your
makeshift <em>nf</em>: otherwise factors could be missed.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nffactorback">
<code class="descname">nffactorback</code><span class="sig-paren">(</span><em>nf</em>, <em>f</em>, <em>e=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nffactorback" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives back the <em>nf</em> element corresponding to a factorization.
The integer <span class="math">\(1\)</span> corresponds to the empty factorization.</p>
<p>If <span class="math">\(e\)</span> is present, <span class="math">\(e\)</span> and <span class="math">\(f\)</span> must be vectors of the same length (<span class="math">\(e\)</span> being
integral), and the corresponding factorization is the product of the
<span class="math">\(f[i]^{e[i]}\)</span>.</p>
<p>If not, and <span class="math">\(f\)</span> is vector, it is understood as in the preceding case with <span class="math">\(e\)</span>
a vector of 1s: we return the product of the <span class="math">\(f[i]\)</span>. Finally, <span class="math">\(f\)</span> can be a
regular factorization matrix.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2+1);
? nffactorback(nf, [3, y+1, [1,2]~], [1, 2, 3])
%2 = [12, -66]~
? 3 * (I+1)^2 * (1+2*I)^3
%3 = 12 - 66*I
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nffactormod">
<code class="descname">nffactormod</code><span class="sig-paren">(</span><em>nf</em>, <em>Q</em>, <em>pr</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nffactormod" title="Permalink to this definition">¶</a></dt>
<dd><p>Factors the univariate polynomial <span class="math">\(Q\)</span> modulo the prime ideal <em>pr</em> in
the number field <span class="math">\(nf\)</span>. The coefficients of <span class="math">\(Q\)</span> belong to the number
field (scalar, polmod, polynomial, even column vector) and the main variable
of <span class="math">\(nf\)</span> must be of lower priority than that of <span class="math">\(Q\)</span> (see
<code class="docutils literal"><span class="pre">priority</span></code> (in the PARI manual)). The prime ideal <em>pr</em> is either in
<code class="docutils literal"><span class="pre">idealprimedec</span></code> or (preferred) <code class="docutils literal"><span class="pre">modprinit</span></code> format. The coefficients
of the polynomial factors are lifted to elements of <em>nf</em>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^2+1);
? P = idealprimedec(K, 3)[1];
? nffactormod(K, x^2 + y*x + 18*y+1, P)
%3 =
[x + (2*y + 1) 1]

[x + (2*y + 2) 1]
? P = nfmodprinit(K, P); \\ convert to nfmodprinit format
? nffactormod(K, x^2 + y*x + 18*y+1)
%5 =
[x + (2*y + 1) 1]

[x + (2*y + 2) 1]
</pre></div>
</div>
<p>Same result, of course, here about 10% faster due to the
precomputation.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfgaloisapply">
<code class="descname">nfgaloisapply</code><span class="sig-paren">(</span><em>nf</em>, <em>aut</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfgaloisapply" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(nf\)</span> be a
number field as output by <code class="docutils literal"><span class="pre">nfinit</span></code>, and let <em>aut</em> be a Galois
automorphism of <span class="math">\(nf\)</span> expressed by its image on the field generator
(such automorphisms can be found using <code class="docutils literal"><span class="pre">nfgaloisconj</span></code>). The function
computes the action of the automorphism <em>aut</em> on the object <span class="math">\(x\)</span> in the
number field; <span class="math">\(x\)</span> can be a number field element, or an ideal (possibly
extended). Because of possible confusion with elements and ideals, other
vector or matrix arguments are forbidden.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(x^2+1);
? L = nfgaloisconj(nf)
%2 = [-x, x]~
? aut = L[1]; /* the non-trivial automorphism */
? nfgaloisapply(nf, aut, x)
%4 = Mod(-x, x^2 + 1)
? P = idealprimedec(nf,5); /* prime ideals above 5 */
? nfgaloisapply(nf, aut, P[2]) == P[1]
%6 = 0 \\ !!!!
? idealval(nf, nfgaloisapply(nf, aut, P[2]), P[1])
%7 = 1
</pre></div>
</div>
<p>The surprising failure of the equality test (<code class="docutils literal"><span class="pre">%7</span></code>) is
due to the fact that although the corresponding prime ideals are equal, their
representations are not. (A prime ideal is specified by a uniformizer, and
there is no guarantee that applying automorphisms yields the same elements
as a direct <code class="docutils literal"><span class="pre">idealprimedec</span></code> call.)</p>
<p>The automorphism can also be given as a column vector, representing the
image of <code class="docutils literal"><span class="pre">Mod(x,</span> <span class="pre">nf.pol)</span></code> as an algebraic number. This last
representation is more efficient and should be preferred if a given
automorphism must be used in many such calls.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(x^3 - 37*x^2 + 74*x - 37);
? l = nfgaloisconj(nf); aut = l[2] \\  automorphisms in basistoalg form
%2 = -31/11*x^2 + 1109/11*x - 925/11
? L = matalgtobasis(nf, l); AUT = L[2] \\  same in algtobasis form
%3 = [16, -6, 5]~
? v = [1, 2, 3]~; nfgaloisapply(nf, aut, v) == nfgaloisapply(nf, AUT, v)
%4 = 1 \\  same result...
? for (i=1,10^5, nfgaloisapply(nf, aut, v))
time = 1,451 ms.
? for (i=1,10^5, nfgaloisapply(nf, AUT, v))
time = 1,045 ms. \\  but the latter is faster
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfgaloisconj">
<code class="descname">nfgaloisconj</code><span class="sig-paren">(</span><em>nf</em>, <em>flag=0</em>, <em>d=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfgaloisconj" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(nf\)</span> being a number field as output by <code class="docutils literal"><span class="pre">nfinit</span></code>, computes the
conjugates of a root <span class="math">\(r\)</span> of the non-constant polynomial <span class="math">\(x = nf[1]\)</span>
expressed as polynomials in <span class="math">\(r\)</span>. This also makes sense when the number field
is not Galois since some conjugates may lie in the field.
<span class="math">\(nf\)</span> can simply be a polynomial.</p>
<p>If no flags or <span class="math">\(flag = 0\)</span>, use a combination of flag <span class="math">\(4\)</span> and <span class="math">\(1\)</span> and the result
is always complete. There is no point whatsoever in using the other flags.</p>
<p>If <span class="math">\(flag = 1\)</span>, use <code class="docutils literal"><span class="pre">nfroots</span></code>: a little slow, but guaranteed to work in
polynomial time.</p>
<p>If <span class="math">\(flag = 2\)</span> (OBSOLETE), use complex approximations to the roots and an integral
LLL. The result is not guaranteed to be complete: some
conjugates may be missing (a warning is issued if the result is not proved
complete), especially so if the corresponding polynomial has a huge index,
and increasing the default precision may help. This variant is slow and
unreliable: don&#8217;t use it.</p>
<p>If <span class="math">\(flag = 4\)</span>, use <code class="docutils literal"><span class="pre">galoisinit</span></code>: very fast, but only applies to (most) Galois
fields. If the field is Galois with weakly
super-solvable Galois group (see <code class="docutils literal"><span class="pre">galoisinit</span></code>), return the complete list
of automorphisms, else only the identity element. If present, <span class="math">\(d\)</span> is assumed to
be a multiple of the least common denominator of the conjugates expressed as
polynomial in a root of <em>pol</em>.</p>
<p>This routine can only compute <span class="math">\(\mathbb{Q}\)</span>-automorphisms, but it may be used to get
<span class="math">\(K\)</span>-automorphism for any base field <span class="math">\(K\)</span> as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">rnfgaloisconj</span><span class="p">(</span><span class="n">nfK</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span> <span class="o">=</span> \\ <span class="n">K</span><span class="o">-</span><span class="n">automorphisms</span> <span class="n">of</span> <span class="n">L</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span>
<span class="p">{</span>
 <span class="n">my</span><span class="p">(</span><span class="n">polabs</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span><span class="n">al</span><span class="p">,</span><span class="n">S</span><span class="p">,</span> <span class="n">ala</span><span class="p">,</span><span class="n">k</span><span class="p">,</span> <span class="n">vR</span><span class="p">);</span>
 <span class="n">R</span> <span class="o">*=</span> <span class="n">Mod</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nfK</span><span class="o">.</span><span class="n">pol</span><span class="p">);</span> \\ <span class="n">convert</span> <span class="n">coeffs</span> <span class="n">to</span> <span class="n">polmod</span> <span class="n">elts</span> <span class="n">of</span> <span class="n">K</span>
 <span class="n">vR</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">R</span><span class="p">);</span>
 <span class="n">al</span> <span class="o">=</span> <span class="n">Mod</span><span class="p">(</span><span class="n">variable</span><span class="p">(</span><span class="n">nfK</span><span class="o">.</span><span class="n">pol</span><span class="p">),</span><span class="n">nfK</span><span class="o">.</span><span class="n">pol</span><span class="p">);</span>
 <span class="p">[</span><span class="n">polabs</span><span class="p">,</span><span class="n">ala</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">rnfequation</span><span class="p">(</span><span class="n">nfK</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
 <span class="n">Rt</span> <span class="o">=</span> <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">subst</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">vR</span><span class="p">,</span><span class="n">vR</span><span class="o">-</span><span class="n">al</span><span class="o">*</span><span class="n">k</span><span class="p">));</span>
 <span class="n">N</span> <span class="o">=</span> <span class="n">nfgaloisconj</span><span class="p">(</span><span class="n">polabs</span><span class="p">)</span> <span class="o">%</span> <span class="n">Rt</span><span class="p">;</span> \\ <span class="n">Q</span><span class="o">-</span><span class="n">automorphisms</span> <span class="n">of</span> <span class="n">L</span>
 <span class="n">S</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">subst</span><span class="p">(</span><span class="n">Rt</span><span class="p">,</span> <span class="n">vR</span><span class="p">,</span> <span class="n">Mod</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">Rt</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">apply</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">subst</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">vR</span><span class="p">,</span><span class="n">vR</span><span class="o">+</span><span class="n">k</span><span class="o">*</span><span class="n">al</span><span class="p">)</span><span class="o">-</span><span class="n">k</span><span class="o">*</span><span class="n">al</span><span class="p">,</span><span class="n">S</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">nfinit</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">rnfgaloisconj</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="n">y</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> \\ <span class="n">K</span><span class="o">-</span><span class="n">automorphisms</span> <span class="n">of</span> <span class="n">L</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfgrunwaldwang">
<code class="descname">nfgrunwaldwang</code><span class="sig-paren">(</span><em>nf</em>, <em>Lpr</em>, <em>Ld</em>, <em>pl</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfgrunwaldwang" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <em>nf</em> a number field in <em>nf</em> or <em>bnf</em> format,
a <code class="docutils literal"><span class="pre">t_VEC</span></code> <em>Lpr</em> of primes of <em>nf</em> and a <code class="docutils literal"><span class="pre">t_VEC</span></code> <em>Ld</em> of
positive integers of the same length, a <code class="docutils literal"><span class="pre">t_VECSMALL</span></code> <em>pl</em> of length
<span class="math">\(r_1\)</span> the number of real places of <em>nf</em>, computes a polynomial with
coefficients in <em>nf</em> defining a cyclic extension of <em>nf</em> of
minimal degree satisfying certain local conditions:</p>
<ul class="simple">
<li>at the prime <code class="docutils literal"><span class="pre">Lpr[i]</span></code>, the extension has local degree a multiple of
<code class="docutils literal"><span class="pre">Ld[i]</span></code>;</li>
<li>at the <span class="math">\(i\)</span>-th real place of <em>nf</em>, it is complex if <span class="math">\(pl[i] = -1\)</span>
(no condition if <span class="math">\(pl[i] = 0\)</span>).</li>
</ul>
<p>The extension has degree the LCM of the local degrees. Currently, the degree
is restricted to be a prime power for the search, and to be prime for the
construction because of the <code class="docutils literal"><span class="pre">rnfkummer</span></code> restrictions.</p>
<p>When <em>nf</em> is <span class="math">\(\mathbb{Q}\)</span>, prime integers are accepted instead of <code class="docutils literal"><span class="pre">prid</span></code>
structures. However, their primality is not checked and the behaviour is
undefined if you provide a composite number.</p>
<p><strong>Warning.</strong> If the number field <em>nf</em> does not contain the <span class="math">\(n\)</span>-th
roots of unity where <span class="math">\(n\)</span> is the degree of the extension to be computed,
triggers the computation of the <em>bnf</em> of <span class="math">\(nf(\zeta_n)\)</span>, which may be
costly.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2-5);
? pr = idealprimedec(nf,13)[1];
? pol = nfgrunwaldwang(nf, [pr], [2], [0,-1], &#39;x)
%3 = x^2 + Mod(3/2*y + 13/2, y^2 - 5)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfhilbert">
<code class="descname">nfhilbert</code><span class="sig-paren">(</span><em>nf</em>, <em>a</em>, <em>b</em>, <em>pr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfhilbert" title="Permalink to this definition">¶</a></dt>
<dd><p>If <em>pr</em> is omitted,
compute the global quadratic Hilbert symbol <span class="math">\((a,b)\)</span> in <span class="math">\(nf\)</span>, that
is <span class="math">\(1\)</span> if <span class="math">\(x^2 - a y^2 - b z^2\)</span> has a non trivial solution <span class="math">\((x,y,z)\)</span> in
<span class="math">\(nf\)</span>, and <span class="math">\(-1\)</span> otherwise. Otherwise compute the local symbol modulo
the prime ideal <em>pr</em>, as output by <code class="docutils literal"><span class="pre">idealprimedec</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfhnf">
<code class="descname">nfhnf</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfhnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a pseudo-matrix <span class="math">\((A,I)\)</span>, finds a
pseudo-basis <span class="math">\((B,J)\)</span> in Hermite normal form of the module it generates.
If <span class="math">\(flag\)</span> is non-zero, also return the transformation matrix <span class="math">\(U\)</span> such that
<span class="math">\(AU = [0\|B]\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfhnfmod">
<code class="descname">nfhnfmod</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>detx</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfhnfmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a pseudo-matrix <span class="math">\((A,I)\)</span>
and an ideal <em>detx</em> which is contained in (read integral multiple of) the
determinant of <span class="math">\((A,I)\)</span>, finds a pseudo-basis in Hermite normal form
of the module generated by <span class="math">\((A,I)\)</span>. This avoids coefficient explosion.
<em>detx</em> can be computed using the function <code class="docutils literal"><span class="pre">nfdetint</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfinit">
<code class="descname">nfinit</code><span class="sig-paren">(</span><em>pol</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfinit" title="Permalink to this definition">¶</a></dt>
<dd><p><em>pol</em> being a non-constant,
preferably monic, irreducible polynomial in <span class="math">\(\mathbb{Z}[X]\)</span>, initializes a
<em>number field</em> structure (<code class="docutils literal"><span class="pre">nf</span></code>) associated to the field <span class="math">\(K\)</span> defined
by <em>pol</em>. As such, it&#8217;s a technical object passed as the first argument
to most <code class="docutils literal"><span class="pre">nf</span></code><em>xxx</em> functions, but it contains some information which
may be directly useful. Access to this information via <em>member
functions</em> is preferred since the specific data organization specified below
may change in the future. Currently, <code class="docutils literal"><span class="pre">nf</span></code> is a row vector with 9
components:</p>
<p><span class="math">\(nf[1]\)</span> contains the polynomial <em>pol</em> (<code class="docutils literal"><span class="pre">:emphasis:`nf</span></code>.pol`).</p>
<p><span class="math">\(nf[2]\)</span> contains <span class="math">\([r1,r2]\)</span> (<code class="docutils literal"><span class="pre">:emphasis:`nf</span></code>.sign`, <code class="docutils literal"><span class="pre">:emphasis:`nf</span></code>.r1`,
<code class="docutils literal"><span class="pre">:emphasis:`nf</span></code>.r2`), the number of real and complex places of <span class="math">\(K\)</span>.</p>
<p><span class="math">\(nf[3]\)</span> contains the discriminant <span class="math">\(d(K)\)</span> (<code class="docutils literal"><span class="pre">:emphasis:`nf</span></code>.disc`) of <span class="math">\(K\)</span>.</p>
<p><span class="math">\(nf[4]\)</span> contains the index of <span class="math">\(nf[1]\)</span> (<code class="docutils literal"><span class="pre">:emphasis:`nf</span></code>.index`),
i.e.&nbsp;<span class="math">\([\mathbb{Z}_K : \mathbb{Z}[\theta]]\)</span>, where <span class="math">\(\theta\)</span> is any root of <span class="math">\(nf[1]\)</span>.</p>
<p><span class="math">\(nf[5]\)</span> is a vector containing 7 matrices <span class="math">\(M\)</span>, <span class="math">\(G\)</span>, <em>roundG</em>, <span class="math">\(T\)</span>,
<span class="math">\(MD\)</span>, <span class="math">\(TI\)</span>, <span class="math">\(MDI\)</span> useful for certain computations in the number field <span class="math">\(K\)</span>.</p>
<p>&nbsp;&nbsp;<strong>*</strong> <span class="math">\(M\)</span> is the <span class="math">\((r1+r2) x n\)</span> matrix whose columns represent
the numerical values of the conjugates of the elements of the integral
basis.</p>
<p>&nbsp;&nbsp;<strong>*</strong> <span class="math">\(G\)</span> is an <span class="math">\(n x n\)</span> matrix such that <span class="math">\(T2 = ^t G G\)</span>,
where <span class="math">\(T2\)</span> is the quadratic form <span class="math">\(T_2(x) = \sum \|\sigma(x)\|^2\)</span>, <span class="math">\(\sigma\)</span>
running over the embeddings of <span class="math">\(K\)</span> into <span class="math">\(\mathbb{C}\)</span>.</p>
<p>&nbsp;&nbsp;<strong>*</strong> <em>roundG</em> is a rescaled copy of <span class="math">\(G\)</span>, rounded to nearest
integers.</p>
<p>&nbsp;&nbsp;<strong>*</strong> <span class="math">\(T\)</span> is the <span class="math">\(n x n\)</span> matrix whose coefficients are
<span class="math">\({Tr}(\omega_i\omega_j)\)</span> where the <span class="math">\(\omega_i\)</span> are the elements of the
integral basis. Note also that <span class="math">\(\det(T)\)</span> is equal to the discriminant of the
field <span class="math">\(K\)</span>. Also, when understood as an ideal, the matrix <span class="math">\(T^{-1}\)</span>
generates the codifferent ideal.</p>
<p>&nbsp;&nbsp;<strong>*</strong> The columns of <span class="math">\(MD\)</span> (<code class="docutils literal"><span class="pre">:emphasis:`nf</span></code>.diff`) express a <span class="math">\(\mathbb{Z}\)</span>-basis
of the different of <span class="math">\(K\)</span> on the integral basis.</p>
<p>&nbsp;&nbsp;<strong>*</strong> <span class="math">\(TI\)</span> is equal to the primitive part of <span class="math">\(T^{-1}\)</span>, which has integral
coefficients.</p>
<p>&nbsp;&nbsp;<strong>*</strong> Finally, <span class="math">\(MDI\)</span> is a two-element representation (for faster
ideal product) of <span class="math">\(d(K)\)</span> times the codifferent ideal
(<code class="docutils literal"><span class="pre">:emphasis:`nf</span></code>.disc:math:<span class="math">\(*\)</span><em>nf</em>.codiff`, which is an integral ideal). <span class="math">\(MDI\)</span>
is only used in <code class="docutils literal"><span class="pre">idealinv</span></code>.</p>
<p><span class="math">\(nf[6]\)</span> is the vector containing the <span class="math">\(r1+r2\)</span> roots
(<code class="docutils literal"><span class="pre">:emphasis:`nf</span></code>.roots`) of <span class="math">\(nf[1]\)</span> corresponding to the <span class="math">\(r1+r2\)</span>
embeddings of the number field into <span class="math">\(\mathbb{C}\)</span> (the first <span class="math">\(r1\)</span> components are real,
the next <span class="math">\(r2\)</span> have positive imaginary part).</p>
<p><span class="math">\(nf[7]\)</span> is an integral basis for <span class="math">\(\mathbb{Z}_K\)</span> (<code class="docutils literal"><span class="pre">:emphasis:`nf</span></code>.zk`) expressed
on the powers of&nbsp;<span class="math">\(\theta\)</span>. Its first element is guaranteed to be <span class="math">\(1\)</span>. This
basis is LLL-reduced with respect to <span class="math">\(T_2\)</span> (strictly speaking, it is a
permutation of such a basis, due to the condition that the first element be
<span class="math">\(1\)</span>).</p>
<p><span class="math">\(nf[8]\)</span> is the <span class="math">\(n x n\)</span> integral matrix expressing the power
basis in terms of the integral basis, and finally</p>
<p><span class="math">\(nf[9]\)</span> is the <span class="math">\(n x n^2\)</span> matrix giving the multiplication table
of the integral basis.</p>
<p>If a non monic polynomial is input, <code class="docutils literal"><span class="pre">nfinit</span></code> will transform it into a
monic one, then reduce it (see <span class="math">\(flag = 3\)</span>). It is allowed, though not very
useful given the existence of <code class="docutils literal"><span class="pre">nfnewprec</span></code>, to input a <em>nf</em> or a
<em>bnf</em> instead of a polynomial. It is also allowed to
input a <em>rnf</em>, in which case an <code class="docutils literal"><span class="pre">nf</span></code> structure associated to the
absolute defining polynomial <code class="docutils literal"><span class="pre">polabs</span></code> is returned (<em>flag</em> is then ignored).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(x^3 - 12); \\ initialize number field Q[X] / (X^3 - 12)
? nf.pol \\ defining polynomial
%2 = x^3 - 12
? nf.disc \\ field discriminant
%3 = -972
? nf.index \\ index of power basis order in maximal order
%4 = 2
? nf.zk \\ integer basis, lifted to Q[X]
%5 = [1, x, 1/2*x^2]
? nf.sign \\ signature
%6 = [1, 1]
? factor(abs(nf.disc )) \\ determines ramified primes
%7 =
[2 2]

[3 5]
? idealfactor(nf, 2)
%8 =
[[2, [0, 0, -1]~, 3, 1, [0, 1, 0]~] 3] \\  p_2^3
</pre></div>
</div>
<p><strong>Huge discriminants, helping nfdisc.</strong></p>
<p>In case <em>pol</em> has a huge discriminant which is difficult to factor,
it is hard to compute from scratch the maximal order. The special input
format <span class="math">\([pol, B]\)</span> is also accepted where <em>pol</em> is a polynomial as
above and <span class="math">\(B\)</span> has one of the following forms</p>
<ul class="simple">
<li>an integer basis, as would be computed by <code class="docutils literal"><span class="pre">nfbasis</span></code>: a vector of
polynomials with first element <span class="math">\(1\)</span>. This is useful if the maximal order is
known in advance.</li>
<li>an argument <code class="docutils literal"><span class="pre">listP</span></code> which specifies a list of primes (see
<code class="docutils literal"><span class="pre">nfbasis</span></code>). Instead of the maximal order, <code class="docutils literal"><span class="pre">nfinit</span></code> then computes an
order which is maximal at these particular primes as well as the primes
contained in the private prime table (see <code class="docutils literal"><span class="pre">addprimes</span></code>). The result is
unconditionaly correct when the discriminant <code class="docutils literal"><span class="pre">nf.disc</span></code> factors
completely over this set of primes. The function <code class="docutils literal"><span class="pre">nfcertify</span></code> automates
this:</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? pol = polcompositum(x^5 - 101, polcyclo(7))[1];
? nf = nfinit( [pol, 10^3] );
? nfcertify(nf)
%3 = []
</pre></div>
</div>
<p>A priori, <code class="docutils literal"><span class="pre">nf.zk</span></code> defines an order which is only known
to be maximal at all primes <span class="math">\(&lt;= 10^3\)</span> (no prime <span class="math">\(&lt;= 10^3\)</span> divides
<code class="docutils literal"><span class="pre">nf.index</span></code>). The certification step proves the correctness of the
computation.</p>
<p>If <span class="math">\(flag = 2\)</span>: <em>pol</em> is changed into another polynomial <span class="math">\(P\)</span> defining the same
number field, which is as simple as can easily be found using the
<code class="docutils literal"><span class="pre">polredbest</span></code> algorithm, and all the subsequent computations are done
using this new polynomial. In particular, the first component of the result
is the modified polynomial.</p>
<p>If <span class="math">\(flag = 3\)</span>, apply <code class="docutils literal"><span class="pre">polredbest</span></code> as in case 2, but outputs
<span class="math">\([nf,Mod(a,P)]\)</span>, where <span class="math">\(nf\)</span> is as before and
<span class="math">\(Mod(a,P) = Mod(x,pol)\)</span> gives the change of
variables. This is implicit when <em>pol</em> is not monic: first a linear change
of variables is performed, to get a monic polynomial, then <code class="docutils literal"><span class="pre">polredbest</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfisideal">
<code class="descname">nfisideal</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfisideal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if <span class="math">\(x\)</span> is an ideal in the number field <span class="math">\(nf\)</span>, 0 otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfisincl">
<code class="descname">nfisincl</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfisincl" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the number field <span class="math">\(K\)</span> defined
by the polynomial <span class="math">\(x\)</span> is conjugate to a subfield of the field <span class="math">\(L\)</span> defined
by <span class="math">\(y\)</span> (where <span class="math">\(x\)</span> and <span class="math">\(y\)</span> must be in <span class="math">\(\mathbb{Q}[X]\)</span>). If they are not, the output
is the number 0. If they are, the output is a vector of polynomials, each
polynomial <span class="math">\(a\)</span> representing an embedding of <span class="math">\(K\)</span> into <span class="math">\(L\)</span>, i.e.&nbsp;being such
that <span class="math">\(y \| x o a\)</span>.</p>
<p>If <span class="math">\(y\)</span> is a number field (<em>nf</em>), a much faster algorithm is used
(factoring <span class="math">\(x\)</span> over <span class="math">\(y\)</span> using <code class="docutils literal"><span class="pre">nffactor</span></code>). Before version 2.0.14, this
wasn&#8217;t guaranteed to return all the embeddings, hence was triggered by a
special flag. This is no more the case.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfisisom">
<code class="descname">nfisisom</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfisisom" title="Permalink to this definition">¶</a></dt>
<dd><p>As <code class="docutils literal"><span class="pre">nfisincl</span></code>, but tests for isomorphism. If either <span class="math">\(x\)</span> or <span class="math">\(y\)</span> is a
number field, a much faster algorithm will be used.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfkermodpr">
<code class="descname">nfkermodpr</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>pr</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfkermodpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel of the matrix <span class="math">\(a\)</span> in <span class="math">\(\mathbb{Z}_K/pr\)</span>, where <em>pr</em> is in
<strong>modpr</strong> format (see <code class="docutils literal"><span class="pre">nfmodprinit</span></code>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfmodprinit">
<code class="descname">nfmodprinit</code><span class="sig-paren">(</span><em>nf</em>, <em>pr</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfmodprinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the prime ideal <em>pr</em> into <code class="docutils literal"><span class="pre">modpr</span></code> format necessary
for all operations modulo <em>pr</em> in the number field <em>nf</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfnewprec">
<code class="descname">nfnewprec</code><span class="sig-paren">(</span><em>nf</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfnewprec" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the number field <span class="math">\(nf\)</span>
into the corresponding data using current (usually larger) precision. This
function works as expected if <em>nf</em> is in fact a <em>bnf</em> or a <em>bnr</em>
(update structure to current precision) but may be quite slow: many
generators of principal ideals have to be computed; note that in this latter
case, the <em>bnf</em> must contain fundamental units.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfroots">
<code class="descname">nfroots</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfroots" title="Permalink to this definition">¶</a></dt>
<dd><p>Roots of the polynomial <span class="math">\(x\)</span> in the
number field <span class="math">\(nf\)</span> given by <code class="docutils literal"><span class="pre">nfinit</span></code> without multiplicity (in <span class="math">\(\mathbb{Q}\)</span>
if <span class="math">\(nf\)</span> is omitted). <span class="math">\(x\)</span> has coefficients in the number field (scalar,
polmod, polynomial, column vector). The main variable of <span class="math">\(nf\)</span> must be
of lower priority than that of <span class="math">\(x\)</span> (see <code class="docutils literal"><span class="pre">priority</span></code> (in the PARI manual)). However if the
coefficients of the number field occur explicitly (as polmods) as
coefficients of <span class="math">\(x\)</span>, the variable of these polmods <em>must</em> be the same as
the main variable of <span class="math">\(t\)</span> (see <code class="docutils literal"><span class="pre">nffactor</span></code>).</p>
<p>It is possible to input a defining polynomial for <em>nf</em>
instead, but this is in general less efficient since parts of an <code class="docutils literal"><span class="pre">nf</span></code>
structure will be computed internally. This is useful in two situations: when
you don&#8217;t need the <code class="docutils literal"><span class="pre">nf</span></code>, or when you can&#8217;t compute its discriminant due
to integer factorization difficulties. In the latter case, <code class="docutils literal"><span class="pre">addprimes</span></code> is
a possibility but a dangerous one: roots will probably be missed if the
(true) field discriminant and an <code class="docutils literal"><span class="pre">addprimes</span></code> entry are strictly divisible
by some prime. If you have such an unsafe <em>nf</em>, it is safer to input
<code class="docutils literal"><span class="pre">nf.pol</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfrootsof1">
<code class="descname">nfrootsof1</code><span class="sig-paren">(</span><em>nf</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfrootsof1" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a two-component vector <span class="math">\([w,z]\)</span> where <span class="math">\(w\)</span> is the number of roots of
unity in the number field <em>nf</em>, and <span class="math">\(z\)</span> is a primitive <span class="math">\(w\)</span>-th root
of unity.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(polcyclo(11));
? nfrootsof1(K)
%2 = [22, [0, 0, 0, 0, 0, -1, 0, 0, 0, 0]~]
? z = nfbasistoalg(K, %[2]) \\ in algebraic form
%3 = Mod(-x^5, x^10 + x^9 + x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1)
? [lift(z^11), lift(z^2)] \\ proves that the order of z is 22
%4 = [-1, -x^9 - x^8 - x^7 - x^6 - x^5 - x^4 - x^3 - x^2 - x - 1]
</pre></div>
</div>
<p>This function guesses the number <span class="math">\(w\)</span> as the gcd of the <span class="math">\(\#k(v)^*\)</span> for
unramified <span class="math">\(v\)</span> above odd primes, then computes the roots in <em>nf</em>
of the <span class="math">\(w\)</span>-th cyclotomic polynomial: the algorithm is polynomial time with
respect to the field degree and the bitsize of the multiplication table in
<em>nf</em> (both of them polynomially bounded in terms of the size of the
discriminant). Fields of degree up to <span class="math">\(100\)</span> or so should require less than
one minute.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfsnf">
<code class="descname">nfsnf</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfsnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a torsion <span class="math">\(\mathbb{Z}_K\)</span>-module <span class="math">\(x\)</span> associated to the square integral
invertible pseudo-matrix <span class="math">\((A,I,J)\)</span>, returns an ideal list
<span class="math">\(D = [d_1,...,d_n]\)</span> which is the Smith normal form of <span class="math">\(x\)</span>. In other
words, <span class="math">\(x\)</span> is isomorphic to <span class="math">\(\mathbb{Z}_K/d_1\oplus...\oplus\mathbb{Z}_K/d_n\)</span> and <span class="math">\(d_i\)</span>
divides <span class="math">\(d_{i-1}\)</span> for <span class="math">\(i &gt;= 2\)</span>. If <span class="math">\(flag\)</span> is non-zero return <span class="math">\([D,U,V]\)</span>, where
<span class="math">\(UAV\)</span> is the identity.</p>
<p>See <code class="docutils literal"><span class="pre">ZKmodules</span></code> (in the PARI manual) for the definition of integral pseudo-matrix;
briefly, it is input as a 3-component row vector <span class="math">\([A,I,J]\)</span> where
<span class="math">\(I = [b_1,...,b_n]\)</span> and <span class="math">\(J = [a_1,...,a_n]\)</span> are two ideal lists,
and <span class="math">\(A\)</span> is a square <span class="math">\(n x n\)</span> matrix with columns <span class="math">\((A_1,...,A_n)\)</span>,
seen as elements in <span class="math">\(K^n\)</span> (with canonical basis <span class="math">\((e_1,...,e_n)\)</span>).
This data defines the <span class="math">\(\mathbb{Z}_K\)</span> module <span class="math">\(x\)</span> given by</p>
<div class="math">
\[(b_1e_1\oplus...\oplus b_ne_n) / (a_1A_1\oplus...\oplus a_nA_n)
,\]</div>
<p>The integrality condition is <span class="math">\(a_{i,j} belongs to b_i a_j^{-1}\)</span> for all <span class="math">\(i,j\)</span>. If it
is not satisfied, then the <span class="math">\(d_i\)</span> will not be integral. Note that every
finitely generated torsion module is isomorphic to a module of this form and
even with <span class="math">\(b_i = Z_K\)</span> for all <span class="math">\(i\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfsolvemodpr">
<code class="descname">nfsolvemodpr</code><span class="sig-paren">(</span><em>nf</em>, <em>a</em>, <em>b</em>, <em>P</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfsolvemodpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(P\)</span> be a prime ideal in <strong>modpr</strong> format (see <code class="docutils literal"><span class="pre">nfmodprinit</span></code>),
let <span class="math">\(a\)</span> be a matrix, invertible over the residue field, and let <span class="math">\(b\)</span> be
a column vector or matrix. This function returns a solution of <span class="math">\(a.x = 
b\)</span>; the coefficients of <span class="math">\(x\)</span> are lifted to <em>nf</em> elements.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^2+1);
? P = idealprimedec(K, 3)[1];
? P = nfmodprinit(K, P);
? a = [y+1, y; y, 0]; b = [1, y]~
? nfsolvemodpr(K, a,b, P)
%5 = [1, 2]~
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfsplitting">
<code class="descname">nfsplitting</code><span class="sig-paren">(</span><em>nf</em>, <em>d=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfsplitting" title="Permalink to this definition">¶</a></dt>
<dd><p>Defining polynomial over&nbsp;<span class="math">\(\mathbb{Q}\)</span> for the splitting field of <em>nf</em>;
if <span class="math">\(d\)</span> is given, it must be a multiple of the splitting field degree.
Instead of&nbsp;<code class="docutils literal"><span class="pre">nf</span></code>, it is possible to input a defining (irreducible)
polynomial <span class="math">\(T\)</span> for&nbsp;<code class="docutils literal"><span class="pre">nf</span></code>, but in general this is less efficient.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(x^3-2);
? nfsplitting(K)
%2 = x^6 + 108
? nfsplitting(x^8-2)
%3 = x^16 + 272*x^8 + 64
</pre></div>
</div>
<p>Specifying the degree of the splitting field can make the computation faster.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nfsplitting(x^17-123);
time = 3,607 ms.
? poldegree(%)
%2 = 272
? nfsplitting(x^17-123,272);
time = 150 ms.
? nfsplitting(x^17-123,273);
 *** nfsplitting: Warning: ignoring incorrect degree bound 273
time = 3,611 ms.
</pre></div>
</div>
<p>The complexity of the algorithm is polynomial in the degree <span class="math">\(d\)</span> of the
splitting field and the bitsize of <span class="math">\(T\)</span>; if <span class="math">\(d\)</span> is large the result will
likely be unusable, e.g. <code class="docutils literal"><span class="pre">nfinit</span></code> will not be an option:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nfsplitting(x^6-x-1)
[... degree 720 polynomial deleted ...]
time = 11,020 ms.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.nfsubfields">
<code class="descname">nfsubfields</code><span class="sig-paren">(</span><em>pol</em>, <em>d=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.nfsubfields" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all subfields of degree
<span class="math">\(d\)</span> of the number field defined by the (monic, integral) polynomial
<em>pol</em> (all subfields if <span class="math">\(d\)</span> is null or omitted). The result is a vector
of subfields, each being given by <span class="math">\([g,h]\)</span>, where <span class="math">\(g\)</span> is an absolute equation
and <span class="math">\(h\)</span> expresses one of the roots of <span class="math">\(g\)</span> in terms of the root <span class="math">\(x\)</span> of the
polynomial defining <span class="math">\(nf\)</span>. This routine uses J.&nbsp;Klüners&#8217;s algorithm
in the general case, and B.&nbsp;Allombert&#8217;s <code class="docutils literal"><span class="pre">galoissubfields</span></code> when <em>nf</em>
is Galois (with weakly supersolvable Galois group).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.norm">
<code class="descname">norm</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebraic norm of <span class="math">\(x\)</span>, i.e.&nbsp;the product of <span class="math">\(x\)</span> with
its conjugate (no square roots are taken), or conjugates for polmods. For
vectors and matrices, the norm is taken componentwise and hence is not the
<span class="math">\(L^2\)</span>-norm (see <code class="docutils literal"><span class="pre">norml2</span></code>). Note that the norm of an element of
<span class="math">\(\mathbb{R}\)</span> is its square, so as to be compatible with the complex norm.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.norml2">
<code class="descname">norml2</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.norml2" title="Permalink to this definition">¶</a></dt>
<dd><p>Square of the <span class="math">\(L^2\)</span>-norm of <span class="math">\(x\)</span>. More precisely,
if <span class="math">\(x\)</span> is a scalar, <span class="math">\(norml2(x)\)</span> is defined to be the square
of the complex modulus of <span class="math">\(x\)</span> (real <code class="docutils literal"><span class="pre">t_QUAD</span></code>&nbsp;s are not supported).
If <span class="math">\(x\)</span> is a polynomial, a (row or column) vector or a matrix, <code class="docutils literal"><span class="pre">norml2(:math:`x</span></code>)` is
defined recursively as <span class="math">\(\sum_i norml2(x_i)\)</span>, where <span class="math">\((x_i)\)</span> run through
the components of <span class="math">\(x\)</span>. In particular, this yields the usual <span class="math">\(\sum \|x_i\|^2\)</span>
(resp.&nbsp;<span class="math">\(\sum \|x_{i,j}\|^2\)</span>) if <span class="math">\(x\)</span> is a polynomial or vector (resp.&nbsp;matrix) with
complex components.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? norml2( [ 1, 2, 3 ] ) \\ vector
%1 = 14
? norml2( [ 1, 2; 3, 4] ) \\ matrix
%2 = 30
? norml2( 2*I + x )
%3 = 5
? norml2( [ [1,2], [3,4], 5, 6 ] ) \\ recursively defined
%4 = 91
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.normlp">
<code class="descname">normlp</code><span class="sig-paren">(</span><em>x</em>, <em>p=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.normlp" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(L^p\)</span>-norm of <span class="math">\(x\)</span>; sup norm if <span class="math">\(p\)</span> is omitted. More precisely,
if <span class="math">\(x\)</span> is a scalar, <code class="docutils literal"><span class="pre">normlp</span></code><span class="math">\((x, p)\)</span> is defined to be <code class="docutils literal"><span class="pre">abs</span></code><span class="math">\((x)\)</span>.
If <span class="math">\(x\)</span> is a polynomial, a (row or column) vector or a matrix:</p>
<ul class="simple">
<li>if <span class="math">\(p\)</span> is omitted, <code class="docutils literal"><span class="pre">normlp(:math:`x</span></code>)` is defined recursively as
<span class="math">\(\max_i normlp(x_i))\)</span>, where <span class="math">\((x_i)\)</span> run through the components of&nbsp;<span class="math">\(x\)</span>.
In particular, this yields the usual sup norm if <span class="math">\(x\)</span> is a polynomial or
vector with complex components.</li>
<li>otherwise, <code class="docutils literal"><span class="pre">normlp(:math:`x</span></code>, <span class="math">\(p\)</span>)` is defined recursively as <span class="math">\((\sum_i
normlp^p(x_i,p))^{1/p}\)</span>. In particular, this yields the usual <span class="math">\((\sum
|x_i|^p)^{1/p}\)</span> if <span class="math">\(x\)</span> is a polynomial or vector with complex components.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? v = [1,-2,3]; normlp(v) \\ vector
%1 = 3
? M = [1,-2;-3,4]; normlp(M) \\ matrix
%2 = 4
? T = (1+I) + I*x^2; normlp(T)
%3 = 1.4142135623730950488016887242096980786
? normlp([[1,2], [3,4], 5, 6]) \\ recursively defined
%4 = 6

? normlp(v, 1)
%5 = 6
? normlp(M, 1)
%6 = 10
? normlp(T, 1)
%7 = 2.4142135623730950488016887242096980786
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.numbpart">
<code class="descname">numbpart</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.numbpart" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the number of unrestricted partitions of
<span class="math">\(n\)</span>, usually called <span class="math">\(p(n)\)</span> in the literature; in other words the number of
nonnegative integer solutions to <span class="math">\(a+2b+3c+.. .= n\)</span>. <span class="math">\(n\)</span> must be of type
integer and <span class="math">\(n &lt; 10^{15}\)</span> (with trivial values <span class="math">\(p(n) = 0\)</span> for <span class="math">\(n &lt; 0\)</span> and
<span class="math">\(p(0) = 1\)</span>). The algorithm uses the Hardy-Ramanujan-Rademacher formula.
To explicitly enumerate them, see <code class="docutils literal"><span class="pre">partitions</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.numdiv">
<code class="descname">numdiv</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.numdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of divisors of <span class="math">\(\|x\|\)</span>. <span class="math">\(x\)</span> must be of type integer.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.numerator">
<code class="descname">numerator</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.numerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerator of <span class="math">\(x\)</span>. The meaning of this
is clear when <span class="math">\(x\)</span> is a rational number or function. If <span class="math">\(x\)</span> is an integer
or a polynomial, it is treated as a rational number or function,
respectively, and the result is <span class="math">\(x\)</span> itself. For polynomials, you
probably want to use</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">numerator</span><span class="p">(</span> <span class="n">content</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>instead.</p>
<p>In other cases, <code class="docutils literal"><span class="pre">numerator(x)</span></code> is defined to be
<code class="docutils literal"><span class="pre">denominator(x)*x</span></code>. This is the case when <span class="math">\(x\)</span> is a vector or a
matrix, but also for <code class="docutils literal"><span class="pre">t_COMPLEX</span></code> or <code class="docutils literal"><span class="pre">t_QUAD</span></code>. In particular since a
<code class="docutils literal"><span class="pre">t_PADIC</span></code> or <code class="docutils literal"><span class="pre">t_INTMOD</span></code> has denominator <span class="math">\(1\)</span>, its numerator is
itself.</p>
<p><strong>Warning.</strong> Multivariate objects are created according to variable
priorities, with possibly surprising side effects (<span class="math">\(x/y\)</span> is a polynomial, but
<span class="math">\(y/x\)</span> is a rational function). See <code class="docutils literal"><span class="pre">priority</span></code> (in the PARI manual).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.omega">
<code class="descname">omega</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.omega" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of distinct prime divisors of <span class="math">\(\|x\|\)</span>. <span class="math">\(x\)</span> must be of type integer.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? factor(392)
%1 =
[2 3]

[7 2]

? omega(392)
%2 = 2; \\ without multiplicity
? bigomega(392)
%3 = 5; \\ = 3+2, with multiplicity
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.padicappr">
<code class="descname">padicappr</code><span class="sig-paren">(</span><em>pol</em>, <em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.padicappr" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector of <span class="math">\(p\)</span>-adic roots of the
polynomial <span class="math">\(pol\)</span> congruent to the <span class="math">\(p\)</span>-adic number <span class="math">\(a\)</span> modulo <span class="math">\(p\)</span>, and with
the same <span class="math">\(p\)</span>-adic precision as <span class="math">\(a\)</span>. The number <span class="math">\(a\)</span> can be an ordinary
<span class="math">\(p\)</span>-adic number (type <code class="docutils literal"><span class="pre">t_PADIC</span></code>, i.e.&nbsp;an element of <span class="math">\(\mathbb{Z}_p\)</span>) or can be an
integral element of a finite extension of <span class="math">\(\mathbb{Q}_p\)</span>, given as a <code class="docutils literal"><span class="pre">t_POLMOD</span></code>
at least one of whose coefficients is a <code class="docutils literal"><span class="pre">t_PADIC</span></code>. In this case, the result
is the vector of roots belonging to the same extension of <span class="math">\(\mathbb{Q}_p\)</span> as <span class="math">\(a\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.padicfields">
<code class="descname">padicfields</code><span class="sig-paren">(</span><em>p</em>, <em>N</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.padicfields" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of polynomials generating all the extensions of degree
<span class="math">\(N\)</span> of the field <span class="math">\(\mathbb{Q}_p\)</span> of <span class="math">\(p\)</span>-adic rational numbers; <span class="math">\(N\)</span> is
allowed to be a 2-component vector <span class="math">\([n,d]\)</span>, in which case we return the
extensions of degree <span class="math">\(n\)</span> and discriminant <span class="math">\(p^d\)</span>.</p>
<p>The list is minimal in the sense that two different polynomials generate
non-isomorphic extensions; in particular, the number of polynomials is the
number of classes of non-isomorphic extensions. If <span class="math">\(P\)</span> is a polynomial in this
list, <span class="math">\(\alpha\)</span> is any root of <span class="math">\(P\)</span> and <span class="math">\(K = \mathbb{Q}_p(\alpha)\)</span>, then <span class="math">\(\alpha\)</span>
is the sum of a uniformizer and a (lift of a) generator of the residue field
of <span class="math">\(K\)</span>; in particular, the powers of <span class="math">\(\alpha\)</span> generate the ring of <span class="math">\(p\)</span>-adic
integers of <span class="math">\(K\)</span>.</p>
<p>If <span class="math">\(flag = 1\)</span>, replace each polynomial <span class="math">\(P\)</span> by a vector <span class="math">\([P, e, f, d, c]\)</span>
where <span class="math">\(e\)</span> is the ramification index, <span class="math">\(f\)</span> the residual degree, <span class="math">\(d\)</span> the
valuation of the discriminant, and <span class="math">\(c\)</span> the number of conjugate fields.
If <span class="math">\(flag = 2\)</span>, only return the <em>number</em> of extensions in a fixed
algebraic closure (Krasner&#8217;s formula), which is much faster.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.padicprec">
<code class="descname">padicprec</code><span class="sig-paren">(</span><em>x</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.padicprec" title="Permalink to this definition">¶</a></dt>
<dd><p>Absolute <span class="math">\(p\)</span>-adic precision of the object <span class="math">\(x\)</span>. This is the minimum
precision of the components of <span class="math">\(x\)</span>. The result is <code class="docutils literal"><span class="pre">LONG_MAX</span></code>
(<span class="math">\(2^{31}-1\)</span> for 32-bit machines or <span class="math">\(2^{63}-1\)</span> for 64-bit machines) if <span class="math">\(x\)</span> is
an exact object.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.parapply">
<code class="descname">parapply</code><span class="sig-paren">(</span><em>f</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.parapply" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel evaluation of <code class="docutils literal"><span class="pre">f</span></code> on the elements of <code class="docutils literal"><span class="pre">x</span></code>.
The function <code class="docutils literal"><span class="pre">f</span></code> must not access global variables or variables
declared with local(), and must be free of side effects.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parapply</span><span class="p">(</span><span class="n">factor</span><span class="p">,[</span><span class="mi">2</span><span class="o">^</span><span class="mi">256</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">^</span><span class="mi">193</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>factors <span class="math">\(2^{256} + 1\)</span> and <span class="math">\(2^{193} - 1\)</span> in parallel.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span>
 <span class="n">my</span><span class="p">(</span><span class="n">E</span> <span class="o">=</span> <span class="n">ellinit</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">V</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">randomprime</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">200</span><span class="p">)));</span>
 <span class="n">parapply</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ellcard</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">p</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>computes the order of <span class="math">\(E(\mathbb{F}_p)\)</span> for <span class="math">\(12\)</span> random primes of <span class="math">\(200\)</span> bits.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.pareval">
<code class="descname">pareval</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.pareval" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel evaluation of the elements of <code class="docutils literal"><span class="pre">x</span></code>, where <code class="docutils literal"><span class="pre">x</span></code> is a
vector of closures. The closures must be of arity <span class="math">\(0\)</span>, must not access
global variables or variables declared with <code class="docutils literal"><span class="pre">local</span></code> and must be
free of side effects.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.parselect">
<code class="descname">parselect</code><span class="sig-paren">(</span><em>f</em>, <em>A</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.parselect" title="Permalink to this definition">¶</a></dt>
<dd><p>Selects elements of <span class="math">\(A\)</span> according to the selection function <span class="math">\(f\)</span>, done in
parallel. If <em>flag</em> is <span class="math">\(1\)</span>, return the indices of those elements (indirect
selection) The function <code class="docutils literal"><span class="pre">f</span></code> must not access global variables or
variables declared with local(), and must be free of side effects.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.permtonum">
<code class="descname">permtonum</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.permtonum" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a permutation <span class="math">\(x\)</span> on <span class="math">\(n\)</span> elements, gives the number <span class="math">\(k\)</span> such that
<span class="math">\(x = numtoperm(n,k)\)</span>, i.e.&nbsp;inverse function of <code class="docutils literal"><span class="pre">numtoperm</span></code>.
The numbering used is the standard lexicographic ordering, starting at <span class="math">\(0\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polclass">
<code class="descname">polclass</code><span class="sig-paren">(</span><em>D</em>, <em>inv=-1</em>, <em>x=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polclass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Hilbert class polynomial for the imaginary quadratic
discriminant <span class="math">\(D\)</span> in the variable <span class="math">\(x\)</span>. If <span class="math">\(inv\)</span> is 0 (the default),
use the modular <span class="math">\(j\)</span> function, if <span class="math">\(inv\)</span> is 1 use the
Weber-<span class="math">\(f\)</span> function, and if <span class="math">\(inv\)</span> is 5, use <span class="math">\(\gamma_2 = 
\sqrt[3]{j}\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? polclass(-163)
%1 = x + 262537412640768000
? polclass(-51, , &#39;z)
%2 = z^2 + 5541101568*z + 6262062317568
? polclass(-151,1)
x^7 - x^6 + x^5 + 3*x^3 - x^2 + 3*x + 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polcoeff">
<code class="descname">polcoeff</code><span class="sig-paren">(</span><em>x</em>, <em>n</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polcoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Coefficient of degree <span class="math">\(n\)</span> of the polynomial <span class="math">\(x\)</span>, with respect to the
main variable if <span class="math">\(v\)</span> is omitted, with respect to <span class="math">\(v\)</span> otherwise. If <span class="math">\(n\)</span>
is greater than the degree, the result is zero.</p>
<p>Naturally applies to scalars (polynomial of degree <span class="math">\(0\)</span>), as well as to
rational functions whose denominator is a monomial.
It also applies to power series: if <span class="math">\(n\)</span> is less than the valuation, the result
is zero. If it is greater than the largest significant degree, then an error
message is issued.</p>
<p>For greater flexibility, <span class="math">\(x\)</span> can be a vector or matrix type and the
function then returns <code class="docutils literal"><span class="pre">component(x,n)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polcompositum">
<code class="descname">polcompositum</code><span class="sig-paren">(</span><em>P</em>, <em>Q</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polcompositum" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(P\)</span> and <span class="math">\(Q\)</span>
being squarefree polynomials in <span class="math">\(\mathbb{Z}[X]\)</span> in the same variable, outputs
the simple factors of the étale <span class="math">\(\mathbb{Q}\)</span>-algebra <span class="math">\(A = \mathbb{Q}(X, Y) / (P(X), Q(Y))\)</span>.
The factors are given by a list of polynomials <span class="math">\(R\)</span> in <span class="math">\(\mathbb{Z}[X]\)</span>, associated to
the number field <span class="math">\(\mathbb{Q}(X)/ (R)\)</span>, and sorted by increasing degree (with respect
to lexicographic ordering for factors of equal degrees). Returns an error if
one of the polynomials is not squarefree.</p>
<p>Note that it is more efficient to reduce to the case where <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are
irreducible first. The routine will not perform this for you, since it may be
expensive, and the inputs are irreducible in most applications anyway. In
this case, there will be a single factor <span class="math">\(R\)</span> if and only if the number
fields defined by <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are linearly disjoint (their intersection is
<span class="math">\(\mathbb{Q}\)</span>).</p>
<p>Assuming <span class="math">\(P\)</span> is irreducible (of smaller degree than <span class="math">\(Q\)</span> for efficiency), it
is in general much faster to proceed as follows</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">nf</span> <span class="o">=</span> <span class="n">nfinit</span><span class="p">(</span><span class="n">P</span><span class="p">);</span> <span class="n">L</span> <span class="o">=</span> <span class="n">nffactor</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">Q</span><span class="p">)[,</span><span class="mi">1</span><span class="p">];</span>
<span class="n">vector</span><span class="p">(</span><span class="c1">#L, i, rnfequation(nf, L[i]))</span>
</pre></div>
</div>
<p>to obtain the same result. If you are only interested in the degrees of the
simple factors, the <code class="docutils literal"><span class="pre">rnfequation</span></code> instruction can be replaced by a
trivial <code class="docutils literal"><span class="pre">poldegree(P)</span> <span class="pre">*</span> <span class="pre">poldegree(L[i])</span></code>.</p>
<p>The binary digits of <span class="math">\(flag\)</span> mean</p>
<p>1: outputs a vector of 4-component vectors <span class="math">\([R,a,b,k]\)</span>, where <span class="math">\(R\)</span>
ranges through the list of all possible compositums as above, and <span class="math">\(a\)</span>
(resp. <span class="math">\(b\)</span>) expresses the root of <span class="math">\(P\)</span> (resp. <span class="math">\(Q\)</span>) as an element of
<span class="math">\(\mathbb{Q}(X)/(R)\)</span>. Finally, <span class="math">\(k\)</span> is a small integer such that <span class="math">\(b + ka = X\)</span> modulo
<span class="math">\(R\)</span>.</p>
<p>2: assume that <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> define number fields which are linearly disjoint:
both polynomials are irreducible and the corresponding number fields
have no common subfield besides <span class="math">\(\mathbb{Q}\)</span>. This allows to save a costly
factorization over <span class="math">\(\mathbb{Q}\)</span>. In this case return the single simple factor
instead of a vector with one element.</p>
<p>A compositum is often defined by a complicated polynomial, which it is
advisable to reduce before further work. Here is an example involving
the field <span class="math">\(\mathbb{Q}(\zeta_5, 5^{1/5})\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? L = polcompositum(x^5 - 5, polcyclo(5), 1); \\ list of [R,a,b,k]
? [R, a] = L[1]; \\ pick the single factor, extract R,a (ignore b,k)
? R \\ defines the compositum
%3 = x^20 + 5*x^19 + 15*x^18 + 35*x^17 + 70*x^16 + 141*x^15 + 260*x^14\
+ 355*x^13 + 95*x^12 - 1460*x^11 - 3279*x^10 - 3660*x^9 - 2005*x^8 \
+ 705*x^7 + 9210*x^6 + 13506*x^5 + 7145*x^4 - 2740*x^3 + 1040*x^2 \
- 320*x + 256
? a^5 - 5 \\ a fifth root of 5
%4 = 0
? [T, X] = polredbest(R, 1);
? T \\ simpler defining polynomial for Q[x]/(R)
%6 = x^20 + 25*x^10 + 5
? X \\  root of R in Q[y]/(T(y))
%7 = Mod(-1/11*x^15 - 1/11*x^14 + 1/22*x^10 - 47/22*x^5 - 29/11*x^4 + 7/22,\
x^20 + 25*x^10 + 5)
? a = subst(a.pol, &#39;x, X) \\ a in the new coordinates
%8 = Mod(1/11*x^14 + 29/11*x^4, x^20 + 25*x^10 + 5)
? a^5 - 5
%9 = 0
</pre></div>
</div>
<p>In the above example, <span class="math">\(x^5-5\)</span> and the <span class="math">\(5\)</span>-th cyclotomic
polynomial are irreducible over <span class="math">\(\mathbb{Q}\)</span>; they have coprime degrees so
define linearly disjoint extensions and we could have started by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? [R,a] = polcompositum(x^5 - 5, polcyclo(5), 3); \\ [R,a,b,k]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polcyclofactors">
<code class="descname">polcyclofactors</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polcyclofactors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of polynomials, whose product is the product of
distinct cyclotomic polynomials dividing <span class="math">\(f\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? f = x^10+5*x^8-x^7+8*x^6-4*x^5+8*x^4-3*x^3+7*x^2+3;
? v = polcyclofactors(f)
%2 = [x^2 + 1, x^2 + x + 1, x^4 - x^3 + x^2 - x + 1]
? apply(poliscycloprod, v)
%3 = [1, 1, 1]
? apply(poliscyclo, v)
%4 = [4, 3, 10]
</pre></div>
</div>
<p>In general, the polynomials are products of cyclotomic
polynomials and not themselves irreducible:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? g = x^8+2*x^7+6*x^6+9*x^5+12*x^4+11*x^3+10*x^2+6*x+3;
? polcyclofactors(g)
%2 = [x^6 + 2*x^5 + 3*x^4 + 3*x^3 + 3*x^2 + 2*x + 1]
? factor(%[1])
%3 =
[ x^2 + x + 1 1]

[x^4 + x^3 + x^2 + x + 1 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.poldegree">
<code class="descname">poldegree</code><span class="sig-paren">(</span><em>x</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.poldegree" title="Permalink to this definition">¶</a></dt>
<dd><p>Degree of the polynomial <span class="math">\(x\)</span> in the main variable if <span class="math">\(v\)</span> is omitted, in
the variable <span class="math">\(v\)</span> otherwise.</p>
<p>The degree of <span class="math">\(0\)</span> is <code class="docutils literal"><span class="pre">-oo</span></code>. The degree of a non-zero scalar is <span class="math">\(0\)</span>.
Finally, when <span class="math">\(x\)</span> is a non-zero polynomial or rational function, returns the
ordinary degree of <span class="math">\(x\)</span>. Raise an error otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.poldisc">
<code class="descname">poldisc</code><span class="sig-paren">(</span><em>pol</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.poldisc" title="Permalink to this definition">¶</a></dt>
<dd><p>Discriminant of the polynomial
<em>pol</em> in the main variable if <span class="math">\(v\)</span> is omitted, in <span class="math">\(v\)</span> otherwise. Uses a
modular algorithm over <span class="math">\(\mathbb{Z}\)</span> or <span class="math">\(\mathbb{Q}\)</span>, and the subresultant algorithm
otherwise.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? T = x^4 + 2*x+1;
? poldisc(T)
%2 = -176
? poldisc(T^2)
%3 = 0
</pre></div>
</div>
<p>For convenience, the function also applies to types <code class="docutils literal"><span class="pre">t_QUAD</span></code> and
<code class="docutils literal"><span class="pre">t_QFI</span></code>/<code class="docutils literal"><span class="pre">t_QFR</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? z = 3*quadgen(8) + 4;
? poldisc(z)
%2 = 8
? q = Qfb(1,2,3);
? poldisc(q)
%4 = -8
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.poldiscreduced">
<code class="descname">poldiscreduced</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.poldiscreduced" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduced discriminant vector of the
(integral, monic) polynomial <span class="math">\(f\)</span>. This is the vector of elementary divisors
of <span class="math">\(\mathbb{Z}[\alpha]/f'(\alpha)\mathbb{Z}[\alpha]\)</span>, where <span class="math">\(\alpha\)</span> is a root of the
polynomial <span class="math">\(f\)</span>. The components of the result are all positive, and their
product is equal to the absolute value of the discriminant of&nbsp;<span class="math">\(f\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polgalois">
<code class="descname">polgalois</code><span class="sig-paren">(</span><em>T</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polgalois" title="Permalink to this definition">¶</a></dt>
<dd><p>Galois group of the non-constant
polynomial <span class="math">\(T belongs to \mathbb{Q}[X]\)</span>. In the present version <strong>2.8.0</strong>, <span class="math">\(T\)</span> must be irreducible
and the degree <span class="math">\(d\)</span> of <span class="math">\(T\)</span> must be less than or equal to 7. If the
<code class="docutils literal"><span class="pre">galdata</span></code> package has been installed, degrees 8, 9, 10 and 11 are also
implemented. By definition, if <span class="math">\(K = \mathbb{Q}[x]/(T)\)</span>, this computes the action of
the Galois group of the Galois closure of <span class="math">\(K\)</span> on the <span class="math">\(d\)</span> distinct roots of
<span class="math">\(T\)</span>, up to conjugacy (corresponding to different root orderings).</p>
<p>The output is a 4-component vector <span class="math">\([n,s,k,name]\)</span> with the
following meaning: <span class="math">\(n\)</span> is the cardinality of the group, <span class="math">\(s\)</span> is its signature
(<span class="math">\(s = 1\)</span> if the group is a subgroup of the alternating group <span class="math">\(A_d\)</span>, <span class="math">\(s = -1\)</span>
otherwise) and name is a character string containing name of the transitive
group according to the GAP 4 transitive groups library by Alexander Hulpke.</p>
<p><span class="math">\(k\)</span> is more arbitrary and the choice made up to version&nbsp;2.2.3 of PARI is rather
unfortunate: for <span class="math">\(d &gt; 7\)</span>, <span class="math">\(k\)</span> is the numbering of the group among all
transitive subgroups of <span class="math">\(S_d\)</span>, as given in &#8220;The transitive groups of degree up
to eleven&#8221;, G.&nbsp;Butler and J.&nbsp;McKay, <em>Communications in Algebra</em>, vol.&nbsp;11,
1983,
pp.&nbsp;863&#8211;911 (group <span class="math">\(k\)</span> is denoted <span class="math">\(T_k\)</span> there). And for <span class="math">\(d &lt;= 7\)</span>, it was ad
hoc, so as to ensure that a given triple would denote a unique group.
Specifically, for polynomials of degree <span class="math">\(d &lt;= 7\)</span>, the groups are coded as
follows, using standard notations</p>
<p>In degree 1: <span class="math">\(S_1 = [1,1,1]\)</span>.</p>
<p>In degree 2: <span class="math">\(S_2 = [2,-1,1]\)</span>.</p>
<p>In degree 3: <span class="math">\(A_3 = C_3 = [3,1,1]\)</span>, <span class="math">\(S_3 = [6,-1,1]\)</span>.</p>
<p>In degree 4: <span class="math">\(C_4 = [4,-1,1]\)</span>, <span class="math">\(V_4 = [4,1,1]\)</span>, <span class="math">\(D_4 = [8,-1,1]\)</span>, <span class="math">\(A_4 = [12,1,1]\)</span>,
<span class="math">\(S_4 = [24,-1,1]\)</span>.</p>
<p>In degree 5: <span class="math">\(C_5 = [5,1,1]\)</span>, <span class="math">\(D_5 = [10,1,1]\)</span>, <span class="math">\(M_{20} = [20,-1,1]\)</span>,
<span class="math">\(A_5 = [60,1,1]\)</span>, <span class="math">\(S_5 = [120,-1,1]\)</span>.</p>
<p>In degree 6: <span class="math">\(C_6 = [6,-1,1]\)</span>, <span class="math">\(S_3 = [6,-1,2]\)</span>, <span class="math">\(D_6 = [12,-1,1]\)</span>, <span class="math">\(A_4 = [12,1,1]\)</span>,
<span class="math">\(G_{18} = [18,-1,1]\)</span>, <span class="math">\(S_4^ -= [24,-1,1]\)</span>, <span class="math">\(A_4 x C_2 = [24,-1,2]\)</span>,
<span class="math">\(S_4^ += [24,1,1]\)</span>, <span class="math">\(G_{36}^ -= [36,-1,1]\)</span>, <span class="math">\(G_{36}^ += [36,1,1]\)</span>,
<span class="math">\(S_4 x C_2 = [48,-1,1]\)</span>, <span class="math">\(A_5 = PSL_2(5) = [60,1,1]\)</span>, <span class="math">\(G_{72} = [72,-1,1]\)</span>,
<span class="math">\(S_5 = PGL_2(5) = [120,-1,1]\)</span>, <span class="math">\(A_6 = [360,1,1]\)</span>, <span class="math">\(S_6 = [720,-1,1]\)</span>.</p>
<p>In degree 7: <span class="math">\(C_7 = [7,1,1]\)</span>, <span class="math">\(D_7 = [14,-1,1]\)</span>, <span class="math">\(M_{21} = [21,1,1]\)</span>,
<span class="math">\(M_{42} = [42,-1,1]\)</span>, <span class="math">\(PSL_2(7) = PSL_3(2) = [168,1,1]\)</span>, <span class="math">\(A_7 = [2520,1,1]\)</span>,
<span class="math">\(S_7 = [5040,-1,1]\)</span>.</p>
<p>This is deprecated and obsolete, but for reasons of backward compatibility,
we cannot change this behavior yet. So you can use the default
<code class="docutils literal"><span class="pre">new_galois_format</span></code> to switch to a consistent naming scheme, namely <span class="math">\(k\)</span> is
always the standard numbering of the group among all transitive subgroups of
<span class="math">\(S_n\)</span>. If this default is in effect, the above groups will be coded as:</p>
<p>In degree 1: <span class="math">\(S_1 = [1,1,1]\)</span>.</p>
<p>In degree 2: <span class="math">\(S_2 = [2,-1,1]\)</span>.</p>
<p>In degree 3: <span class="math">\(A_3 = C_3 = [3,1,1]\)</span>, <span class="math">\(S_3 = [6,-1,2]\)</span>.</p>
<p>In degree 4: <span class="math">\(C_4 = [4,-1,1]\)</span>, <span class="math">\(V_4 = [4,1,2]\)</span>, <span class="math">\(D_4 = [8,-1,3]\)</span>, <span class="math">\(A_4 = [12,1,4]\)</span>,
<span class="math">\(S_4 = [24,-1,5]\)</span>.</p>
<p>In degree 5: <span class="math">\(C_5 = [5,1,1]\)</span>, <span class="math">\(D_5 = [10,1,2]\)</span>, <span class="math">\(M_{20} = [20,-1,3]\)</span>,
<span class="math">\(A_5 = [60,1,4]\)</span>, <span class="math">\(S_5 = [120,-1,5]\)</span>.</p>
<p>In degree 6: <span class="math">\(C_6 = [6,-1,1]\)</span>, <span class="math">\(S_3 = [6,-1,2]\)</span>, <span class="math">\(D_6 = [12,-1,3]\)</span>, <span class="math">\(A_4 = [12,1,4]\)</span>,
<span class="math">\(G_{18} = [18,-1,5]\)</span>, <span class="math">\(A_4 x C_2 = [24,-1,6]\)</span>, <span class="math">\(S_4^ += [24,1,7]\)</span>,
<span class="math">\(S_4^ -= [24,-1,8]\)</span>, <span class="math">\(G_{36}^ -= [36,-1,9]\)</span>, <span class="math">\(G_{36}^ += [36,1,10]\)</span>,
<span class="math">\(S_4 x C_2 = [48,-1,11]\)</span>, <span class="math">\(A_5 = PSL_2(5) = [60,1,12]\)</span>, <span class="math">\(G_{72} = [72,-1,13]\)</span>,
<span class="math">\(S_5 = PGL_2(5) = [120,-1,14]\)</span>, <span class="math">\(A_6 = [360,1,15]\)</span>, <span class="math">\(S_6 = [720,-1,16]\)</span>.</p>
<p>In degree 7: <span class="math">\(C_7 = [7,1,1]\)</span>, <span class="math">\(D_7 = [14,-1,2]\)</span>, <span class="math">\(M_{21} = [21,1,3]\)</span>,
<span class="math">\(M_{42} = [42,-1,4]\)</span>, <span class="math">\(PSL_2(7) = PSL_3(2) = [168,1,5]\)</span>, <span class="math">\(A_7 = [2520,1,6]\)</span>,
<span class="math">\(S_7 = [5040,-1,7]\)</span>.</p>
<p><strong>Warning.</strong> The method used is that of resolvent polynomials and is
sensitive to the current precision. The precision is updated internally but,
in very rare cases, a wrong result may be returned if the initial precision
was not sufficient.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polgraeffe">
<code class="descname">polgraeffe</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polgraeffe" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Graeffe transform <span class="math">\(g\)</span> of <span class="math">\(f\)</span>, such that <span class="math">\(g(x^2) = f(x)
f(-x)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polhensellift">
<code class="descname">polhensellift</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>p</em>, <em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polhensellift" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a prime <span class="math">\(p\)</span>, an integral polynomial <span class="math">\(A\)</span> whose leading coefficient
is a <span class="math">\(p\)</span>-unit, a vector <span class="math">\(B\)</span> of integral polynomials that are monic and
pairwise relatively prime modulo <span class="math">\(p\)</span>, and whose product is congruent to
<span class="math">\(A/{lc}(A)\)</span> modulo <span class="math">\(p\)</span>, lift the elements of <span class="math">\(B\)</span> to polynomials whose
product is congruent to <span class="math">\(A\)</span> modulo <span class="math">\(p^e\)</span>.</p>
<p>More generally, if <span class="math">\(T\)</span> is an integral polynomial irreducible mod <span class="math">\(p\)</span>, and
<span class="math">\(B\)</span> is a factorization of <span class="math">\(A\)</span> over the finite field <span class="math">\(\mathbb{F}_p[t]/(T)\)</span>, you can
lift it to <span class="math">\(\mathbb{Z}_p[t]/(T, p^e)\)</span> by replacing the <span class="math">\(p\)</span> argument with <span class="math">\([p,T]\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? { T = t^3 - 2; p = 7; A = x^2 + t + 1;
 B = [x + (3*t^2 + t + 1), x + (4*t^2 + 6*t + 6)];
 r = polhensellift(A, B, [p, T], 6) }
%1 = [x + (20191*t^2 + 50604*t + 75783), x + (97458*t^2 + 67045*t + 41866)]
? liftall( r[1] * r[2] * Mod(Mod(1,p^6),T) )
%2 = x^2 + (t + 1)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.poliscyclo">
<code class="descname">poliscyclo</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.poliscyclo" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 0 if <span class="math">\(f\)</span> is not a cyclotomic polynomial, and <span class="math">\(n &gt; 0\)</span> if <span class="math">\(f = 
\Phi_n\)</span>, the <span class="math">\(n\)</span>-th cyclotomic polynomial.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? poliscyclo(x^4-x^2+1)
%1 = 12
? polcyclo(12)
%2 = x^4 - x^2 + 1
? poliscyclo(x^4-x^2-1)
%3 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.poliscycloprod">
<code class="descname">poliscycloprod</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.poliscycloprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if <span class="math">\(f\)</span> is a product of cyclotomic polynomial, and <span class="math">\(0\)</span>
otherwise.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? f = x^6+x^5-x^3+x+1;
? poliscycloprod(f)
%2 = 1
? factor(f)
%3 =
[ x^2 + x + 1 1]

[x^4 - x^2 + 1 1]
? [ poliscyclo(T) | T &lt;- %[,1] ]
%4 = [3, 12]
? polcyclo(3) * polcyclo(12)
%5 = x^6 + x^5 - x^3 + x + 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polisirreducible">
<code class="descname">polisirreducible</code><span class="sig-paren">(</span><em>pol</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polisirreducible" title="Permalink to this definition">¶</a></dt>
<dd><p><em>pol</em> being a polynomial (univariate in the present version <strong>2.8.0</strong>),
returns 1 if <em>pol</em> is non-constant and irreducible, 0 otherwise.
Irreducibility is checked over the smallest base field over which <em>pol</em>
seems to be defined.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.pollead">
<code class="descname">pollead</code><span class="sig-paren">(</span><em>x</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.pollead" title="Permalink to this definition">¶</a></dt>
<dd><p>Leading coefficient of the polynomial or power series <span class="math">\(x\)</span>. This is
computed with respect to the main variable of <span class="math">\(x\)</span> if <span class="math">\(v\)</span> is omitted, with
respect to the variable <span class="math">\(v\)</span> otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polrecip">
<code class="descname">polrecip</code><span class="sig-paren">(</span><em>pol</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polrecip" title="Permalink to this definition">¶</a></dt>
<dd><p>Reciprocal polynomial of <em>pol</em>, i.e.&nbsp;the coefficients are in
reverse order. <em>pol</em> must be a polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polred">
<code class="descname">polred</code><span class="sig-paren">(</span><em>T</em>, <em>flag=0</em>, <em>_arg2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polred" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is <em>deprecated</em>, use <code class="docutils literal"><span class="pre">polredbest</span></code> instead.
Finds polynomials with reasonably small coefficients defining subfields of
the number field defined by <span class="math">\(T\)</span>. One of the polynomials always defines <span class="math">\(\mathbb{Q}\)</span>
(hence is equal to <span class="math">\(x-1\)</span>), and another always defines the same number field
as <span class="math">\(T\)</span> if <span class="math">\(T\)</span> is irreducible.</p>
<p>All <span class="math">\(T\)</span> accepted by <code class="docutils literal"><span class="pre">nfinit</span></code> are also allowed here;
in particular, the format <code class="docutils literal"><span class="pre">[T,</span> <span class="pre">listP]</span></code> is recommended, e.g. with
<span class="math">\(listP = 10^5\)</span> or a vector containing all ramified primes. Otherwise,
the maximal order of <span class="math">\(\mathbb{Q}[x]/(T)\)</span> must be computed.</p>
<p>The following binary digits of <span class="math">\(flag\)</span> are significant:</p>
<p>1: Possibly use a suborder of the maximal order. The
primes dividing the index of the order chosen are larger than
<code class="docutils literal"><span class="pre">primelimit</span></code> or divide integers stored in the <code class="docutils literal"><span class="pre">addprimes</span></code> table.
This flag is <em>deprecated</em>, the <code class="docutils literal"><span class="pre">[T,</span> <span class="pre">listP]</span></code> format is more
flexible.</p>
<p>2: gives also elements. The result is a two-column matrix, the first column
giving primitive elements defining these subfields, the second giving the
corresponding minimal polynomials.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = polred(x^4 + 8, 2)
%1 =
[1 x - 1]

[1/2*x^2 x^2 + 2]

[1/4*x^3 x^4 + 2]

[x x^4 + 8]
? minpoly(Mod(M[2,1], x^4+8))
%2 = x^2 + 2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polredabs">
<code class="descname">polredabs</code><span class="sig-paren">(</span><em>T</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polredabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a canonical defining polynomial <span class="math">\(P\)</span> for the number field
<span class="math">\(\mathbb{Q}[X]/(T)\)</span> defined by <span class="math">\(T\)</span>, such that the sum of the squares of the modulus
of the roots (i.e.&nbsp;the <span class="math">\(T_2\)</span>-norm) is minimal. Different <span class="math">\(T\)</span> defining
isomorphic number fields will yield the same <span class="math">\(P\)</span>. All <span class="math">\(T\)</span> accepted by
<code class="docutils literal"><span class="pre">nfinit</span></code> are also allowed here, e.g. non-monic polynomials, or pairs
<code class="docutils literal"><span class="pre">[T,</span> <span class="pre">listP]</span></code> specifying that a non-maximal order may be used.</p>
<p><strong>Warning 1.</strong> Using a <code class="docutils literal"><span class="pre">t_POL</span></code> <span class="math">\(T\)</span> requires computing
and fully factoring the discriminant <span class="math">\(d_K\)</span> of the maximal order which may be
very hard. You can use the format <code class="docutils literal"><span class="pre">[T,</span> <span class="pre">listP]</span></code>, where <code class="docutils literal"><span class="pre">listP</span></code>
encodes a list of known coprime divisors of <span class="math">\(\mathrm{disc}(T)\)</span> (see <code class="docutils literal"><span class="pre">??nfbasis</span></code>),
to help the routine, thereby replacing this part of the algorithm by a
polynomial time computation But this may only compute a suborder of the
maximal order, when the divisors are not squarefree or do not include all
primes dividing <span class="math">\(d_K\)</span>. The routine attempts to certify the result
independently of this order computation as per <code class="docutils literal"><span class="pre">nfcertify</span></code>: we try to
prove that the computed order is maximal. If the certification fails,
the routine then fully factors the integers returned by <code class="docutils literal"><span class="pre">nfcertify</span></code>.
You can use <code class="docutils literal"><span class="pre">polredbest</span></code> or <code class="docutils literal"><span class="pre">polredabs(,16)</span></code> to avoid this
factorization step; in both cases, the result is no longer canonical.</p>
<p><strong>Warning 2.</strong> Apart from the factorization of the discriminant of
<span class="math">\(T\)</span>, this routine runs in polynomial time for a <em>fixed</em> degree.
But the complexity is exponential in the degree: this routine
may be exceedingly slow when the number field has many subfields, hence a
lot of elements of small <span class="math">\(T_2\)</span>-norm. If you do not need a canonical
polynomial, the function <code class="docutils literal"><span class="pre">polredbest</span></code> is in general much faster (it runs
in polynomial time), and tends to return polynomials with smaller
discriminants.</p>
<p>The binary digits of <span class="math">\(flag\)</span> mean</p>
<p>1: outputs a two-component row vector <span class="math">\([P,a]\)</span>, where <span class="math">\(P\)</span> is the default
output and <code class="docutils literal"><span class="pre">Mod(a,</span> <span class="pre">P)</span></code> is a root of the original <span class="math">\(T\)</span>.</p>
<p>4: gives <em>all</em> polynomials of minimal <span class="math">\(T_2\)</span> norm; of the two polynomials
<span class="math">\(P(x)\)</span> and <span class="math">\(± P(-x)\)</span>, only one is given.</p>
<p>16: Possibly use a suborder of the maximal order, <em>without</em> attempting to
certify the result as in Warning 1: we always return a polynomial and never
<span class="math">\(0\)</span>. The result is a priori not canonical.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? T = x^16 - 136*x^14 + 6476*x^12 - 141912*x^10 + 1513334*x^8 \
 - 7453176*x^6 + 13950764*x^4 - 5596840*x^2 + 46225
? T1 = polredabs(T); T2 = polredbest(T);
? [ norml2(polroots(T1)), norml2(polroots(T2)) ]
%3 = [88.0000000, 120.000000]
? [ sizedigit(poldisc(T1)), sizedigit(poldisc(T2)) ]
%4 = [75, 67]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polredbest">
<code class="descname">polredbest</code><span class="sig-paren">(</span><em>T</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polredbest" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds a polynomial with reasonably
small coefficients defining the same number field as <span class="math">\(T\)</span>.
All <span class="math">\(T\)</span> accepted by <code class="docutils literal"><span class="pre">nfinit</span></code> are also allowed here (e.g. non-monic
polynomials, <code class="docutils literal"><span class="pre">nf</span></code>, <code class="docutils literal"><span class="pre">bnf</span></code>, <code class="docutils literal"><span class="pre">[T,Z_K_basis]</span></code>). Contrary to
<code class="docutils literal"><span class="pre">polredabs</span></code>, this routine runs in polynomial time, but it offers no
guarantee as to the minimality of its result.</p>
<p>This routine computes an LLL-reduced basis for the ring of integers of
<span class="math">\(\mathbb{Q}[X]/(T)\)</span>, then examines small linear combinations of the basis vectors,
computing their characteristic polynomials. It returns the <em>separable</em>
<span class="math">\(P\)</span> polynomial of smallest discriminant (the one with lexicographically
smallest <code class="docutils literal"><span class="pre">abs(Vec(P))</span></code> in case of ties). This is a good candidate
for subsequent number field computations, since it guarantees that
the denominators of algebraic integers, when expressed in the power basis,
are reasonably small. With no claim of minimality, though.</p>
<p>It can happen that iterating this functions yields better and better
polynomials, until it stabilizes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \p5
? P = X^12+8*X^8-50*X^6+16*X^4-3069*X^2+625;
? poldisc(P)*1.
%2 = 1.2622 E55
? P = polredbest(P);
? poldisc(P)*1.
%4 = 2.9012 E51
? P = polredbest(P);
? poldisc(P)*1.
%6 = 8.8704 E44
</pre></div>
</div>
<p>In this example, the initial polynomial <span class="math">\(P\)</span> is the one
returned by <code class="docutils literal"><span class="pre">polredabs</span></code>, and the last one is stable.</p>
<p>If <span class="math">\(flag = 1\)</span>: outputs a two-component row vector <span class="math">\([P,a]\)</span>, where <span class="math">\(P\)</span> is the
default output and <code class="docutils literal"><span class="pre">Mod(a,</span> <span class="pre">P)</span></code> is a root of the original <span class="math">\(T\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? [P,a] = polredbest(x^4 + 8, 1)
%1 = [x^4 + 2, Mod(x^3, x^4 + 2)]
? charpoly(a)
%2 = x^4 + 8
</pre></div>
</div>
<p>In particular, the map <span class="math">\(\mathbb{Q}[x]/(T) \to \mathbb{Q}[x]/(P)\)</span>,
<span class="math">\(x:---&gt;Mod(a,P)\)</span> defines an isomorphism of number fields, which can
be computed as</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">subst</span><span class="p">(</span><span class="n">lift</span><span class="p">(</span><span class="n">Q</span><span class="p">),</span> <span class="s1">&#39;x, a)</span>
</pre></div>
</div>
<p>if <span class="math">\(Q\)</span> is a <code class="docutils literal"><span class="pre">t_POLMOD</span></code> modulo <span class="math">\(T\)</span>; <code class="docutils literal"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">modreverse(a)</span></code>
returns a <code class="docutils literal"><span class="pre">t_POLMOD</span></code> giving the inverse of the above map (which should be
useless since <span class="math">\(\mathbb{Q}[x]/(P)\)</span> is a priori a better representation for the number
field and its elements).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polredord">
<code class="descname">polredord</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polredord" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds polynomials with reasonably small
coefficients and of the same degree as that of <span class="math">\(x\)</span> defining suborders of the
order defined by <span class="math">\(x\)</span>. One of the polynomials always defines <span class="math">\(\mathbb{Q}\)</span> (hence
is equal to <span class="math">\((x-1)^n\)</span>, where <span class="math">\(n\)</span> is the degree), and another always defines
the same order as <span class="math">\(x\)</span> if <span class="math">\(x\)</span> is irreducible. Useless function: try
<code class="docutils literal"><span class="pre">polredbest</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polresultant">
<code class="descname">polresultant</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>v=None</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polresultant" title="Permalink to this definition">¶</a></dt>
<dd><p>Resultant of the two
polynomials <span class="math">\(x\)</span> and <span class="math">\(y\)</span> with exact entries, with respect to the main
variables of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> if <span class="math">\(v\)</span> is omitted, with respect to the variable <span class="math">\(v\)</span>
otherwise. The algorithm assumes the base ring is a domain. If you also need
the <span class="math">\(u\)</span> and <span class="math">\(v\)</span> such that <span class="math">\(x*u + y*v = {Res}(x,y)\)</span>, use the
<code class="docutils literal"><span class="pre">polresultantext</span></code> function.</p>
<p>If <span class="math">\(flag = 0\)</span> (default), uses the algorithm best suited to the inputs,
either the subresultant algorithm (Lazard/Ducos variant, generic case),
a modular algorithm (inputs in <span class="math">\(\mathbb{Q}[X]\)</span>) or Sylvester&#8217;s matrix (inexact
inputs).</p>
<p>If <span class="math">\(flag = 1\)</span>, uses the determinant of Sylvester&#8217;s matrix instead; this should
always be slower than the default.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polresultantext">
<code class="descname">polresultantext</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polresultantext" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds polynomials <span class="math">\(U\)</span> and <span class="math">\(V\)</span> such that <span class="math">\(A*U + B*V = R\)</span>, where <span class="math">\(R\)</span> is
the resultant of <span class="math">\(U\)</span> and <span class="math">\(V\)</span> with respect to the main variables of <span class="math">\(A\)</span> and
<span class="math">\(B\)</span> if <span class="math">\(v\)</span> is omitted, and with respect to <span class="math">\(v\)</span> otherwise. Returns the row
vector <span class="math">\([U,V,R]\)</span>. The algorithm used (subresultant) assumes that the base
ring is a domain.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? A = x*y; B = (x+y)^2;
? [U,V,R] = polresultantext(A, B)
%2 = [-y*x - 2*y^2, y^2, y^4]
? A*U + B*V
%3 = y^4
? [U,V,R] = polresultantext(A, B, y)
%4 = [-2*x^2 - y*x, x^2, x^4]
? A*U+B*V
%5 = x^4
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polroots">
<code class="descname">polroots</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polroots" title="Permalink to this definition">¶</a></dt>
<dd><p>Complex roots of the polynomial
<em>x</em>, given as a column vector where each root is repeated according to
its multiplicity. The precision is given as for transcendental functions: in
GP it is kept in the variable <code class="docutils literal"><span class="pre">realprecision</span></code> and is transparent to the
user, but it must be explicitly given as a second argument in library mode.</p>
<p>The algorithm used is a modification of A.&nbsp;Schönhage&#8217;s
root-finding algorithm, due to and originally implemented by X.&nbsp;Gourdon.
Barring bugs, it is guaranteed to converge and to give the roots to the
required accuracy.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polrootsff">
<code class="descname">polrootsff</code><span class="sig-paren">(</span><em>x</em>, <em>p=None</em>, <em>a=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polrootsff" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vector of distinct roots of the polynomial <span class="math">\(x\)</span> in the field
<span class="math">\(\mathbb{F}_q\)</span> defined by the irreducible polynomial <span class="math">\(a\)</span> over <span class="math">\(\mathbb{F}_p\)</span>. The
coefficients of <span class="math">\(x\)</span> must be operation-compatible with <span class="math">\(\mathbb{Z}/p\mathbb{Z}\)</span>.
Either <span class="math">\(a\)</span> or <span class="math">\(p\)</span> can omitted (in which case both are ignored) if x has
<code class="docutils literal"><span class="pre">t_FFELT</span></code> coefficients:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? polrootsff(x^2 + 1, 5, y^2+3) \\ over F_5[y]/(y^2+3) ~ F_25
%1 = [Mod(Mod(3, 5), Mod(1, 5)*y^2 + Mod(3, 5)),
 Mod(Mod(2, 5), Mod(1, 5)*y^2 + Mod(3, 5))]
? t = ffgen(y^2 + Mod(3,5), &#39;t); \\ a generator for F_25 as a t_FFELT
? polrootsff(x^2 + 1) \\ not enough information to determine the base field
 *** at top-level: polrootsff(x^2+1)
 *** ^-----------------
 *** polrootsff: incorrect type in factorff.
? polrootsff(x^2 + t^0) \\ make sure one coeff. is a t_FFELT
%3 = [3, 2]
? polrootsff(x^2 + t + 1)
%4 = [2*t + 1, 3*t + 4]
</pre></div>
</div>
<p>Notice that the second syntax is easier to use and much more readable.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polrootsmod">
<code class="descname">polrootsmod</code><span class="sig-paren">(</span><em>pol</em>, <em>p</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polrootsmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Row vector of roots modulo <span class="math">\(p\)</span> of the polynomial <em>pol</em>.
Multiple roots are <em>not</em> repeated.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? polrootsmod(x^2-1,2)
%1 = [Mod(1, 2)]~
</pre></div>
</div>
<p>If <span class="math">\(p\)</span> is very small, you may set <span class="math">\(flag = 1\)</span>, which uses a naive search.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polrootspadic">
<code class="descname">polrootspadic</code><span class="sig-paren">(</span><em>x</em>, <em>p</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polrootspadic" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector of <span class="math">\(p\)</span>-adic roots of the polynomial <em>pol</em>, given to
<span class="math">\(p\)</span>-adic precision <span class="math">\(r\)</span> <span class="math">\(p\)</span> is assumed to be a prime. Multiple roots are
<em>not</em> repeated. Note that this is not the same as the roots in
<span class="math">\(\mathbb{Z}/p^r\mathbb{Z}\)</span>, rather it gives approximations in <span class="math">\(\mathbb{Z}/p^r\mathbb{Z}\)</span> of the true roots
living in <span class="math">\(\mathbb{Q}_p\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? polrootspadic(x^3 - x^2 + 64, 2, 5)
%1 = [2^3 + O(2^5), 2^3 + 2^4 + O(2^5), 1 + O(2^5)]~
</pre></div>
</div>
<p>If <em>pol</em> has inexact <code class="docutils literal"><span class="pre">t_PADIC</span></code> coefficients, this is not always
well-defined; in this case, the polynomial is first made integral by dividing
out the <span class="math">\(p\)</span>-adic content, then lifted
to <span class="math">\(\mathbb{Z}\)</span> using <code class="docutils literal"><span class="pre">truncate</span></code> coefficientwise. Hence the roots given are
approximations of the roots of an exact polynomial which is <span class="math">\(p\)</span>-adically
close to the input. To avoid pitfalls, we advise to only factor polynomials
with eact rational coefficients.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polrootsreal">
<code class="descname">polrootsreal</code><span class="sig-paren">(</span><em>T</em>, <em>ab=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polrootsreal" title="Permalink to this definition">¶</a></dt>
<dd><p>Real roots of the polynomial <span class="math">\(T\)</span> with rational coefficients, multiple
roots being included according to their multiplicity. The roots are given
to a relative accuracy of <code class="docutils literal"><span class="pre">realprecision</span></code>. If argument <em>ab</em> is
present, it must be a vector <span class="math">\([a,b]\)</span> with two components (of type
<code class="docutils literal"><span class="pre">t_INT</span></code>, <code class="docutils literal"><span class="pre">t_FRAC</span></code> or <code class="docutils literal"><span class="pre">t_INFINITY</span></code>) and we restrict to roots belonging
to that closed interval.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \p9
? polrootsreal(x^2-2)
%1 = [-1.41421356, 1.41421356]~
? polrootsreal(x^2-2, [1,+oo])
%2 = [1.41421356]~
? polrootsreal(x^2-2, [2,3])
%3 = []~
? polrootsreal((x-1)*(x-2), [2,3])
%4 = [2.00000000]~
</pre></div>
</div>
<p>The algorithm used is a modification of Uspensky&#8217;s method (relying on
Descartes&#8217;s rule of sign), following Rouillier and Zimmerman &#8220;Efficient
isolation of a polynomial real roots&#8221;
(<code class="docutils literal"><span class="pre">http://hal.inria.fr/inria-00072518/</span></code>). Barring bugs, it is guaranteed
to converge and to give the roots to the required accuracy.</p>
<p><strong>Remark.</strong> If the polynomial <span class="math">\(T\)</span> is of the
form <span class="math">\(Q(x^h)\)</span> for some <span class="math">\(h &gt;= 2\)</span> and <em>ab</em> is omitted, the routine will
apply the algorithm to <span class="math">\(Q\)</span> (restricting to non-negative roots when <span class="math">\(h\)</span> is
even), then take <span class="math">\(h\)</span>-th roots. On the other hand, if you want to specify
<em>ab</em>, you should apply the routine to <span class="math">\(Q\)</span> yourself and a suitable
interval <span class="math">\([a',b']\)</span> using approximate <span class="math">\(h\)</span>-th roots adapted to your problem:
the function will not perform this change of variables if <em>ab</em> is present.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polsturm">
<code class="descname">polsturm</code><span class="sig-paren">(</span><em>T</em>, <em>ab=None</em>, <em>_arg2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polsturm" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of real roots of the real squarefree polynomial <em>T</em>. If
the argument <em>ab</em> is present, it must be a vector <span class="math">\([a,b]\)</span> with
two real components (of type <code class="docutils literal"><span class="pre">t_INT</span></code>, <code class="docutils literal"><span class="pre">t_REAL</span></code>, <code class="docutils literal"><span class="pre">t_FRAC</span></code>
or <code class="docutils literal"><span class="pre">t_INFINITY</span></code>) and we count roots belonging to that closed interval.</p>
<p>If possible, you should stick to exact inputs, that is avoid <code class="docutils literal"><span class="pre">t_REAL</span></code>&nbsp;s in
<span class="math">\(T\)</span> and the bounds <span class="math">\(a,b\)</span>: the result is then guaranteed and we use a fast
algorithm (Uspensky&#8217;s method, relying on Descartes&#8217;s rule of sign, see
<code class="docutils literal"><span class="pre">polrootsreal</span></code>); otherwise, we use Sturm&#8217;s algorithm and the result
may be wrong due to round-off errors.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? T = (x-1)*(x-2)*(x-3);
? polsturm(T)
%2 = 3
? polsturm(T, [-oo,2])
%3 = 2
? polsturm(T, [1/2,+oo])
%4 = 3
? polsturm(T, [1, Pi]) \\ Pi inexact: not recommended !
%5 = 3
? polsturm(T*1., [0, 4]) \\ T*1. inexact: not recommended !
%6 = 3
? polsturm(T^2, [0, 4]) \\ not squarefree
 *** at top-level: polsturm(T^2,[0,4])
 *** ^-------------------
 *** polsturm: domain error in polsturm: issquarefree(pol) = 0
? polsturm((T*1.)^2, [0, 4]) \\ not squarefree AND inexact
 *** at top-level: polsturm((T*1.)^2,[0
 *** ^--------------------
 *** polsturm: precision too low in polsturm.
</pre></div>
</div>
<p>In the last example, the input polynomial is not
squarefree but there is no way to ascertain it from the given
floating point approximation: we get a precision error in this case.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polsylvestermatrix">
<code class="descname">polsylvestermatrix</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polsylvestermatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Forms the Sylvester matrix
corresponding to the two polynomials <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, where the coefficients of
the polynomials are put in the columns of the matrix (which is the natural
direction for solving equations afterwards). The use of this matrix can be
essential when dealing with polynomials with inexact entries, since
polynomial Euclidean division doesn&#8217;t make much sense in this case.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.polsym">
<code class="descname">polsym</code><span class="sig-paren">(</span><em>x</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.polsym" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the column vector of the symmetric powers of the roots of the
polynomial <span class="math">\(x\)</span> up to power <span class="math">\(n\)</span>, using Newton&#8217;s formula.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.poltschirnhaus">
<code class="descname">poltschirnhaus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.poltschirnhaus" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a random Tschirnhausen
transformation to the polynomial <span class="math">\(x\)</span>, which is assumed to be non-constant
and separable, so as to obtain a new equation for the étale algebra
defined by <span class="math">\(x\)</span>. This is for instance useful when computing resolvents,
hence is used by the <code class="docutils literal"><span class="pre">polgalois</span></code> function.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.powers">
<code class="descname">powers</code><span class="sig-paren">(</span><em>x</em>, <em>n</em>, <em>x0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.powers" title="Permalink to this definition">¶</a></dt>
<dd><p>For non-negative <span class="math">\(n\)</span>, return the vector with <span class="math">\(n+1\)</span> components
<span class="math">\([1,x,...,x^n]\)</span> if <code class="docutils literal"><span class="pre">x0</span></code> is omitted, and <span class="math">\([x_0, x_0*x, ..., x_0*x^n]\)</span>
otherwise.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? powers(Mod(3,17), 4)
%1 = [Mod(1, 17), Mod(3, 17), Mod(9, 17), Mod(10, 17), Mod(13, 17)]
? powers(Mat([1,2;3,4]), 3)
%2 = [[1, 0; 0, 1], [1, 2; 3, 4], [7, 10; 15, 22], [37, 54; 81, 118]]
? powers(3, 5, 2)
%3 = [2, 6, 18, 54, 162, 486]
</pre></div>
</div>
<p>When <span class="math">\(n &lt; 0\)</span>, the function returns the empty vector <code class="docutils literal"><span class="pre">[]</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.precision">
<code class="descname">precision</code><span class="sig-paren">(</span><em>x</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.precision" title="Permalink to this definition">¶</a></dt>
<dd><p>The function has two different behaviors according to whether <span class="math">\(n\)</span> is present or not.</p>
<p>If <span class="math">\(n\)</span> is missing, the function returns the precision in decimal digits of the
PARI object <span class="math">\(x\)</span>. If <span class="math">\(x\)</span> is
an exact object, the largest single precision integer is returned.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? precision(exp(1e-100))
%1 = 134 \\ 134 significant decimal digits
? precision(2 + x)
%2 = 2147483647 \\ exact object
? precision(0.5 + O(x))
%3 = 28 \\ floating point accuracy, NOT series precision
? precision( [ exp(1e-100), 0.5 ] )
%4 = 28 \\ minimal accuracy among components
</pre></div>
</div>
<p>The return value for exact objects is meaningless since it is not even the
same on 32 and 64-bit machines. The proper way to test whether an object is
exact is</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? isexact(x) = precision(x) == precision(0)
</pre></div>
</div>
<p>If <span class="math">\(n\)</span> is present, the function creates a new object equal to <span class="math">\(x\)</span> with a new
&#8220;precision&#8221; <span class="math">\(n\)</span>. (This never changes the type of the result. In particular
it is not possible to use it to obtain a polynomial from a power series; for
that, see <code class="docutils literal"><span class="pre">truncate</span></code>.) Now the meaning of precision is different from the
above (floating point accuracy), and depends on the type of <span class="math">\(x\)</span>:</p>
<p>For exact types, no change. For <span class="math">\(x\)</span> a vector or a matrix, the operation is
done componentwise.</p>
<p>For real <span class="math">\(x\)</span>, <span class="math">\(n\)</span> is the number of desired significant <em>decimal</em>
digits. If <span class="math">\(n\)</span> is smaller than the precision of <span class="math">\(x\)</span>, <span class="math">\(x\)</span> is truncated,
otherwise <span class="math">\(x\)</span> is extended with zeros.</p>
<p>For <span class="math">\(x\)</span> a <span class="math">\(p\)</span>-adic or a power series, <span class="math">\(n\)</span> is the desired number of
<em>significant</em> <span class="math">\(p\)</span>-adic or <span class="math">\(X\)</span>-adic digits, where <span class="math">\(X\)</span> is the main
variable of <span class="math">\(x\)</span>. (Note: yes, this is inconsistent.)
Note that the precision is a priori distinct from the exponent <span class="math">\(k\)</span> appearing
in <span class="math">\(O(*^k)\)</span>; it is indeed equal to <span class="math">\(k\)</span> if and only if <span class="math">\(x\)</span> is a <span class="math">\(p\)</span>-adic
or <span class="math">\(X\)</span>-adic <em>unit</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? precision(1 + O(x), 10)
%1 = 1 + O(x^10)
? precision(x^2 + O(x^10), 3)
%2 = x^2 + O(x^5)
? precision(7^2 + O(7^10), 3)
%3 = 7^2 + O(7^5)
</pre></div>
</div>
<p>For the last two examples, note that <span class="math">\(x^2 + O(x^5) = x^2(1 + O(x^3))\)</span>
indeed has 3 significant coefficients</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.precprime">
<code class="descname">precprime</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.precprime" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the largest pseudoprime (see
<code class="docutils literal"><span class="pre">ispseudoprime</span></code>) less than or equal to <span class="math">\(x\)</span>. <span class="math">\(x\)</span> can be of any real type.
Returns 0 if <span class="math">\(x &lt;= 1\)</span>. Note that if <span class="math">\(x\)</span> is a prime, this function returns <span class="math">\(x\)</span>
and not the largest prime strictly smaller than <span class="math">\(x\)</span>. To rigorously prove that
the result is prime, use <code class="docutils literal"><span class="pre">isprime</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.primepi">
<code class="descname">primepi</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.primepi" title="Permalink to this definition">¶</a></dt>
<dd><p>The prime counting function. Returns the number of
primes <span class="math">\(p\)</span>, <span class="math">\(p &lt;= x\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? primepi(10)
%1 = 4;
? primes(5)
%2 = [2, 3, 5, 7, 11]
? primepi(10^11)
%3 = 4118054813
</pre></div>
</div>
<p>Uses checkpointing and a naive <span class="math">\(O(x)\)</span> algorithm.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.primes">
<code class="descname">primes</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.primes" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a row vector whose components are the first <span class="math">\(n\)</span> prime numbers.
(Returns the empty vector for <span class="math">\(n &lt;= 0\)</span>.) A <code class="docutils literal"><span class="pre">t_VEC</span></code> <span class="math">\(n = [a,b]\)</span> is also
allowed, in which case the primes in <span class="math">\([a,b]\)</span> are returned</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? primes(10) \\ the first 10 primes
%1 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
? primes([0,29]) \\ the primes up to 29
%2 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
? primes([15,30])
%3 = [17, 19, 23, 29]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.psi">
<code class="descname">psi</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.psi" title="Permalink to this definition">¶</a></dt>
<dd><p>The <span class="math">\(\psi\)</span>-function of <span class="math">\(x\)</span>, i.e.&nbsp;the logarithmic derivative
<span class="math">\(\Gamma'(x)/\Gamma(x)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfauto">
<code class="descname">qfauto</code><span class="sig-paren">(</span><em>G</em>, <em>fl=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfauto" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(G\)</span> being a square and symmetric matrix with integer entries representing a
positive definite quadratic form, outputs the automorphism group of the
associate lattice.
Since this requires computing the minimal vectors, the computations can
become very lengthy as the dimension grows. <span class="math">\(G\)</span> can also be given by an
<code class="docutils literal"><span class="pre">qfisominit</span></code> structure.
See <code class="docutils literal"><span class="pre">qfisominit</span></code> for the meaning of <em>fl</em>.</p>
<p>The output is a two-components vector <span class="math">\([o,g]\)</span> where <span class="math">\(o\)</span> is the group order
and <span class="math">\(g\)</span> is the list of generators (as a vector). For each generator <span class="math">\(H\)</span>,
the equality <span class="math">\(G = {^t}H G H\)</span> holds.</p>
<p>The interface of this function is experimental and will likely change in the
future.</p>
<p>This function implements an algorithm of Plesken and Souvignier, following
Souvignier&#8217;s implementation.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfautoexport">
<code class="descname">qfautoexport</code><span class="sig-paren">(</span><em>qfa</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfautoexport" title="Permalink to this definition">¶</a></dt>
<dd><p><em>qfa</em> being an automorphism group as output by
<code class="docutils literal"><span class="pre">qfauto</span></code>, export the underlying matrix group as a string suitable
for (no flags or <span class="math">\(flag = 0\)</span>) GAP or (<span class="math">\(flag = 1\)</span>) Magma. The following example
computes the size of the matrix group using GAP:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = qfauto([2,1;1,2])
%1 = [12, [[-1, 0; 0, -1], [0, -1; 1, 1], [1, 1; 0, -1]]]
? s = qfautoexport(G)
%2 = &quot;Group([[-1, 0], [0, -1]], [[0, -1], [1, 1]], [[1, 1], [0, -1]])&quot;
? extern(&quot;echo \&quot;Order(&quot;s&quot;);\&quot; | gap -q&quot;)
%3 = 12
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbclassno">
<code class="descname">qfbclassno</code><span class="sig-paren">(</span><em>D</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbclassno" title="Permalink to this definition">¶</a></dt>
<dd><p>Ordinary class number of the quadratic order of discriminant <span class="math">\(D\)</span>, for
&#8220;small&#8221; values of <span class="math">\(D\)</span>.</p>
<ul class="simple">
<li>if <span class="math">\(D &gt; 0\)</span> or <span class="math">\(flag = 1\)</span>, use a <span class="math">\(O(\|D\|^{1/2})\)</span>
algorithm (compute <span class="math">\(L(1,\chi_D)\)</span> with the approximate functional equation).
This is slower than <code class="docutils literal"><span class="pre">quadclassunit</span></code> as soon as <span class="math">\(|D| ~ 10^2\)</span> or
so and is not meant to be used for large <span class="math">\(D\)</span>.</li>
<li>if <span class="math">\(D &lt; 0\)</span> and <span class="math">\(flag = 0\)</span> (or omitted), use a <span class="math">\(O(\|D\|^{1/4})\)</span>
algorithm (Shanks&#8217;s baby-step/giant-step method). It should
be faster than <code class="docutils literal"><span class="pre">quadclassunit</span></code> for small values of <span class="math">\(D\)</span>, say
<span class="math">\(|D| &lt; 10^{18}\)</span>.</li>
</ul>
<p><strong>Important warning.</strong> In the latter case, this function only
implements part of Shanks&#8217;s method (which allows to speed it up
considerably). It gives unconditionnally correct results for <span class="math">\(\|D\| &lt; 2.
10^{10}\)</span>, but may give incorrect results for larger values if the class
group has many cyclic factors. We thus recommend to double-check results
using the function <code class="docutils literal"><span class="pre">quadclassunit</span></code>, which is about 2 to 3 times slower in
the above range, assuming GRH. We currently have no counter-examples but
they should exist: we&#8217;d appreciate a bug report if you find one.</p>
<p><strong>Warning.</strong> Contrary to what its name implies, this routine does not
compute the number of classes of binary primitive forms of discriminant <span class="math">\(D\)</span>,
which is equal to the <em>narrow</em> class number. The two notions are the same
when <span class="math">\(D &lt; 0\)</span> or the fundamental unit <span class="math">\(\varepsilon\)</span> has negative norm; when <span class="math">\(D
&gt; 0\)</span> and <span class="math">\(N\varepsilon &gt; 0\)</span>, the number of classes of forms is twice the
ordinary class number. This is a problem which we cannot fix for backward
compatibility reasons. Use the following routine if you are only interested
in the number of classes of forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">QFBclassno</span><span class="p">(</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span>
<span class="n">qfbclassno</span><span class="p">(</span><span class="n">D</span><span class="p">)</span> <span class="o">*</span> <span class="k">if</span> <span class="p">(</span><span class="n">D</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">norm</span><span class="p">(</span><span class="n">quadunit</span><span class="p">(</span><span class="n">D</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Here are a few examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? qfbclassno(400000028)
time = 3,140 ms.
%1 = 1
? quadclassunit(400000028).no
time = 20 ms. \\{ much faster}
%2 = 1
? qfbclassno(-400000028)
time = 0 ms.
%3 = 7253 \\{ correct, and fast enough}
? quadclassunit(-400000028).no
time = 0 ms.
%4 = 7253
</pre></div>
</div>
<p>See also <code class="docutils literal"><span class="pre">qfbhclassno</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbcompraw">
<code class="descname">qfbcompraw</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbcompraw" title="Permalink to this definition">¶</a></dt>
<dd><p>composition of the binary quadratic forms <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, without
reduction of the result. This is useful e.g.&nbsp;to compute a generating
element of an ideal. The result is undefined if <span class="math">\(x\)</span> and <span class="math">\(y\)</span> do not have the
same discriminant.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbhclassno">
<code class="descname">qfbhclassno</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbhclassno" title="Permalink to this definition">¶</a></dt>
<dd><p>Hurwitz class number of <span class="math">\(x\)</span>, where
<span class="math">\(x\)</span> is non-negative and congruent to 0 or 3 modulo 4. For <span class="math">\(x &gt; 5.
10^5\)</span>, we assume the GRH, and use <code class="docutils literal"><span class="pre">quadclassunit</span></code> with default
parameters.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbil">
<code class="descname">qfbil</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>q=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbil" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the bilinear form <span class="math">\(q\)</span> (symmetric matrix)
at the vectors <span class="math">\((x,y)\)</span>; if <span class="math">\(q\)</span> omitted, use the standard Euclidean scalar
product, corresponding to the identity matrix.</p>
<p>Roughly equivalent to <code class="docutils literal"><span class="pre">x~</span> <span class="pre">*</span> <span class="pre">q</span> <span class="pre">*</span> <span class="pre">y</span></code>, but a little faster and
more convenient (does not distinguish between column and row vectors):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? x = [1,2,3]~; y = [-1,0,1]~; qfbil(x,y)
%1 = 2
? q = [1,2,3;2,2,-1;3,-1,0]; qfbil(x,y, q)
%2 = -13
? for(i=1,10^6, qfbil(x,y,q))
%3 = 568ms
? for(i=1,10^6, x~*q*y)
%4 = 717ms
</pre></div>
</div>
<p>The associated quadratic form is also available, as
<code class="docutils literal"><span class="pre">qfnorm</span></code>, slightly faster:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? for(i=1,10^6, qfnorm(x,q))
time = 444ms
? for(i=1,10^6, qfnorm(x))
time = 176 ms.
? for(i=1,10^6, qfbil(x,y))
time = 208 ms.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbnucomp">
<code class="descname">qfbnucomp</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>L</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbnucomp" title="Permalink to this definition">¶</a></dt>
<dd><p>composition of the primitive positive
definite binary quadratic forms <span class="math">\(x\)</span> and <span class="math">\(y\)</span> (type <code class="docutils literal"><span class="pre">t_QFI</span></code>) using the NUCOMP
and NUDUPL algorithms of Shanks, à la Atkin. <span class="math">\(L\)</span> is any positive
constant, but for optimal speed, one should take <span class="math">\(L = \|D/4\|^{1/4}\)</span>, i.e.
<code class="docutils literal"><span class="pre">sqrtnint(abs(D)</span> <span class="pre">&gt;&gt;</span> <span class="pre">2,4)</span></code>, where <span class="math">\(D\)</span> is the common discriminant of <span class="math">\(x\)</span> and
<span class="math">\(y\)</span>. When <span class="math">\(x\)</span> and <span class="math">\(y\)</span> do not have the same discriminant, the result is
undefined.</p>
<p>The current implementation is slower than the generic routine for small <span class="math">\(D\)</span>,
and becomes faster when <span class="math">\(D\)</span> has about <span class="math">\(45\)</span> bits.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbnupow">
<code class="descname">qfbnupow</code><span class="sig-paren">(</span><em>x</em>, <em>n</em>, <em>L=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbnupow" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(n\)</span>-th power of the primitive positive definite
binary quadratic form <span class="math">\(x\)</span> using Shanks&#8217;s NUCOMP and NUDUPL algorithms;
if set, <span class="math">\(L\)</span> should be equal to <code class="docutils literal"><span class="pre">sqrtnint(abs(D)</span> <span class="pre">&gt;&gt;</span> <span class="pre">2,4)</span></code>, where <span class="math">\(D &lt; 0\)</span> is
the discriminant of <span class="math">\(x\)</span>.</p>
<p>The current implementation is slower than the generic routine for small
discriminant <span class="math">\(D\)</span>, and becomes faster for <span class="math">\(D ~ 2^{45}\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbpowraw">
<code class="descname">qfbpowraw</code><span class="sig-paren">(</span><em>x</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbpowraw" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(n\)</span>-th power of the binary quadratic form
<span class="math">\(x\)</span>, computed without doing any reduction (i.e.&nbsp;using <code class="docutils literal"><span class="pre">qfbcompraw</span></code>).
Here <span class="math">\(n\)</span> must be non-negative and <span class="math">\(n &lt; 2^{31}\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbprimeform">
<code class="descname">qfbprimeform</code><span class="sig-paren">(</span><em>x</em>, <em>p</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbprimeform" title="Permalink to this definition">¶</a></dt>
<dd><p>Prime binary quadratic form of discriminant
<span class="math">\(x\)</span> whose first coefficient is <span class="math">\(p\)</span>, where <span class="math">\(\|p\|\)</span> is a prime number.
By abuse of notation,
<span class="math">\(p = ± 1\)</span> is also valid and returns the unit form. Returns an
error if <span class="math">\(x\)</span> is not a quadratic residue mod <span class="math">\(p\)</span>, or if <span class="math">\(x &lt; 0\)</span> and <span class="math">\(p &lt; 0\)</span>.
(Negative definite <code class="docutils literal"><span class="pre">t_QFI</span></code> are not implemented.) In the case where <span class="math">\(x &gt; 0\)</span>,
the &#8220;distance&#8221; component of the form is set equal to zero according to the
current precision.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbred">
<code class="descname">qfbred</code><span class="sig-paren">(</span><em>x</em>, <em>flag=0</em>, <em>d=None</em>, <em>isd=None</em>, <em>sd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbred" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces the binary quadratic form <span class="math">\(x\)</span> (updating Shanks&#8217;s distance function
if <span class="math">\(x\)</span> is indefinite). The binary digits of <span class="math">\(flag\)</span> are toggles meaning</p>
<p>&nbsp;&nbsp;1: perform a single reduction step</p>
<p>&nbsp;&nbsp;2: don&#8217;t update Shanks&#8217;s distance</p>
<p>The arguments <span class="math">\(d\)</span>, <em>isd</em>, <em>sd</em>, if present, supply the values of the
discriminant, <span class="math">\(floor{\sqrt{d}}\)</span>, and <span class="math">\(\sqrt{d}\)</span> respectively
(no checking is done of these facts). If <span class="math">\(d &lt; 0\)</span> these values are useless,
and all references to Shanks&#8217;s distance are irrelevant.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbredsl2">
<code class="descname">qfbredsl2</code><span class="sig-paren">(</span><em>x</em>, <em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbredsl2" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduction of the (real or imaginary) binary quadratic form <span class="math">\(x\)</span>, return
<span class="math">\([y,g]\)</span> where <span class="math">\(y\)</span> is reduced and <span class="math">\(g\)</span> in <span class="math">\({SL}(2,\mathbb{Z})\)</span> is such that
<span class="math">\(g.x = y\)</span>; <em>data</em>, if
present, must be equal to <span class="math">\([D, sqrtint(D)]\)</span>, where <span class="math">\(D &gt; 0\)</span> is the
discriminant of <span class="math">\(x\)</span>. In case <span class="math">\(x\)</span> is <code class="docutils literal"><span class="pre">t_QFR</span></code>, the distance component is
unaffected.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfbsolve">
<code class="descname">qfbsolve</code><span class="sig-paren">(</span><em>Q</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfbsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the equation <span class="math">\(Q(x,y) = p\)</span> over the integers,
where <span class="math">\(Q\)</span> is a binary quadratic form and <span class="math">\(p\)</span> a prime number.</p>
<p>Return <span class="math">\([x,y]\)</span> as a two-components vector, or zero if there is no solution.
Note that this function returns only one solution and not all the solutions.</p>
<p>Let <span class="math">\(D = \mathrm{disc} Q\)</span>. The algorithm used runs in probabilistic polynomial time
in <span class="math">\(p\)</span> (through the computation of a square root of <span class="math">\(D\)</span> modulo <span class="math">\(p\)</span>); it is
polynomial time in <span class="math">\(D\)</span> if <span class="math">\(Q\)</span> is imaginary, but exponential time if <span class="math">\(Q\)</span> is
real (through the computation of a full cycle of reduced forms). In the
latter case, note that <code class="docutils literal"><span class="pre">bnfisprincipal</span></code> provides a solution in heuristic
subexponential time in <span class="math">\(D\)</span> assuming the GRH.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfgaussred">
<code class="descname">qfgaussred</code><span class="sig-paren">(</span><em>q</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfgaussred" title="Permalink to this definition">¶</a></dt>
<dd><p>decomposition into squares of the
quadratic form represented by the symmetric matrix <span class="math">\(q\)</span>. The result is a
matrix whose diagonal entries are the coefficients of the squares, and the
off-diagonal entries on each line represent the bilinear forms. More
precisely, if <span class="math">\((a_{ij})\)</span> denotes the output, one has</p>
<div class="math">
\[q(x) = \sum_i a_{ii} (x_i + \sum_{j != i} a_{ij} x_j)^2\]</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>? qfgaussred([0,1;1,0])
%1 =
[1/2 1]

[-1 -1/2]
</pre></div>
</div>
<p>This means that <span class="math">\(2xy = (1/2)(x+y)^2 - (1/2)(x-y)^2\)</span>.
Singular matrices are supported, in which case some diagonal coefficients
will vanish:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? qfgaussred([1,1;1,1])
%1 =
[1 1]

[1 0]
</pre></div>
</div>
<p>This means that <span class="math">\(x^2 + 2xy + y^2 = (x+y)^2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfisom">
<code class="descname">qfisom</code><span class="sig-paren">(</span><em>G</em>, <em>H</em>, <em>fl=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfisom" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(G\)</span>, <span class="math">\(H\)</span> being square and symmetric matrices with integer entries representing
positive definite quadratic forms, return an invertible matrix <span class="math">\(S\)</span> such that
<span class="math">\(G = {^t}S H S\)</span>. This defines a isomorphism between the corresponding lattices.
Since this requires computing the minimal vectors, the computations can
become very lengthy as the dimension grows.
See <code class="docutils literal"><span class="pre">qfisominit</span></code> for the meaning of <em>fl</em>.</p>
<p><span class="math">\(G\)</span> can also be given by an <code class="docutils literal"><span class="pre">qfisominit</span></code> structure which is preferable if
several forms <span class="math">\(H\)</span> need to be compared to <span class="math">\(G\)</span>.</p>
<p>This function implements an algorithm of Plesken and Souvignier, following
Souvignier&#8217;s implementation.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfisominit">
<code class="descname">qfisominit</code><span class="sig-paren">(</span><em>G</em>, <em>fl=None</em>, <em>m=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfisominit" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(G\)</span> being a square and symmetric matrix with integer entries representing a
positive definite quadratic form, return an <code class="docutils literal"><span class="pre">isom</span></code> structure allowing to
compute isomorphisms between <span class="math">\(G\)</span> and other quadratic forms faster.</p>
<p>The interface of this function is experimental and will likely change in future
release.</p>
<p>If present, the optional parameter <em>fl</em> must be a <code class="docutils literal"><span class="pre">t_VEC</span></code> with two
components. It allows to specify the invariants used, which can make the
computation faster or slower. The components are</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">fl[1]</span></code> Depth of scalar product combination to use.</li>
<li><code class="docutils literal"><span class="pre">fl[2]</span></code> Maximum level of Bacher polynomials to use.</li>
</ul>
<p>If present, <span class="math">\(m\)</span> must be the set of vectors of norm up to the maximal of the
diagonal entry of <span class="math">\(G\)</span>, either as a matrix or as given by <code class="docutils literal"><span class="pre">qfminim</span></code>.
Otherwise this function computes the minimal vectors so it become very
lengthy as the dimension of <span class="math">\(G\)</span> grows.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfjacobi">
<code class="descname">qfjacobi</code><span class="sig-paren">(</span><em>A</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfjacobi" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Jacobi&#8217;s eigenvalue algorithm to the real symmetric matrix <span class="math">\(A\)</span>.
This returns <span class="math">\([L, V]\)</span>, where</p>
<ul class="simple">
<li><span class="math">\(L\)</span> is the vector of (real) eigenvalues of <span class="math">\(A\)</span>, sorted in increasing
order,</li>
<li><span class="math">\(V\)</span> is the corresponding orthogonal matrix of eigenvectors of <span class="math">\(A\)</span>.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \p19
? A = [1,2;2,1]; mateigen(A)
%1 =
[-1 1]

[ 1 1]
? [L, H] = qfjacobi(A);
? L
%3 = [-1.000000000000000000, 3.000000000000000000]~
? H
%4 =
[ 0.7071067811865475245 0.7071067811865475244]

[-0.7071067811865475244 0.7071067811865475245]
? norml2( (A-L[1])*H[,1] ) \\ approximate eigenvector
%5 = 9.403954806578300064 E-38
? norml2(H*H~ - 1)
%6 = 2.350988701644575016 E-38 \\ close to orthogonal
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qflll">
<code class="descname">qflll</code><span class="sig-paren">(</span><em>x</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qflll" title="Permalink to this definition">¶</a></dt>
<dd><p>LLL algorithm applied to the
<em>columns</em> of the matrix <span class="math">\(x\)</span>. The columns of <span class="math">\(x\)</span> may be linearly
dependent. The result is a unimodular transformation matrix <span class="math">\(T\)</span> such that <span class="math">\(x
.T\)</span> is an LLL-reduced basis of the lattice generated by the column
vectors of <span class="math">\(x\)</span>. Note that if <span class="math">\(x\)</span> is not of maximal rank <span class="math">\(T\)</span> will not be
square. The LLL parameters are <span class="math">\((0.51,0.99)\)</span>, meaning that the Gram-Schmidt
coefficients for the final basis satisfy <span class="math">\(\mu_{i,j} &lt;= \|0.51\|\)</span>, and the
Lovász&#8217;s constant is <span class="math">\(0.99\)</span>.</p>
<p>If <span class="math">\(flag = 0\)</span> (default), assume that <span class="math">\(x\)</span> has either exact (integral or
rational) or real floating point entries. The matrix is rescaled, converted
to integers and the behavior is then as in <span class="math">\(flag = 1\)</span>.</p>
<p>If <span class="math">\(flag = 1\)</span>, assume that <span class="math">\(x\)</span> is integral. Computations involving Gram-Schmidt
vectors are approximate, with precision varying as needed (Lehmer&#8217;s trick,
as generalized by Schnorr). Adapted from Nguyen and Stehlé&#8217;s algorithm
and Stehlé&#8217;s code (<code class="docutils literal"><span class="pre">fplll-1.3</span></code>).</p>
<p>If <span class="math">\(flag = 2\)</span>, <span class="math">\(x\)</span> should be an integer matrix whose columns are linearly
independent. Returns a partially reduced basis for <span class="math">\(x\)</span>, using an unpublished
algorithm by Peter Montgomery: a basis is said to be <em>partially reduced</em>
if <span class="math">\(\|v_i ± v_j\| &gt;= \|v_i\|\)</span> for any two distinct basis vectors <span class="math">\(v_i, 
v_j\)</span>.</p>
<p>This is faster than <span class="math">\(flag = 1\)</span>, esp. when one row is huge compared
to the other rows (knapsack-style), and should quickly produce relatively
short vectors. The resulting basis is <em>not</em> LLL-reduced in general.
If LLL reduction is eventually desired, avoid this partial reduction:
applying LLL to the partially reduced matrix is significantly <em>slower</em>
than starting from a knapsack-type lattice.</p>
<p>If <span class="math">\(flag = 4\)</span>, as <span class="math">\(flag = 1\)</span>, returning a vector <span class="math">\([K, T]\)</span> of matrices: the
columns of <span class="math">\(K\)</span> represent a basis of the integer kernel of <span class="math">\(x\)</span>
(not LLL-reduced in general) and <span class="math">\(T\)</span> is the transformation
matrix such that <span class="math">\(x.T\)</span> is an LLL-reduced <span class="math">\(\mathbb{Z}\)</span>-basis of the image
of the matrix <span class="math">\(x\)</span>.</p>
<p>If <span class="math">\(flag = 5\)</span>, case as case <span class="math">\(4\)</span>, but <span class="math">\(x\)</span> may have polynomial coefficients.</p>
<p>If <span class="math">\(flag = 8\)</span>, same as case <span class="math">\(0\)</span>, but <span class="math">\(x\)</span> may have polynomial coefficients.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qflllgram">
<code class="descname">qflllgram</code><span class="sig-paren">(</span><em>G</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qflllgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <code class="docutils literal"><span class="pre">qflll</span></code>, except that the
matrix <span class="math">\(G = x~ * x\)</span> is the Gram matrix of some lattice vectors <span class="math">\(x\)</span>,
and not the coordinates of the vectors themselves. In particular, <span class="math">\(G\)</span> must
now be a square symmetric real matrix, corresponding to a positive
quadratic form (not necessarily definite: <span class="math">\(x\)</span> needs not have maximal rank).
The result is a unimodular
transformation matrix <span class="math">\(T\)</span> such that <span class="math">\(x.T\)</span> is an LLL-reduced basis of
the lattice generated by the column vectors of <span class="math">\(x\)</span>. See <code class="docutils literal"><span class="pre">qflll</span></code> for
further details about the LLL implementation.</p>
<p>If <span class="math">\(flag = 0\)</span> (default), assume that <span class="math">\(G\)</span> has either exact (integral or
rational) or real floating point entries. The matrix is rescaled, converted
to integers and the behavior is then as in <span class="math">\(flag = 1\)</span>.</p>
<p>If <span class="math">\(flag = 1\)</span>, assume that <span class="math">\(G\)</span> is integral. Computations involving Gram-Schmidt
vectors are approximate, with precision varying as needed (Lehmer&#8217;s trick,
as generalized by Schnorr). Adapted from Nguyen and Stehlé&#8217;s algorithm
and Stehlé&#8217;s code (<code class="docutils literal"><span class="pre">fplll-1.3</span></code>).</p>
<p><span class="math">\(flag = 4\)</span>: <span class="math">\(G\)</span> has integer entries, gives the kernel and reduced image of <span class="math">\(x\)</span>.</p>
<p><span class="math">\(flag = 5\)</span>: same as <span class="math">\(4\)</span>, but <span class="math">\(G\)</span> may have polynomial coefficients.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfminim">
<code class="descname">qfminim</code><span class="sig-paren">(</span><em>x</em>, <em>b=None</em>, <em>m=None</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfminim" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> being a square and symmetric matrix representing a positive definite
quadratic form, this function deals with the vectors of <span class="math">\(x\)</span> whose norm is
less than or equal to <span class="math">\(b\)</span>, enumerated using the Fincke-Pohst algorithm,
storing at most <span class="math">\(m\)</span> vectors (no limit if <span class="math">\(m\)</span> is omitted). The function
searches for the minimal non-zero vectors if <span class="math">\(b\)</span> is omitted. The behavior is
undefined if <span class="math">\(x\)</span> is not positive definite (a &#8220;precision too low&#8221; error is
most likely, although more precise error messages are possible). The precise
behavior depends on <span class="math">\(flag\)</span>.</p>
<p>If <span class="math">\(flag = 0\)</span> (default), returns at most <span class="math">\(2m\)</span> vectors. The result is a
three-component vector, the first component being the number of vectors
enumerated (which may be larger than <span class="math">\(2m\)</span>), the second being the maximum
norm found, and the last vector
is a matrix whose columns are found vectors, only one being given for each
pair <span class="math">\(± v\)</span> (at most <span class="math">\(m\)</span> such pairs, unless <span class="math">\(m\)</span> was omitted). The vectors
are returned in no particular order.</p>
<p>If <span class="math">\(flag = 1\)</span>, ignores <span class="math">\(m\)</span> and returns <span class="math">\([N,v]\)</span>, where <span class="math">\(v\)</span> is a non-zero vector
of length <span class="math">\(N &lt;= b\)</span>, or <span class="math">\([]\)</span> if no non-zero vector has length <span class="math">\(&lt;= b\)</span>.
If no explicit <span class="math">\(b\)</span> is provided, return a vector of smallish norm
(smallest vector in an LLL-reduced basis).</p>
<p>In these two cases, <span class="math">\(x\)</span> must have <em>integral</em> entries. The
implementation uses low precision floating point computations for maximal
speed, which gives incorrect result when <span class="math">\(x\)</span> has large entries. (The
condition is checked in the code and the routine raises an error if
large rounding errors occur.) A more robust, but much slower,
implementation is chosen if the following flag is used:</p>
<p>If <span class="math">\(flag = 2\)</span>, <span class="math">\(x\)</span> can have non integral real entries. In this case, if <span class="math">\(b\)</span>
is omitted, the &#8220;minimal&#8221; vectors only have approximately the same norm.
If <span class="math">\(b\)</span> is omitted, <span class="math">\(m\)</span> is an upper bound for the number of vectors that
will be stored and returned, but all minimal vectors are nevertheless
enumerated. If <span class="math">\(m\)</span> is omitted, all vectors found are stored and returned;
note that this may be a huge vector!</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? x = matid(2);
? qfminim(x) \\ 4 minimal vectors of norm 1: ±[0,1], ±[1,0]
%2 = [4, 1, [0, 1; 1, 0]]
? { x =
[4, 2, 0, 0, 0,-2, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 1, 0,-1, 0, 0, 0,-2;
 2, 4,-2,-2, 0,-2, 0, 0, 0, 0, 0, 0, 0,-1, 0, 0, 0, 0, 0,-1, 0, 1,-1,-1;
 0,-2, 4, 0,-2, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 1, 0, 0, 1,-1,-1, 0, 0;
 0,-2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 1,-1, 0, 1,-1, 1, 0;
 0, 0,-2, 0, 4, 0, 0, 0, 1,-1, 0, 0, 1, 0, 0, 0,-2, 0, 0,-1, 1, 1, 0, 0;
-2, -2,0, 0, 0, 4,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,-1, 1, 1;
 0, 0, 0, 0, 0,-2, 4,-2, 0, 0, 0, 0, 0, 1, 0, 0, 0,-1, 0, 0, 0, 1,-1, 0;
 0, 0, 0, 0, 0, 0,-2, 4, 0, 0, 0, 0,-1, 0, 0, 0, 0, 0,-1,-1,-1, 0, 1, 0;
 0, 0, 0, 0, 1,-1, 0, 0, 4, 0,-2, 0, 1, 1, 0,-1, 0, 1, 0, 0, 0, 0, 0, 0;
 0, 0, 0, 0,-1, 0, 0, 0, 0, 4, 0, 0, 1, 1,-1, 1, 0, 0, 0, 1, 0, 0, 1, 0;
 0, 0, 0, 0, 0, 0, 0, 0,-2, 0, 4,-2, 0,-1, 0, 0, 0,-1, 0,-1, 0, 0, 0, 0;
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 4,-1, 1, 0, 0,-1, 1, 0, 1, 1, 1,-1, 0;
 1, 0,-1, 1, 1, 0, 0,-1, 1, 1, 0,-1, 4, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1,-1;
-1,-1, 1,-1, 0, 0, 1, 0, 1, 1,-1, 1, 0, 4, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1;
 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 0, 0, 0, 1, 4, 0, 0, 0, 1, 0, 0, 0, 0, 0;
 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 1, 1, 0, 4, 0, 0, 0, 0, 1, 1, 0, 0;
 0, 0, 1, 0,-2, 0, 0, 0, 0, 0, 0,-1, 0, 0, 0, 0, 4, 1, 1, 1, 0, 0, 1, 1;
 1, 0, 0, 1, 0, 0,-1, 0, 1, 0,-1, 1, 1, 0, 0, 0, 1, 4, 0, 1, 1, 0, 1, 0;
 0, 0, 0,-1, 0, 1, 0,-1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 4, 0, 1, 1, 0, 1;
-1, -1,1, 0,-1, 1, 0,-1, 0, 1,-1, 1, 0, 1, 0, 0, 1, 1, 0, 4, 0, 0, 1, 1;
 0, 0,-1, 1, 1, 0, 0,-1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 4, 1, 0, 1;
 0, 1,-1,-1, 1,-1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 4, 0, 1;
 0,-1, 0, 1, 0, 1,-1, 1, 0, 1, 0,-1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 4, 1;
-2,-1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 4]; }
? qfminim(x,,0) \\ the Leech lattice has 196560 minimal vectors of norm 4
time = 648 ms.
%4 = [196560, 4, [;]]
? qfminim(x,,0,2); \\ safe algorithm. Slower and unnecessary here.
time = 18,161 ms.
%5 = [196560, 4.000061035156250000, [;]]
</pre></div>
</div>
<p>In the last example, we store 0 vectors to limit memory use. All minimal
vectors are nevertheless enumerated. Provided <code class="docutils literal"><span class="pre">parisize</span></code> is about 50MB,
<code class="docutils literal"><span class="pre">qfminim(x)</span></code> succeeds in 2.5 seconds.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfnorm">
<code class="descname">qfnorm</code><span class="sig-paren">(</span><em>x</em>, <em>q=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the binary quadratic form <span class="math">\(q\)</span> (symmetric matrix)
at the vector <span class="math">\(x\)</span>. If <span class="math">\(q\)</span> omitted, use the standard Euclidean form,
corresponding to the identity matrix.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">x~</span> <span class="pre">*</span> <span class="pre">q</span> <span class="pre">*</span> <span class="pre">x</span></code>, but about twice faster and
more convenient (does not distinguish between column and row vectors):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? x = [1,2,3]~; qfnorm(x)
%1 = 14
? q = [1,2,3;2,2,-1;3,-1,0]; qfnorm(x, q)
%2 = 23
? for(i=1,10^6, qfnorm(x,q))
time = 384ms.
? for(i=1,10^6, x~*q*x)
time = 729ms.
</pre></div>
</div>
<p>We also allow <code class="docutils literal"><span class="pre">t_MAT</span></code>&nbsp;s of compatible dimensions for <span class="math">\(x\)</span>,
and return <code class="docutils literal"><span class="pre">x~</span> <span class="pre">*</span> <span class="pre">q</span> <span class="pre">*</span> <span class="pre">x</span></code> in this case as well:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? M = [1,2,3;4,5,6;7,8,9]; qfnorm(M) \\ Gram matrix
%5 =
[66 78 90]

[78 93 108]

[90 108 126]

? for(i=1,10^6, qfnorm(M,q))
time = 2,144 ms.
? for(i=1,10^6, M~*q*M)
time = 2,793 ms.
</pre></div>
</div>
<p>The polar form is also available, as <code class="docutils literal"><span class="pre">qfbil</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qforbits">
<code class="descname">qforbits</code><span class="sig-paren">(</span><em>G</em>, <em>V</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qforbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the orbits of <span class="math">\(V\)</span> under the action of the group
of linear transformation generated by the set <span class="math">\(G\)</span>.
It is assumed that <span class="math">\(G\)</span> contains minus identity, and only one vector
in <span class="math">\({v, -v}\)</span> should be given.
If <span class="math">\(G\)</span> does not stabilize <span class="math">\(V\)</span>, the function return <span class="math">\(0\)</span>.</p>
<p>In the example below, we compute representatives and lengths of the orbits of
the vectors of norm <span class="math">\(&lt;= 3\)</span> under the automorphisms of the lattice <span class="math">\(A_1^6\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? Q=matid(6); G=qfauto(Q); V=qfminim(Q,3);
? apply(x-&gt;[x[1],#x],qforbits(G,V))
%2 = [[[0,0,0,0,0,1]~,6],[[0,0,0,0,1,-1]~,30],[[0,0,0,1,-1,-1]~,80]]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfparam">
<code class="descname">qfparam</code><span class="sig-paren">(</span><em>G</em>, <em>sol</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfparam" title="Permalink to this definition">¶</a></dt>
<dd><p>Coefficients of binary quadratic forms that parametrize the
solutions of the ternary quadratic form <span class="math">\(G\)</span>, using the particular
solution&nbsp;<em>sol</em>.
<em>flag</em> is optional and can be 1, 2, or 3, in which case the <em>flag</em>-th form is
reduced. The default is <em>flag</em> = 0 (no reduction).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = [1,0,0;0,1,0;0,0,-34];
? M = qfparam(G, qfsolve(G))
%2 =
[ 3 -10 -3]

[-5 -6 5]

[ 1 0 1]
</pre></div>
</div>
<p>Indeed, the solutions can be parametrized as</p>
<div class="math">
\[(3x^2 - 10xy - 3y^2)^2 + (-5x^2 - 6xy + 5y^2)^2 -34(x^2 + y^2)^2 = 0.\]</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>? v = y^2 * M*[1,x/y,(x/y)^2]~
%3 = [3*x^2 - 10*y*x - 3*y^2, -5*x^2 - 6*y*x + 5*y^2, -x^2 - y^2]~
? v~*G*v
%4 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfperfection">
<code class="descname">qfperfection</code><span class="sig-paren">(</span><em>G</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfperfection" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(G\)</span> being a square and symmetric matrix with
integer entries representing a positive definite quadratic form, outputs the
perfection rank of the form. That is, gives the rank of the family of the <span class="math">\(s\)</span>
symmetric matrices <span class="math">\(v_iv_i^t\)</span>, where <span class="math">\(s\)</span> is half the number of minimal
vectors and the <span class="math">\(v_i\)</span> (<span class="math">\(1 &lt;= i &lt;= s\)</span>) are the minimal vectors.</p>
<p>Since this requires computing the minimal vectors, the computations can
become very lengthy as the dimension of <span class="math">\(x\)</span> grows.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfrep">
<code class="descname">qfrep</code><span class="sig-paren">(</span><em>q</em>, <em>B</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfrep" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(q\)</span> being a square and symmetric matrix with integer entries representing a
positive definite quadratic form, count the vectors representing successive
integers.</p>
<ul class="simple">
<li>If <span class="math">\(flag = 0\)</span>, count all vectors. Outputs the vector whose <span class="math">\(i\)</span>-th
entry, <span class="math">\(1 &lt;= i &lt;= B\)</span> is half the number of vectors <span class="math">\(v\)</span> such that <span class="math">\(q(v) = i\)</span>.</li>
<li>If <span class="math">\(flag = 1\)</span>, count vectors of even norm. Outputs the vector
whose <span class="math">\(i\)</span>-th entry, <span class="math">\(1 &lt;= i &lt;= B\)</span> is half the number of vectors such
that <span class="math">\(q(v) = 2i\)</span>.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? q = [2, 1; 1, 3];
? qfrep(q, 5)
%2 = Vecsmall([0, 1, 2, 0, 0]) \\ 1 vector of norm 2, 2 of norm 3, etc.
? qfrep(q, 5, 1)
%3 = Vecsmall([1, 0, 0, 1, 0]) \\ 1 vector of norm 2, 0 of norm 4, etc.
</pre></div>
</div>
<p>This routine uses a naive algorithm based on <code class="docutils literal"><span class="pre">qfminim</span></code>, and
will fail if any entry becomes larger than <span class="math">\(2^{31}\)</span> (or <span class="math">\(2^{63}\)</span>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfsign">
<code class="descname">qfsign</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfsign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <span class="math">\([p,m]\)</span> the signature of the quadratic form represented by the
symmetric matrix <span class="math">\(x\)</span>. Namely, <span class="math">\(p\)</span> (resp.&nbsp;<span class="math">\(m\)</span>) is the number of positive
(resp.&nbsp;negative) eigenvalues of <span class="math">\(x\)</span>. The result is computed using Gaussian
reduction.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.qfsolve">
<code class="descname">qfsolve</code><span class="sig-paren">(</span><em>G</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.qfsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a square symmetric matrix <span class="math">\(G\)</span> of dimension <span class="math">\(n &gt;= 1\)</span>, solve over
<span class="math">\(\mathbb{Q}\)</span> the quadratic equation <span class="math">\(X^tGX = 0\)</span>. The matrix <span class="math">\(G\)</span> must have rational
coefficients. The solution might be a single non-zero vector (vectorv) or a
matrix (whose columns generate a totally isotropic subspace).</p>
<p>If no solution exists, returns an integer, that can be a prime <span class="math">\(p\)</span> such that
there is no local solution at <span class="math">\(p\)</span>, or <span class="math">\(-1\)</span> if there is no real solution,
or <span class="math">\(-2\)</span> if <span class="math">\(n = 2\)</span> and <span class="math">\(-\det G\)</span> is positive but not a square (which implies
there is a real solution, but no local solution at some <span class="math">\(p\)</span> dividing <span class="math">\(\det G\)</span>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = [1,0,0;0,1,0;0,0,-34];
? qfsolve(G)
%1 = [-3, -5, 1]~
? qfsolve([1,0; 0,2])
%2 = -1 \\ no real solution
? qfsolve([1,0,0;0,3,0; 0,0,-2])
%3 = 3 \\ no solution in Q_3
? qfsolve([1,0; 0,-2])
%4 = -2 \\ no solution, n = 2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.quadclassunit">
<code class="descname">quadclassunit</code><span class="sig-paren">(</span><em>D</em>, <em>flag=0</em>, <em>tech=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.quadclassunit" title="Permalink to this definition">¶</a></dt>
<dd><p>Buchmann-McCurley&#8217;s sub-exponential algorithm for computing the
class group of a quadratic order of discriminant <span class="math">\(D\)</span>.</p>
<p>This function should be used instead of <code class="docutils literal"><span class="pre">qfbclassno</span></code> or <code class="docutils literal"><span class="pre">quadregula</span></code>
when <span class="math">\(D &lt; -10^{25}\)</span>, <span class="math">\(D &gt; 10^{10}\)</span>, or when the <em>structure</em> is wanted. It
is a special case of <code class="docutils literal"><span class="pre">bnfinit</span></code>, which is slower, but more robust.</p>
<p>The result is a vector <span class="math">\(v\)</span> whose components should be accessed using member
functions:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">:math:`v</span></code>.no`: the class number</li>
<li><code class="docutils literal"><span class="pre">:math:`v</span></code>.cyc`: a vector giving the structure of the class group as a
product of cyclic groups;</li>
<li><code class="docutils literal"><span class="pre">:math:`v</span></code>.gen`: a vector giving generators of those cyclic groups (as
binary quadratic forms).</li>
<li><code class="docutils literal"><span class="pre">:math:`v</span></code>.reg`: the regulator, computed to an accuracy which is the
maximum of an internal accuracy determined by the program and the current
default (note that once the regulator is known to a small accuracy it is
trivial to compute it to very high accuracy, see the tutorial).</li>
</ul>
<p>The <span class="math">\(flag\)</span> is obsolete and should be left alone. In older versions,
it supposedly computed the narrow class group when <span class="math">\(D &gt; 0\)</span>, but this did not
work at all; use the general function <code class="docutils literal"><span class="pre">bnfnarrow</span></code>.</p>
<p>Optional parameter <em>tech</em> is a row vector of the form <span class="math">\([c_1, c_2]\)</span>,
where <span class="math">\(c_1 &lt;= c_2\)</span> are non-negative real numbers which control the execution
time and the stack size, see <code class="docutils literal"><span class="pre">GRHbnf</span></code> (in the PARI manual). The parameter is used as a
threshold to balance the relation finding phase against the final linear
algebra. Increasing the default <span class="math">\(c_1\)</span> means that relations are easier
to find, but more relations are needed and the linear algebra will be
harder. The default value for <span class="math">\(c_1\)</span> is <span class="math">\(0\)</span> and means that it is taken equal
to <span class="math">\(c_2\)</span>. The parameter <span class="math">\(c_2\)</span> is mostly obsolete and should not be changed,
but we still document it for completeness: we compute a tentative class
group by generators and relations using a factorbase of prime ideals
<span class="math">\(&lt;= c_1 (\log \|D\|)^2\)</span>, then prove that ideals of norm
<span class="math">\(&lt;= c_2 (\log \|D\|)^2\)</span> do
not generate a larger group. By default an optimal <span class="math">\(c_2\)</span> is chosen, so that
the result is provably correct under the GRH &#8212; a famous result of Bach
states that <span class="math">\(c_2 = 6\)</span> is fine, but it is possible to improve on this
algorithmically. You may provide a smaller <span class="math">\(c_2\)</span>, it will be ignored
(we use the provably correct
one); you may provide a larger <span class="math">\(c_2\)</span> than the default value, which results
in longer computing times for equally correct outputs (under GRH).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.quaddisc">
<code class="descname">quaddisc</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.quaddisc" title="Permalink to this definition">¶</a></dt>
<dd><p>Discriminant of the étale algebra <span class="math">\(\mathbb{Q}(\sqrt{x})\)</span>, where <span class="math">\(x belongs to \mathbb{Q}^*\)</span>.
This is the same as <code class="docutils literal"><span class="pre">coredisc</span></code><span class="math">\((d)\)</span> where <span class="math">\(d\)</span> is the integer square-free
part of <span class="math">\(x\)</span>, so x = <span class="math">\(d f^2\)</span> with <span class="math">\(f belongs to \mathbb{Q}^*\)</span> and <span class="math">\(d belongs to \mathbb{Z}\)</span>.
This returns <span class="math">\(0\)</span> for <span class="math">\(x = 0\)</span>, <span class="math">\(1\)</span> for <span class="math">\(x\)</span> square and the discriminant of the
quadratic field <span class="math">\(\mathbb{Q}(\sqrt{x})\)</span> otherwise.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? quaddisc(7)
%1 = 28
? quaddisc(-7)
%2 = -7
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.quadgen">
<code class="descname">quadgen</code><span class="sig-paren">(</span><em>D</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.quadgen" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the quadratic
number <span class="math">\(\omega = (a+\sqrt{D})/2\)</span> where <span class="math">\(a = 0\)</span> if <span class="math">\(D = 0 mod 4\)</span>,
<span class="math">\(a = 1\)</span> if <span class="math">\(D = 1 mod 4\)</span>, so that <span class="math">\((1,\omega)\)</span> is an integral basis for the
quadratic order of discriminant <span class="math">\(D\)</span>. <span class="math">\(D\)</span> must be an integer congruent to 0 or
1 modulo 4, which is not a square.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.quadhilbert">
<code class="descname">quadhilbert</code><span class="sig-paren">(</span><em>D</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.quadhilbert" title="Permalink to this definition">¶</a></dt>
<dd><p>Relative equation defining the
Hilbert class field of the quadratic field of discriminant <span class="math">\(D\)</span>.</p>
<p>If <span class="math">\(D &lt; 0\)</span>, uses complex multiplication (Schertz&#8217;s variant).</p>
<p>If <span class="math">\(D &gt; 0\)</span> Stark units are used and (in rare cases) a
vector of extensions may be returned whose compositum is the requested class
field. See <code class="docutils literal"><span class="pre">bnrstark</span></code> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.quadpoly">
<code class="descname">quadpoly</code><span class="sig-paren">(</span><em>D</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.quadpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the &#8220;canonical&#8221; quadratic
polynomial (in the variable <span class="math">\(v\)</span>) corresponding to the discriminant <span class="math">\(D\)</span>,
i.e.&nbsp;the minimal polynomial of <span class="math">\(quadgen(D)\)</span>. <span class="math">\(D\)</span> must be an integer
congruent to 0 or 1 modulo 4, which is not a square.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.quadray">
<code class="descname">quadray</code><span class="sig-paren">(</span><em>D</em>, <em>f</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.quadray" title="Permalink to this definition">¶</a></dt>
<dd><p>Relative equation for the ray
class field of conductor <span class="math">\(f\)</span> for the quadratic field of discriminant <span class="math">\(D\)</span>
using analytic methods. A <code class="docutils literal"><span class="pre">bnf</span></code> for <span class="math">\(x^2 - D\)</span> is also accepted in place
of <span class="math">\(D\)</span>.</p>
<p>For <span class="math">\(D &lt; 0\)</span>, uses the <span class="math">\(\sigma\)</span> function and Schertz&#8217;s method.</p>
<p>For <span class="math">\(D &gt; 0\)</span>, uses Stark&#8217;s conjecture, and a vector of relative equations may be
returned. See <code class="docutils literal"><span class="pre">bnrstark</span></code> for more details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.quadregulator">
<code class="descname">quadregulator</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.quadregulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Regulator of the quadratic field of positive discriminant <span class="math">\(x\)</span>. Returns
an error if <span class="math">\(x\)</span> is not a discriminant (fundamental or not) or if <span class="math">\(x\)</span> is a
square. See also <code class="docutils literal"><span class="pre">quadclassunit</span></code> if <span class="math">\(x\)</span> is large.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.quadunit">
<code class="descname">quadunit</code><span class="sig-paren">(</span><em>D</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.quadunit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fundamental unit of the
real quadratic field <span class="math">\(\mathbb{Q}(\sqrt D)\)</span> where <span class="math">\(D\)</span> is the positive discriminant
of the field. If <span class="math">\(D\)</span> is not a fundamental discriminant, this probably gives
the fundamental unit of the corresponding order. <span class="math">\(D\)</span> must be an integer
congruent to 0 or 1 modulo 4, which is not a square; the result is a
quadratic number (see <code class="docutils literal"><span class="pre">quadgen</span></code> (in the PARI manual)).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.ramanujantau">
<code class="descname">ramanujantau</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.ramanujantau" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value of Ramanujan&#8217;s tau function at an individual <span class="math">\(n\)</span>,
assuming the truth of the GRH (to compute quickly class numbers of imaginary
quadratic fields using <code class="docutils literal"><span class="pre">quadclassunit</span></code>).
Algorithm in <span class="math">\(~{O}(n^{1/2})\)</span> using <span class="math">\(O(\log n)\)</span> space. If all values up
to <span class="math">\(N\)</span> are required, then</p>
<div class="math">
\[\sum \tau(n)q^n = q \prod_{n &gt;= 1} (1-q^n)^{24}\]</div>
<p>will produce them in time <span class="math">\(~{O}(N)\)</span>, against <span class="math">\(~{O}(N^{3/2})\)</span> for
individual calls to <code class="docutils literal"><span class="pre">ramanujantau</span></code>; of course the space complexity then
becomes <span class="math">\(~{O}(N)\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? tauvec(N) = Vec(q*eta(q + O(q^N))^24);
? N = 10^4; v = tauvec(N);
time = 26 ms.
? ramanujantau(N)
%3 = -482606811957501440000
? w = vector(N, n, ramanujantau(n)); \\ much slower !
time = 13,190 ms.
? v == w
%4 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.random">
<code class="descname">random</code><span class="sig-paren">(</span><em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.random" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random element in various natural sets depending on the
argument <span class="math">\(N\)</span>.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">t_INT</span></code>: returns an integer
uniformly distributed between <span class="math">\(0\)</span> and <span class="math">\(N-1\)</span>. Omitting the argument
is equivalent to <code class="docutils literal"><span class="pre">random(2^31)</span></code>.</li>
<li><code class="docutils literal"><span class="pre">t_REAL</span></code>: returns a real number in <span class="math">\([0,1[\)</span> with the same accuracy as
<span class="math">\(N\)</span> (whose mantissa has the same number of significant words).</li>
<li><code class="docutils literal"><span class="pre">t_INTMOD</span></code>: returns a random intmod for the same modulus.</li>
<li><code class="docutils literal"><span class="pre">t_FFELT</span></code>: returns a random element in the same finite field.</li>
<li><code class="docutils literal"><span class="pre">t_VEC</span></code> of length <span class="math">\(2\)</span>, <span class="math">\(N = [a,b]\)</span>: returns an integer uniformly
distributed between <span class="math">\(a\)</span> and <span class="math">\(b\)</span>.</li>
<li><code class="docutils literal"><span class="pre">t_VEC</span></code> generated by <code class="docutils literal"><span class="pre">ellinit</span></code> over a finite field <span class="math">\(k\)</span>
(coefficients are <code class="docutils literal"><span class="pre">t_INTMOD</span></code>&nbsp;s modulo a prime or <code class="docutils literal"><span class="pre">t_FFELT</span></code>&nbsp;s): returns a
&#8220;random&#8221; <span class="math">\(k\)</span>-rational <em>affine</em> point on the curve. More precisely
if the curve has a single point (at infinity!) we return it; otherwise
we return an affine point by drawing an abscissa uniformly at
random until <code class="docutils literal"><span class="pre">ellordinate</span></code> succeeds. Note that this is definitely not a
uniform distribution over <span class="math">\(E(k)\)</span>, but it should be good enough for
applications.</li>
<li><code class="docutils literal"><span class="pre">t_POL</span></code> return a random polynomial of degree at most the degree of <span class="math">\(N\)</span>.
The coefficients are drawn by applying <code class="docutils literal"><span class="pre">random</span></code> to the leading
coefficient of <span class="math">\(N\)</span>.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? random(10)
%1 = 9
? random(Mod(0,7))
%2 = Mod(1, 7)
? a = ffgen(ffinit(3,7), &#39;a); random(a)
%3 = a^6 + 2*a^5 + a^4 + a^3 + a^2 + 2*a
? E = ellinit([3,7]*Mod(1,109)); random(E)
%4 = [Mod(103, 109), Mod(10, 109)]
? E = ellinit([1,7]*a^0); random(E)
%5 = [a^6 + a^5 + 2*a^4 + 2*a^2, 2*a^6 + 2*a^4 + 2*a^3 + a^2 + 2*a]
? random(Mod(1,7)*x^4)
%6 = Mod(5, 7)*x^4 + Mod(6, 7)*x^3 + Mod(2, 7)*x^2 + Mod(2, 7)*x + Mod(5, 7)
</pre></div>
</div>
<p>These variants all depend on a single internal generator, and are
independent from your operating system&#8217;s random number generators.
A random seed may be obtained via <code class="docutils literal"><span class="pre">getrand</span></code>, and reset
using <code class="docutils literal"><span class="pre">setrand</span></code>: from a given seed, and given sequence of <code class="docutils literal"><span class="pre">random</span></code>&nbsp;s,
the exact same values will be generated. The same seed is used at each
startup, reseed the generator yourself if this is a problem. Note that
internal functions also call the random number generator; adding such a
function call in the middle of your code will change the numbers produced.</p>
<p><strong>Technical note.</strong>
Up to
version 2.4 included, the internal generator produced pseudo-random numbers
by means of linear congruences, which were not well distributed in arithmetic
progressions. We now
use Brent&#8217;s XORGEN algorithm, based on Feedback Shift Registers, see
<code class="docutils literal"><span class="pre">http://wwwmaths.anu.edu.au/~brent/random.html</span></code>. The generator has period
<span class="math">\(2^{4096}-1\)</span>, passes the Crush battery of statistical tests of L&#8217;Ecuyer and
Simard, but is not suitable for cryptographic purposes: one can reconstruct
the state vector from a small sample of consecutive values, thus predicting
the entire sequence.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.randomprime">
<code class="descname">randomprime</code><span class="sig-paren">(</span><em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.randomprime" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a strong pseudo prime (see <code class="docutils literal"><span class="pre">ispseudoprime</span></code>) in <span class="math">\([2,N-1]\)</span>.
A <code class="docutils literal"><span class="pre">t_VEC</span></code> <span class="math">\(N = [a,b]\)</span> is also allowed, with <span class="math">\(a &lt;= b\)</span> in which case a
pseudo prime <span class="math">\(a &lt;= p &lt;= b\)</span> is returned; if no prime exists in the
interval, the function will run into an infinite loop. If the upper bound
is less than <span class="math">\(2^{64}\)</span> the pseudo prime returned is a proven prime.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.real">
<code class="descname">real</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.real" title="Permalink to this definition">¶</a></dt>
<dd><p>Real part of <span class="math">\(x\)</span>. In the case where <span class="math">\(x\)</span> is a quadratic number, this is the
coefficient of <span class="math">\(1\)</span> in the &#8220;canonical&#8221; integral basis <span class="math">\((1,\omega)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.removeprimes">
<code class="descname">removeprimes</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.removeprimes" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the primes listed in <span class="math">\(x\)</span> from
the prime number table. In particular <code class="docutils literal"><span class="pre">removeprimes(addprimes())</span></code> empties
the extra prime table. <span class="math">\(x\)</span> can also be a single integer. List the current
extra primes if <span class="math">\(x\)</span> is omitted.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfalgtobasis">
<code class="descname">rnfalgtobasis</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfalgtobasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Expresses <span class="math">\(x\)</span> on the relative
integral basis. Here, <span class="math">\(rnf\)</span> is a relative number field extension <span class="math">\(L/K\)</span>
as output by <code class="docutils literal"><span class="pre">rnfinit</span></code>, and <span class="math">\(x\)</span> an element of <span class="math">\(L\)</span> in absolute form, i.e.
expressed as a polynomial or polmod with polmod coefficients, <em>not</em> on
the relative integral basis.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfbasis">
<code class="descname">rnfbasis</code><span class="sig-paren">(</span><em>bnf</em>, <em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(K\)</span> the field represented by
<em>bnf</em>, as output by <code class="docutils literal"><span class="pre">bnfinit</span></code>. <span class="math">\(M\)</span> is a projective <span class="math">\(\mathbb{Z}_K\)</span>-module
of rank <span class="math">\(n\)</span> (<span class="math">\(M\otimes K\)</span> is an <span class="math">\(n\)</span>-dimensional <span class="math">\(K\)</span>-vector space), given by a
pseudo-basis of size <span class="math">\(n\)</span>. The routine returns either a true <span class="math">\(\mathbb{Z}_K\)</span>-basis of
<span class="math">\(M\)</span> (of size <span class="math">\(n\)</span>) if it exists, or an <span class="math">\(n+1\)</span>-element generating set of <span class="math">\(M\)</span> if
not.</p>
<p>It is allowed to use an irreducible polynomial <span class="math">\(P\)</span> in <span class="math">\(K[X]\)</span> instead of <span class="math">\(M\)</span>,
in which case, <span class="math">\(M\)</span> is defined as the ring of integers of <span class="math">\(K[X]/(P)\)</span>, viewed
as a <span class="math">\(\mathbb{Z}_K\)</span>-module.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfbasistoalg">
<code class="descname">rnfbasistoalg</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfbasistoalg" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the representation of <span class="math">\(x\)</span>
as a polmod with polmods coefficients. Here, <span class="math">\(rnf\)</span> is a relative number
field extension <span class="math">\(L/K\)</span> as output by <code class="docutils literal"><span class="pre">rnfinit</span></code>, and <span class="math">\(x\)</span> an element of
<span class="math">\(L\)</span> expressed on the relative integral basis.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfcharpoly">
<code class="descname">rnfcharpoly</code><span class="sig-paren">(</span><em>nf</em>, <em>T</em>, <em>a</em>, <em>var=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfcharpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>Characteristic polynomial of
<span class="math">\(a\)</span> over <span class="math">\(nf\)</span>, where <span class="math">\(a\)</span> belongs to the algebra defined by <span class="math">\(T\)</span> over
<span class="math">\(nf\)</span>, i.e.&nbsp;<span class="math">\(nf[X]/(T)\)</span>. Returns a polynomial in variable <span class="math">\(v\)</span>
(<span class="math">\(x\)</span> by default).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2+1);
? rnfcharpoly(nf, x^2+y*x+1, x+y)
%2 = x^2 + Mod(-y, y^2 + 1)*x + 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfconductor">
<code class="descname">rnfconductor</code><span class="sig-paren">(</span><em>bnf</em>, <em>pol</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfconductor" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <span class="math">\(bnf\)</span>
as output by <code class="docutils literal"><span class="pre">bnfinit</span></code>, and <em>pol</em> a relative polynomial defining an
Abelian extension, computes the class field theory conductor of this
Abelian extension. The result is a 3-component vector
<span class="math">\([conductor,bnr,subgroup]\)</span>, where <em>conductor</em> is
the conductor of the extension given as a 2-component row vector
<span class="math">\([f_0,f_ oo ]\)</span>, <em>bnr</em> is the associated <code class="docutils literal"><span class="pre">bnr</span></code> structure
and <em>subgroup</em> is a matrix in HNF defining the subgroup of the ray class
group on <code class="docutils literal"><span class="pre">bnr.gen</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfdedekind">
<code class="descname">rnfdedekind</code><span class="sig-paren">(</span><em>nf</em>, <em>pol</em>, <em>pr=None</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfdedekind" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a number field <span class="math">\(K\)</span> coded by <span class="math">\(nf\)</span> and a monic
polynomial <span class="math">\(P belongs to \mathbb{Z}_K[X]\)</span>, irreducible over <span class="math">\(K\)</span> and thus defining a relative
extension <span class="math">\(L\)</span> of <span class="math">\(K\)</span>, applies Dedekind&#8217;s criterion to the order
<span class="math">\(\mathbb{Z}_K[X]/(P)\)</span>, at the prime ideal <em>pr</em>. It is possible to set <em>pr</em>
to a vector of prime ideals (test maximality at all primes in the vector),
or to omit altogether, in which case maximality at <em>all</em> primes is tested;
in this situation <em>flag</em> is automatically set to <span class="math">\(1\)</span>.</p>
<p>The default historic behavior (<em>flag</em> is 0 or omitted and <em>pr</em> is a
single prime ideal) is not so useful since
<code class="docutils literal"><span class="pre">rnfpseudobasis</span></code> gives more information and is generally not that
much slower. It returns a 3-component vector <span class="math">\([max, basis, v]\)</span>:</p>
<ul class="simple">
<li><em>basis</em> is a pseudo-basis of an enlarged order <span class="math">\(O\)</span> produced by
Dedekind&#8217;s criterion, containing the original order <span class="math">\(\mathbb{Z}_K[X]/(P)\)</span>
with index a power of <em>pr</em>. Possibly equal to the original order.</li>
<li><em>max</em> is a flag equal to 1 if the enlarged order <span class="math">\(O\)</span>
could be proven to be <em>pr</em>-maximal and to 0 otherwise; it may still be
maximal in the latter case if <em>pr</em> is ramified in <span class="math">\(L\)</span>,</li>
<li><span class="math">\(v\)</span> is the valuation at <em>pr</em> of the order discriminant.</li>
</ul>
<p>If <em>flag</em> is non-zero, on the other hand, we just return <span class="math">\(1\)</span> if the order
<span class="math">\(\mathbb{Z}_K[X]/(P)\)</span> is <em>pr</em>-maximal (resp.&nbsp;maximal at all relevant primes, as
described above), and <span class="math">\(0\)</span> if not. This is much faster than the default,
since the enlarged order is not computed.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? nf = nfinit(y^2-3); P = x^3 - 2*y;
? pr3 = idealprimedec(nf,3)[1];
? rnfdedekind(nf, P, pr3)
%3 = [1, [[1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 1, 1]], 8]
? rnfdedekind(nf, P, pr3, 1)
%4 = 1
</pre></div>
</div>
<p>In this example, <code class="docutils literal"><span class="pre">pr3</span></code> is the ramified ideal above <span class="math">\(3\)</span>,
and the order generated by the cube roots of <span class="math">\(y\)</span> is already
<code class="docutils literal"><span class="pre">pr3</span></code>-maximal. The order-discriminant has valuation <span class="math">\(8\)</span>. On the other
hand, the order is not maximal at the prime above 2:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? pr2 = idealprimedec(nf,2)[1];
? rnfdedekind(nf, P, pr2, 1)
%6 = 0
? rnfdedekind(nf, P, pr2)
%7 = [0, [[2, 0, 0; 0, 1, 0; 0, 0, 1], [[1, 0; 0, 1], [1, 0; 0, 1],
 [1, 1/2; 0, 1/2]]], 2]
</pre></div>
</div>
<p>The enlarged order is not proven to be <code class="docutils literal"><span class="pre">pr2</span></code>-maximal yet. In fact, it
is; it is in fact the maximal order:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? B = rnfpseudobasis(nf, P)
%8 = [[1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 1, [1, 1/2; 0, 1/2]],
 [162, 0; 0, 162], -1]
? idealval(nf,B[3], pr2)
%9 = 2
</pre></div>
</div>
<p>It is possible to use this routine with non-monic
<span class="math">\(P = \sum_{i &lt;= n} a_i X^i belongs to \mathbb{Z}_K[X]\)</span> if <span class="math">\(flag = 1\)</span>;
in this case, we test maximality of Dedekind&#8217;s order generated by</p>
<div class="math">
\[1, a_n \alpha, a_n\alpha^2 + a_{n-1}\alpha,...,
a_n\alpha^{n-1} + a_{n-1}\alpha^{n-2} +...+ a_1\alpha.\]</div>
<p>The routine will fail if <span class="math">\(P\)</span> is <span class="math">\(0\)</span> on the projective line over the residue
field <span class="math">\(\mathbb{Z}_K/pr\)</span> (FIXME).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfdet">
<code class="descname">rnfdet</code><span class="sig-paren">(</span><em>nf</em>, <em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfdet" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a pseudo-matrix <span class="math">\(M\)</span> over the maximal
order of <span class="math">\(nf\)</span>, computes its determinant.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfdisc">
<code class="descname">rnfdisc</code><span class="sig-paren">(</span><em>nf</em>, <em>pol</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfdisc" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a number field <span class="math">\(nf\)</span> as
output by <code class="docutils literal"><span class="pre">nfinit</span></code> and a polynomial <em>pol</em> with coefficients in
<span class="math">\(nf\)</span> defining a relative extension <span class="math">\(L\)</span> of <span class="math">\(nf\)</span>, computes the
relative discriminant of <span class="math">\(L\)</span>. This is a two-element row vector <span class="math">\([D,d]\)</span>, where
<span class="math">\(D\)</span> is the relative ideal discriminant and <span class="math">\(d\)</span> is the relative discriminant
considered as an element of <span class="math">\(nf^*/{nf^*}^2\)</span>. The main variable of
<span class="math">\(nf\)</span> <em>must</em> be of lower priority than that of <em>pol</em>, see
<code class="docutils literal"><span class="pre">priority</span></code> (in the PARI manual).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfeltabstorel">
<code class="descname">rnfeltabstorel</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfeltabstorel" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(rnf\)</span> be a relative
number field extension <span class="math">\(L/K\)</span> as output by <code class="docutils literal"><span class="pre">rnfinit</span></code> and let <span class="math">\(x\)</span> be an
element of <span class="math">\(L\)</span> expressed as a polynomial modulo the absolute equation
<code class="docutils literal"><span class="pre">:emphasis:`rnf</span></code>.pol`, or in terms of the absolute <span class="math">\(\mathbb{Z}\)</span>-basis for <span class="math">\(\mathbb{Z}_L\)</span>
if <em>rnf</em> contains one (as in <code class="docutils literal"><span class="pre">rnfinit(nf,pol,1)</span></code>, or after
a call to <code class="docutils literal"><span class="pre">nfinit(rnf)</span></code>).
Computes <span class="math">\(x\)</span> as an element of the relative extension
<span class="math">\(L/K\)</span> as a polmod with polmod coefficients.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? L.pol
%2 = x^4 + 1
? rnfeltabstorel(L, Mod(x, L.pol))
%3 = Mod(x, x^2 + Mod(-y, y^2 + 1))
? rnfeltabstorel(L, 1/3)
%4 = 1/3
? rnfeltabstorel(L, Mod(x, x^2-y))
%5 = Mod(x, x^2 + Mod(-y, y^2 + 1))

? rnfeltabstorel(L, [0,0,0,1]~) \\ Z_L not initialized yet
 *** at top-level: rnfeltabstorel(L,[0,
 *** ^--------------------
 *** rnfeltabstorel: incorrect type in rnfeltabstorel, apply nfinit(rnf) (t_COL).
? nfinit(L); \\ initialize now
? rnfeltabstorel(L, [0,0,0,1]~)
%6 = Mod(Mod(y, y^2 + 1)*x, x^2 + Mod(-y, y^2 + 1))
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfeltdown">
<code class="descname">rnfeltdown</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfeltdown" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative number
field extension <span class="math">\(L/K\)</span> as output by <code class="docutils literal"><span class="pre">rnfinit</span></code> and <span class="math">\(x\)</span> being an element of
<span class="math">\(L\)</span> expressed as a polynomial or polmod with polmod coefficients (or as a
<code class="docutils literal"><span class="pre">t_COL</span></code> on <code class="docutils literal"><span class="pre">nfinit(rnf).zk</span></code>), computes
<span class="math">\(x\)</span> as an element of <span class="math">\(K\)</span> as a <code class="docutils literal"><span class="pre">t_POLMOD</span></code> if <span class="math">\(flag = 0\)</span> and as a <code class="docutils literal"><span class="pre">t_COL</span></code>
otherwise. If <span class="math">\(x\)</span> is not in <span class="math">\(K\)</span>, a domain error occurs.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? L.pol
%2 = x^4 + 1
? rnfeltdown(L, Mod(x^2, L.pol))
%3 = Mod(y, y^2 + 1)
? rnfeltdown(L, Mod(x^2, L.pol), 1)
%4 = [0, 1]~
? rnfeltdown(L, Mod(y, x^2-y))
%5 = Mod(y, y^2 + 1)
? rnfeltdown(L, Mod(y,K.pol))
%6 = Mod(y, y^2 + 1)
? rnfeltdown(L, Mod(x, L.pol))
 *** at top-level: rnfeltdown(L,Mod(x,x
 *** ^--------------------
 *** rnfeltdown: domain error in rnfeltdown: element not in the base field
? rnfeltdown(L, Mod(y, x^2-y), 1) \\ as a t_COL
%7 = [0, 1]~
? rnfeltdown(L, [0,1,0,0]~) \\ not allowed without absolute nf struct
 *** rnfeltdown: incorrect type in rnfeltdown (t_COL).
? nfinit(L); \\ add absolute nf structure to L
? rnfeltdown(L, [0,1,0,0]~) \\ now OK
%8 = Mod(y, y^2 + 1)
</pre></div>
</div>
<p>If we had started with
<code class="docutils literal"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">rnfinit(K,</span> <span class="pre">x^2-y,</span> <span class="pre">1)</span></code>, then the final would have worked directly.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfeltnorm">
<code class="descname">rnfeltnorm</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfeltnorm" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative number field extension <span class="math">\(L/K\)</span> as output by
<code class="docutils literal"><span class="pre">rnfinit</span></code> and <span class="math">\(x\)</span> being an element of <span class="math">\(L\)</span>, returns the relative norm
<span class="math">\(N_{L/K}(x)\)</span> as an element of <span class="math">\(K\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? rnfeltnorm(L, Mod(x, L.pol))
%2 = Mod(x, x^2 + Mod(-y, y^2 + 1))
? rnfeltnorm(L, 2)
%3 = 4
? rnfeltnorm(L, Mod(x, x^2-y))
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfeltreltoabs">
<code class="descname">rnfeltreltoabs</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfeltreltoabs" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative
number field extension <span class="math">\(L/K\)</span> as output by <code class="docutils literal"><span class="pre">rnfinit</span></code> and <span class="math">\(x\)</span> being an
element of <span class="math">\(L\)</span> expressed as a polynomial or polmod with polmod
coefficients, computes <span class="math">\(x\)</span> as an element of the absolute extension <span class="math">\(L/\mathbb{Q}\)</span> as
a polynomial modulo the absolute equation <code class="docutils literal"><span class="pre">:emphasis:`rnf</span></code>.pol`.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? L.pol
%2 = x^4 + 1
? rnfeltreltoabs(L, Mod(x, L.pol))
%3 = Mod(x, x^4 + 1)
? rnfeltreltoabs(L, Mod(y, x^2-y))
%4 = Mod(x^2, x^4 + 1)
? rnfeltreltoabs(L, Mod(y,K.pol))
%5 = Mod(x^2, x^4 + 1)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfelttrace">
<code class="descname">rnfelttrace</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfelttrace" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative number field extension <span class="math">\(L/K\)</span> as output by
<code class="docutils literal"><span class="pre">rnfinit</span></code> and <span class="math">\(x\)</span> being an element of <span class="math">\(L\)</span>, returns the relative trace
<span class="math">\(Tr_{L/K}(x)\)</span> as an element of <span class="math">\(K\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? rnfelttrace(L, Mod(x, L.pol))
%2 = 0
? rnfelttrace(L, 2)
%3 = 4
? rnfelttrace(L, Mod(x, x^2-y))
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfeltup">
<code class="descname">rnfeltup</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfeltup" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative number field extension <span class="math">\(L/K\)</span> as output by
<code class="docutils literal"><span class="pre">rnfinit</span></code> and <span class="math">\(x\)</span> being an element of <span class="math">\(K\)</span>, computes <span class="math">\(x\)</span> as an element of
the absolute extension <span class="math">\(L/\mathbb{Q}\)</span>. As a <code class="docutils literal"><span class="pre">t_POLMOD</span></code> modulo <code class="docutils literal"><span class="pre">:emphasis:`rnf</span></code>.pol`
if <span class="math">\(flag = 0\)</span> and as a <code class="docutils literal"><span class="pre">t_COL</span></code> on the absolute field integer basis if
<span class="math">\(flag = 1\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^2+1); L = rnfinit(K, x^2-y);
? L.pol
%2 = x^4 + 1
? rnfeltup(L, Mod(y, K.pol))
%3 = Mod(x^2, x^4 + 1)
? rnfeltup(L, y)
%4 = Mod(x^2, x^4 + 1)
? rnfeltup(L, [1,2]~) \\ in terms of K.zk
%5 = Mod(2*x^2 + 1, x^4 + 1)
? rnfeltup(L, y, 1) \\ in terms of nfinit(L).zk
%6 = [0, 1, 0, 0]~
? rnfeltup(L, [1,2]~, 1)
%7 = [1, 2, 0, 0]~
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfequation">
<code class="descname">rnfequation</code><span class="sig-paren">(</span><em>nf</em>, <em>pol</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfequation" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a number field
<span class="math">\(nf\)</span> as output by <code class="docutils literal"><span class="pre">nfinit</span></code> (or simply a polynomial) and a
polynomial <em>pol</em> with coefficients in <span class="math">\(nf\)</span> defining a relative
extension <span class="math">\(L\)</span> of <span class="math">\(nf\)</span>, computes an absolute equation of <span class="math">\(L\)</span> over
<span class="math">\(\mathbb{Q}\)</span>.</p>
<p>The main variable of <span class="math">\(nf\)</span> <em>must</em> be of lower priority than that
of <em>pol</em> (see <code class="docutils literal"><span class="pre">priority</span></code> (in the PARI manual)). Note that for efficiency, this does
not check whether the relative equation is irreducible over <span class="math">\(nf\)</span>, but
only if it is squarefree. If it is reducible but squarefree, the result will
be the absolute equation of the étale algebra defined by <em>pol</em>. If
<em>pol</em> is not squarefree, raise an <code class="docutils literal"><span class="pre">e_DOMAIN</span></code> exception.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? rnfequation(y^2+1, x^2 - y)
%1 = x^4 + 1
? T = y^3-2; rnfequation(nfinit(T), (x^3-2)/(x-Mod(y,T)))
%2 = x^6 + 108 \\ Galois closure of Q(2^(1/3))
</pre></div>
</div>
<p>If <span class="math">\(flag\)</span> is non-zero, outputs a 3-component row vector <span class="math">\([z,a,k]\)</span>, where</p>
<ul class="simple">
<li><span class="math">\(z\)</span> is the absolute equation of <span class="math">\(L\)</span> over <span class="math">\(\mathbb{Q}\)</span>, as in the default
behavior,</li>
<li><span class="math">\(a\)</span> expresses as a <code class="docutils literal"><span class="pre">t_POLMOD</span></code> modulo <span class="math">\(z\)</span> a root <span class="math">\(\alpha\)</span> of the
polynomial defining the base field <span class="math">\(nf\)</span>,</li>
<li><span class="math">\(k\)</span> is a small integer such that <span class="math">\(\theta = \beta+k\alpha\)</span>
is a root of <span class="math">\(z\)</span>, where <span class="math">\(\beta\)</span> is a root of <span class="math">\(pol\)</span>.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? T = y^3-2; pol = x^2 +x*y + y^2;
? [z,a,k] = rnfequation(T, pol, 1);
? z
%3 = x^6 + 108
? subst(T, y, a)
%4 = 0
? alpha= Mod(y, T);
? beta = Mod(x*Mod(1,T), pol);
? subst(z, x, beta + k*alpha)
%7 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfhnfbasis">
<code class="descname">rnfhnfbasis</code><span class="sig-paren">(</span><em>bnf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfhnfbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <span class="math">\(bnf\)</span> as output by
<code class="docutils literal"><span class="pre">bnfinit</span></code>, and either a polynomial <span class="math">\(x\)</span> with coefficients in <span class="math">\(bnf\)</span>
defining a relative extension <span class="math">\(L\)</span> of <span class="math">\(bnf\)</span>, or a pseudo-basis <span class="math">\(x\)</span> of
such an extension, gives either a true <span class="math">\(bnf\)</span>-basis of <span class="math">\(L\)</span> in upper
triangular Hermite normal form, if it exists, and returns <span class="math">\(0\)</span> otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealabstorel">
<code class="descname">rnfidealabstorel</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealabstorel" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(rnf\)</span> be a relative
number field extension <span class="math">\(L/K\)</span> as output by <code class="docutils literal"><span class="pre">rnfinit</span></code> and <span class="math">\(x\)</span> be an ideal of
the absolute extension <span class="math">\(L/\mathbb{Q}\)</span> given by a <span class="math">\(\mathbb{Z}\)</span>-basis of elements of <span class="math">\(L\)</span>.
Returns the relative pseudo-matrix in HNF giving the ideal <span class="math">\(x\)</span> considered as
an ideal of the relative extension <span class="math">\(L/K\)</span>, i.e.&nbsp;as a <span class="math">\(\mathbb{Z}_K\)</span>-module.</p>
<p>The reason why the input does not use the customary HNF in terms of a fixed
<span class="math">\(\mathbb{Z}\)</span>-basis for <span class="math">\(\mathbb{Z}_L\)</span> is precisely that no such basis has been explicitly
specified. On the other hand, if you already computed an (absolute) <code class="docutils literal"><span class="pre">nf</span></code>
structure <code class="docutils literal"><span class="pre">Labs</span></code> associated to <span class="math">\(L\)</span>, and <span class="math">\(m\)</span> is in HNF, defining
an (absolute) ideal with respect to the <span class="math">\(\mathbb{Z}\)</span>-basis <code class="docutils literal"><span class="pre">Labs.zk</span></code>, then
<code class="docutils literal"><span class="pre">Labs.zk</span> <span class="pre">*</span> <span class="pre">m</span></code> is a suitable <span class="math">\(\mathbb{Z}\)</span>-basis for the ideal, and</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">rnfidealabstorel</span><span class="p">(</span><span class="n">rnf</span><span class="p">,</span> <span class="n">Labs</span><span class="o">.</span><span class="n">zk</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>converts <span class="math">\(m\)</span> to a relative ideal.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^2+1); L = rnfinit(K, x^2-y); Labs = nfinit(L);
? m = idealhnf(Labs, 17, x^3+2);
? B = rnfidealabstorel(L, Labs.zk * m)
%3 = [[1, 8; 0, 1], [[17, 4; 0, 1], 1]] \\ pseudo-basis for m as Z_K-module
? A = rnfidealreltoabs(L, B)
%4 = [17, x^2 + 4, x + 8, x^3 + 8*x^2] \\ Z-basis for m in Q[x]/(L.pol)
? mathnf(matalgtobasis(Labs, A))
%5 =
[17 8 4 2]

[ 0 1 0 0]

[ 0 0 1 0]

[ 0 0 0 1]
? % == m
%6 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealdown">
<code class="descname">rnfidealdown</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(rnf\)</span> be a relative number
field extension <span class="math">\(L/K\)</span> as output by <code class="docutils literal"><span class="pre">rnfinit</span></code>, and <span class="math">\(x\)</span> an ideal of
<span class="math">\(L\)</span>, given either in relative form or by a <span class="math">\(\mathbb{Z}\)</span>-basis of elements of <span class="math">\(L\)</span>
(see <code class="docutils literal"><span class="pre">rnfidealabstorel</span></code> (in the PARI manual)). This function returns the ideal of <span class="math">\(K\)</span>
below <span class="math">\(x\)</span>, i.e.&nbsp;the intersection of <span class="math">\(x\)</span> with <span class="math">\(K\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealhnf">
<code class="descname">rnfidealhnf</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealhnf" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative number
field extension <span class="math">\(L/K\)</span> as output by <code class="docutils literal"><span class="pre">rnfinit</span></code> and <span class="math">\(x\)</span> being a relative
ideal (which can be, as in the absolute case, of many different types,
including of course elements), computes the HNF pseudo-matrix associated to
<span class="math">\(x\)</span>, viewed as a <span class="math">\(\mathbb{Z}_K\)</span>-module.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealmul">
<code class="descname">rnfidealmul</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealmul" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative number
field extension <span class="math">\(L/K\)</span> as output by <code class="docutils literal"><span class="pre">rnfinit</span></code> and <span class="math">\(x\)</span> and <span class="math">\(y\)</span> being ideals
of the relative extension <span class="math">\(L/K\)</span> given by pseudo-matrices, outputs the ideal
product, again as a relative ideal.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealnormabs">
<code class="descname">rnfidealnormabs</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealnormabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(rnf\)</span> be a relative
number field extension <span class="math">\(L/K\)</span> as output by <code class="docutils literal"><span class="pre">rnfinit</span></code> and let <span class="math">\(x\)</span> be a
relative ideal (which can be, as in the absolute case, of many different
types, including of course elements). This function computes the norm of the
<span class="math">\(x\)</span> considered as an ideal of the absolute extension <span class="math">\(L/\mathbb{Q}\)</span>. This is
identical to</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">idealnorm</span><span class="p">(</span><span class="n">rnf</span><span class="p">,</span> <span class="n">rnfidealnormrel</span><span class="p">(</span><span class="n">rnf</span><span class="p">,</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>but faster.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealnormrel">
<code class="descname">rnfidealnormrel</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealnormrel" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(rnf\)</span> be a relative
number field extension <span class="math">\(L/K\)</span> as output by <code class="docutils literal"><span class="pre">rnfinit</span></code> and let <span class="math">\(x\)</span> be a
relative ideal (which can be, as in the absolute case, of many different
types, including of course elements). This function computes the relative
norm of <span class="math">\(x\)</span> as an ideal of <span class="math">\(K\)</span> in HNF.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealprimedec">
<code class="descname">rnfidealprimedec</code><span class="sig-paren">(</span><em>rnf</em>, <em>pr</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealprimedec" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <em>rnf</em> be a relative number
field extension <span class="math">\(L/K\)</span> as output by <code class="docutils literal"><span class="pre">rnfinit</span></code>, and <code class="docutils literal"><span class="pre">pr</span></code> a maximal
ideal of <span class="math">\(K\)</span> (<code class="docutils literal"><span class="pre">prid</span></code>), this function completes the <em>rnf</em>
with a <em>nf</em> structure attached to <span class="math">\(L\)</span> (see <code class="docutils literal"><span class="pre">rnfinit</span></code> (in the PARI manual))
and returns the prime ideal decomposition of <code class="docutils literal"><span class="pre">pr</span></code> in <span class="math">\(L/K\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^2+1); rnf = rnfinit(K, x^3+y+1);
? P = idealprimedec(K, 2)[1];
? S = rnfidealprimedec(rnf, P);
? #S
%4 = 1
</pre></div>
</div>
<p>The argument <code class="docutils literal"><span class="pre">pr</span></code> is also allowed to be a prime number <span class="math">\(p\)</span>, in which
case we return a pair of vectors <code class="docutils literal"><span class="pre">[SK,SL]</span></code>, where <code class="docutils literal"><span class="pre">SK</span></code> contains
the primes of <span class="math">\(K\)</span> above <span class="math">\(p\)</span> and <code class="docutils literal"><span class="pre">SL</span></code><span class="math">\([i]\)</span> is the vector of primes of <span class="math">\(L\)</span>
above <code class="docutils literal"><span class="pre">SK</span></code><span class="math">\([i]\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? [SK,SL] = rnfidealprimedec(rnf, 5);
? [#SK, vector(#SL,i,#SL[i])]
%6 = [2, [2, 2]]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealreltoabs">
<code class="descname">rnfidealreltoabs</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealreltoabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(rnf\)</span> be a relative
number field extension <span class="math">\(L/K\)</span> as output by <code class="docutils literal"><span class="pre">rnfinit</span></code> and let <span class="math">\(x\)</span> be a
relative ideal, given as a <span class="math">\(\mathbb{Z}_K\)</span>-module by a pseudo matrix <span class="math">\([A,I]\)</span>.
This function returns the ideal <span class="math">\(x\)</span> as an absolute ideal of <span class="math">\(L/\mathbb{Q}\)</span>.
If <span class="math">\(flag = 0\)</span>, the result is given by a vector of <code class="docutils literal"><span class="pre">t_POLMOD</span></code>&nbsp;s modulo
<code class="docutils literal"><span class="pre">rnf.pol</span></code> forming a <span class="math">\(\mathbb{Z}\)</span>-basis; if <span class="math">\(flag = 1\)</span>, it is given in HNF in terms
of the fixed <span class="math">\(\mathbb{Z}\)</span>-basis for <span class="math">\(\mathbb{Z}_L\)</span>, see <code class="docutils literal"><span class="pre">rnfinit</span></code> (in the PARI manual).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^2+1); rnf = rnfinit(K, x^2-y);
? P = idealprimedec(K,2)[1];
? P = rnfidealup(rnf, P)
%3 = [2, x^2 + 1, 2*x, x^3 + x]
? Prel = rnfidealhnf(rnf, P)
%4 = [[1, 0; 0, 1], [[2, 1; 0, 1], [2, 1; 0, 1]]]
? rnfidealreltoabs(rnf,Prel)
%5 = [2, x^2 + 1, 2*x, x^3 + x]
? rnfidealreltoabs(rnf,Prel,1)
%6 =
[2 1 0 0]

[0 1 0 0]

[0 0 2 1]

[0 0 0 1]
</pre></div>
</div>
<p>The reason why we do not return by default (<span class="math">\(flag = 0\)</span>) the customary HNF in
terms of a fixed <span class="math">\(\mathbb{Z}\)</span>-basis for <span class="math">\(\mathbb{Z}_L\)</span> is precisely because
a <em>rnf</em> does not contain such a basis by default. Completing the
structure so that it contains a <em>nf</em> structure for <span class="math">\(L\)</span> is polynomial
time but costly when the absolute degree is large, thus it is not done by
default. Note that setting <span class="math">\(flag = 1\)</span> will complete the <em>rnf</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealtwoelt">
<code class="descname">rnfidealtwoelt</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealtwoelt" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(rnf\)</span> being a relative
number field extension <span class="math">\(L/K\)</span> as output by <code class="docutils literal"><span class="pre">rnfinit</span></code> and <span class="math">\(x\)</span> being an
ideal of the relative extension <span class="math">\(L/K\)</span> given by a pseudo-matrix, gives a
vector of two generators of <span class="math">\(x\)</span> over <span class="math">\(\mathbb{Z}_L\)</span> expressed as polmods with polmod
coefficients.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfidealup">
<code class="descname">rnfidealup</code><span class="sig-paren">(</span><em>rnf</em>, <em>x</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfidealup" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(rnf\)</span> be a relative number
field extension <span class="math">\(L/K\)</span> as output by <code class="docutils literal"><span class="pre">rnfinit</span></code> and let <span class="math">\(x\)</span> be an ideal of
<span class="math">\(K\)</span>. This function returns the ideal <span class="math">\(x\mathbb{Z}_L\)</span> as an absolute ideal of <span class="math">\(L/\mathbb{Q}\)</span>,
in the form of a <span class="math">\(\mathbb{Z}\)</span>-basis. If <span class="math">\(flag = 0\)</span>, the result is given by a vector of
polynomials (modulo <code class="docutils literal"><span class="pre">rnf.pol</span></code>); if <span class="math">\(flag = 1\)</span>, it is given in HNF in terms
of the fixed <span class="math">\(\mathbb{Z}\)</span>-basis for <span class="math">\(\mathbb{Z}_L\)</span>, see <code class="docutils literal"><span class="pre">rnfinit</span></code> (in the PARI manual).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^2+1); rnf = rnfinit(K, x^2-y);
? P = idealprimedec(K,2)[1];
? rnfidealup(rnf, P)
%3 = [2, x^2 + 1, 2*x, x^3 + x]
? rnfidealup(rnf, P,1)
%4 =
[2 1 0 0]

[0 1 0 0]

[0 0 2 1]

[0 0 0 1]
</pre></div>
</div>
<p>The reason why we do not return by default (<span class="math">\(flag = 0\)</span>) the customary HNF in
terms of a fixed <span class="math">\(\mathbb{Z}\)</span>-basis for <span class="math">\(\mathbb{Z}_L\)</span> is precisely because
a <em>rnf</em> does not contain such a basis by default. Completing the
structure so that it contains a <em>nf</em> structure for <span class="math">\(L\)</span> is polynomial
time but costly when the absolute degree is large, thus it is not done by
default. Note that setting <span class="math">\(flag = 1\)</span> will complete the <em>rnf</em>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfinit">
<code class="descname">rnfinit</code><span class="sig-paren">(</span><em>nf</em>, <em>pol</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfinit" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(nf\)</span> being a number field in <code class="docutils literal"><span class="pre">nfinit</span></code>
format considered as base field, and <em>pol</em> a polynomial defining a relative
extension over <span class="math">\(nf\)</span>, this computes data to work in the
relative extension. The main variable of <em>pol</em> must be of higher priority
(see <code class="docutils literal"><span class="pre">priority</span></code> (in the PARI manual)) than that of <span class="math">\(nf\)</span>, and the coefficients of
<em>pol</em> must be in <span class="math">\(nf\)</span>.</p>
<p>The result is a row vector, whose components are technical. In the following
description, we let <span class="math">\(K\)</span> be the base field defined by <span class="math">\(nf\)</span> and <span class="math">\(L/K\)</span>
the extension attached to the <em>rnf</em>. Furthermore, we let
<span class="math">\(m = [K:\mathbb{Q}]\)</span> the degree of the base field, <span class="math">\(n = [L:K]\)</span> the relative degree,
<span class="math">\(r_1\)</span> and <span class="math">\(r_2\)</span> the number of real and complex places of <span class="math">\(K\)</span>. Access to this
information via <em>member functions</em> is preferred since the specific
data organization specified below will change in the future.</p>
<p>If <span class="math">\(flag = 1\)</span>, add an <em>nf</em> structure attached to <span class="math">\(L\)</span> to <em>rnf</em>.
This is likely to be very expensive if the absolute degree <span class="math">\(mn\)</span> is large,
but fixes an integer basis for <span class="math">\(\mathbb{Z}_L\)</span> as a <span class="math">\(\mathbb{Z}\)</span>-module and allows to input
and output elements of <span class="math">\(L\)</span> in absolute form: as <code class="docutils literal"><span class="pre">t_COL</span></code> for elements,
as <code class="docutils literal"><span class="pre">t_MAT</span></code> in HNF for ideals, as <code class="docutils literal"><span class="pre">prid</span></code> for prime ideals. Without such
a call, elements of <span class="math">\(L\)</span> are represented as <code class="docutils literal"><span class="pre">t_POLMOD</span></code>, etc.
Note that a subsequent <code class="docutils literal"><span class="pre">nfinit</span></code><span class="math">\((rnf)\)</span> will also explicitly
add such a component, and so will the following functions <code class="docutils literal"><span class="pre">rnfidealmul</span></code>,
<code class="docutils literal"><span class="pre">rnfidealtwoelt</span></code>, <code class="docutils literal"><span class="pre">rnfidealprimedec</span></code>, <code class="docutils literal"><span class="pre">rnfidealup</span></code> (with flag 1)
and <code class="docutils literal"><span class="pre">rnfidealreltoabs</span></code> (with flag 1). The absolute <em>nf</em> structure
attached to <span class="math">\(L\)</span> can be recovered using <code class="docutils literal"><span class="pre">nfinit(rnf)</span></code>.</p>
<p><span class="math">\(rnf[1]`(:literal:`rnf.pol\)</span>) contains the relative polynomial <em>pol</em>.</p>
<p><span class="math">\(rnf[2]\)</span> contains the integer basis <span class="math">\([A,d]\)</span> of <span class="math">\(K\)</span>, as
(integral) elements of <span class="math">\(L/\mathbb{Q}\)</span>. More precisely, <span class="math">\(A\)</span> is a vector of
polynomial with integer coefficients, <span class="math">\(d\)</span> is a denominator, and the integer
basis is given by <span class="math">\(A/d\)</span>.</p>
<p><span class="math">\(rnf[3]\)</span> (<code class="docutils literal"><span class="pre">rnf.disc</span></code>) is a two-component row vector
<span class="math">\([d(L/K),s]\)</span> where <span class="math">\(d(L/K)\)</span> is the relative ideal discriminant
of <span class="math">\(L/K\)</span> and <span class="math">\(s\)</span> is the discriminant of <span class="math">\(L/K\)</span> viewed as an element of
<span class="math">\(K^*/(K^*)^2\)</span>, in other words it is the output of <code class="docutils literal"><span class="pre">rnfdisc</span></code>.</p>
<p><span class="math">\(rnf[4]`(:literal:`rnf.index\)</span>) is the ideal index <span class="math">\(f\)</span>, i.e.&nbsp;such
that <span class="math">\(d(pol)\mathbb{Z}_K = f^2d(L/K)\)</span>.</p>
<p><span class="math">\(rnf[5]\)</span> is currently unused.</p>
<p><span class="math">\(rnf[6]\)</span> is currently unused.</p>
<p><span class="math">\(rnf[7]\)</span> (<code class="docutils literal"><span class="pre">rnf.zk</span></code>) is the pseudo-basis <span class="math">\((A,I)\)</span> for the maximal
order <span class="math">\(\mathbb{Z}_L\)</span> as a <span class="math">\(\mathbb{Z}_K\)</span>-module: <span class="math">\(A\)</span> is the relative integral pseudo basis
expressed as polynomials (in the variable of <span class="math">\(pol\)</span>) with polmod coefficients
in <span class="math">\(nf\)</span>, and the second component <span class="math">\(I\)</span> is the ideal list of the
pseudobasis in HNF.</p>
<p><span class="math">\(rnf[8]\)</span> is the inverse matrix of the integral basis matrix, with
coefficients polmods in <span class="math">\(nf\)</span>.</p>
<p><span class="math">\(rnf[9]\)</span> is currently unused.</p>
<p><span class="math">\(rnf[10]\)</span> (<code class="docutils literal"><span class="pre">rnf.nf</span></code>) is <span class="math">\(nf\)</span>.</p>
<p><span class="math">\(rnf[11]\)</span> is an extension of <code class="docutils literal"><span class="pre">rnfequation(K,</span> <span class="pre">pol,</span> <span class="pre">1)</span></code>. Namely, a
vector <span class="math">\([P, a, k, K.pol, pol]\)</span> describing the <em>absolute</em>
extension
<span class="math">\(L/\mathbb{Q}\)</span>: <span class="math">\(P\)</span> is an absolute equation, more conveniently obtained
as <code class="docutils literal"><span class="pre">rnf.polabs</span></code>; <span class="math">\(a\)</span> expresses the generator <span class="math">\(\alpha = y mod K.pol\)</span>
of the number field <span class="math">\(K\)</span> as an element of <span class="math">\(L\)</span>, i.e.&nbsp;a polynomial modulo the
absolute equation <span class="math">\(P\)</span>;</p>
<p><span class="math">\(k\)</span> is a small integer such that, if <span class="math">\(\beta\)</span> is an abstract root of <em>pol</em>
and <span class="math">\(\alpha\)</span> the generator of <span class="math">\(K\)</span> given above, then <span class="math">\(P(\beta + k\alpha) = 0\)</span>.</p>
<p><strong>Caveat.</strong> Be careful if <span class="math">\(k != 0\)</span> when dealing simultaneously with
absolute and relative quantities since <span class="math">\(L = \mathbb{Q}(\beta + k\alpha) = 
K(\alpha)\)</span>, and the generator chosen for the absolute extension is not the
same as for the relative one. If this happens, one can of course go on
working, but we advise to change the relative polynomial so that its root
becomes <span class="math">\(\beta + k \alpha\)</span>. Typical GP instructions would be</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">P</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">rnfequation</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">pol</span> <span class="o">=</span> <span class="n">subst</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">k</span><span class="o">*</span><span class="n">Mod</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">pol</span><span class="p">)));</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">rnfinit</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">pol</span><span class="p">);</span>
</pre></div>
</div>
<p><span class="math">\(rnf[12]\)</span> is by default unused and set equal to 0. This field is used
to store further information about the field as it becomes available (which
is rarely needed, hence would be too expensive to compute during the initial
<code class="docutils literal"><span class="pre">rnfinit</span></code> call).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfisabelian">
<code class="descname">rnfisabelian</code><span class="sig-paren">(</span><em>nf</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfisabelian" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(T\)</span> being a relative polynomial with coefficients
in <em>nf</em>, return 1 if it defines an abelian extension, and 0 otherwise.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^2 + 23);
? rnfisabelian(K, x^3 - 3*x - y)
%2 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfisfree">
<code class="descname">rnfisfree</code><span class="sig-paren">(</span><em>bnf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfisfree" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <span class="math">\(bnf\)</span> as output by
<code class="docutils literal"><span class="pre">bnfinit</span></code>, and either a polynomial <span class="math">\(x\)</span> with coefficients in <span class="math">\(bnf\)</span>
defining a relative extension <span class="math">\(L\)</span> of <span class="math">\(bnf\)</span>, or a pseudo-basis <span class="math">\(x\)</span> of
such an extension, returns true (1) if <span class="math">\(L/bnf\)</span> is free, false (0) if
not.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfisnorm">
<code class="descname">rnfisnorm</code><span class="sig-paren">(</span><em>T</em>, <em>a</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfisnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to
<code class="docutils literal"><span class="pre">bnfisnorm</span></code> but in the relative case. <span class="math">\(T\)</span> is as output by
<code class="docutils literal"><span class="pre">rnfisnorminit</span></code> applied to the extension <span class="math">\(L/K\)</span>. This tries to decide
whether the element <span class="math">\(a\)</span> in <span class="math">\(K\)</span> is the norm of some <span class="math">\(x\)</span> in the extension
<span class="math">\(L/K\)</span>.</p>
<p>The output is a vector <span class="math">\([x,q]\)</span>, where <span class="math">\(a = \mathrm{Norm}(x)*q\)</span>. The
algorithm looks for a solution <span class="math">\(x\)</span> which is an <span class="math">\(S\)</span>-integer, with <span class="math">\(S\)</span> a list
of places of <span class="math">\(K\)</span> containing at least the ramified primes, the generators of
the class group of <span class="math">\(L\)</span>, as well as those primes dividing <span class="math">\(a\)</span>. If <span class="math">\(L/K\)</span> is
Galois, then this is enough; otherwise, <span class="math">\(flag\)</span> is used to add more primes to
<span class="math">\(S\)</span>: all the places above the primes <span class="math">\(p &lt;= flag\)</span> (resp.&nbsp;<span class="math">\(p\|flag\)</span>) if <span class="math">\(flag &gt; 0\)</span>
(resp.&nbsp;<span class="math">\(flag &lt; 0\)</span>).</p>
<p>The answer is guaranteed (i.e.&nbsp;<span class="math">\(a\)</span> is a norm iff <span class="math">\(q = 1\)</span>) if the field is
Galois, or, under GRH, if <span class="math">\(S\)</span> contains all primes less than
<span class="math">\(12\log^2\|\mathrm{disc}(M)\|\)</span>, where <span class="math">\(M\)</span> is the normal
closure of <span class="math">\(L/K\)</span>.</p>
<p>If <code class="docutils literal"><span class="pre">rnfisnorminit</span></code> has determined (or was told) that <span class="math">\(L/K\)</span> is
Galois, and <span class="math">\(flag != 0\)</span>, a Warning is issued (so that you can set
<span class="math">\(flag = 1\)</span> to check whether <span class="math">\(L/K\)</span> is known to be Galois, according to <span class="math">\(T\)</span>).
Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bnf</span> <span class="o">=</span> <span class="n">bnfinit</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Mod</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bnf</span><span class="o">.</span><span class="n">pol</span><span class="p">);</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">rnfisnorminit</span><span class="p">(</span><span class="n">bnf</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="n">rnfisnorm</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>
</pre></div>
</div>
<p>checks whether <span class="math">\(17\)</span> is a norm in the Galois extension <span class="math">\(\mathbb{Q}(\beta) /
\mathbb{Q}(\alpha)\)</span>, where <span class="math">\(\alpha^3 + \alpha^2 - 2\alpha - 1 = 0\)</span> and <span class="math">\(\beta^2 +
\alpha^2 + 2\alpha + 1 = 0\)</span> (it is).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfisnorminit">
<code class="descname">rnfisnorminit</code><span class="sig-paren">(</span><em>pol</em>, <em>polrel</em>, <em>flag=2</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfisnorminit" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(K\)</span> be defined by a root of <em>pol</em>, and <span class="math">\(L/K\)</span> the extension defined
by the polynomial <em>polrel</em>. As usual, <em>pol</em> can in fact be an <em>nf</em>,
or <em>bnf</em>, etc; if <em>pol</em> has degree <span class="math">\(1\)</span> (the base field is <span class="math">\(\mathbb{Q}\)</span>),
polrel is also allowed to be an <em>nf</em>, etc. Computes technical data needed
by <code class="docutils literal"><span class="pre">rnfisnorm</span></code> to solve norm equations <span class="math">\(Nx = a\)</span>, for <span class="math">\(x\)</span> in <span class="math">\(L\)</span>, and <span class="math">\(a\)</span>
in <span class="math">\(K\)</span>.</p>
<p>If <span class="math">\(flag = 0\)</span>, do not care whether <span class="math">\(L/K\)</span> is Galois or not.</p>
<p>If <span class="math">\(flag = 1\)</span>, <span class="math">\(L/K\)</span> is assumed to be Galois (unchecked), which speeds up
<code class="docutils literal"><span class="pre">rnfisnorm</span></code>.</p>
<p>If <span class="math">\(flag = 2\)</span>, let the routine determine whether <span class="math">\(L/K\)</span> is Galois.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfkummer">
<code class="descname">rnfkummer</code><span class="sig-paren">(</span><em>bnr</em>, <em>subgp=None</em>, <em>d=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfkummer" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bnr</em>
being as output by <code class="docutils literal"><span class="pre">bnrinit</span></code>, finds a relative equation for the
class field corresponding to the module in <em>bnr</em> and the given
congruence subgroup (the full ray class field if <em>subgp</em> is omitted).
If <span class="math">\(d\)</span> is positive, outputs the list of all relative equations of
degree <span class="math">\(d\)</span> contained in the ray class field defined by <em>bnr</em>, with
the <em>same</em> conductor as <span class="math">\((bnr, subgp)\)</span>.</p>
<p><strong>Warning.</strong> This routine only works for subgroups of prime index. It
uses Kummer theory, adjoining necessary roots of unity (it needs to compute a
tough <code class="docutils literal"><span class="pre">bnfinit</span></code> here), and finds a generator via Hecke&#8217;s characterization
of ramification in Kummer extensions of prime degree. If your extension does
not have prime degree, for the time being, you have to split it by hand as a
tower / compositum of such extensions.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnflllgram">
<code class="descname">rnflllgram</code><span class="sig-paren">(</span><em>nf</em>, <em>pol</em>, <em>order</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnflllgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a polynomial
<em>pol</em> with coefficients in <em>nf</em> defining a relative extension <span class="math">\(L\)</span> and
a suborder <em>order</em> of <span class="math">\(L\)</span> (of maximal rank), as output by
<code class="docutils literal"><span class="pre">rnfpseudobasis</span></code><span class="math">\((nf,pol)\)</span> or similar, gives
<span class="math">\([[neworder],U]\)</span>, where <em>neworder</em> is a reduced order and <span class="math">\(U\)</span> is
the unimodular transformation matrix.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfnormgroup">
<code class="descname">rnfnormgroup</code><span class="sig-paren">(</span><em>bnr</em>, <em>pol</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfnormgroup" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bnr</em> being a big ray
class field as output by <code class="docutils literal"><span class="pre">bnrinit</span></code> and <em>pol</em> a relative polynomial
defining an Abelian extension, computes the norm group (alias Artin
or Takagi group) corresponding to the Abelian extension of
<span class="math">\(bnf =\)</span><code class="docutils literal"><span class="pre">bnr.bnf</span></code>
defined by <em>pol</em>, where the module corresponding to <em>bnr</em> is assumed
to be a multiple of the conductor (i.e.&nbsp;<em>pol</em> defines a subextension of
bnr). The result is the HNF defining the norm group on the given generators
of <code class="docutils literal"><span class="pre">bnr.gen</span></code>. Note that neither the fact that <em>pol</em> defines an
Abelian extension nor the fact that the module is a multiple of the conductor
is checked. The result is undefined if the assumption is not correct,
but the function will return the empty matrix <code class="docutils literal"><span class="pre">[;]</span></code> if it detects a
problem; it may also not detect the problem and return a wrong result.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfpolred">
<code class="descname">rnfpolred</code><span class="sig-paren">(</span><em>nf</em>, <em>pol</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfpolred" title="Permalink to this definition">¶</a></dt>
<dd><p>THIS FUNCTION IS OBSOLETE: use <code class="docutils literal"><span class="pre">rnfpolredbest</span></code> instead.
Relative version of <code class="docutils literal"><span class="pre">polred</span></code>. Given a monic polynomial <em>pol</em> with
coefficients in <span class="math">\(nf\)</span>, finds a list of relative polynomials defining some
subfields, hopefully simpler and containing the original field. In the present
version <strong>2.8.0</strong>, this is slower and less efficient than <code class="docutils literal"><span class="pre">rnfpolredbest</span></code>.</p>
<p><strong>Remark.</strong> this function is based on an incomplete reduction
theory of lattices over number fields, implemented by <code class="docutils literal"><span class="pre">rnflllgram</span></code>, which
deserves to be improved.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfpolredabs">
<code class="descname">rnfpolredabs</code><span class="sig-paren">(</span><em>nf</em>, <em>pol</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfpolredabs" title="Permalink to this definition">¶</a></dt>
<dd><p>THIS FUNCTION IS OBSOLETE: use <code class="docutils literal"><span class="pre">rnfpolredbest</span></code> instead.
Relative version of <code class="docutils literal"><span class="pre">polredabs</span></code>. Given a monic polynomial <em>pol</em>
with coefficients in <span class="math">\(nf\)</span>, finds a simpler relative polynomial defining
the same field. The binary digits of <span class="math">\(flag\)</span> mean</p>
<p>The binary digits of <span class="math">\(flag\)</span> correspond to <span class="math">\(1\)</span>: add information to convert
elements to the new representation, <span class="math">\(2\)</span>: absolute polynomial, instead of
relative, <span class="math">\(16\)</span>: possibly use a suborder of the maximal order. More precisely:</p>
<p>0: default, return <span class="math">\(P\)</span></p>
<p>1: returns <span class="math">\([P,a]\)</span> where <span class="math">\(P\)</span> is the default output and <span class="math">\(a\)</span>,
a <code class="docutils literal"><span class="pre">t_POLMOD</span></code> modulo <span class="math">\(P\)</span>, is a root of <em>pol</em>.</p>
<p>2: returns <em>Pabs</em>, an absolute, instead of a relative, polynomial.
Same as but faster than</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">rnfequation</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">rnfpolredabs</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span><span class="n">pol</span><span class="p">))</span>
</pre></div>
</div>
<p>3: returns <span class="math">\([Pabs,a,b]\)</span>, where <em>Pabs</em> is an absolute polynomial
as above, <span class="math">\(a\)</span>, <span class="math">\(b\)</span> are <code class="docutils literal"><span class="pre">t_POLMOD</span></code> modulo <em>Pabs</em>, roots of <code class="docutils literal"><span class="pre">nf.pol</span></code>
and <em>pol</em> respectively.</p>
<p>16: possibly use a suborder of the maximal order. This is slower than the
default when the relative discriminant is smooth, and much faster otherwise.
See <code class="docutils literal"><span class="pre">polredabs</span></code> (in the PARI manual).</p>
<p><strong>Warning.</strong> In the present implementation, <code class="docutils literal"><span class="pre">rnfpolredabs</span></code>
produces smaller polynomials than <code class="docutils literal"><span class="pre">rnfpolred</span></code> and is usually
faster, but its complexity is still exponential in the absolute degree.
The function <code class="docutils literal"><span class="pre">rnfpolredbest</span></code> runs in polynomial time, and tends to
return polynomials with smaller discriminants.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfpolredbest">
<code class="descname">rnfpolredbest</code><span class="sig-paren">(</span><em>nf</em>, <em>pol</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfpolredbest" title="Permalink to this definition">¶</a></dt>
<dd><p>Relative version of <code class="docutils literal"><span class="pre">polredbest</span></code>. Given a monic polynomial <em>pol</em>
with coefficients in <span class="math">\(nf\)</span>, finds a simpler relative polynomial <span class="math">\(P\)</span>
defining the same field. As opposed to <code class="docutils literal"><span class="pre">rnfpolredabs</span></code> this function does
not return a <em>smallest</em> (canonical) polynomial with respect to some
measure, but it does run in polynomial time.</p>
<p>The binary digits of <span class="math">\(flag\)</span> correspond to <span class="math">\(1\)</span>: add information to convert
elements to the new representation, <span class="math">\(2\)</span>: absolute polynomial, instead of
relative. More precisely:</p>
<p>0: default, return <span class="math">\(P\)</span></p>
<p>1: returns <span class="math">\([P,a]\)</span> where <span class="math">\(P\)</span> is the default output and <span class="math">\(a\)</span>,
a <code class="docutils literal"><span class="pre">t_POLMOD</span></code> modulo <span class="math">\(P\)</span>, is a root of <em>pol</em>.</p>
<p>2: returns <em>Pabs</em>, an absolute, instead of a relative, polynomial.
Same as but faster than</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">rnfequation</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">rnfpolredbest</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span><span class="n">pol</span><span class="p">))</span>
</pre></div>
</div>
<p>3: returns <span class="math">\([Pabs,a,b]\)</span>, where <em>Pabs</em> is an absolute polynomial
as above, <span class="math">\(a\)</span>, <span class="math">\(b\)</span> are <code class="docutils literal"><span class="pre">t_POLMOD</span></code> modulo <em>Pabs</em>, roots of <code class="docutils literal"><span class="pre">nf.pol</span></code>
and <em>pol</em> respectively.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? K = nfinit(y^3-2); pol = x^2 +x*y + y^2;
? [P, a] = rnfpolredbest(K,pol,1);
? P
%3 = x^2 - x + Mod(y - 1, y^3 - 2)
? a
%4 = Mod(Mod(2*y^2+3*y+4,y^3-2)*x + Mod(-y^2-2*y-2,y^3-2),
 x^2 - x + Mod(y-1,y^3-2))
? subst(K.pol,y,a)
%5 = 0
? [Pabs, a, b] = rnfpolredbest(K,pol,3);
? Pabs
%7 = x^6 - 3*x^5 + 5*x^3 - 3*x + 1
? a
%8 = Mod(-x^2+x+1, x^6-3*x^5+5*x^3-3*x+1)
? b
%9 = Mod(2*x^5-5*x^4-3*x^3+10*x^2+5*x-5, x^6-3*x^5+5*x^3-3*x+1)
? subst(K.pol,y,a)
%10 = 0
? substvec(pol,[x,y],[a,b])
%11 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfpseudobasis">
<code class="descname">rnfpseudobasis</code><span class="sig-paren">(</span><em>nf</em>, <em>pol</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfpseudobasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a number field
<span class="math">\(nf\)</span> as output by <code class="docutils literal"><span class="pre">nfinit</span></code> and a polynomial <em>pol</em> with
coefficients in <span class="math">\(nf\)</span> defining a relative extension <span class="math">\(L\)</span> of <span class="math">\(nf\)</span>,
computes a pseudo-basis <span class="math">\((A,I)\)</span> for the maximal order <span class="math">\(\mathbb{Z}_L\)</span> viewed as a
<span class="math">\(\mathbb{Z}_K\)</span>-module, and the relative discriminant of <span class="math">\(L\)</span>. This is output as a
four-element row vector <span class="math">\([A,I,D,d]\)</span>, where <span class="math">\(D\)</span> is the relative ideal
discriminant and <span class="math">\(d\)</span> is the relative discriminant considered as an element of
<span class="math">\(nf^*/{nf^*}^2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.rnfsteinitz">
<code class="descname">rnfsteinitz</code><span class="sig-paren">(</span><em>nf</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.rnfsteinitz" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a number field <span class="math">\(nf\)</span> as
output by <code class="docutils literal"><span class="pre">nfinit</span></code> and either a polynomial <span class="math">\(x\)</span> with coefficients in
<span class="math">\(nf\)</span> defining a relative extension <span class="math">\(L\)</span> of <span class="math">\(nf\)</span>, or a pseudo-basis
<span class="math">\(x\)</span> of such an extension as output for example by <code class="docutils literal"><span class="pre">rnfpseudobasis</span></code>,
computes another pseudo-basis <span class="math">\((A,I)\)</span> (not in HNF in general) such that all
the ideals of <span class="math">\(I\)</span> except perhaps the last one are equal to the ring of
integers of <span class="math">\(nf\)</span>, and outputs the four-component row vector <span class="math">\([A,I,D,d]\)</span>
as in <code class="docutils literal"><span class="pre">rnfpseudobasis</span></code>. The name of this function comes from the fact
that the ideal class of the last ideal of <span class="math">\(I\)</span>, which is well defined, is the
Steinitz class of the <span class="math">\(\mathbb{Z}_K\)</span>-module <span class="math">\(\mathbb{Z}_L\)</span> (its image in <span class="math">\(SK_0(\mathbb{Z}_K)\)</span>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.select">
<code class="descname">select</code><span class="sig-paren">(</span><em>f</em>, <em>A</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.select" title="Permalink to this definition">¶</a></dt>
<dd><p>We first describe the default behavior, when <span class="math">\(flag\)</span> is 0 or omitted.
Given a vector or list <code class="docutils literal"><span class="pre">A</span></code> and a <code class="docutils literal"><span class="pre">t_CLOSURE</span></code> <code class="docutils literal"><span class="pre">f</span></code>, <code class="docutils literal"><span class="pre">select</span></code>
returns the elements <span class="math">\(x\)</span> of <code class="docutils literal"><span class="pre">A</span></code> such that <span class="math">\(f(x)\)</span> is non-zero. In other
words, <code class="docutils literal"><span class="pre">f</span></code> is seen as a selection function returning a boolean value.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? select(x-&gt;isprime(x), vector(50,i,i^2+1))
%1 = [2, 5, 17, 37, 101, 197, 257, 401, 577, 677, 1297, 1601]
? select(x-&gt;(x&lt;100), %)
%2 = [2, 5, 17, 37]
</pre></div>
</div>
<p>returns the primes of the form <span class="math">\(i^2+1\)</span> for some <span class="math">\(i &lt;= 50\)</span>,
then the elements less than 100 in the preceding result. The <code class="docutils literal"><span class="pre">select</span></code>
function also applies to a matrix <code class="docutils literal"><span class="pre">A</span></code>, seen as a vector of columns, i.e. it
selects columns instead of entries, and returns the matrix whose columns are
the selected ones.</p>
<p><strong>Remark.</strong> For <span class="math">\(v\)</span> a <code class="docutils literal"><span class="pre">t_VEC</span></code>, <code class="docutils literal"><span class="pre">t_COL</span></code>, <code class="docutils literal"><span class="pre">t_LIST</span></code> or <code class="docutils literal"><span class="pre">t_MAT</span></code>,
the alternative set-notations</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="p">[</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">]</span>
</pre></div>
</div>
<p>are available as shortcuts for</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">apply</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">select</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Vec</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
<span class="n">select</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Vec</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="n">apply</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">Vec</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
</pre></div>
</div>
<p>respectively:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? [ x | x &lt;- vector(50,i,i^2+1), isprime(x) ]
%1 = [2, 5, 17, 37, 101, 197, 257, 401, 577, 677, 1297, 1601]
</pre></div>
</div>
<p>If <span class="math">\(flag = 1\)</span>, this function returns instead the <em>indices</em> of
the selected elements, and not the elements themselves (indirect selection):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? V = vector(50,i,i^2+1);
? select(x-&gt;isprime(x), V, 1)
%2 = Vecsmall([1, 2, 4, 6, 10, 14, 16, 20, 24, 26, 36, 40])
? vecextract(V, %)
%3 = [2, 5, 17, 37, 101, 197, 257, 401, 577, 677, 1297, 1601]
</pre></div>
</div>
<p>The following function lists the elements in <span class="math">\((\mathbb{Z}/N\mathbb{Z})^*\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? invertibles(N) = select(x-&gt;gcd(x,N) == 1, [1..N])
</pre></div>
</div>
<p>Finally</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? select(x-&gt;x, M)
</pre></div>
</div>
<p>selects the non-0 entries in <code class="docutils literal"><span class="pre">M</span></code>. If the latter is a
<code class="docutils literal"><span class="pre">t_MAT</span></code>, we extract the matrix of non-0 columns. Note that <em>removing</em>
entries instead of selecting them just involves replacing the selection
function <code class="docutils literal"><span class="pre">f</span></code> with its negation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? select(x-&gt;!isprime(x), vector(50,i,i^2+1))
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.seralgdep">
<code class="descname">seralgdep</code><span class="sig-paren">(</span><em>s</em>, <em>p</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.seralgdep" title="Permalink to this definition">¶</a></dt>
<dd><p>finds a linear relation between powers <span class="math">\((1,s,
..., s^p)\)</span> of the series <span class="math">\(s\)</span>, with polynomial coefficients of degree
<span class="math">\(&lt;= r\)</span>. In case no relation is found, return <span class="math">\(0\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? s = 1 + 10*y - 46*y^2 + 460*y^3 - 5658*y^4 + 77740*y^5 + O(y^6);
? seralgdep(s, 2, 2)
%2 = -x^2 + (8*y^2 + 20*y + 1)
? subst(%, x, s)
%3 = O(y^6)
? seralgdep(s, 1, 3)
%4 = (-77*y^2 - 20*y - 1)*x + (310*y^3 + 231*y^2 + 30*y + 1)
? seralgdep(s, 1, 2)
%5 = 0
</pre></div>
</div>
<p>The series main variable must not be <span class="math">\(x\)</span>, so as to be able
to express the result as a polynomial in <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.serconvol">
<code class="descname">serconvol</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.serconvol" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolution (or Hadamard product) of the
two power series <span class="math">\(x\)</span> and <span class="math">\(y\)</span>; in other words if <span class="math">\(x = \sum a_k*X^k\)</span> and <span class="math">\(y = \sum
b_k*X^k\)</span> then <span class="math">\(serconvol(x,y) = \sum a_k*b_k*X^k\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.serlaplace">
<code class="descname">serlaplace</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.serlaplace" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> must be a power series with non-negative
exponents or a polynomial. If <span class="math">\(x = \sum (a_k/k!)*X^k\)</span> then the result is <span class="math">\(\sum
a_k*X^k\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.serreverse">
<code class="descname">serreverse</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.serreverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse power series of <span class="math">\(s\)</span>, i.e. the series <span class="math">\(t\)</span> such that <span class="math">\(t(s) = x\)</span>;
<span class="math">\(s\)</span> must be a power series whose valuation is exactly equal to one.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \ps 8
? t = serreverse(tan(x))
%2 = x - 1/3*x^3 + 1/5*x^5 - 1/7*x^7 + O(x^8)
? tan(t)
%3 = x + O(x^8)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.setbinop">
<code class="descname">setbinop</code><span class="sig-paren">(</span><em>f</em>, <em>X</em>, <em>Y=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.setbinop" title="Permalink to this definition">¶</a></dt>
<dd><p>The set whose elements are the f(x,y), where x,y run through X,Y.
respectively. If <span class="math">\(Y\)</span> is omitted, assume that <span class="math">\(X = Y\)</span> and that <span class="math">\(f\)</span> is symmetric:
<span class="math">\(f(x,y) = f(y,x)\)</span> for all <span class="math">\(x,y\)</span> in <span class="math">\(X\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? X = [1,2,3]; Y = [2,3,4];
? setbinop((x,y)-&gt;x+y, X,Y) \\ set X + Y
%2 = [3, 4, 5, 6, 7]
? setbinop((x,y)-&gt;x-y, X,Y) \\ set X - Y
%3 = [-3, -2, -1, 0, 1]
? setbinop((x,y)-&gt;x+y, X) \\ set 2X = X + X
%2 = [2, 3, 4, 5, 6]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.setintersect">
<code class="descname">setintersect</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.setintersect" title="Permalink to this definition">¶</a></dt>
<dd><p>Intersection of the two sets <span class="math">\(x\)</span> and <span class="math">\(y\)</span> (see <code class="docutils literal"><span class="pre">setisset</span></code>).
If <span class="math">\(x\)</span> or <span class="math">\(y\)</span> is not a set, the result is undefined.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.setisset">
<code class="descname">setisset</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.setisset" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true (1) if <span class="math">\(x\)</span> is a set, false (0) if
not. In PARI, a set is a row vector whose entries are strictly
increasing with respect to a (somewhat arbitrary) universal comparison
function. To convert any object into a set (this is most useful for
vectors, of course), use the function <code class="docutils literal"><span class="pre">Set</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? a = [3, 1, 1, 2];
? setisset(a)
%2 = 0
? Set(a)
%3 = [1, 2, 3]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.setminus">
<code class="descname">setminus</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.setminus" title="Permalink to this definition">¶</a></dt>
<dd><p>Difference of the two sets <span class="math">\(x\)</span> and <span class="math">\(y\)</span> (see <code class="docutils literal"><span class="pre">setisset</span></code>),
i.e.&nbsp;set of elements of <span class="math">\(x\)</span> which do not belong to <span class="math">\(y\)</span>.
If <span class="math">\(x\)</span> or <span class="math">\(y\)</span> is not a set, the result is undefined.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.setrand">
<code class="descname">setrand</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.setrand" title="Permalink to this definition">¶</a></dt>
<dd><p>Reseeds the random number generator using the seed <span class="math">\(n\)</span>. No value is
returned. The seed is either a technical array output by <code class="docutils literal"><span class="pre">getrand</span></code>, or a
small positive integer, used to generate deterministically a suitable state
array. For instance, running a randomized computation starting by
<code class="docutils literal"><span class="pre">setrand(1)</span></code> twice will generate the exact same output.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.setsearch">
<code class="descname">setsearch</code><span class="sig-paren">(</span><em>S</em>, <em>x</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.setsearch" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether <span class="math">\(x\)</span> belongs to the set <span class="math">\(S\)</span> (see <code class="docutils literal"><span class="pre">setisset</span></code>).</p>
<p>We first describe the default behaviour, when <span class="math">\(flag\)</span> is zero or omitted. If <span class="math">\(x\)</span>
belongs to the set <span class="math">\(S\)</span>, returns the index <span class="math">\(j\)</span> such that <span class="math">\(S[j] = x\)</span>, otherwise
returns 0.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? T = [7,2,3,5]; S = Set(T);
? setsearch(S, 2)
%2 = 1
? setsearch(S, 4) \\ not found
%3 = 0
? setsearch(T, 7) \\ search in a randomly sorted vector
%4 = 0 \\ WRONG !
</pre></div>
</div>
<p>If <span class="math">\(S\)</span> is not a set, we also allow sorted lists with
respect to the <code class="docutils literal"><span class="pre">cmp</span></code> sorting function, without repeated entries,
as per <code class="docutils literal"><span class="pre">listsort</span></code><span class="math">\((L,1)\)</span>; otherwise the result is undefined.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? L = List([1,4,2,3,2]); setsearch(L, 4)
%1 = 0 \\ WRONG !
? listsort(L, 1); L \\ sort L first
%2 = List([1, 2, 3, 4])
? setsearch(L, 4)
%3 = 4 \\ now correct
</pre></div>
</div>
<p>If <span class="math">\(flag\)</span> is non-zero, this function returns the index <span class="math">\(j\)</span> where <span class="math">\(x\)</span> should be
inserted, and <span class="math">\(0\)</span> if it already belongs to <span class="math">\(S\)</span>. This is meant to be used for
dynamically growing (sorted) lists, in conjunction with <code class="docutils literal"><span class="pre">listinsert</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? L = List([1,5,2,3,2]); listsort(L,1); L
%1 = List([1,2,3,5])
? j = setsearch(L, 4, 1) \\ 4 should have been inserted at index j
%2 = 4
? listinsert(L, 4, j); L
%3 = List([1, 2, 3, 4, 5])
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.setunion">
<code class="descname">setunion</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.setunion" title="Permalink to this definition">¶</a></dt>
<dd><p>Union of the two sets <span class="math">\(x\)</span> and <span class="math">\(y\)</span> (see <code class="docutils literal"><span class="pre">setisset</span></code>).
If <span class="math">\(x\)</span> or <span class="math">\(y\)</span> is not a set, the result is undefined.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.shift">
<code class="descname">shift</code><span class="sig-paren">(</span><em>x</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts <span class="math">\(x\)</span> componentwise left by <span class="math">\(n\)</span> bits if <span class="math">\(n &gt;= 0\)</span> and right by <span class="math">\(\|n\|\)</span>
bits if <span class="math">\(n &lt; 0\)</span>. May be abbreviated as <span class="math">\(x\)</span> :literal:` &lt;&lt; ` <span class="math">\(n\)</span> or <span class="math">\(x\)</span> :literal:` &gt;&gt; ` <span class="math">\((-n)\)</span>.
A left shift by <span class="math">\(n\)</span> corresponds to multiplication by <span class="math">\(2^n\)</span>. A right shift of an
integer <span class="math">\(x\)</span> by <span class="math">\(\|n\|\)</span> corresponds to a Euclidean division of <span class="math">\(x\)</span> by <span class="math">\(2^{\|n\|}\)</span>
with a remainder of the same sign as <span class="math">\(x\)</span>, hence is not the same (in general) as
<span class="math">\(x \ 2^n\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.shiftmul">
<code class="descname">shiftmul</code><span class="sig-paren">(</span><em>x</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.shiftmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplies <span class="math">\(x\)</span> by <span class="math">\(2^n\)</span>. The difference with
<code class="docutils literal"><span class="pre">shift</span></code> is that when <span class="math">\(n &lt; 0\)</span>, ordinary division takes place, hence for
example if <span class="math">\(x\)</span> is an integer the result may be a fraction, while for shifts
Euclidean division takes place when <span class="math">\(n &lt; 0\)</span> hence if <span class="math">\(x\)</span> is an integer the result
is still an integer.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sigma">
<code class="descname">sigma</code><span class="sig-paren">(</span><em>x</em>, <em>k=1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of the <span class="math">\(k-th\)</span> powers of the positive divisors of <span class="math">\(\|x\|\)</span>. <span class="math">\(x\)</span>
and <span class="math">\(k\)</span> must be of type integer.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>sign (<span class="math">\(0\)</span>, <span class="math">\(1\)</span> or <span class="math">\(-1\)</span>) of <span class="math">\(x\)</span>, which must be of
type integer, real or fraction; <code class="docutils literal"><span class="pre">t_QUAD</span></code> with positive discriminants and
<code class="docutils literal"><span class="pre">t_INFINITY</span></code> are also supported.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.simplify">
<code class="descname">simplify</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>This function simplifies <span class="math">\(x\)</span> as much as it can. Specifically, a complex or
quadratic number whose imaginary part is the integer 0 (i.e.&nbsp;not <code class="docutils literal"><span class="pre">Mod(0,2)</span></code>
or <code class="docutils literal"><span class="pre">0.E-28</span></code>) is converted to its real part, and a polynomial of degree <span class="math">\(0\)</span>
is converted to its constant term. Simplifications occur recursively.</p>
<p>This function is especially useful before using arithmetic functions,
which expect integer arguments:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? x = 2 + y - y
%1 = 2
? isprime(x)
 *** at top-level: isprime(x)
 *** ^----------
 *** isprime: not an integer argument in an arithmetic function
? type(x)
%2 = &quot;t_POL&quot;
? type(simplify(x))
%3 = &quot;t_INT&quot;
</pre></div>
</div>
<p>Note that GP results are simplified as above before they are stored in the
history. (Unless you disable automatic simplification with <code class="docutils literal"><span class="pre">\backslash</span> <span class="pre">y</span></code>, that is.)
In particular</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? type(%1)
%4 = &quot;t_INT&quot;
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sin">
<code class="descname">sin</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sin" title="Permalink to this definition">¶</a></dt>
<dd><p>Sine of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sinc">
<code class="descname">sinc</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sinc" title="Permalink to this definition">¶</a></dt>
<dd><p>Cardinal sine of <span class="math">\(x\)</span>, i.e. <span class="math">\(\sin(x)/x\)</span> if <span class="math">\(x != 0\)</span>, <span class="math">\(1\)</span> otherwise.
Note that this function also allows to compute</p>
<div class="math">
\[(1-\cos(x)) / x^2 = sinc(x/2)^2 / 2\]</div>
<p>accurately near <span class="math">\(x = 0\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sinh">
<code class="descname">sinh</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Hyperbolic sine of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sizebyte">
<code class="descname">sizebyte</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sizebyte" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs the total number of bytes occupied by the tree representing the
PARI object <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sizedigit">
<code class="descname">sizedigit</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sizedigit" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs a quick upper bound for the number of decimal digits of (the
components of) <span class="math">\(x\)</span>, off by at most <span class="math">\(1\)</span>. More precisely, for a positive
integer <span class="math">\(x\)</span>, it computes (approximately) the ceiling of</p>
<div class="math">
\[floor(1 + \log_2 x) \log_{10}2,\]</div>
<p>This function is DEPRECATED, essentially meaningless, and provided for
backwards compatibility only. Don&#8217;t use it!</p>
<p>To count the number of decimal digits of a positive integer <span class="math">\(x\)</span>, use
<code class="docutils literal"><span class="pre">#digits(x)</span></code>. To estimate (recursively) the size of <span class="math">\(x\)</span>, use
<code class="docutils literal"><span class="pre">normlp(x)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sqr">
<code class="descname">sqr</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Square of <span class="math">\(x\)</span>. This operation is not completely
straightforward, i.e.&nbsp;identical to <span class="math">\(x * x\)</span>, since it can usually be
computed more efficiently (roughly one-half of the elementary
multiplications can be saved). Also, squaring a <span class="math">\(2\)</span>-adic number increases
its precision. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? (1 + O(2^4))^2
%1 = 1 + O(2^5)
? (1 + O(2^4)) * (1 + O(2^4))
%2 = 1 + O(2^4)
</pre></div>
</div>
<p>Note that this function is also called whenever one multiplies two objects
which are known to be <em>identical</em>, e.g.&nbsp;they are the value of the same
variable, or we are computing a power.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? x = (1 + O(2^4)); x * x
%3 = 1 + O(2^5)
? (1 + O(2^4))^4
%4 = 1 + O(2^6)
</pre></div>
</div>
<p>(note the difference between <code class="docutils literal"><span class="pre">%2</span></code> and <code class="docutils literal"><span class="pre">%3</span></code> above).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sqrt">
<code class="descname">sqrt</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal branch of the square root of <span class="math">\(x\)</span>, defined as <span class="math">\(\sqrt{x} = 
\exp(\log x / 2)\)</span>. In particular, we have
<span class="math">\({Arg}({sqrt}(x)) belongs to ]-\Pi/2, \Pi/2]\)</span>, and if <span class="math">\(x belongs to \mathbb{R}\)</span> and <span class="math">\(x &lt; 0\)</span>,
then the result is complex with positive imaginary part.</p>
<p>Intmod a prime <span class="math">\(p\)</span>, <code class="docutils literal"><span class="pre">t_PADIC</span></code> and <code class="docutils literal"><span class="pre">t_FFELT</span></code> are allowed as arguments. In
the first 2 cases (<code class="docutils literal"><span class="pre">t_INTMOD</span></code>, <code class="docutils literal"><span class="pre">t_PADIC</span></code>), the square root (if it
exists) which is returned is the one whose first <span class="math">\(p\)</span>-adic digit is in the
interval <span class="math">\([0,p/2]\)</span>. For other arguments, the result is undefined.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sqrtint">
<code class="descname">sqrtint</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sqrtint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the integer square root of <span class="math">\(x\)</span>, i.e. the largest integer <span class="math">\(y\)</span>
such that <span class="math">\(y^2 &lt;= x\)</span>, where <span class="math">\(x\)</span> a non-negative integer.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? N = 120938191237; sqrtint(N)
%1 = 347761
? sqrt(N)
%2 = 347761.68741970412747602130964414095216
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sqrtnint">
<code class="descname">sqrtnint</code><span class="sig-paren">(</span><em>x</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sqrtnint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the integer <span class="math">\(n\)</span>-th root of <span class="math">\(x\)</span>, i.e. the largest integer <span class="math">\(y\)</span> such
that <span class="math">\(y^n &lt;= x\)</span>, where <span class="math">\(x\)</span> is a non-negative integer.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? N = 120938191237; sqrtnint(N, 5)
%1 = 164
? N^(1/5)
%2 = 164.63140849829660842958614676939677391
</pre></div>
</div>
<p>The special case <span class="math">\(n = 2\)</span> is <code class="docutils literal"><span class="pre">sqrtint</span></code></p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.subgrouplist">
<code class="descname">subgrouplist</code><span class="sig-paren">(</span><em>bnr</em>, <em>bound=None</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.subgrouplist" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bnr</em> being as output by <code class="docutils literal"><span class="pre">bnrinit</span></code> or a list of cyclic components
of a finite Abelian group <span class="math">\(G\)</span>, outputs the list of subgroups of <span class="math">\(G\)</span>. Subgroups
are given as HNF left divisors of the SNF matrix corresponding to <span class="math">\(G\)</span>.</p>
<p>If <span class="math">\(flag = 0\)</span> (default) and <em>bnr</em> is as output by <code class="docutils literal"><span class="pre">bnrinit</span></code>, gives
only the subgroups whose modulus is the conductor. Otherwise, the modulus is
not taken into account.</p>
<p>If <em>bound</em> is present, and is a positive integer, restrict the output to
subgroups of index less than <em>bound</em>. If <em>bound</em> is a vector
containing a single positive integer <span class="math">\(B\)</span>, then only subgroups of index
exactly equal to <span class="math">\(B\)</span> are computed. For instance</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? subgrouplist([6,2])
%1 = [[6, 0; 0, 2], [2, 0; 0, 2], [6, 3; 0, 1], [2, 1; 0, 1], [3, 0; 0, 2],
[1, 0; 0, 2], [6, 0; 0, 1], [2, 0; 0, 1], [3, 0; 0, 1], [1, 0; 0, 1]]
? subgrouplist([6,2],3) \\ index less than 3
%2 = [[2, 1; 0, 1], [1, 0; 0, 2], [2, 0; 0, 1], [3, 0; 0, 1], [1, 0; 0, 1]]
? subgrouplist([6,2],[3]) \\ index 3
%3 = [[3, 0; 0, 1]]
? bnr = bnrinit(bnfinit(x), [120,[1]], 1);
? L = subgrouplist(bnr, [8]);
</pre></div>
</div>
<p>In the last example, <span class="math">\(L\)</span> corresponds to the 24 subfields of
<span class="math">\(\mathbb{Q}(\zeta_{120})\)</span>, of degree <span class="math">\(8\)</span> and conductor <span class="math">\(120 oo\)</span> (by setting <em>flag</em>,
we see there are a total of <span class="math">\(43\)</span> subgroups of degree <span class="math">\(8\)</span>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? vector(#L, i, galoissubcyclo(bnr, L[i]))
</pre></div>
</div>
<p>will produce their equations. (For a general base field, you would
have to rely on <code class="docutils literal"><span class="pre">bnrstark</span></code>, or <code class="docutils literal"><span class="pre">rnfkummer</span></code>.)</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.subst">
<code class="descname">subst</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.subst" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the simple variable <span class="math">\(y\)</span> by the argument <span class="math">\(z\)</span> in the &#8220;polynomial&#8221;
expression <span class="math">\(x\)</span>. Every type is allowed for <span class="math">\(x\)</span>, but if it is not a genuine
polynomial (or power series, or rational function), the substitution will be
done as if the scalar components were polynomials of degree zero. In
particular, beware that:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? subst(1, x, [1,2; 3,4])
%1 =
[1 0]

[0 1]

? subst(1, x, Mat([0,1]))
 *** at top-level: subst(1,x,Mat([0,1])
 *** ^--------------------
 *** subst: forbidden substitution by a non square matrix.
</pre></div>
</div>
<p>If <span class="math">\(x\)</span> is a power series, <span class="math">\(z\)</span> must be either a polynomial, a power
series, or a rational function. Finally, if <span class="math">\(x\)</span> is a vector,
matrix or list, the substitution is applied to each individual entry.</p>
<p>Use the function <code class="docutils literal"><span class="pre">substvec</span></code> to replace several variables at once,
or the function <code class="docutils literal"><span class="pre">substpol</span></code> to replace a polynomial expression.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.substpol">
<code class="descname">substpol</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.substpol" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the &#8220;variable&#8221; <span class="math">\(y\)</span> by the argument <span class="math">\(z\)</span> in the &#8220;polynomial&#8221;
expression <span class="math">\(x\)</span>. Every type is allowed for <span class="math">\(x\)</span>, but the same behavior
as <code class="docutils literal"><span class="pre">subst</span></code> above apply.</p>
<p>The difference with <code class="docutils literal"><span class="pre">subst</span></code> is that <span class="math">\(y\)</span> is allowed to be any polynomial
here. The substitution is done moding out all components of <span class="math">\(x\)</span>
(recursively) by <span class="math">\(y - t\)</span>, where <span class="math">\(t\)</span> is a new free variable of lowest
priority. Then substituting <span class="math">\(t\)</span> by <span class="math">\(z\)</span> in the resulting expression. For
instance</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? substpol(x^4 + x^2 + 1, x^2, y)
%1 = y^2 + y + 1
? substpol(x^4 + x^2 + 1, x^3, y)
%2 = x^2 + y*x + 1
? substpol(x^4 + x^2 + 1, (x+1)^2, y)
%3 = (-4*y - 6)*x + (y^2 + 3*y - 3)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.substvec">
<code class="descname">substvec</code><span class="sig-paren">(</span><em>x</em>, <em>v</em>, <em>w</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.substvec" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(v\)</span> being a vector of monomials of degree 1 (variables),
<span class="math">\(w\)</span> a vector of expressions of the same length, replace in the expression
<span class="math">\(x\)</span> all occurrences of <span class="math">\(v_i\)</span> by <span class="math">\(w_i\)</span>. The substitutions are done
simultaneously; more precisely, the <span class="math">\(v_i\)</span> are first replaced by new
variables in <span class="math">\(x\)</span>, then these are replaced by the <span class="math">\(w_i\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? substvec([x,y], [x,y], [y,x])
%1 = [y, x]
? substvec([x,y], [x,y], [y,x+y])
%2 = [y, x + y] \\ not [y, 2*y]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sumdedekind">
<code class="descname">sumdedekind</code><span class="sig-paren">(</span><em>h</em>, <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sumdedekind" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Dedekind sum associated to the integers <span class="math">\(h\)</span> and <span class="math">\(k\)</span>,
corresponding to a fast implementation of</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">s</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">frac</span><span class="p">(</span><span class="n">h</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sumdigits">
<code class="descname">sumdigits</code><span class="sig-paren">(</span><em>n</em>, <em>B=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sumdigits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of digits in the integer <span class="math">\(n\)</span>, when written in base <span class="math">\(B &gt; 1\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? sumdigits(123456789)
%1 = 45
? sumdigits(123456789, 2)
%1 = 16
</pre></div>
</div>
<p>Note that the sum of bits in <span class="math">\(n\)</span> is also returned by
<code class="docutils literal"><span class="pre">hammingweight</span></code>. This function is much faster than
<code class="docutils literal"><span class="pre">vecsum(digits(n,B))</span></code> when <span class="math">\(B\)</span> is <span class="math">\(10\)</span> or a power of <span class="math">\(2\)</span>, and only
slightly faster in other cases.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sumformal">
<code class="descname">sumformal</code><span class="sig-paren">(</span><em>f</em>, <em>v=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sumformal" title="Permalink to this definition">¶</a></dt>
<dd><p>formal sum of the polynomial expression <span class="math">\(f\)</span> with respect to the
main variable if <span class="math">\(v\)</span> is omitted, with respect to the variable <span class="math">\(v\)</span> otherwise;
it is assumed that the base ring has characteristic zero. In other words,
considering <span class="math">\(f\)</span> as a polynomial function in the variable <span class="math">\(v\)</span>,
returns <span class="math">\(F\)</span>, a polynomial in <span class="math">\(v\)</span> vanishing at <span class="math">\(0\)</span>, such that <span class="math">\(F(b) - F(a)
= sum_{v = a+1}^b f(v)\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? sumformal(n) \\ 1 + ... + n
%1 = 1/2*n^2 + 1/2*n
? f(n) = n^3+n^2+1;
? F = sumformal(f(n)) \\ f(1) + ... + f(n)
%3 = 1/4*n^4 + 5/6*n^3 + 3/4*n^2 + 7/6*n
? sum(n = 1, 2000, f(n)) == subst(F, n, 2000)
%4 = 1
? sum(n = 1001, 2000, f(n)) == subst(F, n, 2000) - subst(F, n, 1000)
%5 = 1
? sumformal(x^2 + x*y + y^2, y)
%6 = y*x^2 + (1/2*y^2 + 1/2*y)*x + (1/3*y^3 + 1/2*y^2 + 1/6*y)
? x^2 * y + x * sumformal(y) + sumformal(y^2) == %
%7 = 1
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sumnuminit">
<code class="descname">sumnuminit</code><span class="sig-paren">(</span><em>asymp</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sumnuminit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize tables for Euler&#8211;MacLaurin delta summation of a series with
positive terms. If given, <code class="docutils literal"><span class="pre">asymp</span></code> is of the form <span class="math">\([+oo, \alpha]\)</span>,
as in <code class="docutils literal"><span class="pre">intnum</span></code> and indicates the decrease rate at infinity of functions
to be summed. A positive
<span class="math">\(\alpha &gt; 0\)</span> encodes an exponential decrease of type <span class="math">\(\exp(-\alpha n)\)</span> and
a negative <span class="math">\(-2 &lt; \alpha &lt; -1\)</span> encodes a slow polynomial decrease of type
<span class="math">\(n^{\alpha}\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \p200
? sumnum(n=1, n^-2);
time = 200 ms.
? tab = sumnuminit();
time = 188 ms.
? sumnum(n=1, n^-2, tab); \\ faster
time = 8 ms.

? tab = sumnuminit([+oo, log(2)]); \\ decrease like 2^-n
time = 200 ms.
? sumnum(n=1, 2^-n, tab)
time = 44 ms.

? tab = sumnuminit([+oo, -4/3]); \\ decrease like n^(-4/3)
time = 200 ms.
? sumnum(n=1, n^(-4/3), tab);
time = 221 ms.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.sumnummonieninit">
<code class="descname">sumnummonieninit</code><span class="sig-paren">(</span><em>asymp</em>, <em>w=None</em>, <em>n0=None</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.sumnummonieninit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize tables for Monien summation of a series <span class="math">\(\sum_{n &gt;= n_0}
f(n)\)</span> where <span class="math">\(f(1/z)\)</span> has a complex analytic continuation in a (complex)
neighbourhood of the segment <span class="math">\([0,1]\)</span>.</p>
<p>By default, assume that <span class="math">\(f(n) = O(n^{-2})\)</span> and has a non-zero asymptotic
expansion</p>
<div class="math">
\[f(n) = \sum_{i &gt;= 2} a_i / n^i\]</div>
<p>at infinity. Note that the sum starts at <span class="math">\(i = 2\)</span>! The argument <code class="docutils literal"><span class="pre">asymp</span></code>
allows to specify different expansions:</p>
<ul class="simple">
<li>a real number <span class="math">\(\alpha &gt; 1\)</span> means</li>
</ul>
<div class="math">
\[ \begin{align}\begin{aligned}  f(n) = \sum_{i &gt;= 1} a_i / n^\alpha\\(Now the summation starts at :math:`1`.)\end{aligned}\end{align} \]</div>
<ul class="simple">
<li>a vector <span class="math">\([\alpha,\beta]\)</span> of reals, where we must have <span class="math">\(\alpha &gt; 0\)</span>
and <span class="math">\(\alpha + \beta &gt; 1\)</span> to ensure convergence, means that</li>
</ul>
<div class="math">
\[ \begin{align}\begin{aligned}  f(n) = \sum_{i &gt;= 1} a_i / n^{\alpha i + \beta}\\Note that :math:`asymp = [\alpha, \alpha]` is equivalent to
:math:`asymp = \alpha`.\end{aligned}\end{align} \]</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \p38
? s = sumnum(n = 1, sin(1/sqrt(n)) / n)
%1 = 2.3979771206715998375659850036324914714

? sumnummonien(n = 1, sin(1/sqrt(n)) / n) - s
%2 = -0.001[...] \\ completely wrong !

? t = sumnummonieninit([1/2,1]); \\ f(n) = \sum_i 1 / n^(i/2+1)
? sumnummonien(n = 1, sin(1/sqrt(n)) / n, t) - s
%3 = 0.E-37 \\ now correct
</pre></div>
</div>
<p>The argument <span class="math">\(w\)</span> is used to sum expressions of the form</p>
<div class="math">
\[\sum_{n &gt;= n_0} f(n) w(n),\]</div>
<p>for varying <span class="math">\(f\)</span> <em>as above</em>, and fixed weight function <span class="math">\(w\)</span>, where we
further assume that the auxiliary sums</p>
<div class="math">
\[g_w(m) = \sum_{n &gt;= n_0} w(n) / n^{\alpha m + \beta}\]</div>
<p>converge for all <span class="math">\(m &gt;= 1\)</span>. Note that for non-negative integers <span class="math">\(k\)</span>,
and weight <span class="math">\(w(n) = (\log n)^k\)</span>, the function <span class="math">\(g_w(m) = \zeta^{(k)}(\alpha m +
\beta)\)</span> has a simple expression; for general weights, <span class="math">\(g_w\)</span> is
computed using <code class="docutils literal"><span class="pre">sumnum</span></code>. The following variants are available</p>
<ul class="simple">
<li>an integer <span class="math">\(k &gt;= 0\)</span>, to code <span class="math">\(w(n) = (\log n)^k\)</span>;
only the cases <span class="math">\(k = 0,1\)</span> are presently implemented; due to a poor
implementation of <span class="math">\(\zeta\)</span> derivatives, it is not currently worth it
to exploit the special shape of <span class="math">\(g_w\)</span> when <span class="math">\(k &gt; 0\)</span>;</li>
<li>a <code class="docutils literal"><span class="pre">t_CLOSURE</span></code> computing the values <span class="math">\(w(n)\)</span>, where we
assume that <span class="math">\(w(n) = O(n^\epsilon)\)</span> for all <span class="math">\(\epsilon &gt; 0\)</span>;</li>
<li>a vector <span class="math">\([w, fast]\)</span>, where <span class="math">\(w\)</span> is a closure as above
and <code class="docutils literal"><span class="pre">fast</span></code> is a scalar;
we assume that <span class="math">\(w(n) = O(n^{fast+\epsilon})\)</span>; note that
<span class="math">\(w = [w, 0]\)</span> is equivalent to <span class="math">\(w = w\)</span>.</li>
<li>a vector <span class="math">\([w, oo]\)</span>, where <span class="math">\(w\)</span> is a closure as above;
we assume that <span class="math">\(w(n)\)</span> decreases exponentially. Note that in this case,
<code class="docutils literal"><span class="pre">sumnummonien</span></code> is provided for completeness and comparison purposes only:
one of <code class="docutils literal"><span class="pre">suminf</span></code> or <code class="docutils literal"><span class="pre">sumpos</span></code> should be preferred in practice.</li>
</ul>
<p>The cases where <span class="math">\(w\)</span> is a closure or <span class="math">\(w(n) = \log n\)</span> are the only ones where
<span class="math">\(n_0\)</span> is taken into account and stored in the result. The subsequent call to
<code class="docutils literal"><span class="pre">sumnummonien</span></code> <em>must</em> use the same value.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? \p300
? sumnummonien(n = 1, n^-2*log(n)) + zeta&#39;(2)
time = 536 ms.
%1 = -1.323[...]E-6 \\ completely wrong, f does not satisfy hypotheses !
? tab = sumnummonieninit(, 1); \\ codes w(n) = log(n)
time = 18,316 ms.
? sumnummonien(n = 1, n^-2, tab) + zeta&#39;(2)
time = 44 ms.
%3 = -5.562684646268003458 E-309 \\ now perfect

? tab = sumnummonieninit(, n-&gt;log(n)); \\ generic, about as fast
time = 18,693 ms.
? sumnummonien(n = 1, n^-2, tab) + zeta&#39;(2)
time = 40 ms.
%5 = -5.562684646268003458 E-309 \\ identical result
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.tan">
<code class="descname">tan</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.tan" title="Permalink to this definition">¶</a></dt>
<dd><p>Tangent of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.tanh">
<code class="descname">tanh</code><span class="sig-paren">(</span><em>x</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.tanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Hyperbolic tangent of <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.taylor">
<code class="descname">taylor</code><span class="sig-paren">(</span><em>x</em>, <em>t</em>, <em>serprec=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.taylor" title="Permalink to this definition">¶</a></dt>
<dd><p>Taylor expansion around <span class="math">\(0\)</span> of <span class="math">\(x\)</span> with respect to
the simple variable <span class="math">\(t\)</span>. <span class="math">\(x\)</span> can be of any reasonable type, for example a
rational function. Contrary to <code class="docutils literal"><span class="pre">Ser</span></code>, which takes the valuation into
account, this function adds <span class="math">\(O(t^d)\)</span> to all components of <span class="math">\(x\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? taylor(x/(1+y), y, 5)
%1 = (y^4 - y^3 + y^2 - y + 1)*x + O(y^5)
? Ser(x/(1+y), y, 5)
 *** at top-level: Ser(x/(1+y),y,5)
 *** ^----------------
 *** Ser: main variable must have higher priority in gtoser.
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.teichmuller">
<code class="descname">teichmuller</code><span class="sig-paren">(</span><em>x</em>, <em>tab=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.teichmuller" title="Permalink to this definition">¶</a></dt>
<dd><p>Teichmüller character of the <span class="math">\(p\)</span>-adic number <span class="math">\(x\)</span>, i.e. the unique
<span class="math">\((p-1)\)</span>-th root of unity congruent to <span class="math">\(x / p^{v_p(x)}\)</span> modulo <span class="math">\(p\)</span>.
If <span class="math">\(x\)</span> is of the form <span class="math">\([p,n]\)</span>, for a prime <span class="math">\(p\)</span> and integer <span class="math">\(n\)</span>,
return the lifts to <span class="math">\(\mathbb{Z}\)</span> of the images of <span class="math">\(i + O(p^n)\)</span> for
<span class="math">\(i = 1,..., p-1\)</span>, i.e. all roots of <span class="math">\(1\)</span> ordered by residue class modulo
<span class="math">\(p\)</span>. Such a vector can be fed back to <code class="docutils literal"><span class="pre">teichmuller</span></code>, as the
optional argument <code class="docutils literal"><span class="pre">tab</span></code>, to speed up later computations.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? z = teichmuller(2 + O(101^5))
%1 = 2 + 83*101 + 18*101^2 + 69*101^3 + 62*101^4 + O(101^5)
? z^100
%2 = 1 + O(101^5)
? T = teichmuller([101, 5]);
? teichmuller(2 + O(101^5), T)
%4 = 2 + 83*101 + 18*101^2 + 69*101^3 + 62*101^4 + O(101^5)
</pre></div>
</div>
<p>As a rule of thumb, if more than</p>
<div class="math">
\[p / 2(\log_2(p) + hammingweight(p))\]</div>
<p>values of <code class="docutils literal"><span class="pre">teichmuller</span></code> are to be computed, then it is worthwile to
initialize:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? p = 101; n = 100; T = teichmuller([p,n]); \\ instantaneous
? for(i=1,10^3, vector(p-1, i, teichmuller(i+O(p^n), T)))
time = 60 ms.
? for(i=1,10^3, vector(p-1, i, teichmuller(i+O(p^n))))
time = 1,293 ms.
? 1 + 2*(log(p)/log(2) + hammingweight(p))
%8 = 22.316[...]
</pre></div>
</div>
<p>Here the precompuation induces a speedup by a factor
<span class="math">\(1293/ 60 ~ 21.5\)</span>.</p>
<p><strong>Caveat.</strong>
If the accuracy of <code class="docutils literal"><span class="pre">tab</span></code> (the argument <span class="math">\(n\)</span> above) is lower than the
precision of <span class="math">\(x\)</span>, the <em>former</em> is used, i.e. the cached value is not
refined to higher accuracy. It the accuracy of <code class="docutils literal"><span class="pre">tab</span></code> is larger, then
the precision of <span class="math">\(x\)</span> is used:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? Tlow = teichmuller([101, 2]); \\ lower accuracy !
? teichmuller(2 + O(101^5), Tlow)
%10 = 2 + 83*101 + O(101^5) \\ no longer a root of 1

? Thigh = teichmuller([101, 10]); \\ higher accuracy
? teichmuller(2 + O(101^5), Thigh)
%12 = 2 + 83*101 + 18*101^2 + 69*101^3 + 62*101^4 + O(101^5)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.theta">
<code class="descname">theta</code><span class="sig-paren">(</span><em>q</em>, <em>z</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Jacobi sine theta-function</p>
<div class="math">
\[\theta_1(z, q) = 2q^{1/4} \sum_{n &gt;= 0} (-1)^n q^{n(n+1)} \sin((2n+1)z).\]</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.thetanullk">
<code class="descname">thetanullk</code><span class="sig-paren">(</span><em>q</em>, <em>k</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.thetanullk" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(k\)</span>-th derivative at <span class="math">\(z = 0\)</span> of <span class="math">\(theta(q,z)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.thue">
<code class="descname">thue</code><span class="sig-paren">(</span><em>tnf</em>, <em>a</em>, <em>sol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.thue" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all solutions of the equation
<span class="math">\(P(x,y) = a\)</span> in integers <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, where <em>tnf</em> was created with
<span class="math">\(thueinit(P)\)</span>. If present, <em>sol</em> must contain the solutions of
<span class="math">\(\mathrm{Norm}(x) = a\)</span> modulo units of positive norm in the number field
defined by <span class="math">\(P\)</span> (as computed by <code class="docutils literal"><span class="pre">bnfisintnorm</span></code>). If there are infinitely
many solutions, an error is issued.</p>
<p>It is allowed to input directly the polynomial <span class="math">\(P\)</span> instead of a <em>tnf</em>,
in which case, the function first performs <code class="docutils literal"><span class="pre">thueinit(P,0)</span></code>. This is
very wasteful if more than one value of <span class="math">\(a\)</span> is required.</p>
<p>If <em>tnf</em> was computed without assuming GRH (flag <span class="math">\(1\)</span> in <code class="docutils literal"><span class="pre">thueinit</span></code>),
then the result is unconditional. Otherwise, it depends in principle of the
truth of the GRH, but may still be unconditionally correct in some
favorable cases. The result is conditional on the GRH if
<span class="math">\(a != ± 1\)</span> and, <span class="math">\(P\)</span> has a single irreducible rational factor, whose
associated tentative class number <span class="math">\(h\)</span> and regulator <span class="math">\(R\)</span> (as computed
assuming the GRH) satisfy</p>
<ul class="simple">
<li><span class="math">\(h &gt; 1\)</span>,</li>
<li><span class="math">\(R/0.2 &gt; 1.5\)</span>.</li>
</ul>
<p>Here&#8217;s how to solve the Thue equation <span class="math">\(x^{13} - 5y^{13} = - 4\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? tnf = thueinit(x^13 - 5);
? thue(tnf, -4)
%1 = [[1, 1]]
</pre></div>
</div>
<p>In this case, one checks that <code class="docutils literal"><span class="pre">bnfinit(x^13</span> <span class="pre">-5).no</span></code>
is <span class="math">\(1\)</span>. Hence, the only solution is <span class="math">\((x,y) = (1,1)\)</span>, and the result is
unconditional. On the other hand:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? P = x^3-2*x^2+3*x-17; tnf = thueinit(P);
? thue(tnf, -15)
%2 = [[1, 1]] \\ a priori conditional on the GRH.
? K = bnfinit(P); K.no
%3 = 3
? K.reg
%4 = 2.8682185139262873674706034475498755834
</pre></div>
</div>
<p>This time the result is conditional. All results computed using this
particular <em>tnf</em> are likewise conditional, <em>except</em> for a right-hand
side of <span class="math">\(± 1\)</span>.
The above result is in fact correct, so we did not just disprove the GRH:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? tnf = thueinit(x^3-2*x^2+3*x-17, 1 /*unconditional*/);
? thue(tnf, -15)
%4 = [[1, 1]]
</pre></div>
</div>
<p>Note that reducible or non-monic polynomials are allowed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? tnf = thueinit((2*x+1)^5 * (4*x^3-2*x^2+3*x-17), 1);
? thue(tnf, 128)
%2 = [[-1, 0], [1, 0]]
</pre></div>
</div>
<p>Reducible polynomials are in fact much easier to handle.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.thueinit">
<code class="descname">thueinit</code><span class="sig-paren">(</span><em>P</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.thueinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the <em>tnf</em> corresponding to <span class="math">\(P\)</span>, a non-constant
univariate polynomial with integer coefficients.
The result is meant to be used in conjunction with <code class="docutils literal"><span class="pre">thue</span></code> to solve Thue
equations <span class="math">\(P(X / Y)Y^{\deg P} = a\)</span>, where <span class="math">\(a\)</span> is an integer. Accordingly,
<span class="math">\(P\)</span> must either have at least two distinct irreducible factors over <span class="math">\(\mathbb{Q}\)</span>,
or have one irreducible factor <span class="math">\(T\)</span> with degree <span class="math">\(&gt; 2\)</span> or two conjugate
complex roots: under these (necessary and sufficient) conditions, the
equation has finitely many integer solutions.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? S = thueinit(t^2+1);
? thue(S, 5)
%2 = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]]
? S = thueinit(t+1);
 *** at top-level: thueinit(t+1)
 *** ^-------------
 *** thueinit: domain error in thueinit: P = t + 1
</pre></div>
</div>
<p>The hardest case is when <span class="math">\(\deg P &gt; 2\)</span> and <span class="math">\(P\)</span> is irreducible
with at least one real root. The routine then uses Bilu-Hanrot&#8217;s algorithm.</p>
<p>If <span class="math">\(flag\)</span> is non-zero, certify results unconditionally. Otherwise, assume
GRH, this being much faster of course. In the latter case, the result
may still be unconditionally correct, see <code class="docutils literal"><span class="pre">thue</span></code>. For instance in most
cases where <span class="math">\(P\)</span> is reducible (not a pure power of an irreducible), <em>or</em>
conditional computed class groups are trivial <em>or</em> the right hand side
is <span class="math">\(±1\)</span>, then results are unconditional.</p>
<p><strong>Note.</strong> The general philosophy is to disprove the existence of large
solutions then to enumerate bounded solutions naively. The implementation
will overflow when there exist huge solutions and the equation has degree
<span class="math">\(&gt; 2\)</span> (the quadratic imaginary case is special, since we can use
<code class="docutils literal"><span class="pre">bnfisintnorm</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? thue(t^3+2, 10^30)
 *** at top-level: L=thue(t^3+2,10^30)
 *** ^-----------------
 *** thue: overflow in thue (SmallSols): y &lt;= 80665203789619036028928.
? thue(x^2+2, 10^30) \\ quadratic case much easier
%1 = [[-1000000000000000, 0], [1000000000000000, 0]]
</pre></div>
</div>
<p><strong>Note.</strong> It is sometimes possible to circumvent the above, and in any
case obtain an important speed-up, if you can write <span class="math">\(P = Q(x^d)\)</span> for some <span class="math">\(d &gt; 
1\)</span> and <span class="math">\(Q\)</span> still satisfying the <code class="docutils literal"><span class="pre">thueinit</span></code> hypotheses. You can then solve
the equation associated to <span class="math">\(Q\)</span> then eliminate all solutions <span class="math">\((x,y)\)</span> such that
either <span class="math">\(x\)</span> or <span class="math">\(y\)</span> is not a <span class="math">\(d\)</span>-th power.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? thue(x^4+1, 10^40); \\ stopped after 10 hours
? filter(L,d) =
 my(x,y); [[x,y] | v&lt;-L, ispower(v[1],d,&amp;x)&amp;&amp;ispower(v[2],d,&amp;y)];
? L = thue(x^2+1, 10^40);
? filter(L, 2)
%4 = [[0, 10000000000], [10000000000, 0]]
</pre></div>
</div>
<p>The last 2 commands use less than 20ms.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.trace">
<code class="descname">trace</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>This applies to quite general <span class="math">\(x\)</span>. If <span class="math">\(x\)</span> is not a
matrix, it is equal to the sum of <span class="math">\(x\)</span> and its conjugate, except for polmods
where it is the trace as an algebraic number.</p>
<p>For <span class="math">\(x\)</span> a square matrix, it is the ordinary trace. If <span class="math">\(x\)</span> is a
non-square matrix (but not a vector), an error occurs.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.type">
<code class="descname">type</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.type" title="Permalink to this definition">¶</a></dt>
<dd><p>This is useful only under <code class="docutils literal"><span class="pre">gp</span></code>. Returns the internal type name of
the PARI object <span class="math">\(x\)</span> as a string. Check out existing type names with the
metacommand <code class="docutils literal"><span class="pre">\t</span></code>. For example <code class="docutils literal"><span class="pre">type(1)</span></code> will return &#8220;<code class="docutils literal"><span class="pre">t_INT</span></code>&#8221;.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.valuation">
<code class="descname">valuation</code><span class="sig-paren">(</span><em>x</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.valuation" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the highest
exponent of <span class="math">\(p\)</span> dividing <span class="math">\(x\)</span>. If <span class="math">\(p\)</span> is of type integer, <span class="math">\(x\)</span> must be an
integer, an intmod whose modulus is divisible by <span class="math">\(p\)</span>, a fraction, a
<span class="math">\(q\)</span>-adic number with <span class="math">\(q = p\)</span>, or a polynomial or power series in which case the
valuation is the minimum of the valuation of the coefficients.</p>
<p>If <span class="math">\(p\)</span> is of type polynomial, <span class="math">\(x\)</span> must be of type polynomial or rational
function, and also a power series if <span class="math">\(x\)</span> is a monomial. Finally, the
valuation of a vector, complex or quadratic number is the minimum of the
component valuations.</p>
<p>If <span class="math">\(x = 0\)</span>, the result is <code class="docutils literal"><span class="pre">+oo</span></code> if <span class="math">\(x\)</span> is an exact object. If <span class="math">\(x\)</span> is a
<span class="math">\(p\)</span>-adic numbers or power series, the result is the exponent of the zero.
Any other type combinations gives an error.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.variable">
<code class="descname">variable</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the main variable of the object <span class="math">\(x\)</span> (the variable with the highest
priority used in <span class="math">\(x\)</span>), and <span class="math">\(p\)</span> if <span class="math">\(x\)</span> is a <span class="math">\(p\)</span>-adic number. Return <span class="math">\(0\)</span> if
<span class="math">\(x\)</span> has no variable associated to it.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? variable(x^2 + y)
%1 = x
? variable(1 + O(5^2))
%2 = 5
? variable([x,y,z,t])
%3 = x
? variable(1)
%4 = 0
</pre></div>
</div>
<p>The construction</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>if (!variable(x),...)
</pre></div>
</div>
<p>can be used to test whether a variable is attached to <span class="math">\(x\)</span>.</p>
<p>If <span class="math">\(x\)</span> is omitted, returns the list of user variables known to the
interpreter, by order of decreasing priority. (Highest priority is initially
<span class="math">\(x\)</span>, which come first until <code class="docutils literal"><span class="pre">varhigher</span></code> is used.) If <code class="docutils literal"><span class="pre">varhigher</span></code>
or <code class="docutils literal"><span class="pre">varlower</span></code> are used, it is quite possible to end up with different
variables (with different priorities) printed in the same way: they
will then appear multiple times in the output:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? varhigher(&quot;y&quot;);
? varlower(&quot;y&quot;);
? variable()
%4 = [y, x, y]
</pre></div>
</div>
<p>Using <code class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">variable()</span></code> then <code class="docutils literal"><span class="pre">v[1]</span></code>, <code class="docutils literal"><span class="pre">v[2]</span></code>,
etc.&nbsp;allows to recover and use existing variables.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the list of all variables occuring in object <span class="math">\(x\)</span> (all user
variables known to the interpreter if <span class="math">\(x\)</span> is omitted), sorted by
decreasing priority.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? variables([x^2 + y*z + O(t), a+x])
%1 = [x, y, z, t, a]
</pre></div>
</div>
<p>The construction</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>if (!variables(x),...)
</pre></div>
</div>
<p>can be used to test whether a variable is attached to <span class="math">\(x\)</span>.</p>
<p>If <code class="docutils literal"><span class="pre">varhigher</span></code> or <code class="docutils literal"><span class="pre">varlower</span></code> are used, it is quite possible to end up
with different variables (with different priorities) printed in the same
way: they will then appear multiple times in the output:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? y1 = varhigher(&quot;y&quot;);
? y2 = varlower(&quot;y&quot;);
? variables(y*y1*y2)
%4 = [y, y, y]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.vecextract">
<code class="descname">vecextract</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.vecextract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extraction of components of the vector or matrix <span class="math">\(x\)</span> according to <span class="math">\(y\)</span>.
In case <span class="math">\(x\)</span> is a matrix, its components are the <em>columns</em> of <span class="math">\(x\)</span>. The
parameter <span class="math">\(y\)</span> is a component specifier, which is either an integer, a string
describing a range, or a vector.</p>
<p>If <span class="math">\(y\)</span> is an integer, it is considered as a mask: the binary bits of <span class="math">\(y\)</span> are
read from right to left, but correspond to taking the components from left to
right. For example, if <span class="math">\(y = 13 = (1101)_2\)</span> then the components 1,3 and 4 are
extracted.</p>
<p>If <span class="math">\(y\)</span> is a vector (<code class="docutils literal"><span class="pre">t_VEC</span></code>, <code class="docutils literal"><span class="pre">t_COL</span></code> or <code class="docutils literal"><span class="pre">t_VECSMALL</span></code>), which must have
integer entries, these entries correspond to the component numbers to be
extracted, in the order specified.</p>
<p>If <span class="math">\(y\)</span> is a string, it can be</p>
<ul class="simple">
<li>a single (non-zero) index giving a component number (a negative
index means we start counting from the end).</li>
<li>a range of the form <code class="docutils literal"><span class="pre">&quot;:math:`a</span></code>..:math:<span class="math">\(b\)</span>&#8220;<span class="math">\(, where :math:`a\)</span> and <span class="math">\(b\)</span> are
indexes as above. Any of <span class="math">\(a\)</span> and <span class="math">\(b\)</span> can be omitted; in this case, we take
as default values <span class="math">\(a = 1\)</span> and <span class="math">\(b = -1\)</span>, i.e.&nbsp;the first and last components
respectively. We then extract all components in the interval <span class="math">\([a,b]\)</span>, in
reverse order if <span class="math">\(b &lt; a\)</span>.</li>
</ul>
<p>In addition, if the first character in the string is <code class="docutils literal"><span class="pre">^</span></code>, the
complement of the given set of indices is taken.</p>
<p>If <span class="math">\(z\)</span> is not omitted, <span class="math">\(x\)</span> must be a matrix. <span class="math">\(y\)</span> is then the <em>row</em>
specifier, and <span class="math">\(z\)</span> the <em>column</em> specifier, where the component specifier
is as explained above.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? v = [a, b, c, d, e];
? vecextract(v, 5) \\ mask
%1 = [a, c]
? vecextract(v, [4, 2, 1]) \\ component list
%2 = [d, b, a]
? vecextract(v, &quot;2..4&quot;) \\ interval
%3 = [b, c, d]
? vecextract(v, &quot;-1..-3&quot;) \\ interval + reverse order
%4 = [e, d, c]
? vecextract(v, &quot;^2&quot;) \\ complement
%5 = [a, c, d, e]
? vecextract(matid(3), &quot;2..&quot;, &quot;..&quot;)
%6 =
[0 1 0]

[0 0 1]
</pre></div>
</div>
<p>The range notations <code class="docutils literal"><span class="pre">v[i..j]</span></code> and <code class="docutils literal"><span class="pre">v[^i]</span></code> (for <code class="docutils literal"><span class="pre">t_VEC</span></code> or
<code class="docutils literal"><span class="pre">t_COL</span></code>) and <code class="docutils literal"><span class="pre">M[i..j,</span> <span class="pre">k..l]</span></code> and friends (for <code class="docutils literal"><span class="pre">t_MAT</span></code>) implement a
subset of the above, in a simpler and <em>faster</em> way, hence should be
preferred in most common situations. The following features are not
implemented in the range notation:</p>
<ul class="simple">
<li>reverse order,</li>
<li>omitting either <span class="math">\(a\)</span> or <span class="math">\(b\)</span> in <code class="docutils literal"><span class="pre">:math:`a</span></code>..:math:<span class="math">\(b`\)</span>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.vecsearch">
<code class="descname">vecsearch</code><span class="sig-paren">(</span><em>v</em>, <em>x</em>, <em>cmpf=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.vecsearch" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether <span class="math">\(x\)</span> belongs to the sorted vector or list <span class="math">\(v\)</span>: return
the (positive) index where <span class="math">\(x\)</span> was found, or <span class="math">\(0\)</span> if it does not belong to
<span class="math">\(v\)</span>.</p>
<p>If the comparison function cmpf is omitted, we assume that <span class="math">\(v\)</span> is sorted in
increasing order, according to the standard comparison function <code class="docutils literal"><span class="pre">lex</span></code>,
thereby restricting the possible types for <span class="math">\(x\)</span> and the elements of <span class="math">\(v\)</span>
(integers, fractions, reals, and vectors of such).</p>
<p>If <code class="docutils literal"><span class="pre">cmpf</span></code> is present, it is understood as a comparison function and we
assume that <span class="math">\(v\)</span> is sorted according to it, see <code class="docutils literal"><span class="pre">vecsort</span></code> for how to
encode comparison functions.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? v = [1,3,4,5,7];
? vecsearch(v, 3)
%2 = 2
? vecsearch(v, 6)
%3 = 0 \\ not in the list
? vecsearch([7,6,5], 5) \\ unsorted vector: result undefined
%4 = 0
</pre></div>
</div>
<p>By abuse of notation, <span class="math">\(x\)</span> is also allowed to be a matrix, seen as a vector
of its columns; again by abuse of notation, a <code class="docutils literal"><span class="pre">t_VEC</span></code> is considered
as part of the matrix, if its transpose is one of the matrix columns.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? v = vecsort([3,0,2; 1,0,2]) \\ sort matrix columns according to lex order
%1 =
[0 2 3]

[0 2 1]
? vecsearch(v, [3,1]~)
%2 = 3
? vecsearch(v, [3,1]) \\ can search for x or x~
%3 = 3
? vecsearch(v, [1,2])
%4 = 0 \\ not in the list
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.vecsort">
<code class="descname">vecsort</code><span class="sig-paren">(</span><em>x</em>, <em>cmpf=None</em>, <em>flag=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.vecsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the vector <span class="math">\(x\)</span> in ascending order, using a mergesort method.
<span class="math">\(x\)</span> must be a list, vector or matrix (seen as a vector of its columns).
Note that mergesort is stable, hence the initial ordering of &#8220;equal&#8221;
entries (with respect to the sorting criterion) is not changed.</p>
<p>If <code class="docutils literal"><span class="pre">cmpf</span></code> is omitted, we use the standard comparison function
<code class="docutils literal"><span class="pre">lex</span></code>, thereby restricting the possible types for the elements of <span class="math">\(x\)</span>
(integers, fractions or reals and vectors of those). If <code class="docutils literal"><span class="pre">cmpf</span></code> is
present, it is understood as a comparison function and we sort according to
it. The following possibilities exist:</p>
<ul class="simple">
<li>an integer <span class="math">\(k\)</span>: sort according to the value of the <span class="math">\(k\)</span>-th
subcomponents of the components of&nbsp;<span class="math">\(x\)</span>.</li>
<li>a vector: sort lexicographically according to the components listed in
the vector. For example, if <span class="math">\(cmpf = [2,1,3]\)</span>, sort with respect to
the second component, and when these are equal, with respect to the first,
and when these are equal, with respect to the third.</li>
<li>a comparison function (<code class="docutils literal"><span class="pre">t_CLOSURE</span></code>), with two arguments <span class="math">\(x\)</span> and <span class="math">\(y\)</span>,
and returning an integer which is <span class="math">\(&lt; 0\)</span>, <span class="math">\(&gt; 0\)</span> or <span class="math">\(= 0\)</span> if <span class="math">\(x &lt; y\)</span>, <span class="math">\(x &gt; y\)</span> or
<span class="math">\(x = y\)</span> respectively. The <code class="docutils literal"><span class="pre">sign</span></code> function is very useful in this context:</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? vecsort([3,0,2; 1,0,2]) \\ sort columns according to lex order
%1 =
[0 2 3]

[0 2 1]
? vecsort(v, (x,y)-&gt;sign(y-x)) \\ reverse sort
? vecsort(v, (x,y)-&gt;sign(abs(x)-abs(y))) \\ sort by increasing absolute value
? cmpf(x,y) = my(dx = poldisc(x), dy = poldisc(y)); sign(abs(dx) - abs(dy))
? vecsort([x^2+1, x^3-2, x^4+5*x+1], cmpf)
</pre></div>
</div>
<p>The last example used the named <code class="docutils literal"><span class="pre">cmpf</span></code> instead of an anonymous function,
and sorts polynomials with respect to the absolute value of their
discriminant. A more efficient approach would use precomputations to ensure
a given discriminant is computed only once:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? DISC = vector(#v, i, abs(poldisc(v[i])));
? perm = vecsort(vector(#v,i,i), (x,y)-&gt;sign(DISC[x]-DISC[y]))
? vecextract(v, perm)
</pre></div>
</div>
<p>Similar ideas apply whenever we sort according to the values
of a function which is expensive to compute.</p>
<p>The binary digits of <em>flag</em> mean:</p>
<ul class="simple">
<li>1: indirect sorting of the vector <span class="math">\(x\)</span>, i.e.&nbsp;if <span class="math">\(x\)</span> is an
<span class="math">\(n\)</span>-component vector, returns a permutation of <span class="math">\([1,2,...,n]\)</span> which
applied to the components of <span class="math">\(x\)</span> sorts <span class="math">\(x\)</span> in increasing order.
For example, <code class="docutils literal"><span class="pre">vecextract(x,</span> <span class="pre">vecsort(x,,1))</span></code> is equivalent to
<code class="docutils literal"><span class="pre">vecsort(x)</span></code>.</li>
<li>4: use descending instead of ascending order.</li>
<li>8: remove &#8220;duplicate&#8221; entries with respect to the sorting function
(keep the first occurring entry). For example:</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? vecsort([Pi,Mod(1,2),z], (x,y)-&gt;0, 8) \\ make everything compare equal
%1 = [3.141592653589793238462643383]
? vecsort([[2,3],[0,1],[0,3]], 2, 8)
%2 = [[0, 1], [2, 3]]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.vecsum">
<code class="descname">vecsum</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.vecsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of the components of the vector <span class="math">\(v\)</span>. Return <span class="math">\(0\)</span> on an
empty vector.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? vecsum([1,2,3])
%1 = 6
? vecsum([])
%2 = 0
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.weber">
<code class="descname">weber</code><span class="sig-paren">(</span><em>x</em>, <em>flag=0</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.weber" title="Permalink to this definition">¶</a></dt>
<dd><p>One of Weber&#8217;s three <span class="math">\(f\)</span> functions.
If <span class="math">\(flag = 0\)</span>, returns</p>
<div class="math">
\[f(x) = \exp(-i\Pi/24).\eta((x+1)/2)/\eta(x) {such that} 
j = (f^{24}-16)^3/f^{24},\]</div>
<p>where <span class="math">\(j\)</span> is the elliptic <span class="math">\(j\)</span>-invariant (see the function <code class="docutils literal"><span class="pre">ellj</span></code>).
If <span class="math">\(flag = 1\)</span>, returns</p>
<div class="math">
\[f_1(x) = \eta(x/2)/\eta(x) {such that} 
j = (f_1^{24}+16)^3/f_1^{24}.\]</div>
<p>Finally, if <span class="math">\(flag = 2\)</span>, returns</p>
<div class="math">
\[f_2(x) = \sqrt{2}\eta(2x)/\eta(x) {such that} 
j = (f_2^{24}+16)^3/f_2^{24}.\]</div>
<p>Note the identities <span class="math">\(f^8 = f_1^8+f_2^8\)</span> and <span class="math">\(ff_1f_2 = \sqrt2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.zeta">
<code class="descname">zeta</code><span class="sig-paren">(</span><em>s</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.zeta" title="Permalink to this definition">¶</a></dt>
<dd><p>For <span class="math">\(s\)</span> a complex number, Riemann&#8217;s zeta
function <span class="math">\(\zeta(s) = \sum_{n &gt;= 1}n^{-s}\)</span>,
computed using the Euler-Maclaurin summation formula, except
when <span class="math">\(s\)</span> is of type integer, in which case it is computed using
Bernoulli numbers for <span class="math">\(s &lt;= 0\)</span> or <span class="math">\(s &gt; 0\)</span> and
even, and using modular forms for <span class="math">\(s &gt; 0\)</span> and odd.</p>
<p>For <span class="math">\(s\)</span> a <span class="math">\(p\)</span>-adic number, Kubota-Leopoldt zeta function at <span class="math">\(s\)</span>, that
is the unique continuous <span class="math">\(p\)</span>-adic function on the <span class="math">\(p\)</span>-adic integers
that interpolates the values of <span class="math">\((1 - p^{-k}) \zeta(k)\)</span> at negative
integers <span class="math">\(k\)</span> such that <span class="math">\(k = 1 (mod p-1)\)</span> (resp. <span class="math">\(k\)</span> is odd) if
<span class="math">\(p\)</span> is odd (resp. <span class="math">\(p = 2\)</span>).</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.zetamult">
<code class="descname">zetamult</code><span class="sig-paren">(</span><em>s</em>, <em>precision=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.zetamult" title="Permalink to this definition">¶</a></dt>
<dd><p>For <span class="math">\(s\)</span> a vector of positive integers such that <span class="math">\(s[1] &gt;= 2\)</span>,
returns the multiple zeta value (MZV)</p>
<div class="math">
\[\zeta(s_1,..., s_k) = \sum_{n_1 &gt; ... &gt; n_k &gt; 0} n_1^{-s_1}...n_k^{-s_k}.\]</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>? zetamult([2,1]) - zeta(3) \\ Euler&#39;s identity
%1 = 0.E-38
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.zncharinduce">
<code class="descname">zncharinduce</code><span class="sig-paren">(</span><em>G</em>, <em>chi</em>, <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.zncharinduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(G\)</span> be associated to <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span> (as per \kbd{G = 
idealstar(,q)}) and let <code class="docutils literal"><span class="pre">chi</span></code> be a Dirichlet character on <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span>,
given by</p>
<ul class="simple">
<li>a <code class="docutils literal"><span class="pre">t_VEC</span></code>: a standard character on <code class="docutils literal"><span class="pre">bid.gen</span></code>,</li>
<li>a <code class="docutils literal"><span class="pre">t_INT</span></code> or a <code class="docutils literal"><span class="pre">t_COL</span></code>: a Conrey index in <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span> or its
Conrey logarithm;
see <code class="docutils literal"><span class="pre">dirichletchar</span></code> (in the PARI manual) or <code class="docutils literal"><span class="pre">??character</span></code>.</li>
</ul>
<p>Let <span class="math">\(N\)</span> be a multiple of <span class="math">\(q\)</span>, return the character modulo <span class="math">\(N\)</span> induced by
<code class="docutils literal"><span class="pre">chi</span></code>. As usual for arithmetic functions, the new modulus <span class="math">\(N\)</span> can be
given as a <code class="docutils literal"><span class="pre">t_INT</span></code>, via a factorization matrix or a pair \kbd{[N,
factor(N)]}, or by <code class="docutils literal"><span class="pre">idealstar(,N)</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = idealstar(,4);
? chi = znconreylog(G,1); \\ trivial character mod 4
? zncharinduce(G, chi, 80) \\ now mod 80
%3 = [0, 0, 0]~
? zncharinduce(G, 1, 80) \\ same using directly Conrey label
%4 = [0, 0, 0]~
? G2 = idealstar(,80);
? zncharinduce(G, 1, G2) \\ same
%4 = [0, 0, 0]~

? chi = zncharinduce(G, 3, G2) \\ induce the non-trivial character mod 4
%5 = [1, 0, 0]~
? znconreyconductor(G2, chi, &amp;chi0)
%6 = [4, Mat([2, 2])]
? chi0
%7 = [1]~
</pre></div>
</div>
<p>Here is a larger example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = idealstar(,126000);
? label = 1009;
? chi = znconreylog(G, label)
%3 = [0, 0, 0, 14, 0]~
? N0 = znconreyconductor(G, label, &amp;chi0)
%4 = [125, Mat([5, 3])]
? chi0 \\ primitive character mod 5^3 attached to chi
%5 = [14]~
? G0 = idealstar(,N0);
? zncharinduce(G0, chi0, G) \\ induce back
%7 = [0, 0, 0, 14, 0]~
? znconreyexp(G, %)
%8 = 1009
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.zncharisodd">
<code class="descname">zncharisodd</code><span class="sig-paren">(</span><em>G</em>, <em>chi</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.zncharisodd" title="Permalink to this definition">¶</a></dt>
<dd><p>Let <span class="math">\(G\)</span> be associated to <span class="math">\((\mathbb{Z}/N\mathbb{Z})^*\)</span> (as per \kbd{G = 
idealstar(,N)}) and let <code class="docutils literal"><span class="pre">chi</span></code> be a Dirichlet character on <span class="math">\((\mathbb{Z}/N\mathbb{Z})^*\)</span>,
given by</p>
<ul class="simple">
<li>a <code class="docutils literal"><span class="pre">t_VEC</span></code>: a standard character on <code class="docutils literal"><span class="pre">bid.gen</span></code>,</li>
<li>a <code class="docutils literal"><span class="pre">t_INT</span></code> or a <code class="docutils literal"><span class="pre">t_COL</span></code>: a Conrey index in <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span> or its
Conrey logarithm;
see <code class="docutils literal"><span class="pre">dirichletchar</span></code> (in the PARI manual) or <code class="docutils literal"><span class="pre">??character</span></code>.</li>
</ul>
<p>Return <span class="math">\(1\)</span> if and only if <code class="docutils literal"><span class="pre">chi</span></code><span class="math">\((-1) = -1\)</span> and <span class="math">\(0\)</span> otherwise.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = idealstar(,8);
? zncharisodd(G, 1) \\ trivial character
%2 = 0
? zncharisodd(G, 3)
%3 = 1
? chareval(G, 3, -1)
%4 = 1/2
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.znconreychar">
<code class="descname">znconreychar</code><span class="sig-paren">(</span><em>bid</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.znconreychar" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a <em>bid</em> associated to <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span> (as per
<code class="docutils literal"><span class="pre">bid</span> <span class="pre">=</span> <span class="pre">idealstar(,q)</span></code>), this function returns the Dirichlet character
associated to <span class="math">\(m belongs to (\mathbb{Z}/q\mathbb{Z})^*\)</span> via Conrey&#8217;s logarithm, which
establishes a &#8220;canonical&#8221; bijection between <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span> and its dual.</p>
<p>Let <span class="math">\(q = \prod_p p^{e_p}\)</span> be the factorization of <span class="math">\(q\)</span> into distinct primes.
For all odd <span class="math">\(p\)</span> with <span class="math">\(e_p &gt; 0\)</span>, let <span class="math">\(g_p\)</span> be the element in <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span>
which is</p>
<ul class="simple">
<li>congruent to <span class="math">\(1\)</span> mod <span class="math">\(q/p^{e_p}\)</span>,</li>
<li>congruent mod <span class="math">\(p^{e_p}\)</span> to the smallest integer whose order
is <span class="math">\(\phi(p^{e_p})\)</span>.</li>
</ul>
<p>For <span class="math">\(p = 2\)</span>, we let <span class="math">\(g_4\)</span> (if <span class="math">\(2^{e_2} &gt;= 4\)</span>) and <span class="math">\(g_8\)</span> (if furthermore
(<span class="math">\(2^{e_2} &gt;= 8\)</span>) be the elements in <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span> which
are</p>
<ul class="simple">
<li>congruent to <span class="math">\(1\)</span> mod <span class="math">\(q/2^{e_2}\)</span>,</li>
<li><span class="math">\(g_4 = -1 mod 2^{e_2}\)</span>,</li>
<li><span class="math">\(g_8 = 5 mod 2^{e_2}\)</span>.</li>
</ul>
<p>Then the <span class="math">\(g_p\)</span> (and the extra <span class="math">\(g_4\)</span> and <span class="math">\(g_8\)</span> if <span class="math">\(2^{e_2} &gt;= 2\)</span>) are
independent
generators of <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span>, i.e. every <span class="math">\(m\)</span> in <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span> can be written
uniquely as <span class="math">\(\prod_p g_p^{m_p}\)</span>, where <span class="math">\(m_p\)</span> is defined modulo the order
<span class="math">\(o_p\)</span> of <span class="math">\(g_p\)</span>
and <span class="math">\(p belongs to S_q\)</span>, the set of prime divisors of <span class="math">\(q\)</span> together with <span class="math">\(4\)</span>
if <span class="math">\(4 \| q\)</span> and <span class="math">\(8\)</span> if <span class="math">\(8 \| q\)</span>. Note that the <span class="math">\(g_p\)</span> are in general
<em>not</em> SNF
generators as produced by <code class="docutils literal"><span class="pre">znstar</span></code> or <code class="docutils literal"><span class="pre">idealstar</span></code> whenever
<span class="math">\(\omega(q) &gt;= 2\)</span>, although their number is the same. They however allow
to handle the finite abelian group <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span> in a fast and elegant
way. (Which unfortunately does not generalize to ray class groups or Hecke
characters.)</p>
<p>The Conrey logarithm of <span class="math">\(m\)</span> is the vector <span class="math">\((m_p)_{p belongs to S_q}\)</span>, obtained
via <code class="docutils literal"><span class="pre">znconreylog</span></code>. The Conrey character <span class="math">\(\chi_q(m,.)\)</span> associated to
<span class="math">\(m\)</span> mod <span class="math">\(q\)</span> maps
each <span class="math">\(g_p\)</span>, <span class="math">\(p belongs to S_q\)</span> to <span class="math">\(e(m_p / o_p)\)</span>, where <span class="math">\(e(x) = \exp(2i\Pi x)\)</span>.
This function returns the Conrey character expressed in the standard PARI
way in terms of the SNF generators <code class="docutils literal"><span class="pre">bid.gen</span></code>.</p>
<p><strong>Note.</strong> It is useless to include the generators
in the <em>bid</em>, except for debugging purposes: they are well defined from
elementary matrix operations and Chinese remaindering, their explicit value
as elements in <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span> is never used.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = idealstar(,8,2); /*add generators for debugging:*/
? G.cyc
%2 = [2, 2] \\ Z/2 x Z/2
? G.gen
%3 = [7, 3]
? znconreychar(G,1) \\ 1 is always the trivial character
%4 = [0, 0]
? znconreychar(G,2) \\ 2 is not coprime to 8 !!!
 *** at top-level: znconreychar(G,2)
 *** ^-----------------
 *** znconreychar: elements not coprime in Zideallog:
 2
 8
 *** Break loop: type &#39;break&#39; to go back to GP prompt
break&gt;

? znconreychar(G,3)
%5 = [0, 1]
? znconreychar(G,5)
%6 = [1, 1]
? znconreychar(G,7)
%7 = [1, 0]
</pre></div>
</div>
<p>We indeed get all 4 characters of <span class="math">\((\mathbb{Z}/8\mathbb{Z})^*\)</span>.</p>
<p>For convenience, we allow to input the <em>Conrey logarithm</em> of <span class="math">\(m\)</span>
instead of <span class="math">\(m\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = idealstar(,55);
? znconreychar(G,7)
%2 = [7, 0]
? znconreychar(G, znconreylog(G,7))
%3 = [7, 0]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.znconreyexp">
<code class="descname">znconreyexp</code><span class="sig-paren">(</span><em>bid</em>, <em>chi</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.znconreyexp" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a <em>bid</em> associated to <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span> (as per \kbd{bid = 
idealstar(,q)}), this function returns the Conrey exponential of
the character <em>chi</em>: it returns the integer
<span class="math">\(m belongs to (\mathbb{Z}/q\mathbb{Z})^*\)</span> such that <code class="docutils literal"><span class="pre">znconreylog(:emphasis:`bid</span></code>, <span class="math">\(m\)</span>)` is <em>chi</em>.</p>
<p>The character <em>chi</em> is given either as a</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">t_VEC</span></code>: in terms of the generators <code class="docutils literal"><span class="pre">:emphasis:`bid</span></code>.gen`;</li>
<li><code class="docutils literal"><span class="pre">t_COL</span></code>: a Conrey logarithm.</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = idealstar(,126000)
? znconreylog(G,1)
%2 = [0, 0, 0, 0, 0]~
? znconreyexp(G,%)
%3 = 1
? G.cyc \\ SNF generators
%4 = [300, 12, 2, 2, 2]
? chi = [100, 1, 0, 1, 0]; \\ some random character on SNF generators
? znconreylog(G, chi) \\ in terms of Conrey generators
%6 = [0, 3, 3, 0, 2]~
? znconreyexp(G, %) \\ apply to a Conrey log
%7 = 18251
? znconreyexp(G, chi) \\ ... or a char on SNF generators
%8 = 18251
? znconreychar(G,%)
%9 = [100, 1, 0, 1, 0]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.znconreylog">
<code class="descname">znconreylog</code><span class="sig-paren">(</span><em>bid</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.znconreylog" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a <em>bid</em> associated to <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span> (as per \kbd{bid = 
idealstar(,q)}), this function returns the Conrey logarithm of
<span class="math">\(m belongs to (\mathbb{Z}/q\mathbb{Z})^*\)</span>.</p>
<p>Let <span class="math">\(q = \prod_p p^{e_p}\)</span> be the factorization of <span class="math">\(q\)</span> into distinct primes,
where we assume <span class="math">\(e_2 = 0\)</span> or <span class="math">\(e_2 &gt;= 2\)</span>. (If <span class="math">\(e_2 = 1\)</span>, we can ignore <span class="math">\(2\)</span>
from the factorization, as if we replaced <span class="math">\(q\)</span> by <span class="math">\(q/2\)</span>, since <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*
~ (\mathbb{Z}/(q/2)\mathbb{Z})^*\)</span>.)</p>
<p>For all odd <span class="math">\(p\)</span> with <span class="math">\(e_p &gt; 0\)</span>, let <span class="math">\(g_p\)</span> be the element in <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span>
which is</p>
<ul class="simple">
<li>congruent to <span class="math">\(1\)</span> mod <span class="math">\(q/p^{e_p}\)</span>,</li>
<li>congruent mod <span class="math">\(p^{e_p}\)</span> to the smallest integer whose order
is <span class="math">\(\phi(p^{e_p})\)</span> for <span class="math">\(p\)</span> odd,</li>
</ul>
<p>For <span class="math">\(p = 2\)</span>, we let <span class="math">\(g_4\)</span> (if <span class="math">\(2^{e_2} &gt;= 4\)</span>) and <span class="math">\(g_8\)</span> (if furthermore
(<span class="math">\(2^{e_2} &gt;= 8\)</span>) be the elements in <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span> which
are</p>
<ul class="simple">
<li>congruent to <span class="math">\(1\)</span> mod <span class="math">\(q/2^{e_2}\)</span>,</li>
<li><span class="math">\(g_4 = -1 mod 2^{e_2}\)</span>,</li>
<li><span class="math">\(g_8 = 5 mod 2^{e_2}\)</span>.</li>
</ul>
<p>Then the <span class="math">\(g_p\)</span> (and the extra <span class="math">\(g_4\)</span> and <span class="math">\(g_8\)</span> if <span class="math">\(2^{e_2} &gt;= 2\)</span>) are
independent
generators of <span class="math">\(\mathbb{Z}/q\mathbb{Z}^*\)</span>, i.e. every <span class="math">\(m\)</span> in <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span> can be written
uniquely as <span class="math">\(\prod_p g_p^{m_p}\)</span>, where <span class="math">\(m_p\)</span> is defined modulo the
order <span class="math">\(o_p\)</span> of <span class="math">\(g_p\)</span>
and <span class="math">\(p belongs to S_q\)</span>, the set of prime divisors of <span class="math">\(q\)</span> together with <span class="math">\(4\)</span>
if <span class="math">\(4 \| q\)</span> and <span class="math">\(8\)</span> if <span class="math">\(8 \| q\)</span>.
Note that the <span class="math">\(g_p\)</span> are in general <em>not</em> SNF
generators as produced by <code class="docutils literal"><span class="pre">znstar</span></code> or <code class="docutils literal"><span class="pre">idealstar</span></code> whenever
<span class="math">\(\omega(q) &gt;= 2\)</span>, although their number is the same. They however allow
to handle the finite abelian group <span class="math">\((\mathbb{Z}/q\mathbb{Z})^*\)</span> in a fast and elegant
way. (Which unfortunately does not generalize to ray class groups or Hecke
characters.)</p>
<p>The Conrey logarithm of <span class="math">\(m\)</span> is the vector <span class="math">\((m_p)_{p belongs to S_q}\)</span>. The inverse
function <code class="docutils literal"><span class="pre">znconreyexp</span></code> recovers the Conrey label <span class="math">\(m\)</span> from a character.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = idealstar(,126000);
? znconreylog(G,1)
%2 = [0, 0, 0, 0, 0]~
? znconreyexp(G, %)
%3 = 1
? znconreylog(G,2) \\ 2 is not coprime to modulus !!!
 *** at top-level: znconreylog(G,2)
 *** ^-----------------
 *** znconreylog: elements not coprime in Zideallog:
 2
 126000
 *** Break loop: type &#39;break&#39; to go back to GP prompt
break&gt;
? znconreylog(G,11) \\ wrt. Conrey generators
%4 = [0, 3, 1, 76, 4]~
? log11 = ideallog(,11,G) \\ wrt. SNF generators
%5 = [178, 3, -75, 1, 0]~
</pre></div>
</div>
<p>For convenience, we allow to input the ordinary discrete log of <span class="math">\(m\)</span>,
<span class="math">\(ideallog(,m,bid)\)</span>, which allows to convert discrete logs
from <code class="docutils literal"><span class="pre">bid.gen</span></code> generators to Conrey generators.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? znconreylog(G, log11)
%7 = [0, 3, 1, 76, 4]~
</pre></div>
</div>
<p>We also allow a character (<code class="docutils literal"><span class="pre">t_VEC</span></code>) on <code class="docutils literal"><span class="pre">bid.gen</span></code> and
return its representation on the Conrey generators.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G.cyc
%8 = [300, 12, 2, 2, 2]
? chi = [10,1,0,1,1];
? znconreylog(G, chi)
%10 = [1, 3, 3, 10, 2]~
? n = znconreyexp(G, chi)
%11 = 84149
? znconreychar(G, n)
%12 = [10, 1, 0, 1, 1]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.zncoppersmith">
<code class="descname">zncoppersmith</code><span class="sig-paren">(</span><em>P</em>, <em>N</em>, <em>X</em>, <em>B=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.zncoppersmith" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(N\)</span> being an integer and <span class="math">\(P belongs to \mathbb{Z}[X]\)</span>, finds all integers <span class="math">\(x\)</span> with
<span class="math">\(\|x\| &lt;= X\)</span> such that</p>
<div class="math">
\[\mathrm{gcd}(N, P(x)) &gt;= B,\]</div>
<p>using Coppersmith&#8217;s algorithm (a famous application of the LLL
algorithm). <span class="math">\(X\)</span> must be smaller than <span class="math">\(\exp(\log^2 B / (\deg(P) \log N))\)</span>:
for <span class="math">\(B = N\)</span>, this means <span class="math">\(X &lt; N^{1/\deg(P)}\)</span>. Some <span class="math">\(x\)</span> larger than <span class="math">\(X\)</span> may
be returned if you are very lucky. The smaller <span class="math">\(B\)</span> (or the larger <span class="math">\(X\)</span>), the
slower the routine will be. The strength of Coppersmith method is the
ability to find roots modulo a general <em>composite</em> <span class="math">\(N\)</span>: if <span class="math">\(N\)</span> is a prime
or a prime power, <code class="docutils literal"><span class="pre">polrootsmod</span></code> or <code class="docutils literal"><span class="pre">polrootspadic</span></code> will be much
faster.</p>
<p>We shall now present two simple applications. The first one is
finding non-trivial factors of <span class="math">\(N\)</span>, given some partial information on the
factors; in that case <span class="math">\(B\)</span> must obviously be smaller than the largest
non-trivial divisor of <span class="math">\(N\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>setrand(1); \\ to make the example reproducible
interval = [10^30, 10^31];
p = randomprime(interval);
q = randomprime(interval); N = p*q;
p0 = p % 10^20; \\ assume we know 1) p &gt; 10^29, 2) the last 19 digits of p
L = zncoppersmith(10^19*x + p0, N, 10^12, 10^29)

\\ result in 10ms.
%6 = [738281386540]
? gcd(L[1] * 10^19 + p0, N) == p
%7 = 1
</pre></div>
</div>
<p>and we recovered <span class="math">\(p\)</span>, faster than by trying all
possibilities <span class="math">\(&lt; 10^{12}\)</span>.</p>
<p>The second application is an attack on RSA with low exponent, when the
message <span class="math">\(x\)</span> is short and the padding <span class="math">\(P\)</span> is known to the attacker. We use
the same RSA modulus <span class="math">\(N\)</span> as in the first example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>setrand(1);
P = random(N); \\ known padding
e = 3; \\ small public encryption exponent
X = floor(N^0.3); \\ N^(1/e - epsilon)
x0 = random(X); \\ unknown short message
C = lift( (Mod(x0,N) + P)^e ); \\ known ciphertext, with padding P
zncoppersmith((P + x)^3 - C, N, X)

\\ result in 244ms.
%14 = [2679982004001230401]

? %[1] == x0
%15 = 1
</pre></div>
</div>
<p>We guessed an integer of the order of <span class="math">\(10^{18}\)</span>, almost instantly.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.znlog">
<code class="descname">znlog</code><span class="sig-paren">(</span><em>x</em>, <em>g</em>, <em>o=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.znlog" title="Permalink to this definition">¶</a></dt>
<dd><p>Discrete logarithm of <span class="math">\(x\)</span> in <span class="math">\((\mathbb{Z}/N\mathbb{Z})^*\)</span> in base <span class="math">\(g\)</span>.
The result is <span class="math">\([]\)</span> when <span class="math">\(x\)</span> is not a power of <span class="math">\(g\)</span>.
If present, <span class="math">\(o\)</span> represents the multiplicative order of <span class="math">\(g\)</span>, see
<code class="docutils literal"><span class="pre">DLfun</span></code> (in the PARI manual); the preferred format for this parameter is
<code class="docutils literal"><span class="pre">[ord,</span> <span class="pre">factor(ord)]</span></code>, where <code class="docutils literal"><span class="pre">ord</span></code> is the order of <span class="math">\(g\)</span>.
This provides a definite speedup when the discrete log problem is simple:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? p = nextprime(10^4); g = znprimroot(p); o = [p-1, factor(p-1)];
? for(i=1,10^4, znlog(i, g, o))
time = 205 ms.
? for(i=1,10^4, znlog(i, g))
time = 244 ms. \\ a little slower
</pre></div>
</div>
<p>The result is undefined if <span class="math">\(g\)</span> is not invertible mod <span class="math">\(N\)</span> or if the supplied
order is incorrect.</p>
<p>This function uses</p>
<ul class="simple">
<li>a combination of generic discrete log algorithms (see below).</li>
<li>in <span class="math">\((\mathbb{Z}/N\mathbb{Z})^*\)</span> when <span class="math">\(N\)</span> is prime: a linear sieve index calculus
method, suitable for <span class="math">\(N &lt; 10^{50}\)</span>, say, is used for large prime divisors of
the order.</li>
</ul>
<p>The generic discrete log algorithms are:</p>
<ul class="simple">
<li>Pohlig-Hellman algorithm, to reduce to groups of prime order <span class="math">\(q\)</span>,
where <span class="math">\(q | p-1\)</span> and <span class="math">\(p\)</span> is an odd prime divisor of <span class="math">\(N\)</span>,</li>
<li>Shanks baby-step/giant-step (<span class="math">\(q &lt; 2^{32}\)</span> is small),</li>
<li>Pollard rho method (<span class="math">\(q &gt; 2^{32}\)</span>).</li>
</ul>
<p>The latter two algorithms require <span class="math">\(O(\sqrt{q})\)</span> operations in the group on
average, hence will not be able to treat cases where <span class="math">\(q &gt; 10^{30}\)</span>, say.
In addition, Pollard rho is not able to handle the case where there are no
solutions: it will enter an infinite loop.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? g = znprimroot(101)
%1 = Mod(2,101)
? znlog(5, g)
%2 = 24
? g^24
%3 = Mod(5, 101)

? G = znprimroot(2 * 101^10)
%4 = Mod(110462212541120451003, 220924425082240902002)
? znlog(5, G)
%5 = 76210072736547066624
? G^% == 5
%6 = 1
? N = 2^4*3^2*5^3*7^4*11; g = Mod(13, N); znlog(g^110, g)
%7 = 110
? znlog(6, Mod(2,3)) \\ no solution
%8 = []
</pre></div>
</div>
<p>For convenience, <span class="math">\(g\)</span> is also allowed to be a <span class="math">\(p\)</span>-adic number:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? g = 3+O(5^10); znlog(2, g)
%1 = 1015243
? g^%
%2 = 2 + O(5^10)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.znorder">
<code class="descname">znorder</code><span class="sig-paren">(</span><em>x</em>, <em>o=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.znorder" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math">\(x\)</span> must be an integer mod <span class="math">\(n\)</span>, and the
result is the order of <span class="math">\(x\)</span> in the multiplicative group <span class="math">\((\mathbb{Z}/n\mathbb{Z})^*\)</span>. Returns
an error if <span class="math">\(x\)</span> is not invertible.
The parameter o, if present, represents a non-zero
multiple of the order of <span class="math">\(x\)</span>, see <code class="docutils literal"><span class="pre">DLfun</span></code> (in the PARI manual); the preferred format for
this parameter is <code class="docutils literal"><span class="pre">[ord,</span> <span class="pre">factor(ord)]</span></code>, where <code class="docutils literal"><span class="pre">ord</span> <span class="pre">=</span> <span class="pre">eulerphi(n)</span></code>
is the cardinality of the group.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.znprimroot">
<code class="descname">znprimroot</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.znprimroot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a primitive root (generator) of <span class="math">\((\mathbb{Z}/n\mathbb{Z})^*\)</span>, whenever this
latter group is cyclic (<span class="math">\(n = 4\)</span> or <span class="math">\(n = 2p^k\)</span> or <span class="math">\(n = p^k\)</span>, where <span class="math">\(p\)</span> is an
odd prime and <span class="math">\(k &gt;= 0\)</span>). If the group is not cyclic, the result is
undefined. If <span class="math">\(n\)</span> is a prime power, then the smallest positive primitive
root is returned. This may not be true for <span class="math">\(n = 2p^k\)</span>, <span class="math">\(p\)</span> odd.</p>
<p>Note that this function requires factoring <span class="math">\(p-1\)</span> for <span class="math">\(p\)</span> as above,
in order to determine the exact order of elements in
<span class="math">\((\mathbb{Z}/n\mathbb{Z})^*\)</span>: this is likely to be costly if <span class="math">\(p\)</span> is large.</p>
</dd></dl>

<dl class="method">
<dt id="sage.libs.pari.gen.gen_auto.znstar">
<code class="descname">znstar</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gen_auto.znstar" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the structure of the multiplicative group
<span class="math">\((\mathbb{Z}/n\mathbb{Z})^*\)</span> as a 3-component row vector <span class="math">\(v\)</span>, where <span class="math">\(v[1] = \phi(n)\)</span> is the
order of that group, <span class="math">\(v[2]\)</span> is a <span class="math">\(k\)</span>-component row-vector <span class="math">\(d\)</span> of integers
<span class="math">\(d[i]\)</span> such that <span class="math">\(d[i] &gt; 1\)</span> and <span class="math">\(d[i] \| d[i-1]\)</span> for <span class="math">\(i &gt;= 2\)</span> and
<span class="math">\((\mathbb{Z}/n\mathbb{Z})^* ~ \prod_{i = 1}^k(\mathbb{Z}/d[i]\mathbb{Z})\)</span>, and <span class="math">\(v[3]\)</span> is a <span class="math">\(k\)</span>-component row
vector giving generators of the image of the cyclic groups <span class="math">\(\mathbb{Z}/d[i]\mathbb{Z}\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>? G = znstar(40)
%1 = [16, [4, 2, 2], [Mod(17, 40), Mod(21, 40), Mod(11, 40)]]
? G.no \\ eulerphi(40)
%2 = 16
? G.cyc \\ cycle structure
%3 = [4, 2, 2]
? G.gen \\ generators for the cyclic components
%4 = [Mod(17, 40), Mod(21, 40), Mod(11, 40)]
? apply(znorder, G.gen)
%5 = [4, 2, 2]
</pre></div>
</div>
<p>According to the above definitions, <code class="docutils literal"><span class="pre">znstar(0)</span></code> is
<code class="docutils literal"><span class="pre">[2,</span> <span class="pre">[2],</span> <span class="pre">[-1]]</span></code>, corresponding to <span class="math">\(\mathbb{Z}^*\)</span>.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.libs.pari.gen.gentoobj">
<code class="descclassname">sage.libs.pari.gen.</code><code class="descname">gentoobj</code><span class="sig-paren">(</span><em>z</em>, <em>locals={}</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.gentoobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a PARI gen to a Sage/Python object.</p>
<p>See the <code class="docutils literal"><span class="pre">python</span></code> method of <a class="reference internal" href="#sage.libs.pari.gen.gen" title="sage.libs.pari.gen.gen"><code class="xref py py-class docutils literal"><span class="pre">gen</span></code></a> for documentation and
examples.</p>
</dd></dl>

<dl class="function">
<dt id="sage.libs.pari.gen.objtogen">
<code class="descclassname">sage.libs.pari.gen.</code><code class="descname">objtogen</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.pari.gen.objtogen" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert any Sage/Python object to a PARI gen.</p>
<p>For Sage types, this uses the <span class="math">\(_pari_()\)</span> method on the object.
Basic Python types like <code class="docutils literal"><span class="pre">int</span></code> are converted directly. For other
types, the string representation is used.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">[2, 3, 5]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">Matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>
<span class="go">[0, 1; 2, 3]</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x^2 - 3</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">(1, &#39;t_INT&#39;)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">(1/2, &#39;t_FRAC&#39;)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">(1/2, &#39;t_FRAC&#39;)</span>
</pre></div>
</div>
<p>Conversion from reals uses the real&#8217;s own precision:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="mf">1.2</span><span class="p">);</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">precision</span><span class="p">()</span>
<span class="go">(1.20000000000000, &#39;t_REAL&#39;, 4) # 32-bit</span>
<span class="go">(1.20000000000000, &#39;t_REAL&#39;, 3) # 64-bit</span>
</pre></div>
</div>
<p>Conversion from strings uses the current PARI real precision.
By default, this is 64 bits:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1.2&#39;</span><span class="p">);</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">precision</span><span class="p">()</span>
<span class="go">(1.20000000000000, &#39;t_REAL&#39;, 4)  # 32-bit</span>
<span class="go">(1.20000000000000, &#39;t_REAL&#39;, 3)  # 64-bit</span>
</pre></div>
</div>
<p>But we can change this precision:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">set_real_precision</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span>  <span class="c1"># precision in decimal digits</span>
<span class="go">15</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="s1">&#39;1.2&#39;</span><span class="p">);</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">precision</span><span class="p">()</span>
<span class="go">(1.2000000000000000000000000000000000, &#39;t_REAL&#39;, 6)  # 32-bit</span>
<span class="go">(1.2000000000000000000000000000000000, &#39;t_REAL&#39;, 4)  # 64-bit</span>
</pre></div>
</div>
<p>Set the precision to 15 digits for the remaining tests:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="o">.</span><span class="n">set_real_precision</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="go">35</span>
</pre></div>
</div>
<p>Conversion from matrices and vectors is supported:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">pari</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]));</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">([1, 2, 3; 4, 5, 6], &#39;t_MAT&#39;)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">vector</span><span class="p">([</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">,</span> <span class="mf">5.6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">[1.20000000000000, 3.40000000000000, 5.60000000000000]</span>
</pre></div>
</div>
<p>Some more exotic examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span><span class="o">.&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="go">[y^3 - 2, [1, 1], -108, 1, [[1, 1.25992104989487, 1.58740105196820; 1, -0.629960524947437 + 1.09112363597172*I, -0.793700525984100 - 1.37472963699860*I], [1, 1.25992104989487, 1.58740105196820; 1, 0.461163111024285, -2.16843016298270; 1, -1.72108416091916, 0.581029111014503], [1, 1, 2; 1, 0, -2; 1, -2, 1], [3, 0, 0; 0, 0, 6; 0, 6, 0], [6, 0, 0; 0, 6, 0; 0, 0, 3], [2, 0, 0; 0, 0, 1; 0, 1, 0], [2, [0, 0, 2; 1, 0, 0; 0, 1, 0]], []], [1.25992104989487, -0.629960524947437 + 1.09112363597172*I], [1, y, y^2], [1, 0, 0; 0, 1, 0; 0, 0, 1], [1, 0, 0, 0, 0, 2, 0, 2, 0; 0, 1, 0, 1, 0, 0, 0, 0, 2; 0, 0, 1, 0, 1, 0, 1, 0, 0]]</span>

<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s1">&#39;37a1&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="go">[0, 0, 1, -1, 0, 0, -2, 1, -1, 48, -216, 37, 110592/37, Vecsmall([1]), [Vecsmall([64, 1])], [0, 0, 0, 0, 0, 0, 0, 0]]</span>
</pre></div>
</div>
<p>Conversion from basic Python types:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">))</span>
<span class="go">-5</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="nb">long</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">150</span><span class="p">))</span>
<span class="go">1427247692705959881058285969449495136382746624</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">pi</span><span class="p">))</span>
<span class="go">3.14159265358979</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="o">/</span><span class="mi">4</span><span class="p">)))</span>
<span class="go">0.707106781186548 + 0.707106781186548*I</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Some commands are just executed without returning a value:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="s2">&quot;dummy = 0; kill(dummy)&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">pari</span><span class="p">(</span><span class="s2">&quot;dummy = 0; kill(dummy)&quot;</span><span class="p">))</span>
<span class="go">&lt;type &#39;NoneType&#39;&gt;</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pari</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Cannot convert None to pari</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="../lrcalc/lrcalc.html"
                                  title="previous chapter">An interface to Anders Buch&#8217;s Littlewood-Richardson Calculator <code class="docutils literal"><span class="pre">lrcalc</span></code></a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="pari_instance.html"
                                  title="next chapter">PARI C-library interface</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../../_sources/sage/libs/pari/gen.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pari_instance.html" title="PARI C-library interface"
             >next</a> |</li>
        <li class="right" >
          <a href="../lrcalc/lrcalc.html" title="An interface to Anders Buch’s Littlewood-Richardson Calculator lrcalc"
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">C/C++ Library Interfaces</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.4.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>