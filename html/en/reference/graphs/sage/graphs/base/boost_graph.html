<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Interface to run Boost algorithms &mdash; Sage Reference Manual v7.1: Graph Theory</title>
    
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v7.1: Graph Theory" href="../../../index.html" />
    <link rel="next" title="Hypergraph generators" href="../hypergraph_generators.html" />
    <link rel="prev" title="Backends for Sage (di)graphs." href="graph_backends.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../hypergraph_generators.html" title="Hypergraph generators"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="graph_backends.html" title="Backends for Sage (di)graphs."
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">Graph Theory</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="interface-to-run-boost-algorithms">
<span id="sage-graphs-base-boost-graph"></span><h1>Interface to run Boost algorithms<a class="headerlink" href="#interface-to-run-boost-algorithms" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.graphs.base.boost_graph"></span><p>Wrapper for a Boost graph. The Boost graphs are Cython C++ variables, and they
cannot be converted to Python objects: as a consequence, only functions defined
with cdef are able to create, read, modify, and delete these graphs.</p>
<p>A very important feature of Boost graph library is that all object are generic:
for instance, adjacency lists can be stored using different data structures,
and (most of) the functions work with all implementations provided. This feature
is implemented in our interface using fused types: however, Cython&#8217;s support for
fused types is still experimental, and some features are missing. For instance,
there cannot be nested generic function calls, and no variable can have a
generic type, apart from the arguments of a generic function.</p>
<p>All the input functions use pointers, because otherwise we might have problems
with <tt class="docutils literal"><span class="pre">delete()</span></tt>.</p>
<p><strong>Basic Boost Graph operations:</strong></p>
<table border="1" class="contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.base.boost_graph.clustering_coeff" title="sage.graphs.base.boost_graph.clustering_coeff"><tt class="xref py py-func docutils literal"><span class="pre">clustering_coeff()</span></tt></a></td>
<td>Returns the clustering coefficient of all vertices in the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.base.boost_graph.edge_connectivity" title="sage.graphs.base.boost_graph.edge_connectivity"><tt class="xref py py-func docutils literal"><span class="pre">edge_connectivity()</span></tt></a></td>
<td>Returns the edge connectivity of the graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.base.boost_graph.dominator_tree" title="sage.graphs.base.boost_graph.dominator_tree"><tt class="xref py py-func docutils literal"><span class="pre">dominator_tree()</span></tt></a></td>
<td>Returns a dominator tree of the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.base.boost_graph.bandwidth_heuristics" title="sage.graphs.base.boost_graph.bandwidth_heuristics"><tt class="xref py py-func docutils literal"><span class="pre">bandwidth_heuristics()</span></tt></a></td>
<td>Uses heuristics to approximate the bandwidth of the graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.base.boost_graph.min_spanning_tree" title="sage.graphs.base.boost_graph.min_spanning_tree"><tt class="xref py py-func docutils literal"><span class="pre">min_spanning_tree()</span></tt></a></td>
<td>Computes a minimum spanning tree of a (weighted) graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.base.boost_graph.shortest_paths" title="sage.graphs.base.boost_graph.shortest_paths"><tt class="xref py py-func docutils literal"><span class="pre">shortest_paths()</span></tt></a></td>
<td>Uses Dijkstra or Bellman-Ford algorithm to compute the single-source shortest paths.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.base.boost_graph.johnson_shortest_paths" title="sage.graphs.base.boost_graph.johnson_shortest_paths"><tt class="xref py py-func docutils literal"><span class="pre">johnson_shortest_paths()</span></tt></a></td>
<td>Uses Johnson algorithm to compute the all-pairs shortest paths.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.base.boost_graph.johnson_closeness_centrality" title="sage.graphs.base.boost_graph.johnson_closeness_centrality"><tt class="xref py py-func docutils literal"><span class="pre">johnson_closeness_centrality()</span></tt></a></td>
<td>Uses Johnson algorithm to compute the closeness centrality of all vertices.</td>
</tr>
</tbody>
</table>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="sage.graphs.base.boost_graph.bandwidth_heuristics">
<tt class="descclassname">sage.graphs.base.boost_graph.</tt><tt class="descname">bandwidth_heuristics</tt><big>(</big><em>g</em>, <em>algorithm='cuthill_mckee'</em><big>)</big><a class="headerlink" href="#sage.graphs.base.boost_graph.bandwidth_heuristics" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses Boost heuristics to approximate the bandwidth of the input graph.</p>
<p>The bandwidth <span class="math">\(bw(M)\)</span> of a matrix <span class="math">\(M\)</span> is the smallest integer <span class="math">\(k\)</span> such that
all non-zero entries of <span class="math">\(M\)</span> are at distance <span class="math">\(k\)</span> from the diagonal. The
bandwidth <span class="math">\(bw(g)\)</span> of an undirected graph <span class="math">\(g\)</span> is the minimum bandwidth of
the adjacency matrix of <span class="math">\(g\)</span>, over all possible relabellings of its vertices
(for more information, see the
<a class="reference internal" href="../graph_decompositions/bandwidth.html#module-sage.graphs.graph_decompositions.bandwidth" title="sage.graphs.graph_decompositions.bandwidth"><tt class="xref py py-mod docutils literal"><span class="pre">bandwidth</span></tt></a>
module).</p>
<p>Unfortunately, exactly computing the bandwidth is NP-hard (and an
exponential algorithm is implemented in Sagemath in routine
<a class="reference internal" href="../graph_decompositions/bandwidth.html#sage.graphs.graph_decompositions.bandwidth.bandwidth" title="sage.graphs.graph_decompositions.bandwidth.bandwidth"><tt class="xref py py-func docutils literal"><span class="pre">bandwidth()</span></tt></a>). Here, we
implement two heuristics to find good orderings: Cuthill-McKee, and King.</p>
<p>This function works only in undirected graphs, and its running time is
<span class="math">\(O(md_{max}\log d_{max})\)</span> for the Cuthill-McKee ordering, and
<span class="math">\(O(md_{max}^2\log d_{max})\)</span> for the King ordering, where <span class="math">\(m\)</span> is the number
of edges, and <span class="math">\(d_{max}\)</span> is the maximum degree in the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">g</span></tt> (<tt class="docutils literal"><span class="pre">Graph</span></tt>) - the input graph.</li>
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> (<tt class="docutils literal"><span class="pre">'cuthill_mckee'</span></tt> or <tt class="docutils literal"><span class="pre">'king'</span></tt>) - the heuristic used to
compute the ordering: Cuthill-McKee, or King.</li>
</ul>
<p>OUTPUT:</p>
<p>A pair <tt class="docutils literal"><span class="pre">[bandwidth,</span> <span class="pre">ordering]</span></tt>, where <tt class="docutils literal"><span class="pre">ordering</span></tt> is the ordering of
vertices, <tt class="docutils literal"><span class="pre">bandwidth</span></tt> is the bandwidth of that specific ordering (which
is not necessarily the bandwidth of the graph, because this is a heuristic).</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">bandwidth_heuristics</span>
<span class="gp">sage: </span><span class="n">bandwidth_heuristics</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">(1, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">sage: </span><span class="n">bandwidth_heuristics</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">(3, [(0, 0), (1, 0), (0, 1), (2, 0), (1, 1), (0, 2), (2, 1), (1, 2), (2, 2)])</span>
<span class="gp">sage: </span><span class="n">bandwidth_heuristics</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;king&#39;</span><span class="p">)</span>
<span class="go">(3, [(0, 0), (1, 0), (0, 1), (2, 0), (1, 1), (0, 2), (2, 1), (1, 2), (2, 2)])</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Given an input which is not a graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">bandwidth_heuristics</span>
<span class="gp">sage: </span><span class="n">bandwidth_heuristics</span><span class="p">(</span><span class="n">digraphs</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The input g must be a Graph.</span>
<span class="gp">sage: </span><span class="n">bandwidth_heuristics</span><span class="p">(</span><span class="s2">&quot;I am not a graph!&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The input g must be a Graph.</span>
</pre></div>
</div>
<p>Given a wrong algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>from sage.graphs.base.boost_graph import bandwidth_heuristics
sage: bandwidth_heuristics(graphs.PathGraph(3), algorithm=&#39;tip top&#39;)
Traceback (most recent call last):
...
ValueError: Algorithm &#39;tip top&#39; not yet implemented. Please contribute.
</pre></div>
</div>
<p>Given a graph with no edges:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>from sage.graphs.base.boost_graph import bandwidth_heuristics
sage: bandwidth_heuristics(Graph())
(0, [])
sage: bandwidth_heuristics(graphs.RandomGNM(10,0))
(0, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.base.boost_graph.clustering_coeff">
<tt class="descclassname">sage.graphs.base.boost_graph.</tt><tt class="descname">clustering_coeff</tt><big>(</big><em>g</em>, <em>vertices=None</em><big>)</big><a class="headerlink" href="#sage.graphs.base.boost_graph.clustering_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the clustering coefficient of the input graph, using Boost.</p>
<p>The output is a pair <tt class="docutils literal"><span class="pre">[average_clustering_coefficient,</span> <span class="pre">clust_of_v]</span></tt>, where
<tt class="docutils literal"><span class="pre">average_clustering_coefficient</span></tt> is the average clustering of the vertices
in variable <tt class="docutils literal"><span class="pre">vertices</span></tt>, <tt class="docutils literal"><span class="pre">clust_of_v</span></tt> is a dictionary that associates to
each vertex its clustering coefficient. If <tt class="docutils literal"><span class="pre">vertices</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt>, all
vertices are considered.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../generic_graph.html#sage.graphs.generic_graph.GenericGraph.clustering_coeff" title="sage.graphs.generic_graph.GenericGraph.clustering_coeff"><tt class="xref py py-meth docutils literal"><span class="pre">sage.graphs.generic_graph.GenericGraph.clustering_coeff()</span></tt></a></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">g</span></tt> (Graph) - the input graph.</li>
<li><tt class="docutils literal"><span class="pre">vertices</span></tt> (list) - the list of vertices we need to analyze (if
<tt class="docutils literal"><span class="pre">None</span></tt>, we will compute the clustering coefficient of all vertices).</li>
</ul>
<p>EXAMPLES:</p>
<p>Computing the clustering coefficient of a clique:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">clustering_coeff</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">clustering_coeff</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">[1.0, {0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0}]</span>
<span class="gp">sage: </span><span class="n">clustering_coeff</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[1.0, {0: 1.0, 1: 1.0, 2: 1.0}]</span>
</pre></div>
</div>
<p>Of a non-clique graph with triangles:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">IcosahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">clustering_coeff</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">[0.5, {1: 0.5, 2: 0.5, 3: 0.5}]</span>
</pre></div>
</div>
<p>With labels:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s2">&quot;abcdefghiklm&quot;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">clustering_coeff</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="s2">&quot;abde&quot;</span><span class="p">)</span>
<span class="go">[0.5, {&#39;a&#39;: 0.5, &#39;b&#39;: 0.5, &#39;d&#39;: 0.5, &#39;e&#39;: 0.5}]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.base.boost_graph.dominator_tree">
<tt class="descclassname">sage.graphs.base.boost_graph.</tt><tt class="descname">dominator_tree</tt><big>(</big><em>g</em>, <em>root</em>, <em>return_dict=False</em><big>)</big><a class="headerlink" href="#sage.graphs.base.boost_graph.dominator_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses Boost to compute the dominator tree of <tt class="docutils literal"><span class="pre">g</span></tt>, rooted at <tt class="docutils literal"><span class="pre">root</span></tt>.</p>
<p>A node <span class="math">\(d\)</span> dominates a node <span class="math">\(n\)</span> if every path from the entry node
<tt class="docutils literal"><span class="pre">root</span></tt> to <span class="math">\(n\)</span> must go through <span class="math">\(d\)</span>. The immediate dominator of a node
<span class="math">\(n\)</span> is the unique node that strictly dominates <span class="math">\(n\)</span> but does not dominate
any other node that dominates <span class="math">\(n\)</span>. A dominator tree is a tree where each
node&#8217;s children are those nodes it immediately dominates. For more
information, see <a class="reference external" href="https://en.wikipedia.org/wiki/Dominator_(graph_theory)">Wikipedia article Dominator_(graph_theory)</a>.</p>
<p>If the graph is connected and undirected, the parent of a vertex <span class="math">\(v\)</span> is:</p>
<blockquote>
<div><ul class="simple">
<li>the root if <span class="math">\(v\)</span> is in the same biconnected component as the root;</li>
<li>the first cut vertex in a path from <span class="math">\(v\)</span> to the root, otherwise.</li>
</ul>
</div></blockquote>
<p>If the graph is not connected, the dominator tree of the whole graph is
equal to the dominator tree of the connected component of the root.</p>
<p>If the graph is directed, computing a dominator tree is more complicated,
and it needs time <span class="math">\(O(m\log m)\)</span>, where <span class="math">\(m\)</span> is the number of edges. The
implementation provided by Boost is the most general one, so it needs time
<span class="math">\(O(m\log m)\)</span> even for undirected graphs.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">g</span></tt> (generic_graph) - the input graph.</li>
<li><tt class="docutils literal"><span class="pre">root</span></tt> (vertex) - the root of the dominator tree.</li>
<li><tt class="docutils literal"><span class="pre">return_dict</span></tt> (boolean) - if <tt class="docutils literal"><span class="pre">True</span></tt>, the function returns a
dictionary associating to each vertex its parent in the dominator
tree. If <tt class="docutils literal"><span class="pre">False</span></tt> (default), it returns the whole tree, as a <tt class="docutils literal"><span class="pre">Graph</span></tt>
or a <tt class="docutils literal"><span class="pre">DiGraph</span></tt>.</li>
</ul>
<p>OUTPUT:</p>
<p>The dominator tree, as a graph or as a dictionary, depending on the
value of <tt class="docutils literal"><span class="pre">return_dict</span></tt>. If the output is a dictionary, it will contain
<tt class="docutils literal"><span class="pre">None</span></tt> in correspondence of <tt class="docutils literal"><span class="pre">root</span></tt> and of vertices that are not
reachable from <tt class="docutils literal"><span class="pre">root</span></tt>. If the output is a graph, it will not contain
vertices that are not reachable from <tt class="docutils literal"><span class="pre">root</span></tt>.</p>
<p>EXAMPLES:</p>
<p>An undirected grid is biconnected, and its dominator tree is a star
(everyone&#8217;s parent is the root):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">to_dictionary</span><span class="p">()</span>
<span class="go">{(0, 0): [(0, 1), (1, 0), (1, 1)], (0, 1): [(0, 0)], (1, 0): [(0, 0)], (1, 1): [(0, 0)]}</span>
</pre></div>
</div>
<p>If the graph is made by two 3-cycles <span class="math">\(C_1,C_2\)</span> connected by an edge <span class="math">\((v,w)\)</span>,
with <span class="math">\(v \in C_1\)</span>, <span class="math">\(w \in C_2\)</span>, the cut vertices are <span class="math">\(v\)</span> and <span class="math">\(w\)</span>, the
biconnected components are <span class="math">\(C_1\)</span>, <span class="math">\(C_2\)</span>, and the edge <span class="math">\((v,w)\)</span>. If the root
is in <span class="math">\(C_1\)</span>, the parent of each vertex in <span class="math">\(C_1\)</span> is the root, the parent of
<span class="math">\(w\)</span> is <span class="math">\(v\)</span>, and the parent of each vertex in <span class="math">\(C_2\)</span> is <span class="math">\(w\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">return_dict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">{0: 1, 1: None, 2: 1, 3: 0, 4: 3, 5: 3}</span>
</pre></div>
</div>
<p>An example with a directed graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">to_dictionary</span><span class="p">()</span>
<span class="go">{0: [1], 1: [2], 2: [3], 3: [4], 4: [], 5: [6], 6: [7], 7: [8], 8: [9], 9: [0]}</span>
</pre></div>
</div>
<p>If the output is a dictionary:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">return_dict</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">{(0, 0): None, (0, 1): (0, 0), (1, 0): (0, 0), (1, 1): (0, 0)}</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>If <tt class="docutils literal"><span class="pre">g</span></tt> is not a graph, an error is raised:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">dominator_tree</span>
<span class="gp">sage: </span><span class="n">dominator_tree</span><span class="p">(</span><span class="s1">&#39;I am not a graph&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The input g must be a Sage graph.</span>
</pre></div>
</div>
<p>If <tt class="docutils literal"><span class="pre">root</span></tt> is not a vertex, an error is raised:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">digraphs</span><span class="o">.</span><span class="n">TransitiveTournament</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">(</span><span class="s1">&#39;Not a vertex!&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The input root must be a vertex of g.</span>
<span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The input root must be a vertex of g.</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.base.boost_graph.edge_connectivity">
<tt class="descclassname">sage.graphs.base.boost_graph.</tt><tt class="descname">edge_connectivity</tt><big>(</big><em>g</em><big>)</big><a class="headerlink" href="#sage.graphs.base.boost_graph.edge_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the edge connectivity of the input graph, using Boost.</p>
<p>The output is a pair <tt class="docutils literal"><span class="pre">[ec,edges]</span></tt>, where <tt class="docutils literal"><span class="pre">ec</span></tt> is the edge connectivity,
<tt class="docutils literal"><span class="pre">edges</span></tt> is the list of edges in a minimum cut.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../generic_graph.html#sage.graphs.generic_graph.GenericGraph.edge_connectivity" title="sage.graphs.generic_graph.GenericGraph.edge_connectivity"><tt class="xref py py-meth docutils literal"><span class="pre">sage.graphs.generic_graph.GenericGraph.edge_connectivity()</span></tt></a></p>
</div>
<p>EXAMPLES:</p>
<p>Computing the edge connectivity of a clique:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">edge_connectivity</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">[4, [(0, 1), (0, 2), (0, 3), (0, 4)]]</span>
</pre></div>
</div>
<p>Vertex-labeled graphs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">edge_connectivity</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">edge_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">[2, [((0, 0), (0, 1)), ((0, 0), (1, 0))]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.base.boost_graph.johnson_closeness_centrality">
<tt class="descclassname">sage.graphs.base.boost_graph.</tt><tt class="descname">johnson_closeness_centrality</tt><big>(</big><em>g</em>, <em>weight_function=None</em><big>)</big><a class="headerlink" href="#sage.graphs.base.boost_graph.johnson_closeness_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses Johnson algorithm to compute the closeness centrality of all vertices.</p>
<p>This routine is preferrable to <a class="reference internal" href="#sage.graphs.base.boost_graph.johnson_shortest_paths" title="sage.graphs.base.boost_graph.johnson_shortest_paths"><tt class="xref py py-func docutils literal"><span class="pre">johnson_shortest_paths()</span></tt></a> because it
does not create a doubly indexed dictionary of distances, saving memory.</p>
<p>The time-complexity is <span class="math">\(O(mn\log n)\)</span>, where <span class="math">\(n\)</span> is the number of nodes and
<span class="math">\(m\)</span> is the number of edges.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">g</span></tt> (generic_graph) - the input graph.</li>
<li><tt class="docutils literal"><span class="pre">weight_function</span></tt> (function) - a function that inputs an edge
<tt class="docutils literal"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></tt> and outputs its weight. If not <tt class="docutils literal"><span class="pre">None</span></tt>, <tt class="docutils literal"><span class="pre">by_weight</span></tt>
is automatically set to <tt class="docutils literal"><span class="pre">True</span></tt>. If <tt class="docutils literal"><span class="pre">None</span></tt> and <tt class="docutils literal"><span class="pre">by_weight</span></tt> is
<tt class="docutils literal"><span class="pre">True</span></tt>, we use the edge label <tt class="docutils literal"><span class="pre">l</span></tt> as a weight.</li>
</ul>
<p>OUTPUT:</p>
<p>A dictionary associating each vertex <tt class="docutils literal"><span class="pre">v</span></tt> to its closeness centrality.</p>
<p>EXAMPLES:</p>
<p>Undirected graphs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">johnson_closeness_centrality</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">johnson_closeness_centrality</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">{0: 0.375, 1: 0.5, 2: 0.5, 3: 0.375}</span>
</pre></div>
</div>
<p>Directed graphs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">johnson_closeness_centrality</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">johnson_closeness_centrality</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">{0: inf, 1: -0.4444444444444444, 2: 0.3333333333333333}</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Given an input which is not a graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">johnson_closeness_centrality</span>
<span class="gp">sage: </span><span class="n">johnson_closeness_centrality</span><span class="p">(</span><span class="s2">&quot;I am not a graph!&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The input g must be a Sage Graph or DiGraph.</span>
</pre></div>
</div>
<p>If there is a negative cycle:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">johnson_closeness_centrality</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">johnson_closeness_centrality</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The graph contains a negative cycle.</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.base.boost_graph.johnson_shortest_paths">
<tt class="descclassname">sage.graphs.base.boost_graph.</tt><tt class="descname">johnson_shortest_paths</tt><big>(</big><em>g</em>, <em>weight_function=None</em><big>)</big><a class="headerlink" href="#sage.graphs.base.boost_graph.johnson_shortest_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses Johnson algorithm to solve the all-pairs-shortest-paths.</p>
<p>This routine outputs the distance between each pair of vertices, using a
dictionary of dictionaries. It works on all kinds of graphs, but it is
designed specifically for graphs with negative weights (otherwise there are
more efficient algorithms, like Dijkstra).</p>
<p>The time-complexity is <span class="math">\(O(mn\log n)\)</span>, where <span class="math">\(n\)</span> is the number of nodes and
<span class="math">\(m\)</span> is the number of edges.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">g</span></tt> (generic_graph) - the input graph.</li>
<li><tt class="docutils literal"><span class="pre">weight_function</span></tt> (function) - a function that inputs an edge
<tt class="docutils literal"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></tt> and outputs its weight. If not <tt class="docutils literal"><span class="pre">None</span></tt>, <tt class="docutils literal"><span class="pre">by_weight</span></tt>
is automatically set to <tt class="docutils literal"><span class="pre">True</span></tt>. If <tt class="docutils literal"><span class="pre">None</span></tt> and <tt class="docutils literal"><span class="pre">by_weight</span></tt> is
<tt class="docutils literal"><span class="pre">True</span></tt>, we use the edge label <tt class="docutils literal"><span class="pre">l</span></tt> as a weight.</li>
</ul>
<p>OUTPUT:</p>
<p>A dictionary of dictionary <tt class="docutils literal"><span class="pre">distances</span></tt> such that <tt class="docutils literal"><span class="pre">distances[v][w]</span></tt> is
the distance between vertex <tt class="docutils literal"><span class="pre">v</span></tt> and vertex <tt class="docutils literal"><span class="pre">w</span></tt>.</p>
<p>EXAMPLES:</p>
<p>Undirected graphs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">johnson_shortest_paths</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">johnson_shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">{0: {0: 0, 1: 1, 2: 3, 3: 4},</span>
<span class="go"> 1: {0: 1, 1: 0, 2: 2, 3: 3},</span>
<span class="go"> 2: {0: 3, 1: 2, 2: 0, 3: 1},</span>
<span class="go"> 3: {0: 4, 1: 3, 2: 1, 3: 0}}</span>
</pre></div>
</div>
<p>Directed graphs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">johnson_shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">{0: {0: 0, 1: 1, 2: -1, 3: 0},</span>
<span class="go"> 1: {1: 0, 2: -2, 3: -1},</span>
<span class="go"> 2: {2: 0, 3: 1},</span>
<span class="go"> 3: {3: 0}}</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Given an input which is not a graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">johnson_shortest_paths</span><span class="p">(</span><span class="s2">&quot;I am not a graph!&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The input g must be a Sage Graph or DiGraph.</span>
</pre></div>
</div>
<p>If there is a negative cycle:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">johnson_shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The graph contains a negative cycle.</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.base.boost_graph.min_spanning_tree">
<tt class="descclassname">sage.graphs.base.boost_graph.</tt><tt class="descname">min_spanning_tree</tt><big>(</big><em>g</em>, <em>weight_function=None</em>, <em>algorithm='Kruskal'</em><big>)</big><a class="headerlink" href="#sage.graphs.base.boost_graph.min_spanning_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses Boost to compute the minimum spanning tree of the input graph.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">g</span></tt> (<tt class="docutils literal"><span class="pre">Graph</span></tt>) - the input graph.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">weight_function</span></tt> (function) - a function that inputs an edge <tt class="docutils literal"><span class="pre">e</span></tt> and
outputs its weight. An edge has the form <tt class="docutils literal"><span class="pre">(u,v,l)</span></tt>, where <tt class="docutils literal"><span class="pre">u</span></tt> and
<tt class="docutils literal"><span class="pre">v</span></tt> are vertices, <tt class="docutils literal"><span class="pre">l</span></tt> is a label (that can be of any kind). The
<tt class="docutils literal"><span class="pre">weight_function</span></tt> can be used to transform the label into a weight (see
the example below). In particular:</p>
<ul class="simple">
<li>if <tt class="docutils literal"><span class="pre">weight_function</span></tt> is not <tt class="docutils literal"><span class="pre">None</span></tt>, the weight of an edge <tt class="docutils literal"><span class="pre">e</span></tt> is
<tt class="docutils literal"><span class="pre">weight_function(e)</span></tt>;</li>
<li>if <tt class="docutils literal"><span class="pre">weight_function</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt> (default) and <tt class="docutils literal"><span class="pre">g</span></tt> is weighted (that
is, <tt class="docutils literal"><span class="pre">g.weighted()==True</span></tt>), for each edge <tt class="docutils literal"><span class="pre">e=(u,v,l)</span></tt>, we set weight
<tt class="docutils literal"><span class="pre">l</span></tt>;</li>
<li>if <tt class="docutils literal"><span class="pre">weight_function</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt> and <tt class="docutils literal"><span class="pre">g</span></tt> is not weighted, we set all
weights to 1 (hence, the output can be any spanning tree).</li>
</ul>
<p>Note that, if the weight is not convertible to a number with function
<tt class="docutils literal"><span class="pre">float()</span></tt>, an error is raised (see tests below).</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">algorithm</span></tt> (<tt class="docutils literal"><span class="pre">'Kruskal'</span></tt> or <tt class="docutils literal"><span class="pre">'Prim'</span></tt>) - the algorithm used.</p>
</li>
</ul>
<p>OUTPUT:</p>
<p>The edges of a minimum spanning tree of <tt class="docutils literal"><span class="pre">g</span></tt>, if one exists, otherwise
the empty list.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="../generic_graph.html#sage.graphs.generic_graph.GenericGraph.min_spanning_tree" title="sage.graphs.generic_graph.GenericGraph.min_spanning_tree"><tt class="xref py py-meth docutils literal"><span class="pre">sage.graphs.generic_graph.GenericGraph.min_spanning_tree()</span></tt></a></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">min_spanning_tree</span>
<span class="gp">sage: </span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">[(0, 1, None), (1, 2, None), (2, 3, None)]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">})])</span>
<span class="gp">sage: </span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight_function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">])</span>
<span class="go">[(0, 1, {&#39;name&#39;: &#39;a&#39;, &#39;weight&#39;: 1}), (1, 2, {&#39;name&#39;: &#39;b&#39;, &#39;weight&#39;: 1})]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Given an input which is not a graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="s2">&quot;I am not a graph!&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The input g must be a Sage Graph.</span>
</pre></div>
</div>
<p>Given a wrong algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;tip top&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Algorithm &#39;tip top&#39; not yet implemented. Please contribute.</span>
</pre></div>
</div>
<p>If the weight is not a number:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The weight function cannot find the weight of (1, 2, &#39;a&#39;).</span>

<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])],</span> <span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The weight function cannot find the weight of (1, 2, [1, 2, 3]).</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.base.boost_graph.shortest_paths">
<tt class="descclassname">sage.graphs.base.boost_graph.</tt><tt class="descname">shortest_paths</tt><big>(</big><em>g</em>, <em>start</em>, <em>weight_function=None</em>, <em>algorithm=None</em><big>)</big><a class="headerlink" href="#sage.graphs.base.boost_graph.shortest_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the shortest paths from <tt class="docutils literal"><span class="pre">start</span></tt> to all other vertices.</p>
<p>This routine outputs all shortest paths from node <tt class="docutils literal"><span class="pre">start</span></tt> to any other
node in the graph. The input graph can be weighted: if the algorithm is
Dijkstra, no negative weights are allowed, while if the algorithm is
Bellman-Ford, negative weights are allowed, but there must be no negative
cycle (otherwise, the shortest paths might not exist).</p>
<p>However, Dijkstra algorithm is more efficient: for this reason, we suggest
to use Bellman-Ford only if necessary (which is also the default option).
Note that, if the graph is undirected, a negative edge automatically creates
a negative cycle: for this reason, in this case, Dijkstra algorithm is
always better.</p>
<p>The running-time is <span class="math">\(O(n \log n+m)\)</span> for Dijkstra algorithm and <span class="math">\(O(mn)\)</span> for
Bellman-Ford algorithm, where <span class="math">\(n\)</span> is the number of nodes and <span class="math">\(m\)</span> is the
number of edges.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">g</span></tt> (generic_graph) - the input graph.</li>
<li><tt class="docutils literal"><span class="pre">start</span></tt> (vertex) - the starting vertex to compute shortest paths.</li>
<li><tt class="docutils literal"><span class="pre">weight_function</span></tt> (function) - a function that associates a weight to
each edge. If <tt class="docutils literal"><span class="pre">None</span></tt> (default), the weights of <tt class="docutils literal"><span class="pre">g</span></tt> are used, if
available, otherwise all edges have weight 1.</li>
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> (string) - one of the following algorithms:<ul>
<li><tt class="docutils literal"><span class="pre">'Dijkstra','Dijkstra_Boost'</span></tt>: the Dijkstra algorithm implemented in
Boost (works only with positive weights).</li>
<li><tt class="docutils literal"><span class="pre">'Bellman-Ford','Bellman-Ford_Boost'</span></tt>: the Bellman-Ford algorithm
implemented in Boost (works also with negative weights, if there is no
negative cycle).</li>
</ul>
</li>
</ul>
<p>OUTPUT:</p>
<p>A pair of dictionaries <tt class="docutils literal"><span class="pre">[distances,</span> <span class="pre">predecessors]</span></tt> such that, for each
vertex <tt class="docutils literal"><span class="pre">v</span></tt>, <tt class="docutils literal"><span class="pre">distances[v]</span></tt> is the distance from <tt class="docutils literal"><span class="pre">start</span></tt> to <tt class="docutils literal"><span class="pre">v</span></tt>,
<tt class="docutils literal"><span class="pre">predecessors[v]</span></tt> is the last vertex in a shortest path from <tt class="docutils literal"><span class="pre">start</span></tt> to
<tt class="docutils literal"><span class="pre">v</span></tt>.</p>
<p>EXAMPLES:</p>
<p>Undirected graphs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">shortest_paths</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[{0: 1, 1: 0, 2: 2, 3: 3}, {0: 1, 1: None, 2: 1, 3: 2}]</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">weight_function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[{(0, 0): 0, (0, 1): 2, (1, 0): 2, (1, 1): 4},</span>
<span class="go"> {(0, 0): None, (0, 1): (0, 0), (1, 0): (0, 0), (1, 1): (0, 1)}]</span>
</pre></div>
</div>
<p>Directed graphs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[{1: 0, 2: 2, 3: 3}, {1: None, 2: 1, 3: 2}]</span>
</pre></div>
</div>
<p>TESTS:</p>
<p>Given an input which is not a graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">shortest_paths</span><span class="p">(</span><span class="s2">&quot;I am not a graph!&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The input g must be a Sage Graph or DiGraph.</span>
</pre></div>
</div>
<p>If there is a negative cycle:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">shortest_paths</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The graph contains a negative cycle.</span>
</pre></div>
</div>
<p>If Dijkstra is used with negative weights:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">shortest_paths</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Dijkstra algorithm does not work with negative weights. Please, use Bellman-Ford.</span>
</pre></div>
</div>
<p>Wrong starting vartex:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">[])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The starting vertex [] is not in the graph.</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../../../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Interface to run Boost algorithms</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="graph_backends.html"
                                  title="previous chapter">Backends for Sage (di)graphs.</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="../hypergraph_generators.html"
                                  title="next chapter">Hypergraph generators</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../../_sources/sage/graphs/base/boost_graph.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../hypergraph_generators.html" title="Hypergraph generators"
             >next</a> |</li>
        <li class="right" >
          <a href="graph_backends.html" title="Backends for Sage (di)graphs."
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../../index.html">Graph Theory</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2016, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>