<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Lattice and reflexive polytopes &mdash; Sage Reference Manual v6.7: Geometry</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '6.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="Sage Reference Manual v6.7: Geometry" href="../../index.html" />
    <link rel="next" title="Polyhedra" href="polyhedron/constructor.html" />
    <link rel="prev" title="Groebner Fans" href="../rings/polynomial/groebner_fan.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="polyhedron/constructor.html" title="Polyhedra"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../rings/polynomial/groebner_fan.html" title="Groebner Fans"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Geometry</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="lattice-and-reflexive-polytopes">
<span id="sage-geometry-lattice-polytope"></span><h1>Lattice and reflexive polytopes<a class="headerlink" href="#lattice-and-reflexive-polytopes" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.geometry.lattice_polytope"></span><p>This module provides tools for work with lattice and reflexive
polytopes. A <em>convex polytope</em> is the convex hull of finitely many
points in <span class="math">\(\RR^n\)</span>. The dimension <span class="math">\(n\)</span> of a
polytope is the smallest <span class="math">\(n\)</span> such that the polytope can be
embedded in <span class="math">\(\RR^n\)</span>.</p>
<p>A <em>lattice polytope</em> is a polytope whose vertices all have integer
coordinates.</p>
<p>If <span class="math">\(L\)</span> is a lattice polytope, the dual polytope of
<span class="math">\(L\)</span> is</p>
<div class="math">
\[\{y \in \ZZ^n :   x\cdot y \geq -1 \text{ all } x \in L\}\]</div>
<p>A <em>reflexive polytope</em> is a lattice polytope, such that its polar
is also a lattice polytope, i.e. it is bounded and has vertices with
integer coordinates.</p>
<p>This Sage module uses Package for Analyzing Lattice Polytopes
(PALP), which is a program written in C by Maximilian Kreuzer and
Harald Skarke, which is freely available under the GNU license
terms at <a class="reference external" href="http://hep.itp.tuwien.ac.at/~kreuzer/CY/">http://hep.itp.tuwien.ac.at/~kreuzer/CY/</a>. Moreover, PALP is
included standard with Sage.</p>
<p>PALP is described in the paper <a class="reference external" href="http://arxiv.org/abs/math.SC/0204356">Arxiv math.SC/0204356</a>. Its distribution
also contains the application nef.x, which was created by Erwin
Riegler and computes nef-partitions and Hodge data for toric
complete intersections.</p>
<p>ACKNOWLEDGMENT: polytope.py module written by William Stein was
used as an example of organizing an interface between an external
program and Sage. William Stein also helped Andrey Novoseltsev with
debugging and tuning of this module.</p>
<p>Robert Bradshaw helped Andrey Novoseltsev to realize plot3d
function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">IMPORTANT: PALP requires some parameters to be determined during
compilation time, i.e., the maximum dimension of polytopes, the
maximum number of points, etc. These limitations may lead to errors
during calls to different functions of these module.  Currently, a
ValueError exception will be raised if the output of poly.x or
nef.x is empty or contains the exclamation mark. The error message
will contain the exact command that caused an error, the
description and vertices of the polytope, and the obtained output.</p>
</div>
<p>Data obtained from PALP and some other data is cached and most
returned values are immutable. In particular, you cannot change the
vertices of the polytope or their order after creation of the
polytope.</p>
<p>If you are going to work with large sets of data, take a look at
<tt class="docutils literal"><span class="pre">all_*</span></tt> functions in this module. They precompute different data
for sequences of polynomials with a few runs of external programs.
This can significantly affect the time of future computations. You
can also use dump/load, but not all data will be stored (currently
only faces and the number of their internal and boundary points are
stored, in addition to polytope vertices and its polar).</p>
<p>AUTHORS:</p>
<ul>
<li><p class="first">Andrey Novoseltsev (2007-01-11): initial version</p>
</li>
<li><p class="first">Andrey Novoseltsev (2007-01-15): <tt class="docutils literal"><span class="pre">all_*</span></tt> functions</p>
</li>
<li><p class="first">Andrey Novoseltsev (2008-04-01): second version, including:</p>
<blockquote>
<div><ul class="simple">
<li>dual nef-partitions and necessary convex_hull and minkowski_sum</li>
<li>built-in sequences of 2- and 3-dimensional reflexive polytopes</li>
<li>plot3d, skeleton_show</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Andrey Novoseltsev (2009-08-26): dropped maximal dimension requirement</p>
</li>
<li><p class="first">Andrey Novoseltsev (2010-12-15): new version of nef-partitions</p>
</li>
<li><p class="first">Andrey Novoseltsev (2013-09-30): switch to PointCollection.</p>
</li>
<li><p class="first">Maximilian Kreuzer and Harald Skarke: authors of PALP (which was
also used to obtain the list of 3-dimensional reflexive polytopes)</p>
</li>
<li><p class="first">Erwin Riegler: the author of nef.x</p>
</li>
</ul>
<dl class="function">
<dt id="sage.geometry.lattice_polytope.LatticePolytope">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">LatticePolytope</tt><big>(</big><em>data</em>, <em>desc=None</em>, <em>compute_vertices=True</em>, <em>n=0</em>, <em>lattice=None</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a lattice polytope.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">data</span></tt> &#8211; points spanning the lattice polytope, specified as one of:</p>
<blockquote>
<div><ul class="simple">
<li>a <a class="reference internal" href="point_collection.html#sage.geometry.point_collection.PointCollection" title="sage.geometry.point_collection.PointCollection"><tt class="xref py py-class docutils literal"><span class="pre">point</span> <span class="pre">collection</span></tt></a> (this is the
preferred input and it is the quickest and the most memory efficient
one);</li>
<li>an iterable of iterables (for example, a list of vectors)
defining the point coordinates;</li>
<li>a file with matrix data, opened for reading, or</li>
<li>a filename of such a file, see <a class="reference internal" href="#sage.geometry.lattice_polytope.read_palp_matrix" title="sage.geometry.lattice_polytope.read_palp_matrix"><tt class="xref py py-func docutils literal"><span class="pre">read_palp_matrix()</span></tt></a> for the
file format;</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">desc</span></tt> &#8211; DEPRECATED (default: &#8220;A lattice polytope&#8221;) a string
description of the polytope;</p>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">compute_vertices</span></tt> &#8211; boolean (default: <tt class="docutils literal"><span class="pre">True</span></tt>). If <tt class="docutils literal"><span class="pre">True</span></tt>, the</dt>
<dd><p class="first last">convex hull of the given points will be computed for
determining vertices. Otherwise, the given points must be
vertices;</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">n</span></tt> &#8211; an integer (default: 0) if <tt class="docutils literal"><span class="pre">data</span></tt> is a name of a file,</dt>
<dd><p class="first last">that contains data blocks for several polytopes, the <tt class="docutils literal"><span class="pre">n</span></tt>-th block
will be used;</p>
</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">lattice</span></tt> &#8211; the ambient lattice of the polytope. If not given, a
suitable lattice will be determined automatically, most likely the
<a class="reference internal" href="toric_lattice.html#sage.geometry.toric_lattice.ToricLatticeFactory" title="sage.geometry.toric_lattice.ToricLatticeFactory"><tt class="xref py py-class docutils literal"><span class="pre">toric</span> <span class="pre">lattice</span></tt></a>
<span class="math">\(M\)</span> of the appropriate dimension.</p>
</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a <a class="reference internal" href="#sage.geometry.lattice_polytope.LatticePolytopeClass" title="sage.geometry.lattice_polytope.LatticePolytopeClass"><tt class="xref py py-class docutils literal"><span class="pre">lattice</span> <span class="pre">polytope</span></tt></a>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span>
<span class="go">3-d reflexive polytope in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0),</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0,  0),</span>
<span class="go">M( 0, -1,  0),</span>
<span class="go">M( 0,  0, -1)</span>
<span class="go">in 3-d lattice M</span>
</pre></div>
</div>
<p>We draw a pretty picture of the polytope in 3-dimensional space:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">plot3d</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Now we add an extra point, which is in the interior of the
polytope...</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">nvertices</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<p>You can suppress vertex computation for speed but this can lead to
mistakes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">compute_vertices</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">nvertices</span><span class="p">()</span>
<span class="go">7</span>
</pre></div>
</div>
<p>Given points must be in the lattice:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LatticePolytope</span><span class="p">(</span><span class="n">matrix</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">]))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">points</span>
<span class="go">[(1/2), (3/2)]</span>
<span class="go">are not in 1-d lattice M!</span>
</pre></div>
</div>
<p>But it is OK to create polytopes of non-maximal dimension:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span>
<span class="go">2-d lattice polytope in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0, 0),</span>
<span class="go">M( 0,  1, 0),</span>
<span class="go">M(-1,  0, 0),</span>
<span class="go">M( 0, -1, 0)</span>
<span class="go">in 3-d lattice M</span>
</pre></div>
</div>
<p>An empty lattice polytope can be considered as well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">ToricLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">dual</span><span class="p">());</span> <span class="n">p</span>
<span class="go">-1-d lattice polytope in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">ambient_dim</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">nfacets</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">points_pc</span><span class="p">()</span>
<span class="go">Empty collection</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass">
<em class="property">class </em><tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">LatticePolytopeClass</tt><big>(</big><em>points</em>, <em>compute_vertices</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Basic Structures v6.7)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.sage_object.SageObject</span></tt></a>, <tt class="xref py py-class docutils literal"><span class="pre">_abcoll.Hashable</span></tt></p>
<p>Construct a lattice polytope from prepared data.</p>
<p>In most cases you should use <a class="reference internal" href="#sage.geometry.lattice_polytope.LatticePolytope" title="sage.geometry.lattice_polytope.LatticePolytope"><tt class="xref py py-func docutils literal"><span class="pre">LatticePolytope()</span></tt></a> for constructing
polytopes.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">points</span></tt> &#8211; a <a class="reference internal" href="point_collection.html#sage.geometry.point_collection.PointCollection" title="sage.geometry.point_collection.PointCollection"><tt class="xref py py-class docutils literal"><span class="pre">PointCollection</span></tt></a>;</li>
<li><tt class="docutils literal"><span class="pre">compute_vertices</span></tt> &#8211; boolean.</li>
</ul>
<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.affine_transform">
<tt class="descname">affine_transform</tt><big>(</big><em>a=1</em>, <em>b=0</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.affine_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a*P+b, where P is this lattice polytope.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic simple">
<li>While <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> may be rational, the final result must be a
lattice polytope, i.e. all vertices must be integral.</li>
<li>If the transform (restricted to this polytope) is bijective, facial
structure will be preserved, e.g. the first facet of the image will
be spanned by the images of vertices which span the first facet of
the original polytope.</li>
</ol>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span></tt> - (default: 1) rational scalar or matrix</li>
<li><tt class="docutils literal"><span class="pre">b</span></tt> - (default: 0) rational scalar or vector, scalars are
interpreted as vectors with the same components</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0),</span>
<span class="go">M( 0,  1),</span>
<span class="go">M(-1,  0),</span>
<span class="go">M( 0, -1)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">affine_transform</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 2,  0),</span>
<span class="go">M( 0,  2),</span>
<span class="go">M(-2,  0),</span>
<span class="go">M( 0, -2)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">affine_transform</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M(2, 1),</span>
<span class="go">M(1, 2),</span>
<span class="go">M(0, 1),</span>
<span class="go">M(1, 0)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">affine_transform</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M(2, 1),</span>
<span class="go">M(1, 2),</span>
<span class="go">M(0, 1),</span>
<span class="go">M(1, 0)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">affine_transform</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M(2,  0),</span>
<span class="go">M(1,  1),</span>
<span class="go">M(0,  0),</span>
<span class="go">M(1, -1)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">N(-1,  1),</span>
<span class="go">N( 1,  1),</span>
<span class="go">N(-1, -1),</span>
<span class="go">N( 1, -1)</span>
<span class="go">in 2-d lattice N</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span><span class="o">.</span><span class="n">affine_transform</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M(0,  1),</span>
<span class="go">M(1,  1),</span>
<span class="go">M(0, -2),</span>
<span class="go">M(1, -2)</span>
<span class="go">in 2-d lattice M</span>
</pre></div>
</div>
<p>While you can use rational transformation, the result must be integer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">affine_transform</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">points</span>
<span class="go">[(1/2, 0), (0, 3/2), (-1/2, 0), (0, -3/2)]</span>
<span class="go">are not in 2-d lattice M!</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.ambient_dim">
<tt class="descname">ambient_dim</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.ambient_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension of the ambient space of this polytope.</p>
<p>EXAMPLES: We create a 3-dimensional octahedron and check its
ambient dimension:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">ambient_dim</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.dim">
<tt class="descname">dim</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension of this polytope.</p>
<p>EXAMPLES: We create a 3-dimensional octahedron and check its
dimension:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Now we create a 2-dimensional diamond in a 3-dimensional space:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">ambient_dim</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.distances">
<tt class="descname">distances</tt><big>(</big><em>point=None</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.distances" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix of distances for this polytope or distances for
the given point.</p>
<p>The matrix of distances m gives distances m[i,j] between the i-th
facet (which is also the i-th vertex of the polar polytope in the
reflexive case) and j-th point of this polytope.</p>
<p>If point is specified, integral distances from the point to all
facets of this polytope will be computed.</p>
<p>This function CAN be used for polytopes whose dimension is smaller
than the dimension of the ambient space. In this case distances are
computed in the affine subspace spanned by the polytope and if the
point is given, it must be in this subspace.</p>
<p>EXAMPLES: The matrix of distances for a 3-dimensional octahedron:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">distances</span><span class="p">()</span>
<span class="go">[0 0 2 2 2 0 1]</span>
<span class="go">[2 0 2 0 2 0 1]</span>
<span class="go">[0 2 2 2 0 0 1]</span>
<span class="go">[2 2 2 0 0 0 1]</span>
<span class="go">[0 0 0 2 2 2 1]</span>
<span class="go">[2 0 0 0 2 2 1]</span>
<span class="go">[0 2 0 2 0 2 1]</span>
<span class="go">[2 2 0 0 0 2 1]</span>
</pre></div>
</div>
<p>Distances from facets to the point (1,2,3):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">distances</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">(1, 3, 5, 7, -5, -3, -1, 1)</span>
</pre></div>
</div>
<p>It is OK to use RATIONAL coordinates:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">distances</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(-1/2, 3/2, 7/2, 11/2, -7/2, -3/2, 1/2, 5/2)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">distances</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">TypeError</span>: <span class="n-Identifier">unable to convert sqrt(2) to a rational</span>
</pre></div>
</div>
<p>Now we create a non-spanning polytope:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">distances</span><span class="p">()</span>
<span class="go">[0 2 2 0 1]</span>
<span class="go">[2 2 0 0 1]</span>
<span class="go">[0 0 2 2 1]</span>
<span class="go">[2 0 0 2 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">distances</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">(7/2, 9/2, -5/2, -3/2)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">distances</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ArithmeticError</span>: <span class="n-Identifier">vector is not in free module</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.dual_lattice">
<tt class="descname">dual_lattice</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.dual_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual of the ambient lattice of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a lattice. If possible (that is, if <a class="reference internal" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.lattice" title="sage.geometry.lattice_polytope.LatticePolytopeClass.lattice"><tt class="xref py py-meth docutils literal"><span class="pre">lattice()</span></tt></a> has a
<tt class="docutils literal"><span class="pre">dual()</span></tt> method), the dual lattice is returned. Otherwise,
<span class="math">\(\ZZ^n\)</span> is returned, where <span class="math">\(n\)</span> is the dimension of <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span><span class="o">.</span><span class="n">dual_lattice</span><span class="p">()</span>
<span class="go">2-d lattice N</span>
<span class="gp">sage: </span><span class="n">LatticePolytope</span><span class="p">([],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">ZZ</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">dual_lattice</span><span class="p">()</span>
<span class="go">Ambient free module of rank 3</span>
<span class="go">over the principal ideal domain Integer Ring</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.edges">
<tt class="descname">edges</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sequence of edges of this polytope (i.e. faces of
dimension 1).</p>
<p>EXAMPLES: The octahedron has 12 edges:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
<span class="go">12</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[[1, 5], [0, 5], [0, 1], [3, 5], [1, 3], [4, 5], [0, 4], [3, 4], [1, 2], [0, 2], [2, 3], [2, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.faces">
<tt class="descname">faces</tt><big>(</big><em>dim=None</em>, <em>codim=None</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sequence of proper faces of this polytope.</p>
<p>If <tt class="docutils literal"><span class="pre">dim</span></tt> or <tt class="docutils literal"><span class="pre">codim</span></tt> are specified,
returns a sequence of faces of the corresponding dimension or
codimension. Otherwise returns the sequence of such sequences for
all dimensions.</p>
<p>EXAMPLES: All faces of the 3-dimensional octahedron:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">[[0], [1], [2], [3], [4], [5]],</span>
<span class="go">[[1, 5], [0, 5], [0, 1], [3, 5], [1, 3], [4, 5], [0, 4], [3, 4], [1, 2], [0, 2], [2, 3], [2, 4]],</span>
<span class="go">[[0, 1, 5], [1, 3, 5], [0, 4, 5], [3, 4, 5], [0, 1, 2], [1, 2, 3], [0, 2, 4], [2, 3, 4]]</span>
<span class="go">]</span>
</pre></div>
</div>
<p>Its faces of dimension one (i.e., edges):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[[1, 5], [0, 5], [0, 1], [3, 5], [1, 3], [4, 5], [0, 4], [3, 4], [1, 2], [0, 2], [2, 3], [2, 4]]</span>
</pre></div>
</div>
<p>Its faces of codimension two (also edges):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">codim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[[1, 5], [0, 5], [0, 1], [3, 5], [1, 3], [4, 5], [0, 4], [3, 4], [1, 2], [0, 2], [2, 3], [2, 4]]</span>
</pre></div>
</div>
<p>It is an error to specify both dimension and codimension at the
same time, even if they do agree:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">codim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">Both dim and codim are given!</span>
</pre></div>
</div>
<p>The only faces of a zero-dimensional polytope are the empty set and
the polytope itself, i.e. it has no proper faces at all:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M(1)</span>
<span class="go">in 1-d lattice M</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>In particular, you an exception will be raised if you try to access
faces of the given dimension or codimension, including edges and
facets:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">facets</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">IndexError</span>: <span class="n-Identifier">list index out of range</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.facet_constant">
<tt class="descname">facet_constant</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.facet_constant" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the constant in the <tt class="docutils literal"><span class="pre">i</span></tt>-th facet inequality of this polytope.</p>
<p>The i-th facet inequality is given by
self.facet_normal(i) * X + self.facet_constant(i) &gt;= 0.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">i</span></tt> - integer, the index of the facet</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>integer &#8211; the constant in the <tt class="docutils literal"><span class="pre">i</span></tt>-th facet inequality.</li>
</ul>
<p>EXAMPLES:</p>
<p>Let&#8217;s take a look at facets of the octahedron and some polytopes
inside it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0),</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0,  0),</span>
<span class="go">M( 0, -1,  0),</span>
<span class="go">M( 0,  0, -1)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">facet_normal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">N(-1, -1, 1)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">facet_constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0,  0),</span>
<span class="go">M( 0, -1,  0),</span>
<span class="go">M( 0,  0, -1)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">facet_normal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">N(-1, 0, 0)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">facet_constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M(0,  1,  0),</span>
<span class="go">M(0,  0,  1),</span>
<span class="go">M(0, -1,  0),</span>
<span class="go">M(0,  0, -1)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">facet_normal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">N(0, -1, 1)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">facet_constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>This is a 2-dimensional lattice polytope in a 4-dimensional space:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span>
<span class="go">2-d lattice polytope in 4-d lattice M</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1, -1, 1, 3),</span>
<span class="go">M(-1, -1, 1, 3),</span>
<span class="go">M( 0,  0, 0, 0)</span>
<span class="go">in 4-d lattice M</span>
<span class="gp">sage: </span><span class="n">fns</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">facet_normal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">nfacets</span><span class="p">())]</span>
<span class="gp">sage: </span><span class="n">fns</span>
<span class="go">[N(11, -1, 1, 3), N(-11, -1, 1, 3), N(0, 1, -1, -3)]</span>
<span class="gp">sage: </span><span class="n">fcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">facet_constant</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">nfacets</span><span class="p">())]</span>
<span class="gp">sage: </span><span class="n">fcs</span>
<span class="go">[0, 0, 11]</span>
</pre></div>
</div>
<p>Now we manually compute the distance matrix of this polytope. Since it
is a triangle, each line (corresponding to a facet) should have two
zeros (vertices of the corresponding facet) and one positive number
(since our normals are inner):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">matrix</span><span class="p">([[</span><span class="n">fns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="n">fcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">... </span>           <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">nvertices</span><span class="p">())]</span>
<span class="gp">... </span>          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">nfacets</span><span class="p">())])</span>
<span class="go">[22  0  0]</span>
<span class="go">[ 0 22  0]</span>
<span class="go">[ 0  0 11]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.facet_constants">
<tt class="descname">facet_constants</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.facet_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Return facet constants of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>an integer vector.</li>
</ul>
<p>EXAMPLES:</p>
<p>For reflexive polytopes all constants are 1:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0),</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0,  0),</span>
<span class="go">M( 0, -1,  0),</span>
<span class="go">M( 0,  0, -1)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">facet_constants</span><span class="p">()</span>
<span class="go">(1, 1, 1, 1, 1, 1, 1, 1)</span>
</pre></div>
</div>
<p>Here is an example of a 3-dimensional polytope in a 4-dimensional
space with 3 facets containing the origin:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span>
<span class="gp">... </span>                       <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 0,  0, 0, 0),</span>
<span class="go">M( 1,  1, 1, 3),</span>
<span class="go">M( 1, -1, 1, 3),</span>
<span class="go">M(-1, -1, 1, 3)</span>
<span class="go">in 4-d lattice M</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">facet_constants</span><span class="p">()</span>
<span class="go">(0, 0, 0, 10)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.facet_normal">
<tt class="descname">facet_normal</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.facet_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inner normal to the <tt class="docutils literal"><span class="pre">i</span></tt>-th facet of this polytope.</p>
<p>If this polytope is not full-dimensional, facet normals will be
orthogonal to the integer kernel of the affine subspace spanned by
this polytope.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">i</span></tt> &#8211; integer, the index of the facet</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>vectors &#8211; the inner normal of the <tt class="docutils literal"><span class="pre">i</span></tt>-th facet</li>
</ul>
<p>EXAMPLES:</p>
<p>Let&#8217;s take a look at facets of the octahedron and some polytopes
inside it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0),</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0,  0),</span>
<span class="go">M( 0, -1,  0),</span>
<span class="go">M( 0,  0, -1)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">facet_normal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">N(-1, -1, 1)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">facet_constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0,  0),</span>
<span class="go">M( 0, -1,  0),</span>
<span class="go">M( 0,  0, -1)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">facet_normal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">N(-1, 0, 0)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">facet_constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M(0,  1,  0),</span>
<span class="go">M(0,  0,  1),</span>
<span class="go">M(0, -1,  0),</span>
<span class="go">M(0,  0, -1)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">facet_normal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">N(0, -1, 1)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">facet_constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Here is an example of a 3-dimensional polytope in a 4-dimensional
space:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span>
<span class="gp">... </span>                       <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 0,  0, 0, 0),</span>
<span class="go">M( 1,  1, 1, 3),</span>
<span class="go">M( 1, -1, 1, 3),</span>
<span class="go">M(-1, -1, 1, 3)</span>
<span class="go">in 4-d lattice M</span>
<span class="gp">sage: </span><span class="n">ker</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span><span class="o">.</span><span class="n">column_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">integer_kernel</span><span class="p">()</span><span class="o">.</span><span class="n">matrix</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ker</span>
<span class="go">[ 0  0  3 -1]</span>
<span class="gp">sage: </span><span class="n">ker</span> <span class="o">*</span> <span class="n">p</span><span class="o">.</span><span class="n">facet_normals</span><span class="p">()</span>
<span class="go">[0 0 0 0]</span>
</pre></div>
</div>
<p>Now we manually compute the distance matrix of this polytope. Since it
is a simplex, each line (corresponding to a facet) should consist of
zeros (indicating generating vertices of the corresponding facet) and
a single positive number (since our normals are inner):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">matrix</span><span class="p">([[</span><span class="n">p</span><span class="o">.</span><span class="n">facet_normal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
<span class="gp">... </span>           <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">facet_constant</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">... </span>           <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">nvertices</span><span class="p">())]</span>
<span class="gp">... </span>          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">nfacets</span><span class="p">())])</span>
<span class="go">[ 0  0  0 20]</span>
<span class="go">[ 0  0 20  0]</span>
<span class="go">[ 0 20  0  0]</span>
<span class="go">[10  0  0  0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.facet_normals">
<tt class="descname">facet_normals</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.facet_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return inner normals to the facets of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a <tt class="xref py py-class docutils literal"><span class="pre">point</span> <span class="pre">collection</span></tt> in the
<a class="reference internal" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.dual_lattice" title="sage.geometry.lattice_polytope.LatticePolytopeClass.dual_lattice"><tt class="xref py py-meth docutils literal"><span class="pre">dual_lattice()</span></tt></a> of <tt class="docutils literal"><span class="pre">self</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<p>Normals to facets of an octahedron are vertices of a cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0),</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0,  0),</span>
<span class="go">M( 0, -1,  0),</span>
<span class="go">M( 0,  0, -1)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">facet_normals</span><span class="p">()</span>
<span class="go">N(-1, -1,  1),</span>
<span class="go">N( 1, -1,  1),</span>
<span class="go">N(-1,  1,  1),</span>
<span class="go">N( 1,  1,  1),</span>
<span class="go">N(-1, -1, -1),</span>
<span class="go">N( 1, -1, -1),</span>
<span class="go">N(-1,  1, -1),</span>
<span class="go">N( 1,  1, -1)</span>
<span class="go">in 3-d lattice N</span>
</pre></div>
</div>
<p>Here is an example of a 3-dimensional polytope in a 4-dimensional
space:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span>
<span class="gp">... </span>                       <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 0,  0, 0, 0),</span>
<span class="go">M( 1,  1, 1, 3),</span>
<span class="go">M( 1, -1, 1, 3),</span>
<span class="go">M(-1, -1, 1, 3)</span>
<span class="go">in 4-d lattice M</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">facet_normals</span><span class="p">()</span>
<span class="go">N(-10,   0,  1,  3),</span>
<span class="go">N( 10, -10,  0,  0),</span>
<span class="go">N(  0,  10,  1,  3),</span>
<span class="go">N(  0,   0, -1, -3)</span>
<span class="go">in 4-d lattice N</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.facets">
<tt class="descname">facets</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sequence of facets of this polytope (i.e. faces of
codimension 1).</p>
<p>EXAMPLES: All facets of the 3-dimensional octahedron:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">facets</span><span class="p">()</span>
<span class="go">[[0, 1, 5], [1, 3, 5], [0, 4, 5], [3, 4, 5], [0, 1, 2], [1, 2, 3], [0, 2, 4], [2, 3, 4]]</span>
</pre></div>
</div>
<p>Facets are the same as faces of codimension one:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">facets</span><span class="p">()</span> <span class="ow">is</span> <span class="n">o</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">codim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.index">
<tt class="descname">index</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of this polytope in the internal database of 2- or
3-dimensional reflexive polytopes. Databases are stored in the
directory of the package.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The first call to this function for each dimension can take
a few seconds while the dictionary of all polytopes is
constructed, but after that it is cached and fast.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>EXAMPLES: We check what is the index of the &#8220;diamond&#8221; in the
database:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">index</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Note that polytopes with the same index are not necessarily the
same:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0),</span>
<span class="go">M( 0,  1),</span>
<span class="go">M(-1,  0),</span>
<span class="go">M( 0, -1)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">ReflexivePolytope</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0),</span>
<span class="go">M( 0,  1),</span>
<span class="go">M( 0, -1),</span>
<span class="go">M(-1,  0)</span>
<span class="go">in 2-d lattice M</span>
</pre></div>
</div>
<p>But they are in the same <span class="math">\(GL(Z^n)\)</span> orbit and have the same
normal form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">normal_form_pc</span><span class="p">()</span>
<span class="go">M( 1,  0),</span>
<span class="go">M( 0,  1),</span>
<span class="go">M( 0, -1),</span>
<span class="go">M(-1,  0)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">ReflexivePolytope</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">normal_form_pc</span><span class="p">()</span>
<span class="go">M( 1,  0),</span>
<span class="go">M( 0,  1),</span>
<span class="go">M( 0, -1),</span>
<span class="go">M(-1,  0)</span>
<span class="go">in 2-d lattice M</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.is_reflexive">
<tt class="descname">is_reflexive</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.is_reflexive" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if this polytope is reflexive.</p>
<p>EXAMPLES: The 3-dimensional octahedron is reflexive (and 4318 other
3-polytopes):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">is_reflexive</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But not all polytopes are reflexive:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">is_reflexive</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Only full-dimensional polytopes can be reflexive (otherwise the polar
set is not a polytope at all, since it is unbounded):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">is_reflexive</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.lattice">
<tt class="descname">lattice</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ambient lattice of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a lattice.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">lattice</span><span class="p">()</span>
<span class="go">3-d lattice M</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.linearly_independent_vertices">
<tt class="descname">linearly_independent_vertices</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.linearly_independent_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a maximal set of linearly independent vertices.</p>
<p>OUTPUT:</p>
<p>A tuple of vertex indices.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">linearly_independent_vertices</span><span class="p">()</span>
<span class="go">(1, 2)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">linearly_independent_vertices</span><span class="p">()</span>
<span class="go">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">linearly_independent_vertices</span><span class="p">()</span>
<span class="go">(0,)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.nef_partitions">
<tt class="descname">nef_partitions</tt><big>(</big><em>keep_symmetric=False</em>, <em>keep_products=True</em>, <em>keep_projections=True</em>, <em>hodge_numbers=False</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.nef_partitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 2-part nef-partitions of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">keep_symmetric</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) if <tt class="docutils literal"><span class="pre">True</span></tt>, &#8220;-s&#8221; option
will be passed to <tt class="docutils literal"><span class="pre">nef.x</span></tt> in order to keep symmetric partitions,
i.e. partitions related by lattice automorphisms preserving <tt class="docutils literal"><span class="pre">self</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">keep_products</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) if <tt class="docutils literal"><span class="pre">True</span></tt>, &#8220;-D&#8221; option
will be passed to <tt class="docutils literal"><span class="pre">nef.x</span></tt> in order to keep product partitions,
with corresponding complete intersections being direct products;</li>
<li><tt class="docutils literal"><span class="pre">keep_projections</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">True</span></tt>) if <tt class="docutils literal"><span class="pre">True</span></tt>, &#8220;-P&#8221; option
will be passed to <tt class="docutils literal"><span class="pre">nef.x</span></tt> in order to keep projection partitions,
i.e. partitions with one of the parts consisting of a single vertex;</li>
<li><tt class="docutils literal"><span class="pre">hodge_numbers</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) if <tt class="docutils literal"><span class="pre">False</span></tt>, &#8220;-p&#8221; option
will be passed to <tt class="docutils literal"><span class="pre">nef.x</span></tt> in order to skip Hodge numbers
computation, which takes a lot of time.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a sequence of <a class="reference internal" href="#sage.geometry.lattice_polytope.NefPartition" title="sage.geometry.lattice_polytope.NefPartition"><tt class="xref py py-class docutils literal"><span class="pre">nef-partitions</span></tt></a>.</li>
</ul>
<p>Type <tt class="docutils literal"><span class="pre">NefPartition?</span></tt> for definitions and notation.</p>
<p>EXAMPLES:</p>
<p>Nef-partitions of the 4-dimensional cross-polytope:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">Nef-partition {0, 1, 4, 5} U {2, 3, 6, 7} (direct product),</span>
<span class="go">Nef-partition {0, 1, 2, 4} U {3, 5, 6, 7},</span>
<span class="go">Nef-partition {0, 1, 2, 4, 5} U {3, 6, 7},</span>
<span class="go">Nef-partition {0, 1, 2, 4, 5, 6} U {3, 7} (direct product),</span>
<span class="go">Nef-partition {0, 1, 2, 3} U {4, 5, 6, 7},</span>
<span class="go">Nef-partition {0, 1, 2, 3, 4} U {5, 6, 7},</span>
<span class="go">Nef-partition {0, 1, 2, 3, 4, 5} U {6, 7},</span>
<span class="go">Nef-partition {0, 1, 2, 3, 4, 5, 6} U {7} (projection)</span>
<span class="go">]</span>
</pre></div>
</div>
<p>Now we omit projections:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">(</span><span class="n">keep_projections</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">[</span>
<span class="go">Nef-partition {0, 1, 4, 5} U {2, 3, 6, 7} (direct product),</span>
<span class="go">Nef-partition {0, 1, 2, 4} U {3, 5, 6, 7},</span>
<span class="go">Nef-partition {0, 1, 2, 4, 5} U {3, 6, 7},</span>
<span class="go">Nef-partition {0, 1, 2, 4, 5, 6} U {3, 7} (direct product),</span>
<span class="go">Nef-partition {0, 1, 2, 3} U {4, 5, 6, 7},</span>
<span class="go">Nef-partition {0, 1, 2, 3, 4} U {5, 6, 7},</span>
<span class="go">Nef-partition {0, 1, 2, 3, 4, 5} U {6, 7}</span>
<span class="go">]</span>
</pre></div>
</div>
<p>Currently Hodge numbers cannot be computed for a given nef-partition:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">hodge_numbers</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">NotImplementedError</span>: <span class="n-Identifier">use nef_partitions(hodge_numbers=True)!</span>
</pre></div>
</div>
<p>But they can be obtained from <tt class="docutils literal"><span class="pre">nef.x</span></tt> for all nef-partitions at once.
Partitions will be exactly the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">(</span><span class="n">hodge_numbers</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># long time (2s on sage.math, 2011)</span>
<span class="go">[</span>
<span class="go">Nef-partition {0, 1, 4, 5} U {2, 3, 6, 7} (direct product),</span>
<span class="go">Nef-partition {0, 1, 2, 4} U {3, 5, 6, 7},</span>
<span class="go">Nef-partition {0, 1, 2, 4, 5} U {3, 6, 7},</span>
<span class="go">Nef-partition {0, 1, 2, 4, 5, 6} U {3, 7} (direct product),</span>
<span class="go">Nef-partition {0, 1, 2, 3} U {4, 5, 6, 7},</span>
<span class="go">Nef-partition {0, 1, 2, 3, 4} U {5, 6, 7},</span>
<span class="go">Nef-partition {0, 1, 2, 3, 4, 5} U {6, 7},</span>
<span class="go">Nef-partition {0, 1, 2, 3, 4, 5, 6} U {7} (projection)</span>
<span class="go">]</span>
</pre></div>
</div>
<p>Now it is possible to get Hodge numbers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">(</span><span class="n">hodge_numbers</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">hodge_numbers</span><span class="p">()</span>
<span class="go">(20,)</span>
</pre></div>
</div>
<p>Since nef-partitions are cached, their Hodge numbers are accessible
after the first request, even if you do not specify
<tt class="docutils literal"><span class="pre">hodge_numbers=True</span></tt> anymore:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">hodge_numbers</span><span class="p">()</span>
<span class="go">(20,)</span>
</pre></div>
</div>
<p>We illustrate removal of symmetric partitions on a diamond:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">Nef-partition {0, 2} U {1, 3} (direct product),</span>
<span class="go">Nef-partition {0, 1} U {2, 3},</span>
<span class="go">Nef-partition {0, 1, 2} U {3} (projection)</span>
<span class="go">]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">(</span><span class="n">keep_symmetric</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[</span>
<span class="go">Nef-partition {0, 1, 3} U {2} (projection),</span>
<span class="go">Nef-partition {0, 2, 3} U {1} (projection),</span>
<span class="go">Nef-partition {0, 3} U {1, 2},</span>
<span class="go">Nef-partition {1, 2, 3} U {0} (projection),</span>
<span class="go">Nef-partition {1, 3} U {0, 2} (direct product),</span>
<span class="go">Nef-partition {2, 3} U {0, 1},</span>
<span class="go">Nef-partition {0, 1, 2} U {3} (projection)</span>
<span class="go">]</span>
</pre></div>
</div>
<p>Nef-partitions can be computed only for reflexive polytopes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span>                       <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">The given polytope is not reflexive!</span>
<span class="go">Polytope: 3-d lattice polytope in 3-d lattice M</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.nef_x">
<tt class="descname">nef_x</tt><big>(</big><em>keys</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.nef_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Run nef.x with given <tt class="docutils literal"><span class="pre">keys</span></tt> on vertices of this
polytope.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">keys</span></tt> - a string of options passed to nef.x. The
key &#8220;-f&#8221; is added automatically.</li>
</ul>
<p>OUTPUT: the output of nef.x as a string.</p>
<p>EXAMPLES: This call is used internally for computing
nef-partitions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">nef_x</span><span class="p">(</span><span class="s">&quot;-N -V -p&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span>                      <span class="c"># output contains random time</span>
<span class="go">M:27 8 N:7 6  codim=2 #part=5</span>
<span class="go">3 6  Vertices of P:</span>
<span class="go">    1    0    0   -1    0    0</span>
<span class="go">    0    1    0    0   -1    0</span>
<span class="go">    0    0    1    0    0   -1</span>
<span class="go"> P:0 V:2 4 5       0sec  0cpu</span>
<span class="go"> P:2 V:3 4 5       0sec  0cpu</span>
<span class="go"> P:3 V:4 5       0sec  0cpu</span>
<span class="go">np=3 d:1 p:1    0sec     0cpu</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.nfacets">
<tt class="descname">nfacets</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.nfacets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of facets of this polytope.</p>
<p>EXAMPLES: The number of facets of the 3-dimensional octahedron:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">nfacets</span><span class="p">()</span>
<span class="go">8</span>
</pre></div>
</div>
<p>The number of facets of an interval is 2:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LatticePolytope</span><span class="p">(([</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">nfacets</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Now consider a 2-dimensional diamond in a 3-dimensional space:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">nfacets</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.normal_form">
<tt class="descname">normal_form</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.normal_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normal form of <tt class="docutils literal"><span class="pre">self</span></tt> as a matrix.</p>
<p>EXAMPLES:</p>
<p>We compute the normal form of the &#8220;diamond&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">normal_form</span><span class="p">()</span>
<span class="go">doctest:...: DeprecationWarning: normal_form() output will change,</span>
<span class="go">please use normal_form_pc().column_matrix() instead</span>
<span class="go">or consider using normal_form_pc() directly!</span>
<span class="go">See http://trac.sagemath.org/15240 for details.</span>
<span class="go">[ 1  0  0  0  0 -1]</span>
<span class="go">[ 0  1  0  0 -1  0]</span>
<span class="go">[ 0  0  1 -1  0  0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.normal_form_pc">
<tt class="descname">normal_form_pc</tt><big>(</big><em>algorithm='palp'</em>, <em>permutation=False</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.normal_form_pc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normal form of vertices of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>Two full-dimensional lattice polytopes are in the same
<tt class="docutils literal"><span class="pre">GL(\mathbb{Z})</span></tt>-orbit if and only if their normal forms are the
same. Normal form is not defined and thus cannot be used for polytopes
whose dimension is smaller than the dimension of the ambient space.</p>
<p>The original algorithm was presented in <a class="reference internal" href="#ks98" id="id1">[KS98]</a> and implemented
in PALP. A modified version of the PALP algorithm is discussed in
<a class="reference internal" href="#gk13" id="id2">[GK13]</a> and available here as &#8220;palp_modified&#8221;.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">algorithm</span></tt> &#8211; (default: &#8220;palp&#8221;) The algorithm which is used
to compute the normal form. Options are:<ul>
<li>&#8220;palp&#8221; &#8211; Run external PALP code, usually the fastest option.</li>
<li>&#8220;palp_native&#8221; &#8211; The original PALP algorithm implemented
in sage. Currently considerably slower than PALP.</li>
<li>&#8220;palp_modified&#8221; &#8211; A modified version of the PALP
algorithm which determines the maximal vertex-facet
pairing matrix first and then computes its
automorphisms, while the PALP algorithm does both things
concurrently.</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">permutation</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) If <tt class="docutils literal"><span class="pre">True</span></tt> the permutation
applied to vertices to obtain the normal form is returned as well.
Note that the different algorithms may return different results
that nevertheless lead to the same normal form.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a <tt class="xref py py-class docutils literal"><span class="pre">point</span> <span class="pre">collection</span></tt> in the <a class="reference internal" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.lattice" title="sage.geometry.lattice_polytope.LatticePolytopeClass.lattice"><tt class="xref py py-meth docutils literal"><span class="pre">lattice()</span></tt></a>
of <tt class="docutils literal"><span class="pre">self</span></tt> or a tuple of it and a permutation.</li>
</ul>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="ks98" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[KS98]</a></td><td>Maximilian Kreuzer and Harald Skarke, Classification of
Reflexive Polyhedra in Three Dimensions, arXiv:hep-th/9805190</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="gk13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[GK13]</a></td><td>Roland Grinis and Alexander Kasprzyk, Normal forms of
convex lattice polytopes, arXiv:1301.6641</td></tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<p>We compute the normal form of the &#8220;diamond&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0),</span>
<span class="go">M( 0,  1),</span>
<span class="go">M(-1,  0),</span>
<span class="go">M( 0, -1)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">normal_form_pc</span><span class="p">()</span>
<span class="go">M( 1,  0),</span>
<span class="go">M( 0,  1),</span>
<span class="go">M( 0, -1),</span>
<span class="go">M(-1,  0)</span>
<span class="go">in 2-d lattice M</span>
</pre></div>
</div>
<p>The diamond is the 3rd polytope in the internal database:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">index</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">d</span>
<span class="go">2-d reflexive polytope #3 in 2-d lattice M</span>
</pre></div>
</div>
<p>You can get it in its normal form (in the default lattice) as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">ReflexivePolytope</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0),</span>
<span class="go">M( 0,  1),</span>
<span class="go">M( 0, -1),</span>
<span class="go">M(-1,  0)</span>
<span class="go">in 2-d lattice M</span>
</pre></div>
</div>
<p>It is not possible to compute normal forms for polytopes which do not
span the space:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">normal_form</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">normal form is not defined for</span>
<span class="go">2-d lattice polytope in 3-d lattice M</span>
</pre></div>
</div>
<p>We can perform the same examples using other algorithms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">normal_form_pc</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s">&quot;palp_native&quot;</span><span class="p">)</span>
<span class="go">M( 1,  0),</span>
<span class="go">M( 0,  1),</span>
<span class="go">M( 0, -1),</span>
<span class="go">M(-1,  0)</span>
<span class="go">in 2-d lattice M</span>

<span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">normal_form_pc</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s">&quot;palp_modified&quot;</span><span class="p">)</span>
<span class="go">M( 1,  0),</span>
<span class="go">M( 0,  1),</span>
<span class="go">M( 0, -1),</span>
<span class="go">M(-1,  0)</span>
<span class="go">in 2-d lattice M</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.npoints">
<tt class="descname">npoints</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.npoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of lattice points of this polytope.</p>
<p>EXAMPLES: The number of lattice points of the 3-dimensional
octahedron and its polar cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
<span class="go">7</span>
<span class="gp">sage: </span><span class="n">cube</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">cube</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
<span class="go">27</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.nvertices">
<tt class="descname">nvertices</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.nvertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of vertices of this polytope.</p>
<p>EXAMPLES: The number of vertices of the 3-dimensional octahedron
and its polar cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">nvertices</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">cube</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">cube</span><span class="o">.</span><span class="n">nvertices</span><span class="p">()</span>
<span class="go">8</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.origin">
<tt class="descname">origin</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the origin in the list of points of self.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>integer if the origin belongs to this polytope, <tt class="docutils literal"><span class="pre">None</span></tt> otherwise.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">origin</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">origin</span><span class="p">())</span>
<span class="go">M(0, 0)</span>

<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">(([</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">points_pc</span><span class="p">()</span>
<span class="go">M(1),</span>
<span class="go">M(2)</span>
<span class="go">in 1-d lattice M</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="n">p</span><span class="o">.</span><span class="n">origin</span><span class="p">()</span>
<span class="go">None</span>
</pre></div>
</div>
<p>Now we make sure that the origin of non-full-dimensional polytopes can
be identified correctly (Trac #10661):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span><span class="o">.</span><span class="n">origin</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.parent">
<tt class="descname">parent</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of all lattice polytopes.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Set of all Lattice Polytopes</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.plot3d">
<tt class="descname">plot3d</tt><big>(</big><em>show_facets=True</em>, <em>facet_opacity=0.5</em>, <em>facet_color=(0</em>, <em>1</em>, <em>0)</em>, <em>facet_colors=None</em>, <em>show_edges=True</em>, <em>edge_thickness=3</em>, <em>edge_color=(0.5</em>, <em>0.5</em>, <em>0.5)</em>, <em>show_vertices=True</em>, <em>vertex_size=10</em>, <em>vertex_color=(1</em>, <em>0</em>, <em>0)</em>, <em>show_points=True</em>, <em>point_size=10</em>, <em>point_color=(0</em>, <em>0</em>, <em>1)</em>, <em>show_vindices=None</em>, <em>vindex_color=(0</em>, <em>0</em>, <em>0)</em>, <em>vlabels=None</em>, <em>show_pindices=None</em>, <em>pindex_color=(0</em>, <em>0</em>, <em>0)</em>, <em>index_shift=1.1</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.plot3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 3d-plot of this polytope.</p>
<p>Polytopes with ambient dimension 1 and 2 will be plotted along x-axis
or in xy-plane respectively. Polytopes of dimension 3 and less with
ambient dimension 4 and greater will be plotted in some basis of the
spanned space.</p>
<p>By default, everything is shown with more or less pretty
combination of size and color parameters.</p>
<p>INPUT: Most of the parameters are self-explanatory:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">show_facets</span></tt> - (default:True)</li>
<li><tt class="docutils literal"><span class="pre">facet_opacity</span></tt> - (default:0.5)</li>
<li><tt class="docutils literal"><span class="pre">facet_color</span></tt> - (default:(0,1,0))</li>
<li><tt class="docutils literal"><span class="pre">facet_colors</span></tt> - (default:None) if specified, must be a list of
colors for each facet separately, used instead of <tt class="docutils literal"><span class="pre">facet_color</span></tt></li>
<li><tt class="docutils literal"><span class="pre">show_edges</span></tt> - (default:True) whether to draw
edges as lines</li>
<li><tt class="docutils literal"><span class="pre">edge_thickness</span></tt> - (default:3)</li>
<li><tt class="docutils literal"><span class="pre">edge_color</span></tt> - (default:(0.5,0.5,0.5))</li>
<li><tt class="docutils literal"><span class="pre">show_vertices</span></tt> - (default:True) whether to draw
vertices as balls</li>
<li><tt class="docutils literal"><span class="pre">vertex_size</span></tt> - (default:10)</li>
<li><tt class="docutils literal"><span class="pre">vertex_color</span></tt> - (default:(1,0,0))</li>
<li><tt class="docutils literal"><span class="pre">show_points</span></tt> - (default:True) whether to draw
other poits as balls</li>
<li><tt class="docutils literal"><span class="pre">point_size</span></tt> - (default:10)</li>
<li><tt class="docutils literal"><span class="pre">point_color</span></tt> - (default:(0,0,1))</li>
<li><tt class="docutils literal"><span class="pre">show_vindices</span></tt> - (default:same as
show_vertices) whether to show indices of vertices</li>
<li><tt class="docutils literal"><span class="pre">vindex_color</span></tt> - (default:(0,0,0)) color for
vertex labels</li>
<li><tt class="docutils literal"><span class="pre">vlabels</span></tt> - (default:None) if specified, must be a list of labels
for each vertex, default labels are vertex indicies</li>
<li><tt class="docutils literal"><span class="pre">show_pindices</span></tt> - (default:same as show_points)
whether to show indices of other points</li>
<li><tt class="docutils literal"><span class="pre">pindex_color</span></tt> - (default:(0,0,0)) color for
point labels</li>
<li><tt class="docutils literal"><span class="pre">index_shift</span></tt> - (default:1.1)) if 1, labels are
placed exactly at the corresponding points. Otherwise the label
position is computed as a multiple of the point position vector.</li>
</ul>
<p>EXAMPLES: The default plot of a cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">plot3d</span><span class="p">()</span>
<span class="go">Graphics3d Object</span>
</pre></div>
</div>
<p>Plot without facets and points, shown without the frame:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">plot3d</span><span class="p">(</span><span class="n">show_facets</span><span class="o">=</span><span class="n">false</span><span class="p">,</span><span class="n">show_points</span><span class="o">=</span><span class="n">false</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Plot with facets of different colors:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">plot3d</span><span class="p">(</span><span class="n">facet_colors</span><span class="o">=</span><span class="n">rainbow</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nfacets</span><span class="p">(),</span> <span class="s">&#39;rgbtuple&#39;</span><span class="p">))</span>
<span class="go">Graphics3d Object</span>
</pre></div>
</div>
<p>It is also possible to plot lower dimensional polytops in 3D (let&#8217;s
also change labels of vertices):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">plot3d</span><span class="p">(</span><span class="n">vlabels</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="s">&quot;D&quot;</span><span class="p">])</span>
<span class="go">Graphics3d Object</span>
</pre></div>
</div>
<p>TESTS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">plot3d</span><span class="p">()</span>
<span class="go">Graphics3d Object</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.point">
<tt class="descname">point</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the i-th point of this polytope, i.e. the i-th column of the
matrix returned by points().</p>
<p>EXAMPLES: First few points are actually vertices:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0),</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0,  0),</span>
<span class="go">M( 0, -1,  0),</span>
<span class="go">M( 0,  0, -1)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">M(0, 1, 0)</span>
</pre></div>
</div>
<p>The only other point in the octahedron is the origin:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">M(0, 0, 0)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">points_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0),</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0,  0),</span>
<span class="go">M( 0, -1,  0),</span>
<span class="go">M( 0,  0, -1),</span>
<span class="go">M( 0,  0,  0)</span>
<span class="go">in 3-d lattice M</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.points">
<tt class="descname">points</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.points" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all lattice points of this polytope as columns of a matrix.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">points</span><span class="p">()</span>
<span class="go">doctest:...: DeprecationWarning: points() output will change,</span>
<span class="go">please use points_pc().column_matrix() instead or</span>
<span class="go">consider using points_pc() directly!</span>
<span class="go">See http://trac.sagemath.org/15240 for details.</span>
<span class="go">[ 1  0  0 -1  0  0  0]</span>
<span class="go">[ 0  1  0  0 -1  0  0]</span>
<span class="go">[ 0  0  1  0  0 -1  0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.points_pc">
<tt class="descname">points_pc</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.points_pc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all lattice points of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a <tt class="xref py py-class docutils literal"><span class="pre">point</span> <span class="pre">collection</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<p>Lattice points of the octahedron and its polar cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">points_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0),</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0,  0),</span>
<span class="go">M( 0, -1,  0),</span>
<span class="go">M( 0,  0, -1),</span>
<span class="go">M( 0,  0,  0)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">cube</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">cube</span><span class="o">.</span><span class="n">points_pc</span><span class="p">()</span>
<span class="go">N(-1, -1,  1),</span>
<span class="go">N( 1, -1,  1),</span>
<span class="go">N(-1,  1,  1),</span>
<span class="go">N( 1,  1,  1),</span>
<span class="go">N(-1, -1, -1),</span>
<span class="go">N( 1, -1, -1),</span>
<span class="go">N(-1,  1, -1),</span>
<span class="go">N( 1,  1, -1),</span>
<span class="go">N(-1, -1,  0),</span>
<span class="go">N(-1,  0, -1),</span>
<span class="go">N(-1,  0,  0),</span>
<span class="go">N(-1,  0,  1),</span>
<span class="go">N(-1,  1,  0),</span>
<span class="go">N( 0, -1, -1),</span>
<span class="go">N( 0, -1,  0),</span>
<span class="go">N( 0, -1,  1),</span>
<span class="go">N( 0,  0, -1),</span>
<span class="go">N( 0,  0,  0),</span>
<span class="go">N( 0,  0,  1),</span>
<span class="go">N( 0,  1, -1),</span>
<span class="go">N( 0,  1,  0),</span>
<span class="go">N( 0,  1,  1),</span>
<span class="go">N( 1, -1,  0),</span>
<span class="go">N( 1,  0, -1),</span>
<span class="go">N( 1,  0,  0),</span>
<span class="go">N( 1,  0,  1),</span>
<span class="go">N( 1,  1,  0)</span>
<span class="go">in 3-d lattice N</span>
</pre></div>
</div>
<p>Lattice points of a 2-dimensional diamond in a 3-dimensional space:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">points_pc</span><span class="p">()</span>
<span class="go">M( 1,  0, 0),</span>
<span class="go">M( 0,  1, 0),</span>
<span class="go">M(-1,  0, 0),</span>
<span class="go">M( 0, -1, 0),</span>
<span class="go">M( 0,  0, 0)</span>
<span class="go">in 3-d lattice M</span>
</pre></div>
</div>
<p>We check that points of a zero-dimensional polytope can be computed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">points_pc</span><span class="p">()</span>
<span class="go">M(1)</span>
<span class="go">in 1-d lattice M</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.polar">
<tt class="descname">polar</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.polar" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the polar polytope, if this polytope is reflexive.</p>
<p>EXAMPLES: The polar polytope to the 3-dimensional octahedron:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cube</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">cube</span>
<span class="go">3-d reflexive polytope in 3-d lattice N</span>
</pre></div>
</div>
<p>The polar polytope &#8220;remembers&#8221; the original one:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">cube</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span>
<span class="go">3-d reflexive polytope in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">cube</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span> <span class="ow">is</span> <span class="n">cube</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Only reflexive polytopes have polars:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span>                       <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">The given polytope is not reflexive!</span>
<span class="go">Polytope: 3-d lattice polytope in 3-d lattice M</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.poly_x">
<tt class="descname">poly_x</tt><big>(</big><em>keys</em>, <em>reduce_dimension=False</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.poly_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Run poly.x with given <tt class="docutils literal"><span class="pre">keys</span></tt> on vertices of this
polytope.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">keys</span></tt> - a string of options passed to poly.x. The
key &#8220;f&#8221; is added automatically.</li>
<li><tt class="docutils literal"><span class="pre">reduce_dimension</span></tt> - (default: False) if <tt class="docutils literal"><span class="pre">True</span></tt> and this
polytope is not full-dimensional, poly.x will be called for the
vertices of this polytope in some basis of the spanned affine space.</li>
</ul>
<p>OUTPUT: the output of poly.x as a string.</p>
<p>EXAMPLES: This call is used for determining if a polytope is
reflexive or not:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span> <span class="n">o</span><span class="o">.</span><span class="n">poly_x</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">)</span>
<span class="go">8 3  Vertices of P-dual &lt;-&gt; Equations of P</span>
<span class="go">  -1  -1   1</span>
<span class="go">   1  -1   1</span>
<span class="go">  -1   1   1</span>
<span class="go">   1   1   1</span>
<span class="go">  -1  -1  -1</span>
<span class="go">   1  -1  -1</span>
<span class="go">  -1   1  -1</span>
<span class="go">   1   1  -1</span>
</pre></div>
</div>
<p>Since PALP has limits on different parameters determined during
compilation, the following code is likely to fail, unless you
change default settings of PALP:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">BIG</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BIG</span>
<span class="go">7-d lattice polytope in 7-d lattice M</span>
<span class="gp">sage: </span><span class="n">BIG</span><span class="o">.</span><span class="n">poly_x</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">)</span>      <span class="c"># possibly different output depending on your system</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">Error executing &#39;poly.x -fe&#39; for the given polytope!</span>
<span class="go">Output:</span>
<span class="go">Please increase POLY_Dmax to at least 7</span>
</pre></div>
</div>
<p>You cannot call poly.x for polytopes that don&#8217;t span the space (if you
could, it would crush anyway):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">poly_x</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">Cannot run PALP for a 2-dimensional polytope in a 3-dimensional space!</span>
</pre></div>
</div>
<p>But if you know what you are doing, you can call it for the polytope in
some basis of the spanned space:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="k">print</span> <span class="n">p</span><span class="o">.</span><span class="n">poly_x</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">reduce_dimension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">4 2  Equations of P</span>
<span class="go">  -1   1     0</span>
<span class="go">   1   1     2</span>
<span class="go">  -1  -1     0</span>
<span class="go">   1  -1     2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.show3d">
<tt class="descname">show3d</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.show3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Show a 3d picture of the polytope with default settings and without axes or frame.</p>
<p>See self.plot3d? for more details.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">show3d</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.skeleton">
<tt class="descname">skeleton</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.skeleton" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the graph of the one-skeleton of this polytope.</p>
<p>EXAMPLES: We construct the one-skeleton graph for the &#8220;diamond&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">skeleton</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span>
<span class="go">Graph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 3, None), (1, 2, None), (2, 3, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.skeleton_points">
<tt class="descname">skeleton_points</tt><big>(</big><em>k=1</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.skeleton_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the increasing list of indices of lattice points in
k-skeleton of the polytope (k is 1 by default).</p>
<p>EXAMPLES: We compute all skeleton points for the cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">skeleton_points</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 15, 19, 21, 22, 23, 25, 26]</span>
</pre></div>
</div>
<p>The default was 1-skeleton:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">skeleton_points</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 15, 19, 21, 22, 23, 25, 26]</span>
</pre></div>
</div>
<p>0-skeleton just lists all vertices:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">skeleton_points</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7]</span>
</pre></div>
</div>
<p>2-skeleton lists all points except for the origin (point #17):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">skeleton_points</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 26]</span>
</pre></div>
</div>
<p>3-skeleton includes all points:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">skeleton_points</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]</span>
</pre></div>
</div>
<p>It is OK to compute higher dimensional skeletons - you will get the
list of all points:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">skeleton_points</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.skeleton_show">
<tt class="descname">skeleton_show</tt><big>(</big><em>normal=None</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.skeleton_show" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the graph of one-skeleton of this polytope.
Works only for polytopes in a 3-dimensional space.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">normal</span></tt> - a 3-dimensional vector (can be given as
a list), which should be perpendicular to the screen. If not given,
will be selected randomly (new each time and it may be far from
&#8220;nice&#8221;).</li>
</ul>
<p>EXAMPLES: Show a pretty picture of the octahedron:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">skeleton_show</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
<p>Does not work for a diamond at the moment:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">skeleton_show</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">NotImplementedError</span>: <span class="n-Identifier">skeleton view is implemented only in 3-d space</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.traverse_boundary">
<tt class="descname">traverse_boundary</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.traverse_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of indices of vertices of a 2-dimensional polytope in their boundary order.</p>
<p>Needed for plot3d function of polytopes.</p>
<p>EXAMPLES:</p>
<blockquote>
<div>sage: p = lattice_polytope.cross_polytope(2).polar()
sage: p.traverse_boundary()
[0, 1, 3, 2]</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.vertex">
<tt class="descname">vertex</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the i-th vertex of this polytope, i.e. the i-th column of
the matrix returned by vertices().</p>
<p>EXAMPLES: Note that numeration starts with zero:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0),</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0,  0),</span>
<span class="go">M( 0, -1,  0),</span>
<span class="go">M( 0,  0, -1)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">M(-1, 0, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.vertex_facet_pairing_matrix">
<tt class="descname">vertex_facet_pairing_matrix</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.vertex_facet_pairing_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex facet pairing matrix <span class="math">\(PM\)</span>.</p>
<p>Return a matrix whose the <span class="math">\(i, j^\text{th}\)</span> entry is the height
of the <span class="math">\(j^\text{th}\)</span> vertex over the <span class="math">\(i^\text{th}\)</span> facet.
The ordering of the vertices and facets is as in
<a class="reference internal" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.vertices" title="sage.geometry.lattice_polytope.LatticePolytopeClass.vertices"><tt class="xref py py-meth docutils literal"><span class="pre">vertices()</span></tt></a> and <a class="reference internal" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.facets" title="sage.geometry.lattice_polytope.LatticePolytopeClass.facets"><tt class="xref py py-meth docutils literal"><span class="pre">facets()</span></tt></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">vertex_facet_pairing_matrix</span><span class="p">()</span>
<span class="go">[0 0 2 2 2 0]</span>
<span class="go">[2 0 2 0 2 0]</span>
<span class="go">[0 2 2 2 0 0]</span>
<span class="go">[2 2 2 0 0 0]</span>
<span class="go">[0 0 0 2 2 2]</span>
<span class="go">[2 0 0 0 2 2]</span>
<span class="go">[0 2 0 2 0 2]</span>
<span class="go">[2 2 0 0 0 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.vertices">
<tt class="descname">vertices</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vertices of this polytope as columns of a matrix.</p>
<p>EXAMPLES: The lattice points of the 3-dimensional octahedron and
its polar cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">doctest:...: DeprecationWarning: vertices() output will change,</span>
<span class="go">please use vertices_pc().column_matrix() instead or</span>
<span class="go">consider using vertices_pc() directly!</span>
<span class="go">See http://trac.sagemath.org/15240 for details.</span>
<span class="go">[ 1  0  0 -1  0  0]</span>
<span class="go">[ 0  1  0  0 -1  0]</span>
<span class="go">[ 0  0  1  0  0 -1]</span>
<span class="gp">sage: </span><span class="n">cube</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">cube</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
<span class="go">[-1  1 -1  1 -1  1 -1  1]</span>
<span class="go">[-1 -1  1  1 -1 -1  1  1]</span>
<span class="go">[ 1  1  1  1 -1 -1 -1 -1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.LatticePolytopeClass.vertices_pc">
<tt class="descname">vertices_pc</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.LatticePolytopeClass.vertices_pc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vertices of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a <tt class="xref py py-class docutils literal"><span class="pre">point</span> <span class="pre">collection</span></tt>.</li>
</ul>
<p>EXAMPLES:</p>
<p>Vertices of the octahedron and its polar cube are in dual lattices:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0),</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0,  0),</span>
<span class="go">M( 0, -1,  0),</span>
<span class="go">M( 0,  0, -1)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">cube</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">cube</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">N(-1, -1,  1),</span>
<span class="go">N( 1, -1,  1),</span>
<span class="go">N(-1,  1,  1),</span>
<span class="go">N( 1,  1,  1),</span>
<span class="go">N(-1, -1, -1),</span>
<span class="go">N( 1, -1, -1),</span>
<span class="go">N(-1,  1, -1),</span>
<span class="go">N( 1,  1, -1)</span>
<span class="go">in 3-d lattice N</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.geometry.lattice_polytope.NefPartition">
<em class="property">class </em><tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">NefPartition</tt><big>(</big><em>data</em>, <em>Delta_polar</em>, <em>check=True</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.NefPartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Basic Structures v6.7)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.sage_object.SageObject</span></tt></a>, <tt class="xref py py-class docutils literal"><span class="pre">_abcoll.Hashable</span></tt></p>
<p>Create a nef-partition.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">data</span></tt> &#8211; a list of integers, the <span class="math">\(i\)</span>-th element of this list must be
the part of the $i$-th vertex of <tt class="docutils literal"><span class="pre">Delta_polar</span></tt> in this nef-partition;</li>
<li><tt class="docutils literal"><span class="pre">Delta_polar</span></tt> &#8211; a <a class="reference internal" href="#sage.geometry.lattice_polytope.LatticePolytopeClass" title="sage.geometry.lattice_polytope.LatticePolytopeClass"><tt class="xref py py-class docutils literal"><span class="pre">lattice</span> <span class="pre">polytope</span></tt></a>;</li>
<li><tt class="docutils literal"><span class="pre">check</span></tt> &#8211; by default the input will be checked for correctness, i.e.
that <tt class="docutils literal"><span class="pre">data</span></tt> indeed specify a nef-partition. If you are sure that the
input is correct, you can speed up construction via <tt class="docutils literal"><span class="pre">check=False</span></tt>
option.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a nef-partition of <tt class="docutils literal"><span class="pre">Delta_polar</span></tt>.</li>
</ul>
<p>Let <span class="math">\(M\)</span> and <span class="math">\(N\)</span> be dual lattices. Let <span class="math">\(\Delta \subset M_\RR\)</span> be a reflexive
polytope with polar <span class="math">\(\Delta^\circ \subset N_\RR\)</span>. Let <span class="math">\(X_\Delta\)</span> be the
toric variety associated to the normal fan of <span class="math">\(\Delta\)</span>. A <strong>nef-partition</strong>
is a decomposition of the vertex set <span class="math">\(V\)</span> of <span class="math">\(\Delta^\circ\)</span> into a disjoint
union <span class="math">\(V = V_0 \sqcup V_1 \sqcup \dots \sqcup V_{k-1}\)</span> such that divisors
<span class="math">\(E_i = \sum_{v\in V_i} D_v\)</span> are Cartier (here <span class="math">\(D_v\)</span> are prime
torus-invariant Weil divisors corresponding to vertices of <span class="math">\(\Delta^\circ\)</span>).
Equivalently, let <span class="math">\(\nabla_i \subset N_\RR\)</span> be the convex hull of vertices
from <span class="math">\(V_i\)</span> and the origin. These polytopes form a nef-partition if their
Minkowski sum <span class="math">\(\nabla \subset N_\RR\)</span> is a reflexive polytope.</p>
<p>The <strong>dual nef-partition</strong> is formed by polytopes <span class="math">\(\Delta_i \subset M_\RR\)</span>
of <span class="math">\(E_i\)</span>, which give a decomposition of the vertex set of <span class="math">\(\nabla^\circ
\subset M_\RR\)</span> and their Minkowski sum is <span class="math">\(\Delta\)</span>, i.e. the polar duality
of reflexive polytopes switches convex hull and Minkowski sum for dual
nef-partitions:</p>
<div class="math">
\[\begin{split}\Delta^\circ
&amp;=
\mathrm{Conv} \left(\nabla_0, \nabla_1, \dots, \nabla_{k-1}\right), \\
\nabla^{\phantom{\circ}}
&amp;=
\nabla_0 + \nabla_1 + \dots + \nabla_{k-1}, \\
&amp;
\\
\Delta^{\phantom{\circ}}
&amp;=
\Delta_0 + \Delta_1 + \dots + \Delta_{k-1}, \\
\nabla^\circ
&amp;=
\mathrm{Conv} \left(\Delta_0, \Delta_1, \dots, \Delta_{k-1}\right).\end{split}\]</div>
<p>See Section 4.3.1 in <a class="reference internal" href="#ck99" id="id3">[CK99]</a> and references therein for further details, or
<a class="reference internal" href="#bn08" id="id4">[BN08]</a> for a purely combinatorial approach.</p>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="bn08" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[BN08]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> Victor V. Batyrev and Benjamin Nill.
Combinatorial aspects of mirror symmetry.
In <em>Integer points in polyhedra &#8212; geometry, number theory,
representation theory, algebra, optimization, statistics</em>,
volume 452 of <em>Contemp. Math.</em>, pages 35&#8211;66.
Amer. Math. Soc., Providence, RI, 2008.
arXiv:math/0703456v2 [math.CO].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ck99" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[CK99]</a></td><td>David A. Cox and Sheldon Katz.
<em>Mirror symmetry and algebraic geometry</em>,
volume 68 of <em>Mathematical Surveys and Monographs</em>.
American Mathematical Society, Providence, RI, 1999.</td></tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<p>It is very easy to create a nef-partition for the octahedron, since for
this polytope any decomposition of vertices is a nef-partition. We create a
3-part nef-partition with the 0-th and 1-st vertices belonging to the 0-th
part (recall that numeration in Sage starts with 0), the 2-nd and 5-th
vertices belonging to the 1-st part, and 3-rd and 4-th vertices belonging
to the 2-nd part:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">np</span> <span class="o">=</span> <span class="n">NefPartition</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">o</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">np</span>
<span class="go">Nef-partition {0, 1} U {2, 5} U {3, 4}</span>
</pre></div>
</div>
<p>The octahedron plays the role of <span class="math">\(\Delta^\circ\)</span> in the above description:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">Delta_polar</span><span class="p">()</span> <span class="ow">is</span> <span class="n">o</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The dual nef-partition (corresponding to the &#8220;mirror complete
intersection&#8221;) gives decomposition of the vertex set of <span class="math">\(\nabla^\circ\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="go">Nef-partition {4, 5, 6} U {1, 3} U {0, 2, 7}</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">nabla_polar</span><span class="p">()</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">N( 1,  1,  0),</span>
<span class="go">N( 0,  0,  1),</span>
<span class="go">N( 0,  1,  0),</span>
<span class="go">N( 0,  0, -1),</span>
<span class="go">N(-1, -1,  0),</span>
<span class="go">N( 0, -1,  0),</span>
<span class="go">N(-1,  0,  0),</span>
<span class="go">N( 1,  0,  0)</span>
<span class="go">in 3-d lattice N</span>
</pre></div>
</div>
<p>Of course, <span class="math">\(\nabla^\circ\)</span> is <span class="math">\(\Delta^\circ\)</span> from the point of view of the
dual nef-partition:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">Delta_polar</span><span class="p">()</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">nabla_polar</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">Delta</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">N(0, 0,  1),</span>
<span class="go">N(0, 0, -1)</span>
<span class="go">in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">N(0, 0,  1),</span>
<span class="go">N(0, 0, -1)</span>
<span class="go">in 3-d lattice N</span>
</pre></div>
</div>
<p>Instead of constructing nef-partitions directly, you can request all 2-part
nef-partitions of a given reflexive polytope (they will be computed using
<tt class="docutils literal"><span class="pre">nef.x</span></tt> program from PALP):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">Nef-partition {0, 1, 3} U {2, 4, 5},</span>
<span class="go">Nef-partition {0, 1, 3, 4} U {2, 5} (direct product),</span>
<span class="go">Nef-partition {0, 1, 2} U {3, 4, 5},</span>
<span class="go">Nef-partition {0, 1, 2, 3} U {4, 5},</span>
<span class="go">Nef-partition {0, 1, 2, 3, 4} U {5} (projection)</span>
<span class="go">]</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.geometry.lattice_polytope.NefPartition.Delta">
<tt class="descname">Delta</tt><big>(</big><em>i=None</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.NefPartition.Delta" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the polytope <span class="math">\(\Delta\)</span> or <span class="math">\(\Delta_i\)</span> corresponding to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">i</span></tt> &#8211; an integer. If not given, <span class="math">\(\Delta\)</span> will be returned.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a <a class="reference internal" href="#sage.geometry.lattice_polytope.LatticePolytopeClass" title="sage.geometry.lattice_polytope.LatticePolytopeClass"><tt class="xref py py-class docutils literal"><span class="pre">lattice</span> <span class="pre">polytope</span></tt></a>.</li>
</ul>
<p>See <a class="reference internal" href="#sage.geometry.lattice_polytope.NefPartition" title="sage.geometry.lattice_polytope.NefPartition"><tt class="xref py py-class docutils literal"><span class="pre">nef-partition</span></tt></a> class documentation for
definitions and notation.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">np</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">np</span>
<span class="go">Nef-partition {0, 1, 3} U {2, 4, 5}</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">Delta</span><span class="p">()</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span> <span class="ow">is</span> <span class="n">o</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">Delta</span><span class="p">()</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">N(-1, -1,  1),</span>
<span class="go">N( 1, -1,  1),</span>
<span class="go">N(-1,  1,  1),</span>
<span class="go">N( 1,  1,  1),</span>
<span class="go">N(-1, -1, -1),</span>
<span class="go">N( 1, -1, -1),</span>
<span class="go">N(-1,  1, -1),</span>
<span class="go">N( 1,  1, -1)</span>
<span class="go">in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">Delta</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">N( 1, -1, 0),</span>
<span class="go">N( 1,  0, 0),</span>
<span class="go">N(-1, -1, 0),</span>
<span class="go">N(-1,  0, 0)</span>
<span class="go">in 3-d lattice N</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.NefPartition.Delta_polar">
<tt class="descname">Delta_polar</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.NefPartition.Delta_polar" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the polytope <span class="math">\(\Delta^\circ\)</span> corresponding to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a <a class="reference internal" href="#sage.geometry.lattice_polytope.LatticePolytopeClass" title="sage.geometry.lattice_polytope.LatticePolytopeClass"><tt class="xref py py-class docutils literal"><span class="pre">lattice</span> <span class="pre">polytope</span></tt></a>.</li>
</ul>
<p>See <a class="reference internal" href="#sage.geometry.lattice_polytope.NefPartition" title="sage.geometry.lattice_polytope.NefPartition"><tt class="xref py py-class docutils literal"><span class="pre">nef-partition</span></tt></a> class documentation for
definitions and notation.</p>
<p>EXAMPLE:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">np</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">np</span>
<span class="go">Nef-partition {0, 1, 3} U {2, 4, 5}</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">Delta_polar</span><span class="p">()</span> <span class="ow">is</span> <span class="n">o</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.NefPartition.Deltas">
<tt class="descname">Deltas</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.NefPartition.Deltas" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the polytopes <span class="math">\(\Delta_i\)</span> corresponding to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a tuple of <a class="reference internal" href="#sage.geometry.lattice_polytope.LatticePolytopeClass" title="sage.geometry.lattice_polytope.LatticePolytopeClass"><tt class="xref py py-class docutils literal"><span class="pre">lattice</span> <span class="pre">polytopes</span></tt></a>.</li>
</ul>
<p>See <a class="reference internal" href="#sage.geometry.lattice_polytope.NefPartition" title="sage.geometry.lattice_polytope.NefPartition"><tt class="xref py py-class docutils literal"><span class="pre">nef-partition</span></tt></a> class documentation for
definitions and notation.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">np</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">np</span>
<span class="go">Nef-partition {0, 1, 3} U {2, 4, 5}</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">Delta</span><span class="p">()</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">N(-1, -1,  1),</span>
<span class="go">N( 1, -1,  1),</span>
<span class="go">N(-1,  1,  1),</span>
<span class="go">N( 1,  1,  1),</span>
<span class="go">N(-1, -1, -1),</span>
<span class="go">N( 1, -1, -1),</span>
<span class="go">N(-1,  1, -1),</span>
<span class="go">N( 1,  1, -1)</span>
<span class="go">in 3-d lattice N</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">Delta_i</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span> <span class="k">for</span> <span class="n">Delta_i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">Deltas</span><span class="p">()]</span>
<span class="go">[N( 1, -1, 0),</span>
<span class="go">N( 1,  0, 0),</span>
<span class="go">N(-1, -1, 0),</span>
<span class="go">N(-1,  0, 0)</span>
<span class="go">in 3-d lattice N,</span>
<span class="go">N(0, 1,  1),</span>
<span class="go">N(0, 0,  1),</span>
<span class="go">N(0, 0, -1),</span>
<span class="go">N(0, 1, -1)</span>
<span class="go">in 3-d lattice N]</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">nabla_polar</span><span class="p">()</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">N( 1, -1,  0),</span>
<span class="go">N( 0,  1,  1),</span>
<span class="go">N( 1,  0,  0),</span>
<span class="go">N( 0,  0,  1),</span>
<span class="go">N( 0,  0, -1),</span>
<span class="go">N(-1, -1,  0),</span>
<span class="go">N( 0,  1, -1),</span>
<span class="go">N(-1,  0,  0)</span>
<span class="go">in 3-d lattice N</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.NefPartition.dual">
<tt class="descname">dual</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.NefPartition.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual nef-partition.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a <a class="reference internal" href="#sage.geometry.lattice_polytope.NefPartition" title="sage.geometry.lattice_polytope.NefPartition"><tt class="xref py py-class docutils literal"><span class="pre">nef-partition</span></tt></a>.</li>
</ul>
<p>See the class documentation for the definition.</p>
<p>ALGORITHM:</p>
<p>See Proposition 3.19 in <a class="reference internal" href="#bn08" id="id5">[BN08]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">np</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">np</span>
<span class="go">Nef-partition {0, 1, 3} U {2, 4, 5}</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="go">Nef-partition {0, 2, 5, 7} U {1, 3, 4, 6}</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">Delta</span><span class="p">()</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">Delta</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.NefPartition.hodge_numbers">
<tt class="descname">hodge_numbers</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.NefPartition.hodge_numbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Hodge numbers corresponding to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a tuple of integers (produced by <tt class="docutils literal"><span class="pre">nef.x</span></tt> program from PALP).</li>
</ul>
<p>EXAMPLES:</p>
<p>Currently, you need to request Hodge numbers when you compute
nef-partitions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">np</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># long time (4s on sage.math, 2011)</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">hodge_numbers</span><span class="p">()</span>  <span class="c"># long time</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">NotImplementedError</span>: <span class="n-Identifier">use nef_partitions(hodge_numbers=True)!</span>
<span class="gp">sage: </span><span class="n">np</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">(</span><span class="n">hodge_numbers</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># long time (13s on sage.math, 2011)</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">hodge_numbers</span><span class="p">()</span>  <span class="c"># long time</span>
<span class="go">(19, 19)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.NefPartition.nabla">
<tt class="descname">nabla</tt><big>(</big><em>i=None</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.NefPartition.nabla" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the polytope <span class="math">\(\nabla\)</span> or <span class="math">\(\nabla_i\)</span> corresponding to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">i</span></tt> &#8211; an integer. If not given, <span class="math">\(\nabla\)</span> will be returned.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a <a class="reference internal" href="#sage.geometry.lattice_polytope.LatticePolytopeClass" title="sage.geometry.lattice_polytope.LatticePolytopeClass"><tt class="xref py py-class docutils literal"><span class="pre">lattice</span> <span class="pre">polytope</span></tt></a>.</li>
</ul>
<p>See <a class="reference internal" href="#sage.geometry.lattice_polytope.NefPartition" title="sage.geometry.lattice_polytope.NefPartition"><tt class="xref py py-class docutils literal"><span class="pre">nef-partition</span></tt></a> class documentation for
definitions and notation.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">np</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">np</span>
<span class="go">Nef-partition {0, 1, 3} U {2, 4, 5}</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">Delta_polar</span><span class="p">()</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0),</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0,  0),</span>
<span class="go">M( 0, -1,  0),</span>
<span class="go">M( 0,  0, -1)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1, 0, 0),</span>
<span class="go">M( 0, 1, 0),</span>
<span class="go">M(-1, 0, 0)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">nabla</span><span class="p">()</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  1),</span>
<span class="go">M( 1, -1,  0),</span>
<span class="go">M( 1,  0, -1),</span>
<span class="go">M( 0,  1,  1),</span>
<span class="go">M( 0,  1, -1),</span>
<span class="go">M(-1,  0,  1),</span>
<span class="go">M(-1, -1,  0),</span>
<span class="go">M(-1,  0, -1)</span>
<span class="go">in 3-d lattice M</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.NefPartition.nabla_polar">
<tt class="descname">nabla_polar</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.NefPartition.nabla_polar" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the polytope <span class="math">\(\nabla^\circ\)</span> corresponding to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a <a class="reference internal" href="#sage.geometry.lattice_polytope.LatticePolytopeClass" title="sage.geometry.lattice_polytope.LatticePolytopeClass"><tt class="xref py py-class docutils literal"><span class="pre">lattice</span> <span class="pre">polytope</span></tt></a>.</li>
</ul>
<p>See <a class="reference internal" href="#sage.geometry.lattice_polytope.NefPartition" title="sage.geometry.lattice_polytope.NefPartition"><tt class="xref py py-class docutils literal"><span class="pre">nef-partition</span></tt></a> class documentation for
definitions and notation.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">np</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">np</span>
<span class="go">Nef-partition {0, 1, 3} U {2, 4, 5}</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">nabla_polar</span><span class="p">()</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">N( 1, -1,  0),</span>
<span class="go">N( 0,  1,  1),</span>
<span class="go">N( 1,  0,  0),</span>
<span class="go">N( 0,  0,  1),</span>
<span class="go">N( 0,  0, -1),</span>
<span class="go">N(-1, -1,  0),</span>
<span class="go">N( 0,  1, -1),</span>
<span class="go">N(-1,  0,  0)</span>
<span class="go">in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">nabla_polar</span><span class="p">()</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">Delta_polar</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.NefPartition.nablas">
<tt class="descname">nablas</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.NefPartition.nablas" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the polytopes <span class="math">\(\nabla_i\)</span> corresponding to <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a tuple of <a class="reference internal" href="#sage.geometry.lattice_polytope.LatticePolytopeClass" title="sage.geometry.lattice_polytope.LatticePolytopeClass"><tt class="xref py py-class docutils literal"><span class="pre">lattice</span> <span class="pre">polytopes</span></tt></a>.</li>
</ul>
<p>See <a class="reference internal" href="#sage.geometry.lattice_polytope.NefPartition" title="sage.geometry.lattice_polytope.NefPartition"><tt class="xref py py-class docutils literal"><span class="pre">nef-partition</span></tt></a> class documentation for
definitions and notation.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">np</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">np</span>
<span class="go">Nef-partition {0, 1, 3} U {2, 4, 5}</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">Delta_polar</span><span class="p">()</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0),</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0,  0),</span>
<span class="go">M( 0, -1,  0),</span>
<span class="go">M( 0,  0, -1)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">nabla_i</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span> <span class="k">for</span> <span class="n">nabla_i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">nablas</span><span class="p">()]</span>
<span class="go">[M( 1, 0, 0),</span>
<span class="go">M( 0, 1, 0),</span>
<span class="go">M(-1, 0, 0)</span>
<span class="go">in 3-d lattice M,</span>
<span class="go">M(0,  0,  1),</span>
<span class="go">M(0, -1,  0),</span>
<span class="go">M(0,  0, -1)</span>
<span class="go">in 3-d lattice M]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.NefPartition.nparts">
<tt class="descname">nparts</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.NefPartition.nparts" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of parts in <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>an integer.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">np</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">np</span>
<span class="go">Nef-partition {0, 1, 3} U {2, 4, 5}</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">nparts</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.NefPartition.part">
<tt class="descname">part</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.NefPartition.part" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <tt class="docutils literal"><span class="pre">i</span></tt>-th part of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">i</span></tt> &#8211; an integer.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a tuple of integers, indices of vertices of <span class="math">\(\Delta^\circ\)</span> belonging
to $V_i$.</li>
</ul>
<p>See <a class="reference internal" href="#sage.geometry.lattice_polytope.NefPartition" title="sage.geometry.lattice_polytope.NefPartition"><tt class="xref py py-class docutils literal"><span class="pre">nef-partition</span></tt></a> class documentation for
definitions and notation.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">np</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">np</span>
<span class="go">Nef-partition {0, 1, 3} U {2, 4, 5}</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">part</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">(0, 1, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.NefPartition.part_of">
<tt class="descname">part_of</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.NefPartition.part_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the part containing the <tt class="docutils literal"><span class="pre">i</span></tt>-th vertex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">i</span></tt> &#8211; an integer.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an integer <span class="math">\(j\)</span> such that the <tt class="docutils literal"><span class="pre">i</span></tt>-th vertex of <span class="math">\(\Delta^\circ\)</span>
belongs to $V_j$.</li>
</ul>
<p>See <a class="reference internal" href="#sage.geometry.lattice_polytope.NefPartition" title="sage.geometry.lattice_polytope.NefPartition"><tt class="xref py py-class docutils literal"><span class="pre">nef-partition</span></tt></a> class documentation for
definitions and notation.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">np</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">np</span>
<span class="go">Nef-partition {0, 1, 3} U {2, 4, 5}</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">part_of</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">part_of</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.NefPartition.part_of_point">
<tt class="descname">part_of_point</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.NefPartition.part_of_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the part containing the <tt class="docutils literal"><span class="pre">i</span></tt>-th point.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">i</span></tt> &#8211; an integer.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an integer <span class="math">\(j\)</span> such that the <tt class="docutils literal"><span class="pre">i</span></tt>-th point of <span class="math">\(\Delta^\circ\)</span>
belongs to <span class="math">\(\nabla_j\)</span>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since a nef-partition induces a partition on the set of boundary
lattice points of <span class="math">\(\Delta^\circ\)</span>, the value of <span class="math">\(j\)</span> is well-defined
for all <span class="math">\(i\)</span> but the one that corresponds to the origin, in which
case this method will raise a <tt class="docutils literal"><span class="pre">ValueError</span></tt> exception. (The origin
always belongs to all <span class="math">\(\nabla_j\)</span>.)</p>
</div>
<p>See <a class="reference internal" href="#sage.geometry.lattice_polytope.NefPartition" title="sage.geometry.lattice_polytope.NefPartition"><tt class="xref py py-class docutils literal"><span class="pre">nef-partition</span></tt></a> class documentation for
definitions and notation.</p>
<p>EXAMPLES:</p>
<p>We consider a relatively complicated reflexive polytope #2252 (easily
accessible in Sage as <tt class="docutils literal"><span class="pre">ReflexivePolytope(3,</span> <span class="pre">2252)</span></tt>, we create it here
explicitly to avoid loading the whole database):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>          <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">np</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">np</span>
<span class="go">Nef-partition {1, 2, 5, 7, 8} U {0, 3, 4, 6}</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">nvertices</span><span class="p">()</span>
<span class="go">9</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
<span class="go">15</span>
</pre></div>
</div>
<p>We see that the polytope has 6 more points in addition to vertices. One
of them is the origin:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">origin</span><span class="p">()</span>
<span class="go">14</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">part_of_point</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">the origin belongs to all parts!</span>
</pre></div>
</div>
<p>But the remaining 5 are partitioned by <tt class="docutils literal"><span class="pre">np</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">npoints</span><span class="p">())</span>
<span class="gp">... </span>     <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">origin</span><span class="p">()</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">part_of_point</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">[1, 2, 5, 7, 8, 9, 11, 13]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">npoints</span><span class="p">())</span>
<span class="gp">... </span>     <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">origin</span><span class="p">()</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">part_of_point</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">[0, 3, 4, 6, 10, 12]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.lattice_polytope.NefPartition.parts">
<tt class="descname">parts</tt><big>(</big><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.NefPartition.parts" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all parts of <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a tuple of tuples of integers. The <span class="math">\(i\)</span>-th tuple contains indices of
vertices of $Delta^circ$ belonging to $V_i$.</li>
</ul>
<p>See <a class="reference internal" href="#sage.geometry.lattice_polytope.NefPartition" title="sage.geometry.lattice_polytope.NefPartition"><tt class="xref py py-class docutils literal"><span class="pre">nef-partition</span></tt></a> class documentation for
definitions and notation.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">np</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">np</span>
<span class="go">Nef-partition {0, 1, 3} U {2, 4, 5}</span>
<span class="gp">sage: </span><span class="n">np</span><span class="o">.</span><span class="n">parts</span><span class="p">()</span>
<span class="go">((0, 1, 3), (2, 4, 5))</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.ReflexivePolytope">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">ReflexivePolytope</tt><big>(</big><em>dim</em>, <em>n</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.ReflexivePolytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Return n-th reflexive polytope from the database of 2- or
3-dimensional reflexive polytopes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic simple">
<li>Numeration starts with zero: <span class="math">\(0 \leq n \leq 15\)</span> for <span class="math">\({\rm dim} = 2\)</span>
and <span class="math">\(0 \leq n \leq 4318\)</span> for <span class="math">\({\rm dim} = 3\)</span>.</li>
<li>During the first call, all reflexive polytopes of requested
dimension are loaded and cached for future use, so the first
call for 3-dimensional polytopes can take several seconds,
but all consecutive calls are fast.</li>
<li>Equivalent to <tt class="docutils literal"><span class="pre">ReflexivePolytopes(dim)[n]</span></tt> but checks bounds
first.</li>
</ol>
</div>
<p>EXAMPLES: The 3rd 2-dimensional polytope is &#8220;the diamond:&#8221;</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">ReflexivePolytope</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">2-d reflexive polytope #3 in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">ReflexivePolytope</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0),</span>
<span class="go">M( 0,  1),</span>
<span class="go">M( 0, -1),</span>
<span class="go">M(-1,  0)</span>
<span class="go">in 2-d lattice M</span>
</pre></div>
</div>
<p>There are 16 reflexive polygons and numeration starts with 0:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">ReflexivePolytope</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">there are only 16 reflexive polygons!</span>
</pre></div>
</div>
<p>It is not possible to load a 4-dimensional polytope in this way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">ReflexivePolytope</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">NotImplementedError</span>: <span class="n-Identifier">only 2- and 3-dimensional reflexive polytopes are available!</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.ReflexivePolytopes">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">ReflexivePolytopes</tt><big>(</big><em>dim</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.ReflexivePolytopes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sequence of all 2- or 3-dimensional reflexive polytopes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">During the first call the database is loaded and cached for
future use, so repetitive calls will return the same object in
memory.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dim</strong> (<em>2 or 3</em>) &#8211; dimension of required reflexive polytopes</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of lattice polytopes</td>
</tr>
</tbody>
</table>
<p>EXAMPLES: There are 16 reflexive polygons:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">ReflexivePolytopes</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">16</span>
</pre></div>
</div>
<p>It is not possible to load 4-dimensional polytopes in this way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">ReflexivePolytopes</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">NotImplementedError</span>: <span class="n-Identifier">only 2- and 3-dimensional reflexive polytopes are available!</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.geometry.lattice_polytope.SetOfAllLatticePolytopesClass">
<em class="property">class </em><tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">SetOfAllLatticePolytopesClass</tt><a class="headerlink" href="#sage.geometry.lattice_polytope.SetOfAllLatticePolytopesClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/parent.html#sage.structure.parent.Set_generic" title="(in Sage Reference Manual: Basic Structures v6.7)"><tt class="xref py py-class docutils literal"><span class="pre">sage.structure.parent.Set_generic</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.all_cached_data">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">all_cached_data</tt><big>(</big><em>polytopes</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.all_cached_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all cached data for all given <tt class="docutils literal"><span class="pre">polytopes</span></tt> and
their polars.</p>
<p>This functions does it MUCH faster than member functions of
<tt class="docutils literal"><span class="pre">LatticePolytope</span></tt> during the first run. So it is recommended to
use this functions if you work with big sets of data. None of the
polytopes in the given sequence should be constructed as the polar
polytope to another one.</p>
<p>INPUT: a sequence of lattice polytopes.</p>
<p>EXAMPLES: This function has no output, it is just a fast way to
work with long sequences of polytopes. Of course, you can use short
sequences as well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">all_cached_data</span><span class="p">([</span><span class="n">o</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">[[0], [1], [2], [3], [4], [5]],</span>
<span class="go">[[1, 5], [0, 5], [0, 1], [3, 5], [1, 3], [4, 5], [0, 4], [3, 4], [1, 2], [0, 2], [2, 3], [2, 4]],</span>
<span class="go">[[0, 1, 5], [1, 3, 5], [0, 4, 5], [3, 4, 5], [0, 1, 2], [1, 2, 3], [0, 2, 4], [2, 3, 4]]</span>
<span class="go">]</span>
</pre></div>
</div>
<p>However, you cannot use it for polytopes that are constructed as
polar polytopes of others:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">all_cached_data</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">polar</span><span class="p">()])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">Cannot read face structure for a polytope constructed as polar, use _compute_faces!</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.all_faces">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">all_faces</tt><big>(</big><em>polytopes</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.all_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute faces for all given <tt class="docutils literal"><span class="pre">polytopes</span></tt>.</p>
<p>This functions does it MUCH faster than member functions of
<tt class="docutils literal"><span class="pre">LatticePolytope</span></tt> during the first run. So it is recommended to
use this functions if you work with big sets of data.</p>
<p>INPUT: a sequence of lattice polytopes.</p>
<p>EXAMPLES: This function has no output, it is just a fast way to
work with long sequences of polytopes. Of course, you can use short
sequences as well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">all_faces</span><span class="p">([</span><span class="n">o</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">[[0], [1], [2], [3], [4], [5]],</span>
<span class="go">[[1, 5], [0, 5], [0, 1], [3, 5], [1, 3], [4, 5], [0, 4], [3, 4], [1, 2], [0, 2], [2, 3], [2, 4]],</span>
<span class="go">[[0, 1, 5], [1, 3, 5], [0, 4, 5], [3, 4, 5], [0, 1, 2], [1, 2, 3], [0, 2, 4], [2, 3, 4]]</span>
<span class="go">]</span>
</pre></div>
</div>
<p>However, you cannot use it for polytopes that are constructed as
polar polytopes of others:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">all_faces</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">polar</span><span class="p">()])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">Cannot read face structure for a polytope constructed as polar, use _compute_faces!</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.all_facet_equations">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">all_facet_equations</tt><big>(</big><em>polytopes</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.all_facet_equations" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute polar polytopes for all reflexive and equations of facets
for all non-reflexive <tt class="docutils literal"><span class="pre">polytopes</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">all_facet_equations</span></tt> and <tt class="docutils literal"><span class="pre">all_polars</span></tt> are synonyms.</p>
<p>This functions does it MUCH faster than member functions of
<tt class="docutils literal"><span class="pre">LatticePolytope</span></tt> during the first run. So it is recommended to
use this functions if you work with big sets of data.</p>
<p>INPUT: a sequence of lattice polytopes.</p>
<p>EXAMPLES: This function has no output, it is just a fast way to
work with long sequences of polytopes. Of course, you can use short
sequences as well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">all_polars</span><span class="p">([</span><span class="n">o</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span>
<span class="go">3-d reflexive polytope in 3-d lattice N</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.all_nef_partitions">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">all_nef_partitions</tt><big>(</big><em>polytopes</em>, <em>keep_symmetric=False</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.all_nef_partitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute nef-partitions for all given <tt class="docutils literal"><span class="pre">polytopes</span></tt>.</p>
<p>This functions does it MUCH faster than member functions of
<tt class="docutils literal"><span class="pre">LatticePolytope</span></tt> during the first run. So it is recommended to
use this functions if you work with big sets of data.</p>
<p>Note: member function <tt class="docutils literal"><span class="pre">is_reflexive</span></tt> will be called
separately for each polytope. It is strictly recommended to call
<tt class="docutils literal"><span class="pre">all_polars</span></tt> on the sequence of
<tt class="docutils literal"><span class="pre">polytopes</span></tt> before using this function.</p>
<p>INPUT: a sequence of lattice polytopes.</p>
<p>EXAMPLES: This function has no output, it is just a fast way to
work with long sequences of polytopes. Of course, you can use short
sequences as well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">all_nef_partitions</span><span class="p">([</span><span class="n">o</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">Nef-partition {0, 1, 3} U {2, 4, 5},</span>
<span class="go">Nef-partition {0, 1, 3, 4} U {2, 5} (direct product),</span>
<span class="go">Nef-partition {0, 1, 2} U {3, 4, 5},</span>
<span class="go">Nef-partition {0, 1, 2, 3} U {4, 5},</span>
<span class="go">Nef-partition {0, 1, 2, 3, 4} U {5} (projection)</span>
<span class="go">]</span>
</pre></div>
</div>
<p>You cannot use this function for non-reflexive polytopes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span>                       <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">all_nef_partitions</span><span class="p">([</span><span class="n">o</span><span class="p">,</span> <span class="n">p</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">nef-partitions can be computed for reflexive polytopes only</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.all_points">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">all_points</tt><big>(</big><em>polytopes</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.all_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute lattice points for all given <tt class="docutils literal"><span class="pre">polytopes</span></tt>.</p>
<p>This functions does it MUCH faster than member functions of
<tt class="docutils literal"><span class="pre">LatticePolytope</span></tt> during the first run. So it is recommended to
use this functions if you work with big sets of data.</p>
<p>INPUT: a sequence of lattice polytopes.</p>
<p>EXAMPLES: This function has no output, it is just a fast way to
work with long sequences of polytopes. Of course, you can use short
sequences as well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">all_points</span><span class="p">([</span><span class="n">o</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">points_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0),</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0,  0),</span>
<span class="go">M( 0, -1,  0),</span>
<span class="go">M( 0,  0, -1),</span>
<span class="go">M( 0,  0,  0)</span>
<span class="go">in 3-d lattice M</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.all_polars">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">all_polars</tt><big>(</big><em>polytopes</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.all_polars" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute polar polytopes for all reflexive and equations of facets
for all non-reflexive <tt class="docutils literal"><span class="pre">polytopes</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">all_facet_equations</span></tt> and <tt class="docutils literal"><span class="pre">all_polars</span></tt> are synonyms.</p>
<p>This functions does it MUCH faster than member functions of
<tt class="docutils literal"><span class="pre">LatticePolytope</span></tt> during the first run. So it is recommended to
use this functions if you work with big sets of data.</p>
<p>INPUT: a sequence of lattice polytopes.</p>
<p>EXAMPLES: This function has no output, it is just a fast way to
work with long sequences of polytopes. Of course, you can use short
sequences as well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">all_polars</span><span class="p">([</span><span class="n">o</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">polar</span><span class="p">()</span>
<span class="go">3-d reflexive polytope in 3-d lattice N</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.always_use_files">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">always_use_files</tt><big>(</big><em>new_state=None</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.always_use_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Set or get the way of using PALP for lattice polytopes.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">new_state</span></tt> - (default:None) if specified, must be <tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt>.</li>
</ul>
<p>OUTPUT: The current state of using PALP. If <tt class="docutils literal"><span class="pre">True</span></tt>, files are used
for all calls to PALP, otherwise pipes are used for single polytopes.
While the latter may have some advantage in speed, the first method
is more reliable when working with large outputs. The initial state
is <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">always_use_files</span><span class="p">()</span>
<span class="go">doctest:...: DeprecationWarning: using PALP via pipes is deprecated and</span>
<span class="go">will be removed, if you have a use case for this,</span>
<span class="go">please email Andrey Novoseltsev</span>
<span class="go">See http://trac.sagemath.org/15240 for details.        </span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">(([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
<span class="go">20</span>
</pre></div>
</div>
<p>Now let&#8217;s use pipes instead of files:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">always_use_files</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">(([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">npoints</span><span class="p">()</span>
<span class="go">20</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.convex_hull">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">convex_hull</tt><big>(</big><em>points</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the convex hull of the given points.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">points</span></tt> might not span the space. Also, it fails for large
numbers of vertices in dimensions 4 or greater</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">points</span></tt> - a list that can be converted into
vectors of the same dimension over ZZ.</li>
</ul>
<p>OUTPUT: list of vertices of the convex hull of the given points (as
vectors).</p>
<p>EXAMPLES: Let&#8217;s compute the convex hull of several points on a line
in the plane:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">convex_hull</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]])</span>
<span class="go">[(1, 2), (7, 8)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.cross_polytope">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">cross_polytope</tt><big>(</big><em>dim</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.cross_polytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a cross-polytope of the given dimension.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">dim</span></tt> &#8211; an integer.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a <a class="reference internal" href="#sage.geometry.lattice_polytope.LatticePolytopeClass" title="sage.geometry.lattice_polytope.LatticePolytopeClass"><tt class="xref py py-class docutils literal"><span class="pre">lattice</span> <span class="pre">polytope</span></tt></a>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span>
<span class="go">3-d reflexive polytope in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">o</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0),</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0,  0),</span>
<span class="go">M( 0, -1,  0),</span>
<span class="go">M( 0,  0, -1)</span>
<span class="go">in 3-d lattice M</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.filter_polytopes">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">filter_polytopes</tt><big>(</big><em>f</em>, <em>polytopes</em>, <em>subseq=None</em>, <em>print_numbers=False</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.filter_polytopes" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the function <tt class="docutils literal"><span class="pre">f</span></tt> to filter polytopes in a list.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> - filtering function, it must take one
argument, a lattice polytope, and return True or False.</li>
<li><tt class="docutils literal"><span class="pre">polytopes</span></tt> - list of polytopes.</li>
<li><tt class="docutils literal"><span class="pre">subseq</span></tt> - (default: None) list of integers. If it
is specified, only polytopes with these numbers will be
considered.</li>
<li><tt class="docutils literal"><span class="pre">print_numbers</span></tt> - (default: False) if True, the
number of the current polytope will be printed on the screen before
calling <tt class="docutils literal"><span class="pre">f</span></tt>.</li>
</ul>
<p>OUTPUT: a list of integers &#8211; numbers of polytopes in the given
list, that satisfy the given condition (i.e. function
<tt class="docutils literal"><span class="pre">f</span></tt> returns True) and are elements of subseq, if it
is given.</p>
<p>EXAMPLES: Consider a sequence of cross-polytopes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">polytopes</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">([</span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">....:                       for n in range(2, 7)], cr=True)</span>
<span class="gp">sage: </span><span class="n">polytopes</span>
<span class="go">[</span>
<span class="go">2-d reflexive polytope #3 in 2-d lattice M,</span>
<span class="go">3-d reflexive polytope in 3-d lattice M,</span>
<span class="go">4-d reflexive polytope in 4-d lattice M,</span>
<span class="go">5-d reflexive polytope in 5-d lattice M,</span>
<span class="go">6-d reflexive polytope in 6-d lattice M</span>
<span class="go">]</span>
</pre></div>
</div>
<p>This filters polytopes of dimension at least 4:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">filter_polytopes</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">polytopes</span><span class="p">)</span>
<span class="go">doctest:...: DeprecationWarning: filter_polytopes is deprecated,</span>
<span class="go">use standard tools instead</span>
<span class="go">See http://trac.sagemath.org/15240 for details.</span>
<span class="go">[2, 3, 4]</span>
</pre></div>
</div>
<p>For long tests you can see the current progress:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">filter_polytopes</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">nvertices</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">polytopes</span><span class="p">,</span> <span class="n">print_numbers</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">[3, 4]</span>
</pre></div>
</div>
<p>Here we consider only some of the polytopes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">filter_polytopes</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">nvertices</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">polytopes</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">print_numbers</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">[3, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.integral_length">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">integral_length</tt><big>(</big><em>v</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.integral_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the integral length of a given rational vector.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">v</span></tt> - any object which can be converted to a list of rationals</li>
</ul>
<p>OUTPUT: Rational number <tt class="docutils literal"><span class="pre">r</span></tt> such that <tt class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">r</span> <span class="pre">u</span></tt>, where <tt class="docutils literal"><span class="pre">u</span></tt> is the
primitive integral vector in the direction of <tt class="docutils literal"><span class="pre">v</span></tt>.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">integral_length</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">integral_length</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">integral_length</span><span class="p">([</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">2/3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.is_LatticePolytope">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">is_LatticePolytope</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.is_LatticePolytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <tt class="docutils literal"><span class="pre">x</span></tt> is a lattice polytope.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; anything.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">x</span></tt> is a <a class="reference internal" href="#sage.geometry.lattice_polytope.LatticePolytopeClass" title="sage.geometry.lattice_polytope.LatticePolytopeClass"><tt class="xref py py-class docutils literal"><span class="pre">lattice</span> <span class="pre">polytope</span></tt></a>,
<tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.geometry.lattice_polytope</span> <span class="kn">import</span> <span class="n">is_LatticePolytope</span>
<span class="gp">sage: </span><span class="n">is_LatticePolytope</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span>
<span class="go">2-d reflexive polytope #0 in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">is_LatticePolytope</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.is_NefPartition">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">is_NefPartition</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.is_NefPartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <tt class="docutils literal"><span class="pre">x</span></tt> is a nef-partition.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> &#8211; anything.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">x</span></tt> is a <a class="reference internal" href="#sage.geometry.lattice_polytope.NefPartition" title="sage.geometry.lattice_polytope.NefPartition"><tt class="xref py py-class docutils literal"><span class="pre">nef-partition</span></tt></a> and
<tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.geometry.lattice_polytope</span> <span class="kn">import</span> <span class="n">is_NefPartition</span>
<span class="gp">sage: </span><span class="n">is_NefPartition</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">np</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">nef_partitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">np</span>
<span class="go">Nef-partition {0, 1, 3} U {2, 4, 5}</span>
<span class="gp">sage: </span><span class="n">is_NefPartition</span><span class="p">(</span><span class="n">np</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.minkowski_sum">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">minkowski_sum</tt><big>(</big><em>points1</em>, <em>points2</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.minkowski_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Minkowski sum of two convex polytopes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Polytopes might not be of maximal dimension.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">points1,</span> <span class="pre">points2</span></tt> - lists of objects that can be
converted into vectors of the same dimension, treated as vertices
of two polytopes.</li>
</ul>
<p>OUTPUT: list of vertices of the Minkowski sum, given as vectors.</p>
<p>EXAMPLES: Let&#8217;s compute the Minkowski sum of two line segments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">minkowski_sum</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="go">[(1, 1), (1, -1), (-1, 1), (-1, -1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.positive_integer_relations">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">positive_integer_relations</tt><big>(</big><em>points</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.positive_integer_relations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return relations between given points.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">points</span></tt> - lattice points given as columns of a
matrix</li>
</ul>
<p>OUTPUT: matrix of relations between given points with non-negative
integer coefficients</p>
<p>EXAMPLES: This is a 3-dimensional reflexive polytope:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">LatticePolytope</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
<span class="gp">... </span>            <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">points_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0),</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M(-1, -1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1,  0, -1),</span>
<span class="go">M( 0,  0,  0)</span>
<span class="go">in 3-d lattice M</span>
</pre></div>
</div>
<p>We can compute linear relations between its points in the following
way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">points_pc</span><span class="p">()</span><span class="o">.</span><span class="n">matrix</span><span class="p">()</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span><span class="o">.</span><span class="n">echelonized_basis_matrix</span><span class="p">()</span>
<span class="go">[ 1  0  0  1  1  0]</span>
<span class="go">[ 0  1  1 -1 -1  0]</span>
<span class="go">[ 0  0  0  0  0  1]</span>
</pre></div>
</div>
<p>However, the above relations may contain negative and rational
numbers. This function transforms them in such a way, that all
coefficients are non-negative integers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">positive_integer_relations</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">points_pc</span><span class="p">()</span><span class="o">.</span><span class="n">column_matrix</span><span class="p">())</span>
<span class="go">[1 0 0 1 1 0]</span>
<span class="go">[1 1 1 0 0 0]</span>
<span class="go">[0 0 0 0 0 1]</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">positive_integer_relations</span><span class="p">(</span><span class="n">ReflexivePolytope</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span><span class="o">.</span><span class="n">column_matrix</span><span class="p">())</span>
<span class="go">[2 1 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.projective_space">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">projective_space</tt><big>(</big><em>dim</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.projective_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a simplex of the given dimension, corresponding to
<span class="math">\(P_{dim}\)</span>.</p>
<p>EXAMPLES: We construct 3- and 4-dimensional simplexes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">projective_space</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">doctest:...: DeprecationWarning: this function is deprecated,</span>
<span class="go">perhaps toric_varieties.P(n) is what you are looking for?</span>
<span class="go">See http://trac.sagemath.org/15240 for details.        </span>
<span class="gp">sage: </span><span class="n">p</span>
<span class="go">3-d reflexive polytope in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0),</span>
<span class="go">M( 0,  1,  0),</span>
<span class="go">M( 0,  0,  1),</span>
<span class="go">M(-1, -1, -1)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">projective_space</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span>
<span class="go">4-d reflexive polytope in 4-d lattice M</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">()</span>
<span class="go">M( 1,  0,  0,  0),</span>
<span class="go">M( 0,  1,  0,  0),</span>
<span class="go">M( 0,  0,  1,  0),</span>
<span class="go">M( 0,  0,  0,  1),</span>
<span class="go">M(-1, -1, -1, -1)</span>
<span class="go">in 4-d lattice M</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.read_all_polytopes">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">read_all_polytopes</tt><big>(</big><em>file_name</em>, <em>desc=None</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.read_all_polytopes" title="Permalink to this definition">¶</a></dt>
<dd><p>Read all polytopes from the given file.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">file_name</span></tt> &#8211; a string with the name of a file with VERTICES of
polytopes.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a sequence of polytopes.</li>
</ul>
<p>EXAMPLES:</p>
<p>We use poly.x to compute two polar polytopes and read them:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result_name</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">_palp</span><span class="p">(</span><span class="s">&quot;poly.x -fe&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">o</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="go">....:     print f.read()</span>
<span class="go">4 2  Vertices of P-dual &lt;-&gt; Equations of P</span>
<span class="go">  -1   1</span>
<span class="go">   1   1</span>
<span class="go">  -1  -1</span>
<span class="go">   1  -1</span>
<span class="go">8 3  Vertices of P-dual &lt;-&gt; Equations of P</span>
<span class="go">  -1  -1   1</span>
<span class="go">   1  -1   1</span>
<span class="go">  -1   1   1</span>
<span class="go">   1   1   1</span>
<span class="go">  -1  -1  -1</span>
<span class="go">   1  -1  -1</span>
<span class="go">  -1   1  -1</span>
<span class="go">   1   1  -1</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">read_all_polytopes</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span>
<span class="go">[</span>
<span class="go">2-d reflexive polytope #14 in 2-d lattice M,</span>
<span class="go">3-d reflexive polytope in 3-d lattice M</span>
<span class="go">]</span>
<span class="gp">sage: </span><span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.read_palp_matrix">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">read_palp_matrix</tt><big>(</big><em>data</em>, <em>permutation=False</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.read_palp_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Read and return an integer matrix from a string or an opened file.</p>
<p>First input line must start with two integers m and n, the number
of rows and columns of the matrix. The rest of the first line is
ignored. The next m lines must contain n numbers each.</p>
<p>If m&gt;n, returns the transposed matrix. If the string is empty or EOF
is reached, returns the empty matrix, constructed by
<tt class="docutils literal"><span class="pre">matrix()</span></tt>.</p>
<p>INPUT:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">data</span></tt> &#8211; Either a string containing the filename or the file itself</dt>
<dd><p class="first last">containing the output by PALP.</p>
</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">permutation</span></tt> &#8211; (default: <tt class="docutils literal"><span class="pre">False</span></tt>) If <tt class="docutils literal"><span class="pre">True</span></tt>, try to retrieve
the permutation output by PALP. This parameter makes sense only
when PALP computed the normal form of a lattice polytope.</p>
</li>
</ul>
<p>OUTPUT:</p>
<p>A matrix or a tuple of a matrix and a permutation.</p>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">read_palp_matrix</span><span class="p">(</span><span class="s">&quot;2 3 comment </span><span class="se">\n</span><span class="s"> 1 2 3 </span><span class="se">\n</span><span class="s"> 4 5 6&quot;</span><span class="p">)</span>
<span class="go">[1 2 3]</span>
<span class="go">[4 5 6]</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">read_palp_matrix</span><span class="p">(</span><span class="s">&quot;3 2 Will be transposed </span><span class="se">\n</span><span class="s"> 1 2 </span><span class="se">\n</span><span class="s"> 3 4 </span><span class="se">\n</span><span class="s"> 5 6&quot;</span><span class="p">)</span>
<span class="go">[1 3 5]</span>
<span class="go">[2 4 6]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.sage_matrix_to_maxima">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">sage_matrix_to_maxima</tt><big>(</big><em>m</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.sage_matrix_to_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Sage matrix to the string representation of Maxima.</p>
<p>EXAMPLE:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">sage_matrix_to_maxima</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">matrix([0,0],[0,0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.set_palp_dimension">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">set_palp_dimension</tt><big>(</big><em>d</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.set_palp_dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the dimension for PALP calls to <tt class="docutils literal"><span class="pre">d</span></tt>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">d</span></tt> &#8211; an integer from the list [4,5,6,11] or <tt class="docutils literal"><span class="pre">None</span></tt>.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>none.</li>
</ul>
<p>PALP has many hard-coded limits, which must be specified before
compilation, one of them is dimension. Sage includes several versions with
different dimension settings (which may also affect other limits and enable
certain features of PALP). You can change the version which will be used by
calling this function. Such a change is not done automatically for each
polytope based on its dimension, since depending on what you are doing it
may be necessary to use dimensions higher than that of the input polytope.</p>
<p>EXAMPLES:</p>
<p>By default, it is not possible to create the 7-dimensional simplex with
vertices at the basis of the 8-dimensional space:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">LatticePolytope</span><span class="p">(</span><span class="n">identity_matrix</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">Error executing &#39;poly.x -fv&#39; for the given polytope!</span>
<span class="go">Output:</span>
<span class="go">Please increase POLY_Dmax to at least 7</span>
</pre></div>
</div>
<p>However, we can work with this polytope by changing PALP dimension to 11:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">set_palp_dimension</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">LatticePolytope</span><span class="p">(</span><span class="n">identity_matrix</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="go">7-d lattice polytope in 8-d lattice M</span>
</pre></div>
</div>
<p>Let&#8217;s go back to default settings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">set_palp_dimension</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.skip_palp_matrix">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">skip_palp_matrix</tt><big>(</big><em>data</em>, <em>n=1</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.skip_palp_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Skip matrix data in a file.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">data</span></tt> - opened file with blocks of matrix data in
the following format: A block consisting of m+1 lines has the
number m as the first element of its first line.</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt> - (default: 1) integer, specifies how many
blocks should be skipped</li>
</ul>
<p>If EOF is reached during the process, raises ValueError exception.</p>
<p>EXAMPLE: We create a file with vertices of the square and the cube,
but read only the second set:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result_name</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">_palp</span><span class="p">(</span><span class="s">&quot;poly.x -fe&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">o</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="go">....:     print f.read()</span>
<span class="go">4 2  Vertices of P-dual &lt;-&gt; Equations of P</span>
<span class="go">  -1   1</span>
<span class="go">   1   1</span>
<span class="go">  -1  -1</span>
<span class="go">   1  -1</span>
<span class="go">8 3  Vertices of P-dual &lt;-&gt; Equations of P</span>
<span class="go">  -1  -1   1</span>
<span class="go">   1  -1   1</span>
<span class="go">  -1   1   1</span>
<span class="go">   1   1   1</span>
<span class="go">  -1  -1  -1</span>
<span class="go">   1  -1  -1</span>
<span class="go">  -1   1  -1</span>
<span class="go">   1   1  -1</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">skip_palp_matrix</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">read_palp_matrix</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">[-1  1 -1  1 -1  1 -1  1]</span>
<span class="go">[-1 -1  1  1 -1 -1  1  1]</span>
<span class="go">[ 1  1  1  1 -1 -1 -1 -1]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">result_name</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.lattice_polytope.write_palp_matrix">
<tt class="descclassname">sage.geometry.lattice_polytope.</tt><tt class="descname">write_palp_matrix</tt><big>(</big><em>m</em>, <em>ofile=None</em>, <em>comment=''</em>, <em>format=None</em><big>)</big><a class="headerlink" href="#sage.geometry.lattice_polytope.write_palp_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Write <tt class="docutils literal"><span class="pre">m</span></tt> into <tt class="docutils literal"><span class="pre">ofile</span></tt> in PALP format.</p>
<p>INPUT:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">m</span></tt> &#8211; a matrix over integers or a
<tt class="xref py py-class docutils literal"><span class="pre">point</span> <span class="pre">collection</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">ofile</span></tt> &#8211; a file opened for writing (default: stdout)</li>
<li><tt class="docutils literal"><span class="pre">comment</span></tt> &#8211; a string (default: empty) see output description</li>
<li><tt class="docutils literal"><span class="pre">format</span></tt> &#8211; a format string used to print matrix entries.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>nothing is returned, output written to <tt class="docutils literal"><span class="pre">ofile</span></tt> has the format<ul>
<li>First line: number_of_rows number_of_columns comment</li>
<li>Next number_of_rows lines: rows of the matrix.</li>
</ul>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">sage: </span><span class="n">o</span> <span class="o">=</span> <span class="n">lattice_polytope</span><span class="o">.</span><span class="n">cross_polytope</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">write_palp_matrix</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">(),</span> <span class="n">comment</span><span class="o">=</span><span class="s">&quot;3D Octahedron&quot;</span><span class="p">)</span>
<span class="go">3 6 3D Octahedron</span>
<span class="go"> 1  0  0 -1  0  0</span>
<span class="go"> 0  1  0  0 -1  0</span>
<span class="go"> 0  0  1  0  0 -1</span>
<span class="gp">sage: </span><span class="n">lattice_polytope</span><span class="o">.</span><span class="n">write_palp_matrix</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">vertices_pc</span><span class="p">(),</span> <span class="n">format</span><span class="o">=</span><span class="s">&quot;</span><span class="si">%4d</span><span class="s">&quot;</span><span class="p">)</span>
<span class="go">3 6</span>
<span class="go">   1    0    0   -1    0    0</span>
<span class="go">   0    1    0    0   -1    0</span>
<span class="go">   0    0    1    0    0   -1</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="../rings/polynomial/groebner_fan.html"
                                  title="previous chapter">Groebner Fans</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="polyhedron/constructor.html"
                                  title="next chapter">Polyhedra</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/geometry/lattice_polytope.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="polyhedron/constructor.html" title="Polyhedra"
             >next</a> |</li>
        <li class="right" >
          <a href="../rings/polynomial/groebner_fan.html" title="Groebner Fans"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/sagelogo.png" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li><a href="../../index.html">Geometry</a> &raquo;</li>
 
      </ul>
    </div>
    
    <div class="footer">
        &copy; Copyright 2005--2015, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>